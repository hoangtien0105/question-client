<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-can-templates-only-be-implemented-in-the-header-file-1657384341933","name":"Questions"}}]}</script><title>Why can templates only be implemented in the header file? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Quote from The C++ standard library: a tutorial and handbook:


  The only portable way of using templates at the moment is to implement them in header files by using inline functions.


Why is this?

(Clarification: header files are not the only portable solution. But they are the most convenient portable solution.)
    "/><meta property="og:title" content="Why can templates only be implemented in the header file? | Solutions Checker"/><meta property="og:description" content="Quote from The C++ standard library: a tutorial and handbook:


  The only portable way of using templates at the moment is to implement them in header files by using inline functions.


Why is this?

(Clarification: header files are not the only portable solution. But they are the most convenient portable solution.)
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why can templates only be implemented in the header file?","text":"Quote from The C++ standard library: a tutorial and handbook:\n\n\n  The only portable way of using templates at the moment is to implement them in header files by using inline functions.\n\n\nWhy is this?\n\n(Clarification: header files are not the only portable solution. But they are the most convenient portable solution.)\n    ","answerCount":17,"upVoteCount":500,"suggestedAnswer":[{"text":"Caveat: It is not necessary to put the implementation in the header file, see the alternative solution at the end of this answer.\n\nAnyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:\n\ntemplate&lt;typename T&gt;\nstruct Foo\n{\n    T bar;\n    void doSomething(T param) {/* do stuff using T */}\n};\n\n// somewhere in a .cpp\nFoo&lt;int&gt; f; \n\n\nWhen reading this line, the compiler will create a new class (let&apos;s call it FooInt), which is equivalent to the following:\n\nstruct FooInt\n{\n    int bar;\n    void doSomething(int param) {/* do stuff using int */}\n}\n\n\nConsequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case int). If these implementations were not in the header, they wouldn&apos;t be accessible, and therefore the compiler wouldn&apos;t be able to instantiate the template.\n\nA common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.\n\nFoo.h\n\ntemplate &lt;typename T&gt;\nstruct Foo\n{\n    void doSomething(T param);\n};\n\n#include &quot;Foo.tpp&quot;\n\n\nFoo.tpp\n\ntemplate &lt;typename T&gt;\nvoid Foo&lt;T&gt;::doSomething(T param)\n{\n    //implementation\n}\n\n\nThis way, implementation is still separated from declaration, but is accessible to the compiler.\n\nAlternative solution\n\nAnother solution is to keep the implementation separated, and explicitly instantiate all the template instances you&apos;ll need:\n\nFoo.h\n\n// no implementation\ntemplate &lt;typename T&gt; struct Foo { ... };\n\n\nFoo.cpp\n\n// implementation of Foo&apos;s methods\n\n// explicit instantiations\ntemplate class Foo&lt;int&gt;;\ntemplate class Foo&lt;float&gt;;\n// You will only be able to use Foo with int or float\n\n\nIf my explanation isn&apos;t clear enough, you can have a look at the C++ Super-FAQ on this subject.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"It&apos;s because of the requirement for separate compilation and because templates are instantiation-style polymorphism.\n\nLets get a little closer to concrete for an explanation. Say I&apos;ve got the following files:\n\n\nfoo.h\n\ndeclares the interface of class MyClass&lt;T&gt;\n\nfoo.cpp\n\ndefines the implementation of class MyClass&lt;T&gt;\n\nbar.cpp\n\nuses MyClass&lt;int&gt;\n\n\n\nSeparate compilation means I should be able to compile foo.cpp independently from bar.cpp. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don&apos;t need to do whole-program analysis. It&apos;s only the linker that needs to handle the entire program at once, and the linker&apos;s job is substantially easier.\n\nbar.cpp doesn&apos;t even need to exist when I compile foo.cpp, but I should still be able to link the foo.o I already had together with the bar.o I&apos;ve only just produced, without needing to recompile foo.cpp. foo.cpp could even be compiled into a dynamic library, distributed somewhere else without foo.cpp, and linked with code they write years after I wrote foo.cpp.\n\n&quot;Instantiation-style polymorphism&quot; means that the template MyClass&lt;T&gt; isn&apos;t really a generic class that can be compiled to code that can work for any value of T. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical class MyClass_int, class MyClass_float, etc, but to still be able to end up with compiled code that is mostly as if we had written each version separately. So a template is literally a template; a class template is not a class, it&apos;s a recipe for creating a new class for each T we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.\n\nSo when foo.cpp is compiled, the compiler can&apos;t see bar.cpp to know that MyClass&lt;int&gt; is needed. It can see the template MyClass&lt;T&gt;, but it can&apos;t emit code for that (it&apos;s a template, not a class). And when bar.cpp is compiled, the compiler can see that it needs to create a MyClass&lt;int&gt;, but it can&apos;t see the template MyClass&lt;T&gt; (only its interface in foo.h) so it can&apos;t create it.\n\nIf foo.cpp itself uses MyClass&lt;int&gt;, then code for that will be generated while compiling foo.cpp, so when bar.o is linked to foo.o they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there&apos;s no way for bar.cpp to use the template as a template and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of foo.cpp thought to provide.\n\nYou might think that when compiling a template the compiler should &quot;generate all versions&quot;, with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because &quot;type modifier&quot; features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:\n\n\nbaz.cpp\n\ndeclares and implements class BazPrivate, and uses MyClass&lt;BazPrivate&gt;\n\n\n\nThere is no possible way that this could work unless we either\n\n\nHave to recompile foo.cpp every time we change any other file in the program, in case it added a new novel instantiation of MyClass&lt;T&gt;\nRequire that baz.cpp contains (possibly via header includes) the full template of MyClass&lt;T&gt;, so that the compiler can generate MyClass&lt;BazPrivate&gt; during compilation of baz.cpp.\n\n\nNobody likes (1), because whole-program-analysis compilation systems take forever to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Plenty correct answers here, but I wanted to add this (for completeness):\nIf you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.\nEdit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.\ntemplate class vector&lt;int&gt;;\n\nThis will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for function templates, so if you have non-member operator overloads you may need to do the same for those.\nThe above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses extern template class vector&lt;int&gt; so as to keep it from instantiating it in all the other (1000?) files that use vector.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Templates need to be instantiated by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in a.h, defined in a.cpp and used in b.cpp. When a.cpp is compiled, it is not necessarily known that the upcoming compilation b.cpp will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.\n\nOne can argue that compilers can be made smarter to &quot;look ahead&quot; for all uses of the template, but I&apos;m sure that it wouldn&apos;t be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don&apos;t do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Actually, prior to C++11 the standard defined the export keyword that would make it possible to declare templates in a header file and implement them elsewhere. In a manner of speaking. Not really, as the only ones who ever implemented that feature pointed out:\n\nPhantom advantage #1: Hiding source code. Many users, have said that they expect that by using export they will\nno longer have to ship definitions for member/nonmember function templates and member functions of class\ntemplates. This is not true. With export, library writers still have to ship full template source code or its direct\nequivalent (e.g., a system-specific parse tree) because the full information is required for instantiation. [...]\n\n\nPhantom advantage #2: Fast builds, reduced dependencies. Many users expect that export will allow true separate\ncompilation of templates to object code which they expect would allow faster builds. It doesnt because the\ncompilation of exported templates is indeed separate but not to object code. Instead, export almost always makes\nbuilds slower, because at least the same amount of compilation work must still be done at prelink time. Export\ndoes not even reduce dependencies between template definitions because the dependencies are intrinsic,\nindependent of file organization.\n\nNone of the popular compilers implemented this keyword. The only implementation of the feature was in the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).\nAs a result, the ISO C++ standard committee decided to remove the export feature of templates with C++11.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won&apos;t allow them to be defined in non-header files such as .cpp files\n\nThere is an export keyword which is supposed to mitigate this problem, but it&apos;s nowhere close to being portable.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Templates are often used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters, and it&apos;s easier (as a programmer) to let the compiler recompile the same code multiple times and deduplicate later.\nRemember that a template doesn&apos;t represent code directly, but a template for several versions of that code.\nWhen you compile a non-template function in a .cpp file, you are compiling a concrete function/class.\nThis is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.\nThere was a feature with the export keyword that was meant to be used for separate compilation.\nThe export feature is deprecated in C++11 and, AFAIK, only one compiler implemented it.\nYou shouldn&apos;t make use of export.\nSeparate compilation is not possible in C++ or C++11 but maybe in C++17, if concepts make it in, we could have some way of separate compilation.\nFor separate compilation to be achieved, separate template body checking must be possible.\nIt seems that a solution is possible with concepts.\nTake a look at this paper recently presented at the\nstandards committee meeting.\nI think this is not the only requirement, since you still need to instantiate code for the template code in user code.\nThe separate compilation problem for templates I guess it&apos;s also a problem that is arising with the migration to modules, which is currently being worked.\nEDIT: As of August 2020 Modules are already a reality for C++: https://en.cppreference.com/w/cpp/language/modules\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Even though there are plenty of good explanations above, I&apos;m missing a practical way to separate templates into header and body.\nMy main concern is avoiding recompilation of all template users, when I change its definition.\nHaving all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.\nI took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).\n\nFor each template usage there&apos;s a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).\nEach user of the template includes that header file and uses the typedef.  \n\nA schematic example:\n\nMyTemplate.h:\n\n#ifndef MyTemplate_h\n#define MyTemplate_h 1\n\ntemplate &lt;class T&gt;\nclass MyTemplate\n{\npublic:\n  MyTemplate(const T&amp; rt);\n  void dump();\n  T t;\n};\n\n#endif\n\n\nMyTemplate.cpp:\n\n#include &quot;MyTemplate.h&quot;\n#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nMyTemplate&lt;T&gt;::MyTemplate(const T&amp; rt)\n: t(rt)\n{\n}\n\ntemplate &lt;class T&gt;\nvoid MyTemplate&lt;T&gt;::dump()\n{\n  cerr &lt;&lt; t &lt;&lt; endl;\n}\n\n\nMyInstantiatedTemplate.h:\n\n#ifndef MyInstantiatedTemplate_h\n#define MyInstantiatedTemplate_h 1\n#include &quot;MyTemplate.h&quot;\n\ntypedef MyTemplate&lt; int &gt; MyInstantiatedTemplate;\n\n#endif\n\n\nMyInstantiatedTemplate.cpp:\n\n#include &quot;MyTemplate.cpp&quot;\n\ntemplate class MyTemplate&lt; int &gt;;\n\n\nmain.cpp:\n\n#include &quot;MyInstantiatedTemplate.h&quot;\n\nint main()\n{\n  MyInstantiatedTemplate m(100);\n  m.dump();\n  return 0;\n}\n\n\nThis way only the template instantiations will need to be recompiled, not all template users (and dependencies).\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.\n\ntemplate &lt; typename ... &gt;\nclass MyClass\n{\n\n    int myMethod()\n    {\n       // Not just declaration. Add method implementation here\n    }\n};\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The compiler will generate code for each template instantiation when you use a template during the compilation step. \nIn the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.\n\nHowever since templates need to be processed in the compilation step in order to generate code for each template instantiation that you define, so simply compiling a template separate from it&apos;s header file won&apos;t work because they always go hand and hand, for the very reason that each template instantiation is a whole new class literally. In a regular class you can separate .h and .cpp because .h is a blueprint of that class and the .cpp is the raw implementation so any implementation files can be compiled and linked regularly, however using templates .h is a blueprint of how the class should look not how the object should look meaning a template .cpp file isn&apos;t a raw regular implementation of a class, it&apos;s simply a blueprint for a class, so any implementation of a .h template file can&apos;t be compiled because you need something concrete to compile, templates are abstract in that sense. \n\nTherefore templates are never separately compiled and are only compiled wherever you have a concrete instantiation in some other source file. However, the concrete instantiation needs to know the implementation of the template file, because simply modifying the typename T using a concrete type in the .h file is not going to do the job because what .cpp is there to link, I can&apos;t find it later on because remember templates are abstract and can&apos;t be compiled, so I&apos;m forced to give the implementation right now so I know what to compile and link, and now that I have the implementation it gets linked into the enclosing source file. Basically, the moment I instantiate a template I need to create a whole new class, and I can&apos;t do that if I don&apos;t know how that class should look like when using the type I provide unless I make notice to the compiler of the template implementation, so now the compiler can replace T with my type and create a concrete class that&apos;s ready to be compiled and linked.\n\nTo sum up, templates are blueprints for how classes should look, classes are blueprints for how an object should look.\nI can&apos;t compile templates separate from their concrete instantiation because the compiler only compiles concrete types, in other words, templates at least in C++, is pure language abstraction. We have to de-abstract templates so to speak, and we do so by giving them a concrete type to deal with so that our template abstraction can transform into a regular class file and in turn, it can be compiled normally. Separating the template .h file and the template .cpp file is meaningless. It is nonsensical because the separation of .cpp and .h only is only where the .cpp can be compiled individually and linked individually, with templates since we can&apos;t compile them separately, because templates are an abstraction, therefore we are always forced to put the abstraction always together with the concrete instantiation where the concrete instantiation always has to know about the type being used.\n\nMeaning typename T get&apos;s replaced during the compilation step not the linking step so if I try to compile a template without T being replaced as a concrete value type that is completely meaningless to the compiler and as a result object code can&apos;t be created because it doesn&apos;t know what T is.\n\nIt is technically possible to create some sort of functionality that will save the template.cpp file and switch out the types when it finds them in other sources, I think that the standard does have a keyword export that will allow you to put templates in a separate cpp file but not that many compilers actually implement this.\n\nJust a side note, when making specializations for a template class, you can separate the header from the implementation because a specialization by definition means that I am specializing for a concrete type that can be compiled and linked individually.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.\n\n\n\nmyQueue.hpp:\n\ntemplate &lt;class T&gt; \nclass QueueA {\n    int size;\n    ...\npublic:\n    template &lt;class T&gt; T dequeue() {\n       // implementation here\n    }\n\n    bool isEmpty();\n\n    ...\n}    \n\n\n\n\nmyQueue.cpp:\n\n// implementation of regular methods goes like this:\ntemplate &lt;class T&gt; bool QueueA&lt;T&gt;::isEmpty() {\n    return this-&gt;size == 0;\n}\n\n\nmain()\n{\n    QueueA&lt;char&gt; Q;\n\n    ...\n}\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file. \n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn&apos;t know the type is can&apos;t compile it. In .Net it can because all objects derive from the Object class. This is not .Net.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"A way to have separate implementation is as follows.\n\n//inner_foo.h\n\ntemplate &lt;typename T&gt;\nstruct Foo\n{\n    void doSomething(T param);\n};\n\n\n//foo.tpp\n#include &quot;inner_foo.h&quot;\ntemplate &lt;typename T&gt;\nvoid Foo&lt;T&gt;::doSomething(T param)\n{\n    //implementation\n}\n\n\n//foo.h\n#include &lt;foo.tpp&gt;\n\n//main.cpp\n#include &lt;foo.h&gt;\n\n\ninner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.\n\nOn compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.\n\nI do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"I suggest looking at this gcc page which discusses the tradeoffs between the &quot;cfront&quot; and &quot;borland&quot; model for template instantiations.\n\nhttps://gcc.gnu.org/onlinedocs/gcc-4.6.4/gcc/Template-Instantiation.html\n\nThe &quot;borland&quot; model corresponds to what the author suggests, providing the full template definition, and having things compiled multiple times.\n\nIt contains explicit recommendations concerning using manual and automatic template instantiation.  For example, the &quot;-repo&quot; option can be used to collect templates which need to be instantiated.  Or another option is to disable automatic template instantiations using &quot;-fno-implicit-templates&quot; to force manual template instantiation.\n\nIn my experience, I rely on the C++ Standard Library and Boost templates being instantiated for each compilation unit (using a template library).  For my large template classes, I do manual template instantiation, once, for the types I need.\n\nThis is my approach because I am providing a working program, not a template library for use in other programs.  The author of the book, Josuttis, works a lot on template libraries.\n\nIf I was really worried about speed, I suppose I would explore using Precompiled Headers \nhttps://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html\n\nwhich is gaining support in many compilers.  However, I think precompiled headers would be difficult with template header files.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Another reason that it&apos;s a good idea to write both declarations and definitions in header files is for readability. Suppose there&apos;s such a template function in Utility.h:\n\ntemplate &lt;class T&gt;\nT min(T const&amp; one, T const&amp; theOther);\n\n\nAnd in the Utility.cpp:\n\n#include &quot;Utility.h&quot;\ntemplate &lt;class T&gt;\nT min(T const&amp; one, T const&amp; other)\n{\n    return one &lt; other ? one : other;\n}\n\n\nThis requires every T class here to implement the less than operator (&lt;). It will throw a compiler error when you compare two class instances that haven&apos;t implemented the &quot;&lt;&quot;.\n\nTherefore if you separate the template declaration and definition, you won&apos;t be able to only read the header file to see the ins and outs of this template in order to use this API on your own classes, though the compiler will tell you in this case about which operator needs to be overridden.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"You can actually define your template class inside a .template file rather than a .cpp file. Whoever is saying you can only define it inside a header file is wrong. This is something that works all the way back to c++ 98.\n\nDon&apos;t forget to have your compiler treat your .template file as a c++ file to keep the intelli sense. \n\nHere is an example of this for a dynamic array class.\n\n#ifndef dynarray_h\n#define dynarray_h\n\n#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nclass DynArray{\n    int capacity_;\n    int size_;\n    T* data;\npublic:\n    explicit DynArray(int size = 0, int capacity=2);\n    DynArray(const DynArray&amp; d1);\n    ~DynArray();\n    T&amp; operator[]( const int index);\n    void operator=(const DynArray&lt;T&gt;&amp; d1);\n    int size();\n\n    int capacity();\n    void clear();\n\n    void push_back(int n);\n\n    void pop_back();\n    T&amp; at(const int n);\n    T&amp; back();\n    T&amp; front();\n};\n\n#include &quot;dynarray.template&quot; // this is how you get the header file\n\n#endif\n\n\nNow inside you .template file you define your functions just how you normally would.\n\ntemplate &lt;class T&gt;\nDynArray&lt;T&gt;::DynArray(int size, int capacity){\n    if (capacity &gt;= size){\n        this-&gt;size_ = size;\n        this-&gt;capacity_ = capacity;\n        data = new T[capacity];\n    }\n    //    for (int i = 0; i &lt; size; ++i) {\n    //        data[i] = 0;\n    //    }\n}\n\ntemplate &lt;class T&gt;\nDynArray&lt;T&gt;::DynArray(const DynArray&amp; d1){\n    //clear();\n    //delete [] data;\n    std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl;\n    this-&gt;size_ = d1.size_;\n    this-&gt;capacity_ = d1.capacity_;\n    data = new T[capacity()];\n    for(int i = 0; i &lt; size(); ++i){\n        data[i] = d1.data[i];\n    }\n}\n\ntemplate &lt;class T&gt;\nDynArray&lt;T&gt;::~DynArray(){\n    delete [] data;\n}\n\ntemplate &lt;class T&gt;\nT&amp; DynArray&lt;T&gt;::operator[]( const int index){\n    return at(index);\n}\n\ntemplate &lt;class T&gt;\nvoid DynArray&lt;T&gt;::operator=(const DynArray&lt;T&gt;&amp; d1){\n    if (this-&gt;size() &gt; 0) {\n        clear();\n    }\n    std::cout &lt;&lt; &quot;assign&quot; &lt;&lt; std::endl;\n    this-&gt;size_ = d1.size_;\n    this-&gt;capacity_ = d1.capacity_;\n    data = new T[capacity()];\n    for(int i = 0; i &lt; size(); ++i){\n        data[i] = d1.data[i];\n    }\n\n    //delete [] d1.data;\n}\n\ntemplate &lt;class T&gt;\nint DynArray&lt;T&gt;::size(){\n    return size_;\n}\n\ntemplate &lt;class T&gt;\nint DynArray&lt;T&gt;::capacity(){\n    return capacity_;\n}\n\ntemplate &lt;class T&gt;\nvoid DynArray&lt;T&gt;::clear(){\n    for( int i = 0; i &lt; size(); ++i){\n        data[i] = 0;\n    }\n    size_ = 0;\n    capacity_ = 2;\n}\n\ntemplate &lt;class T&gt;\nvoid DynArray&lt;T&gt;::push_back(int n){\n    if (size() &gt;= capacity()) {\n        std::cout &lt;&lt; &quot;grow&quot; &lt;&lt; std::endl;\n        //redo the array\n        T* copy = new T[capacity_ + 40];\n        for (int i = 0; i &lt; size(); ++i) {\n            copy[i] = data[i];\n        }\n\n        delete [] data;\n        data = new T[ capacity_ * 2];\n        for (int i = 0; i &lt; capacity() * 2; ++i) {\n            data[i] = copy[i];\n        }\n        delete [] copy;\n        capacity_ *= 2;\n    }\n    data[size()] = n;\n    ++size_;\n}\n\ntemplate &lt;class T&gt;\nvoid DynArray&lt;T&gt;::pop_back(){\n    data[size()-1] = 0;\n    --size_;\n}\n\ntemplate &lt;class T&gt;\nT&amp; DynArray&lt;T&gt;::at(const int n){\n    if (n &gt;= size()) {\n        throw std::runtime_error(&quot;invalid index&quot;);\n    }\n    return data[n];\n}\n\ntemplate &lt;class T&gt;\nT&amp; DynArray&lt;T&gt;::back(){\n    if (size() == 0) {\n        throw std::runtime_error(&quot;vector is empty&quot;);\n    }\n    return data[size()-1];\n}\n\ntemplate &lt;class T&gt;\nT&amp; DynArray&lt;T&gt;::front(){\n    if (size() == 0) {\n        throw std::runtime_error(&quot;vector is empty&quot;);\n    }\n    return data[0];\n    }\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e79b78ef884195a.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-c1a73f3e758d48b9.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_buildManifest.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-can-templates-only-be-implemented-in-the-header-file-1657384341933#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-can-templates-only-be-implemented-in-the-header-file-1657384341933"><h1>Why can templates only be implemented in the header file?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/templates">templates</a></div></div><div class="question-content mt-5">
                
<p>Quote from <a href="http://books.google.com/books?id=n9VEG2Gp5pkC&amp;pg=PA10&amp;lpg=PA10&amp;dq=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;source=bl&amp;ots=Ref8pl8dPX&amp;sig=t4K5gvxtBblpcujNxodpwMfei8I&amp;hl=en&amp;ei=qkR6TvbiGojE0AHq4IzqAg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=3&amp;ved=0CC8Q6AEwAg#v=onepage&amp;q=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;f=false" rel="noreferrer">The C++ standard library: a tutorial and handbook</a>:</p>

<blockquote>
  <p>The only portable way of using templates at the moment is to implement them in header files by using inline functions.</p>
</blockquote>

<p>Why is this?</p>

<p>(Clarification: header files are not the <em>only</em> portable solution. But they are the most convenient portable solution.)</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Caveat: It is <em>not</em> necessary to put the implementation in the header file, see the alternative solution at the end of this answer.</p>

<p>Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>
{
    T bar;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T param)</span> </span>{<span class="hljs-comment">/* do stuff using T */</span>}
};

<span class="hljs-comment">// somewhere in a .cpp</span>
Foo&lt;<span class="hljs-type">int</span>&gt; f; 
</code></pre>

<p>When reading this line, the compiler will create a new class (let's call it <code>FooInt</code>), which is equivalent to the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FooInt</span>
{
    <span class="hljs-type">int</span> bar;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span> param)</span> </span>{<span class="hljs-comment">/* do stuff using int */</span>}
}
</code></pre>

<p>Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case <code>int</code>). If these implementations were not in the header, they wouldn't be accessible, and therefore the compiler wouldn't be able to instantiate the template.</p>

<p>A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.</p>

<p>Foo.h</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T param)</span></span>;
};

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Foo.tpp"</span></span>
</code></pre>

<p>Foo.tpp</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> Foo&lt;T&gt;::<span class="hljs-built_in">doSomething</span>(T param)
{
    <span class="hljs-comment">//implementation</span>
}
</code></pre>

<p>This way, implementation is still separated from declaration, but is accessible to the compiler.</p>

<h1>Alternative solution</h1>

<p>Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you'll need:</p>

<p>Foo.h</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// no implementation</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> { ... };
</code></pre>

<p>Foo.cpp</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// implementation of Foo's methods</span>

<span class="hljs-comment">// explicit instantiations</span>
<span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">int</span>&gt;;
<span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">float</span>&gt;;
<span class="hljs-comment">// You will only be able to use Foo with int or float</span>
</code></pre>

<p>If my explanation isn't clear enough, you can have a look at the <a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" rel="noreferrer">C++ Super-FAQ on this subject</a>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's because of the requirement for separate compilation and because templates are instantiation-style polymorphism.</p>

<p>Lets get a little closer to concrete for an explanation. Say I've got the following files:</p>

<ul>
<li>foo.h
<ul>
<li>declares the interface of <code>class MyClass&lt;T&gt;</code></li>
</ul></li>
<li>foo.cpp
<ul>
<li>defines the implementation of <code>class MyClass&lt;T&gt;</code></li>
</ul></li>
<li>bar.cpp
<ul>
<li>uses <code>MyClass&lt;int&gt;</code></li>
</ul></li>
</ul>

<p>Separate compilation means I should be able to compile <strong>foo.cpp</strong> independently from <strong>bar.cpp</strong>. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don't need to do whole-program analysis. It's only the linker that needs to handle the entire program at once, and the linker's job is substantially easier.</p>

<p><strong>bar.cpp</strong> doesn't even need to exist when I compile <strong>foo.cpp</strong>, but I should still be able to link the <strong>foo.o</strong> I already had together with the <strong>bar.o</strong> I've only just produced, without needing to recompile <strong>foo.cpp</strong>. <strong>foo.cpp</strong> could even be compiled into a dynamic library, distributed somewhere else without <strong>foo.cpp</strong>, and linked with code they write years after I wrote <strong>foo.cpp</strong>.</p>

<p>"Instantiation-style polymorphism" means that the template <code>MyClass&lt;T&gt;</code> isn't really a generic class that can be compiled to code that can work for any value of <code>T</code>. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical <code>class MyClass_int</code>, <code>class MyClass_float</code>, etc, but to still be able to end up with compiled code that is mostly as if we <em>had</em> written each version separately. So a template is <em>literally</em> a template; a class template is <em>not</em> a class, it's a recipe for creating a new class for each <code>T</code> we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.</p>

<p>So when <strong>foo.cpp</strong> is compiled, the compiler can't see <strong>bar.cpp</strong> to know that <code>MyClass&lt;int&gt;</code> is needed. It can see the template <code>MyClass&lt;T&gt;</code>, but it can't emit code for that (it's a template, not a class). And when <strong>bar.cpp</strong> is compiled, the compiler can see that it needs to create a <code>MyClass&lt;int&gt;</code>, but it can't see the template <code>MyClass&lt;T&gt;</code> (only its interface in <strong>foo.h</strong>) so it can't create it.</p>

<p>If <strong>foo.cpp</strong> itself uses <code>MyClass&lt;int&gt;</code>, then code for that will be generated while compiling <strong>foo.cpp</strong>, so when <strong>bar.o</strong> is linked to <strong>foo.o</strong> they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there's no way for <strong>bar.cpp</strong> to use the template <em>as a template</em> and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of <strong>foo.cpp</strong> thought to provide.</p>

<p>You might think that when compiling a template the compiler should "generate all versions", with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because "type modifier" features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:</p>

<ul>
<li>baz.cpp
<ul>
<li>declares and implements <code>class BazPrivate</code>, and uses <code>MyClass&lt;BazPrivate&gt;</code></li>
</ul></li>
</ul>

<p>There is no possible way that this could work unless we either</p>

<ol>
<li>Have to recompile <strong>foo.cpp</strong> every time we change <em>any other file in the program</em>, in case it added a new novel instantiation of <code>MyClass&lt;T&gt;</code></li>
<li>Require that <strong>baz.cpp</strong> contains (possibly via header includes) the full template of <code>MyClass&lt;T&gt;</code>, so that the compiler can generate <code>MyClass&lt;BazPrivate&gt;</code> during compilation of <strong>baz.cpp</strong>.</li>
</ol>

<p>Nobody likes (1), because whole-program-analysis compilation systems take <em>forever</em> to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Plenty correct answers here, but I wanted to add this (for completeness):</p>
<p>If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.</p>
<p>Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>&lt;<span class="hljs-type">int</span>&gt;;
</code></pre>
<p>This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for function templates, so if you have non-member operator overloads you may need to do the same for those.</p>
<p>The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses <code>extern template class vector&lt;int&gt;</code> so as to keep it from instantiating it in all the <em>other</em> (1000?) files that use vector.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Templates need to be <em>instantiated</em> by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in <code>a.h</code>, defined in <code>a.cpp</code> and used in <code>b.cpp</code>. When <code>a.cpp</code> is compiled, it is not necessarily known that the upcoming compilation <code>b.cpp</code> will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.</p>

<p>One can argue that compilers can be made smarter to "look ahead" for all uses of the template, but I'm sure that it wouldn't be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don't do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Actually, prior to C++11 the standard defined the <code>export</code> keyword that <em>would</em> make it possible to declare templates in a header file and implement them elsewhere. In a manner of speaking. Not really, as the only ones who ever <em>implemented</em> that feature <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1426.pdf" rel="nofollow noreferrer">pointed out</a>:</p>
<blockquote>
<p>Phantom advantage #1: Hiding source code. Many users, have said that they expect that by using export they will
no longer have to ship definitions for member/nonmember function templates and member functions of class
templates. This is not true. With export, library writers still have to ship full template source code or its direct
equivalent (e.g., a system-specific parse tree) because the full information is required for instantiation. [...]</p>
</blockquote>
<blockquote>
<p>Phantom advantage #2: Fast builds, reduced dependencies. Many users expect that export will allow true separate
compilation of templates to object code which they expect would allow faster builds. It doesnt because the
compilation of exported templates is indeed separate but not to object code. Instead, export almost always makes
builds slower, because at least the same amount of compilation work must still be done at prelink time. Export
does not even reduce dependencies between template definitions because the dependencies are intrinsic,
independent of file organization.</p>
</blockquote>
<p>None of the popular compilers implemented this keyword. The only implementation of the feature was in the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).</p>
<p>As a result, the ISO C++ standard committee decided to remove the <code>export</code> feature of templates with C++11.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won't allow them to be defined in non-header files such as .cpp files</p>

<p>There is an <em>export</em> keyword which is supposed to mitigate this problem, but it's nowhere close to being portable.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Templates are often used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters, and it's easier (as a programmer) to let the compiler recompile the same code multiple times and deduplicate later.
Remember that a template doesn't represent code directly, but a template for several versions of that code.
When you compile a non-template function in a <code>.cpp</code> file, you are compiling a concrete function/class.
This is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.</p>
<p>There was a feature with the <code>export</code> keyword that was meant to be used for separate compilation.
The <code>export</code> feature is deprecated in <code>C++11</code> and, AFAIK, only one compiler implemented it.
You shouldn't make use of <code>export</code>.
Separate compilation is not possible in <code>C++</code> or <code>C++11</code> but maybe in <code>C++17</code>, if concepts make it in, we could have some way of separate compilation.</p>
<p>For separate compilation to be achieved, separate template body checking must be possible.
It seems that a solution is possible with concepts.
Take a look at this <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3629.pdf" rel="nofollow noreferrer">paper</a> recently presented at the
standards committee meeting.
I think this is not the only requirement, since you still need to instantiate code for the template code in user code.</p>
<p>The separate compilation problem for templates I guess it's also a problem that is arising with the migration to modules, which is currently being worked.</p>
<p>EDIT: As of August 2020 Modules are already a reality for C++: <a href="https://en.cppreference.com/w/cpp/language/modules" rel="nofollow noreferrer">https://en.cppreference.com/w/cpp/language/modules</a></p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Even though there are plenty of good explanations above, I'm missing a practical way to separate templates into header and body.<br>
My main concern is avoiding recompilation of all template users, when I change its definition.<br>
Having all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.<br>
I took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).</p>

<p>For each template usage there's a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).<br>
Each user of the template includes that header file and uses the typedef.  </p>

<p>A schematic example:</p>

<p>MyTemplate.h:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MyTemplate_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MyTemplate_h 1</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTemplate</span>
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">MyTemplate</span>(<span class="hljs-type">const</span> T&amp; rt);
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span></span>;
  T t;
};

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>MyTemplate.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyTemplate.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
MyTemplate&lt;T&gt;::<span class="hljs-built_in">MyTemplate</span>(<span class="hljs-type">const</span> T&amp; rt)
: <span class="hljs-built_in">t</span>(rt)
{
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> MyTemplate&lt;T&gt;::<span class="hljs-built_in">dump</span>()
{
  cerr &lt;&lt; t &lt;&lt; endl;
}
</code></pre>

<p>MyInstantiatedTemplate.h:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MyInstantiatedTemplate_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MyInstantiatedTemplate_h 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyTemplate.h"</span></span>

<span class="hljs-keyword">typedef</span> MyTemplate&lt; <span class="hljs-type">int</span> &gt; MyInstantiatedTemplate;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>MyInstantiatedTemplate.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyTemplate.cpp"</span></span>

<span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTemplate</span>&lt; <span class="hljs-type">int</span> &gt;;
</code></pre>

<p>main.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyInstantiatedTemplate.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-function">MyInstantiatedTemplate <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;
  m.<span class="hljs-built_in">dump</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>This way only the template instantiations will need to be recompiled, not all template users (and dependencies).</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> ... &gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>
{

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span>
    </span>{
       <span class="hljs-comment">// Not just declaration. Add method implementation here</span>
    }
};
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The compiler will generate code for each template instantiation when you use a template during the compilation step. 
In the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.</p>

<p>However since templates need to be processed in the compilation step in order to generate code for each template instantiation that you define, so simply compiling a template separate from it's header file won't work because they always go hand and hand, for the very reason that each template instantiation is a whole new class literally. In a regular class you can separate .h and .cpp because .h is a blueprint of that class and the .cpp is the raw implementation so any implementation files can be compiled and linked regularly, however using templates .h is a blueprint of how the class should look not how the object should look meaning a template .cpp file isn't a raw regular implementation of a class, it's simply a blueprint for a class, so any implementation of a .h template file can't be compiled because you need something concrete to compile, templates are abstract in that sense. </p>

<p>Therefore templates are never separately compiled and are only compiled wherever you have a concrete instantiation in some other source file. However, the concrete instantiation needs to know the implementation of the template file, because simply modifying the <code>typename T</code> using a concrete type in the .h file is not going to do the job because what .cpp is there to link, I can't find it later on because remember templates are abstract and can't be compiled, so I'm forced to give the implementation right now so I know what to compile and link, and now that I have the implementation it gets linked into the enclosing source file. Basically, the moment I instantiate a template I need to create a whole new class, and I can't do that if I don't know how that class should look like when using the type I provide unless I make notice to the compiler of the template implementation, so now the compiler can replace <code>T</code> with my type and create a concrete class that's ready to be compiled and linked.</p>

<p>To sum up, templates are blueprints for how classes should look, classes are blueprints for how an object should look.
I can't compile templates separate from their concrete instantiation because the compiler only compiles concrete types, in other words, templates at least in C++, is pure language abstraction. We have to de-abstract templates so to speak, and we do so by giving them a concrete type to deal with so that our template abstraction can transform into a regular class file and in turn, it can be compiled normally. Separating the template .h file and the template .cpp file is meaningless. It is nonsensical because the separation of .cpp and .h only is only where the .cpp can be compiled individually and linked individually, with templates since we can't compile them separately, because templates are an abstraction, therefore we are always forced to put the abstraction always together with the concrete instantiation where the concrete instantiation always has to know about the type being used.</p>

<p>Meaning <code>typename T</code> get's replaced during the compilation step not the linking step so if I try to compile a template without <code>T</code> being replaced as a concrete value type that is completely meaningless to the compiler and as a result object code can't be created because it doesn't know what <code>T</code> is.</p>

<p>It is technically possible to create some sort of functionality that will save the template.cpp file and switch out the types when it finds them in other sources, I think that the standard does have a keyword <code>export</code> that will allow you to put templates in a separate cpp file but not that many compilers actually implement this.</p>

<p>Just a side note, when making specializations for a template class, you can separate the header from the implementation because a specialization by definition means that I am specializing for a concrete type that can be compiled and linked individually.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.</p>

<hr>

<p>myQueue.hpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueA</span> {
    <span class="hljs-type">int</span> size;
    ...
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function">T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-comment">// implementation here</span>
    }

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;

    ...
}    
</code></pre>

<hr>

<p>myQueue.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// implementation of regular methods goes like this:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> QueueA&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;size == <span class="hljs-number">0</span>;
}


<span class="hljs-built_in">main</span>()
{
    QueueA&lt;<span class="hljs-type">char</span>&gt; Q;

    ...
}
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file. </p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn't know the type is can't compile it. In .Net it can because all objects derive from the Object class. This is not .Net.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A way to have separate implementation is as follows.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//inner_foo.h</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T param)</span></span>;
};


<span class="hljs-comment">//foo.tpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"inner_foo.h"</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> Foo&lt;T&gt;::<span class="hljs-built_in">doSomething</span>(T param)
{
    <span class="hljs-comment">//implementation</span>
}


<span class="hljs-comment">//foo.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;foo.tpp&gt;</span></span>

<span class="hljs-comment">//main.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;foo.h&gt;</span></span>
</code></pre>

<p>inner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.</p>

<p>On compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.</p>

<p>I do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I suggest looking at this gcc page which discusses the tradeoffs between the "cfront" and "borland" model for template instantiations.</p>

<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.4/gcc/Template-Instantiation.html" rel="nofollow noreferrer">https://gcc.gnu.org/onlinedocs/gcc-4.6.4/gcc/Template-Instantiation.html</a></p>

<p>The "borland" model corresponds to what the author suggests, providing the full template definition, and having things compiled multiple times.</p>

<p>It contains explicit recommendations concerning using manual and automatic template instantiation.  For example, the "-repo" option can be used to collect templates which need to be instantiated.  Or another option is to disable automatic template instantiations using "-fno-implicit-templates" to force manual template instantiation.</p>

<p>In my experience, I rely on the C++ Standard Library and Boost templates being instantiated for each compilation unit (using a template library).  For my large template classes, I do manual template instantiation, once, for the types I need.</p>

<p>This is my approach because I am providing a working program, not a template library for use in other programs.  The author of the book, Josuttis, works a lot on template libraries.</p>

<p>If I was really worried about speed, I suppose I would explore using Precompiled Headers 
<a href="https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html" rel="nofollow noreferrer">https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html</a></p>

<p>which is gaining support in many compilers.  However, I think precompiled headers would be difficult with template header files.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another reason that it's a good idea to write both declarations and definitions in header files is for readability. Suppose there's such a template function in Utility.h:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; one, T <span class="hljs-type">const</span>&amp; theOther)</span></span>;
</code></pre>

<p>And in the Utility.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Utility.h"</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; one, T <span class="hljs-type">const</span>&amp; other)</span>
</span>{
    <span class="hljs-keyword">return</span> one &lt; other ? one : other;
}
</code></pre>

<p>This requires every T class here to implement the less than operator (&lt;). It will throw a compiler error when you compare two class instances that haven't implemented the "&lt;".</p>

<p>Therefore if you separate the template declaration and definition, you won't be able to only read the header file to see the ins and outs of this template in order to use this API on your own classes, though the compiler will tell you in this case about which operator needs to be overridden.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/templates">templates</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can actually define your template class inside a .template file rather than a .cpp file. Whoever is saying you can only define it inside a header file is wrong. This is something that works all the way back to c++ 98.</p>

<p>Don't forget to have your compiler treat your .template file as a c++ file to keep the intelli sense. </p>

<p>Here is an example of this for a dynamic array class.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> dynarray_h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> dynarray_h</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DynArray</span>{
    <span class="hljs-type">int</span> capacity_;
    <span class="hljs-type">int</span> size_;
    T* data;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DynArray</span><span class="hljs-params">(<span class="hljs-type">int</span> size = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> capacity=<span class="hljs-number">2</span>)</span></span>;
    <span class="hljs-built_in">DynArray</span>(<span class="hljs-type">const</span> DynArray&amp; d1);
    ~<span class="hljs-built_in">DynArray</span>();
    T&amp; <span class="hljs-keyword">operator</span>[]( <span class="hljs-type">const</span> <span class="hljs-type">int</span> index);
    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DynArray&lt;T&gt;&amp; d1);
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n)</span></span>;
    <span class="hljs-function">T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"dynarray.template"</span> <span class="hljs-comment">// this is how you get the header file</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>Now inside you .template file you define your functions just how you normally would.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
DynArray&lt;T&gt;::<span class="hljs-built_in">DynArray</span>(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> capacity){
    <span class="hljs-keyword">if</span> (capacity &gt;= size){
        <span class="hljs-keyword">this</span>-&gt;size_ = size;
        <span class="hljs-keyword">this</span>-&gt;capacity_ = capacity;
        data = <span class="hljs-keyword">new</span> T[capacity];
    }
    <span class="hljs-comment">//    for (int i = 0; i &lt; size; ++i) {</span>
    <span class="hljs-comment">//        data[i] = 0;</span>
    <span class="hljs-comment">//    }</span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
DynArray&lt;T&gt;::<span class="hljs-built_in">DynArray</span>(<span class="hljs-type">const</span> DynArray&amp; d1){
    <span class="hljs-comment">//clear();</span>
    <span class="hljs-comment">//delete [] data;</span>
    std::cout &lt;&lt; <span class="hljs-string">"copy"</span> &lt;&lt; std::endl;
    <span class="hljs-keyword">this</span>-&gt;size_ = d1.size_;
    <span class="hljs-keyword">this</span>-&gt;capacity_ = d1.capacity_;
    data = <span class="hljs-keyword">new</span> T[<span class="hljs-built_in">capacity</span>()];
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>(); ++i){
        data[i] = d1.data[i];
    }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
DynArray&lt;T&gt;::~<span class="hljs-built_in">DynArray</span>(){
    <span class="hljs-keyword">delete</span> [] data;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T&amp; DynArray&lt;T&gt;::<span class="hljs-keyword">operator</span>[]( <span class="hljs-type">const</span> <span class="hljs-type">int</span> index){
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">at</span>(index);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> DynArray&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DynArray&lt;T&gt;&amp; d1){
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">clear</span>();
    }
    std::cout &lt;&lt; <span class="hljs-string">"assign"</span> &lt;&lt; std::endl;
    <span class="hljs-keyword">this</span>-&gt;size_ = d1.size_;
    <span class="hljs-keyword">this</span>-&gt;capacity_ = d1.capacity_;
    data = <span class="hljs-keyword">new</span> T[<span class="hljs-built_in">capacity</span>()];
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>(); ++i){
        data[i] = d1.data[i];
    }

    <span class="hljs-comment">//delete [] d1.data;</span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">int</span> DynArray&lt;T&gt;::<span class="hljs-built_in">size</span>(){
    <span class="hljs-keyword">return</span> size_;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">int</span> DynArray&lt;T&gt;::<span class="hljs-built_in">capacity</span>(){
    <span class="hljs-keyword">return</span> capacity_;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> DynArray&lt;T&gt;::<span class="hljs-built_in">clear</span>(){
    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>(); ++i){
        data[i] = <span class="hljs-number">0</span>;
    }
    size_ = <span class="hljs-number">0</span>;
    capacity_ = <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> DynArray&lt;T&gt;::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> n){
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-built_in">capacity</span>()) {
        std::cout &lt;&lt; <span class="hljs-string">"grow"</span> &lt;&lt; std::endl;
        <span class="hljs-comment">//redo the array</span>
        T* copy = <span class="hljs-keyword">new</span> T[capacity_ + <span class="hljs-number">40</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>(); ++i) {
            copy[i] = data[i];
        }

        <span class="hljs-keyword">delete</span> [] data;
        data = <span class="hljs-keyword">new</span> T[ capacity_ * <span class="hljs-number">2</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">capacity</span>() * <span class="hljs-number">2</span>; ++i) {
            data[i] = copy[i];
        }
        <span class="hljs-keyword">delete</span> [] copy;
        capacity_ *= <span class="hljs-number">2</span>;
    }
    data[<span class="hljs-built_in">size</span>()] = n;
    ++size_;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> DynArray&lt;T&gt;::<span class="hljs-built_in">pop_back</span>(){
    data[<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;
    --size_;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T&amp; DynArray&lt;T&gt;::<span class="hljs-built_in">at</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n){
    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-built_in">size</span>()) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"invalid index"</span>);
    }
    <span class="hljs-keyword">return</span> data[n];
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T&amp; DynArray&lt;T&gt;::<span class="hljs-built_in">back</span>(){
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"vector is empty"</span>);
    }
    <span class="hljs-keyword">return</span> data[<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T&amp; DynArray&lt;T&gt;::<span class="hljs-built_in">front</span>(){
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"vector is empty"</span>);
    }
    <span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>];
    }
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160">How do I merge two dictionaries in a single expression?</a><a href="/questions/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554">Why does the order in which libraries are linked sometimes cause errors in GCC?</a><a href="/questions/asynctask-android-example-1657388127898">AsyncTask Android example</a><a href="/questions/how-do-i-count-the-occurrences-of-a-list-item-1657387916234">How do I count the occurrences of a list item?</a><a href="/questions/variables-are-not-behaving-as-expected-1657384865672">Variables are not behaving as expected</a><a href="/questions/do-dom-tree-elements-with-ids-become-global-properties-1657387475110">Do DOM tree elements with IDs become global properties?</a><a href="/questions/how-to-get-all-possible-combinations-of-a-list&#x27;s-elements-1657388271070">How to get all possible combinations of a lists elements?</a><a href="/questions/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379">How to print a number with commas as thousands separators in JavaScript</a><a href="/questions/what-is-the-(function()-)()-construct-in-javascript-1657385508348">What is the (function() { } )() construct in JavaScript?</a><a href="/questions/xmlhttprequest-cannot-load-xxx-no-&#x27;access-control-allow-origin&#x27;-header-1657384758362">XMLHttpRequest cannot load XXX No &#x27;Access-Control-Allow-Origin&#x27; header</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/jquery-dollar-is-not-defined-1657388385731">JQuery - $ is not defined</a><a href="/questions/how-to-compare-arrays-in-javascript-1657387352277">How to compare arrays in JavaScript?</a><a href="/questions/how-do-i-import-a-module-given-the-full-path-1657388139965">How do I import a module given the full path?</a><a href="/questions/what-is-jsonp-and-why-was-it-created-1657387770563">What is JSONP, and why was it created?</a><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118">Why does std::getline() skip input after a formatted extraction?</a><a href="/questions/how-do-i-print-my-java-object-without-getting-%22sometype@2f92e0f4%22-1657384731950">How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?</a><a href="/questions/%22thinking-in-angularjs%22-if-i-have-a-jquery-background-closed-1657384761159">&quot;Thinking in AngularJS&quot; if I have a jQuery background? [closed]</a><a href="/questions/passing-data-between-view-controllers-1657384540021">Passing data between view controllers</a><a href="/questions/the-definitive-c-book-guide-and-list-1657384747653">The Definitive C Book Guide and List</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Caveat: It is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; necessary to put the implementation in the header file, see the alternative solution at the end of this answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    T bar;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T param)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do stuff using T */\u0026lt;/span\u0026gt;}\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// somewhere in a .cpp\u0026lt;/span\u0026gt;\nFoo\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; f; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When reading this line, the compiler will create a new class (let\u0026apos;s call it \u0026lt;code\u0026gt;FooInt\u0026lt;/code\u0026gt;), which is equivalent to the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;FooInt\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bar;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; param)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do stuff using int */\u0026lt;/span\u0026gt;}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;). If these implementations were not in the header, they wouldn\u0026apos;t be accessible, and therefore the compiler wouldn\u0026apos;t be able to instantiate the template.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Foo.h\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T param)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo.tpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Foo.tpp\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; Foo\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;(T param)\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//implementation\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This way, implementation is still separated from declaration, but is accessible to the compiler.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Alternative solution\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you\u0026apos;ll need:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Foo.h\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no implementation\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; { ... };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Foo.cpp\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implementation of Foo\u0026apos;s methods\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// explicit instantiations\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// You will only be able to use Foo with int or float\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If my explanation isn\u0026apos;t clear enough, you can have a look at the \u0026lt;a href=\u0026quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++ Super-FAQ on this subject\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s because of the requirement for separate compilation and because templates are instantiation-style polymorphism.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lets get a little closer to concrete for an explanation. Say I\u0026apos;ve got the following files:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;foo.h\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;declares the interface of \u0026lt;code\u0026gt;class MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;foo.cpp\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;defines the implementation of \u0026lt;code\u0026gt;class MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;bar.cpp\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;uses \u0026lt;code\u0026gt;MyClass\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Separate compilation means I should be able to compile \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; independently from \u0026lt;strong\u0026gt;bar.cpp\u0026lt;/strong\u0026gt;. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don\u0026apos;t need to do whole-program analysis. It\u0026apos;s only the linker that needs to handle the entire program at once, and the linker\u0026apos;s job is substantially easier.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;bar.cpp\u0026lt;/strong\u0026gt; doesn\u0026apos;t even need to exist when I compile \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt;, but I should still be able to link the \u0026lt;strong\u0026gt;foo.o\u0026lt;/strong\u0026gt; I already had together with the \u0026lt;strong\u0026gt;bar.o\u0026lt;/strong\u0026gt; I\u0026apos;ve only just produced, without needing to recompile \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt;. \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; could even be compiled into a dynamic library, distributed somewhere else without \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt;, and linked with code they write years after I wrote \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;Instantiation-style polymorphism\u0026quot; means that the template \u0026lt;code\u0026gt;MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; isn\u0026apos;t really a generic class that can be compiled to code that can work for any value of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical \u0026lt;code\u0026gt;class MyClass_int\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;class MyClass_float\u0026lt;/code\u0026gt;, etc, but to still be able to end up with compiled code that is mostly as if we \u0026lt;em\u0026gt;had\u0026lt;/em\u0026gt; written each version separately. So a template is \u0026lt;em\u0026gt;literally\u0026lt;/em\u0026gt; a template; a class template is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a class, it\u0026apos;s a recipe for creating a new class for each \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So when \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; is compiled, the compiler can\u0026apos;t see \u0026lt;strong\u0026gt;bar.cpp\u0026lt;/strong\u0026gt; to know that \u0026lt;code\u0026gt;MyClass\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt; is needed. It can see the template \u0026lt;code\u0026gt;MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, but it can\u0026apos;t emit code for that (it\u0026apos;s a template, not a class). And when \u0026lt;strong\u0026gt;bar.cpp\u0026lt;/strong\u0026gt; is compiled, the compiler can see that it needs to create a \u0026lt;code\u0026gt;MyClass\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt;, but it can\u0026apos;t see the template \u0026lt;code\u0026gt;MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; (only its interface in \u0026lt;strong\u0026gt;foo.h\u0026lt;/strong\u0026gt;) so it can\u0026apos;t create it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; itself uses \u0026lt;code\u0026gt;MyClass\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt;, then code for that will be generated while compiling \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt;, so when \u0026lt;strong\u0026gt;bar.o\u0026lt;/strong\u0026gt; is linked to \u0026lt;strong\u0026gt;foo.o\u0026lt;/strong\u0026gt; they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there\u0026apos;s no way for \u0026lt;strong\u0026gt;bar.cpp\u0026lt;/strong\u0026gt; to use the template \u0026lt;em\u0026gt;as a template\u0026lt;/em\u0026gt; and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; thought to provide.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might think that when compiling a template the compiler should \u0026quot;generate all versions\u0026quot;, with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because \u0026quot;type modifier\u0026quot; features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;baz.cpp\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;declares and implements \u0026lt;code\u0026gt;class BazPrivate\u0026lt;/code\u0026gt;, and uses \u0026lt;code\u0026gt;MyClass\u0026amp;lt;BazPrivate\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;There is no possible way that this could work unless we either\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Have to recompile \u0026lt;strong\u0026gt;foo.cpp\u0026lt;/strong\u0026gt; every time we change \u0026lt;em\u0026gt;any other file in the program\u0026lt;/em\u0026gt;, in case it added a new novel instantiation of \u0026lt;code\u0026gt;MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Require that \u0026lt;strong\u0026gt;baz.cpp\u0026lt;/strong\u0026gt; contains (possibly via header includes) the full template of \u0026lt;code\u0026gt;MyClass\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, so that the compiler can generate \u0026lt;code\u0026gt;MyClass\u0026amp;lt;BazPrivate\u0026amp;gt;\u0026lt;/code\u0026gt; during compilation of \u0026lt;strong\u0026gt;baz.cpp\u0026lt;/strong\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Nobody likes (1), because whole-program-analysis compilation systems take \u0026lt;em\u0026gt;forever\u0026lt;/em\u0026gt; to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Plenty correct answers here, but I wanted to add this (for completeness):\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for function templates, so if you have non-member operator overloads you may need to do the same for those.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses \u0026lt;code\u0026gt;extern template class vector\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt; so as to keep it from instantiating it in all the \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; (1000?) files that use vector.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Templates need to be \u0026lt;em\u0026gt;instantiated\u0026lt;/em\u0026gt; by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in \u0026lt;code\u0026gt;a.h\u0026lt;/code\u0026gt;, defined in \u0026lt;code\u0026gt;a.cpp\u0026lt;/code\u0026gt; and used in \u0026lt;code\u0026gt;b.cpp\u0026lt;/code\u0026gt;. When \u0026lt;code\u0026gt;a.cpp\u0026lt;/code\u0026gt; is compiled, it is not necessarily known that the upcoming compilation \u0026lt;code\u0026gt;b.cpp\u0026lt;/code\u0026gt; will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One can argue that compilers can be made smarter to \u0026quot;look ahead\u0026quot; for all uses of the template, but I\u0026apos;m sure that it wouldn\u0026apos;t be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don\u0026apos;t do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Actually, prior to C++11 the standard defined the \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt; keyword that \u0026lt;em\u0026gt;would\u0026lt;/em\u0026gt; make it possible to declare templates in a header file and implement them elsewhere. In a manner of speaking. Not really, as the only ones who ever \u0026lt;em\u0026gt;implemented\u0026lt;/em\u0026gt; that feature \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1426.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;pointed out\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Phantom advantage #1: Hiding source code. Many users, have said that they expect that by using export they will\nno longer have to ship definitions for member/nonmember function templates and member functions of class\ntemplates. This is not true. With export, library writers still have to ship full template source code or its direct\nequivalent (e.g., a system-specific parse tree) because the full information is required for instantiation. [...]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Phantom advantage #2: Fast builds, reduced dependencies. Many users expect that export will allow true separate\ncompilation of templates to object code which they expect would allow faster builds. It doesnt because the\ncompilation of exported templates is indeed separate but not to object code. Instead, export almost always makes\nbuilds slower, because at least the same amount of compilation work must still be done at prelink time. Export\ndoes not even reduce dependencies between template definitions because the dependencies are intrinsic,\nindependent of file organization.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;None of the popular compilers implemented this keyword. The only implementation of the feature was in the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As a result, the ISO C++ standard committee decided to remove the \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt; feature of templates with C++11.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won\u0026apos;t allow them to be defined in non-header files such as .cpp files\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is an \u0026lt;em\u0026gt;export\u0026lt;/em\u0026gt; keyword which is supposed to mitigate this problem, but it\u0026apos;s nowhere close to being portable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Templates are often used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters, and it\u0026apos;s easier (as a programmer) to let the compiler recompile the same code multiple times and deduplicate later.\nRemember that a template doesn\u0026apos;t represent code directly, but a template for several versions of that code.\nWhen you compile a non-template function in a \u0026lt;code\u0026gt;.cpp\u0026lt;/code\u0026gt; file, you are compiling a concrete function/class.\nThis is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There was a feature with the \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt; keyword that was meant to be used for separate compilation.\nThe \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt; feature is deprecated in \u0026lt;code\u0026gt;C++11\u0026lt;/code\u0026gt; and, AFAIK, only one compiler implemented it.\nYou shouldn\u0026apos;t make use of \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt;.\nSeparate compilation is not possible in \u0026lt;code\u0026gt;C++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;C++11\u0026lt;/code\u0026gt; but maybe in \u0026lt;code\u0026gt;C++17\u0026lt;/code\u0026gt;, if concepts make it in, we could have some way of separate compilation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For separate compilation to be achieved, separate template body checking must be possible.\nIt seems that a solution is possible with concepts.\nTake a look at this \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3629.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;paper\u0026lt;/a\u0026gt; recently presented at the\nstandards committee meeting.\nI think this is not the only requirement, since you still need to instantiate code for the template code in user code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The separate compilation problem for templates I guess it\u0026apos;s also a problem that is arising with the migration to modules, which is currently being worked.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;EDIT: As of August 2020 Modules are already a reality for C++: \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/modules\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://en.cppreference.com/w/cpp/language/modules\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Even though there are plenty of good explanations above, I\u0026apos;m missing a practical way to separate templates into header and body.\u0026lt;br\u0026gt;\nMy main concern is avoiding recompilation of all template users, when I change its definition.\u0026lt;br\u0026gt;\nHaving all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.\u0026lt;br\u0026gt;\nI took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For each template usage there\u0026apos;s a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).\u0026lt;br\u0026gt;\nEach user of the template includes that header file and uses the typedef.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A schematic example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;MyTemplate.h:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; MyTemplate_h\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; MyTemplate_h 1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyTemplate\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyTemplate\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; rt);\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;dump\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  T t;\n};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;MyTemplate.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;MyTemplate.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nMyTemplate\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyTemplate\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; rt)\n: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt;(rt)\n{\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; MyTemplate\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dump\u0026lt;/span\u0026gt;()\n{\n  cerr \u0026amp;lt;\u0026amp;lt; t \u0026amp;lt;\u0026amp;lt; endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;MyInstantiatedTemplate.h:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; MyInstantiatedTemplate_h\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; MyInstantiatedTemplate_h 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;MyTemplate.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; MyTemplate\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;gt; MyInstantiatedTemplate;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;MyInstantiatedTemplate.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;MyTemplate.cpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyTemplate\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;main.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;MyInstantiatedTemplate.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyInstantiatedTemplate \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;m\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  m.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dump\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This way only the template instantiations will need to be recompiled, not all template users (and dependencies).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ... \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyClass\u0026lt;/span\u0026gt;\n{\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;myMethod\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not just declaration. Add method implementation here\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The compiler will generate code for each template instantiation when you use a template during the compilation step. \nIn the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However since templates need to be processed in the compilation step in order to generate code for each template instantiation that you define, so simply compiling a template separate from it\u0026apos;s header file won\u0026apos;t work because they always go hand and hand, for the very reason that each template instantiation is a whole new class literally. In a regular class you can separate .h and .cpp because .h is a blueprint of that class and the .cpp is the raw implementation so any implementation files can be compiled and linked regularly, however using templates .h is a blueprint of how the class should look not how the object should look meaning a template .cpp file isn\u0026apos;t a raw regular implementation of a class, it\u0026apos;s simply a blueprint for a class, so any implementation of a .h template file can\u0026apos;t be compiled because you need something concrete to compile, templates are abstract in that sense. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore templates are never separately compiled and are only compiled wherever you have a concrete instantiation in some other source file. However, the concrete instantiation needs to know the implementation of the template file, because simply modifying the \u0026lt;code\u0026gt;typename T\u0026lt;/code\u0026gt; using a concrete type in the .h file is not going to do the job because what .cpp is there to link, I can\u0026apos;t find it later on because remember templates are abstract and can\u0026apos;t be compiled, so I\u0026apos;m forced to give the implementation right now so I know what to compile and link, and now that I have the implementation it gets linked into the enclosing source file. Basically, the moment I instantiate a template I need to create a whole new class, and I can\u0026apos;t do that if I don\u0026apos;t know how that class should look like when using the type I provide unless I make notice to the compiler of the template implementation, so now the compiler can replace \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; with my type and create a concrete class that\u0026apos;s ready to be compiled and linked.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To sum up, templates are blueprints for how classes should look, classes are blueprints for how an object should look.\nI can\u0026apos;t compile templates separate from their concrete instantiation because the compiler only compiles concrete types, in other words, templates at least in C++, is pure language abstraction. We have to de-abstract templates so to speak, and we do so by giving them a concrete type to deal with so that our template abstraction can transform into a regular class file and in turn, it can be compiled normally. Separating the template .h file and the template .cpp file is meaningless. It is nonsensical because the separation of .cpp and .h only is only where the .cpp can be compiled individually and linked individually, with templates since we can\u0026apos;t compile them separately, because templates are an abstraction, therefore we are always forced to put the abstraction always together with the concrete instantiation where the concrete instantiation always has to know about the type being used.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Meaning \u0026lt;code\u0026gt;typename T\u0026lt;/code\u0026gt; get\u0026apos;s replaced during the compilation step not the linking step so if I try to compile a template without \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; being replaced as a concrete value type that is completely meaningless to the compiler and as a result object code can\u0026apos;t be created because it doesn\u0026apos;t know what \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is technically possible to create some sort of functionality that will save the template.cpp file and switch out the types when it finds them in other sources, I think that the standard does have a keyword \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt; that will allow you to put templates in a separate cpp file but not that many compilers actually implement this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just a side note, when making specializations for a template class, you can separate the header from the implementation because a specialization by definition means that I am specializing for a concrete type that can be compiled and linked individually.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;myQueue.hpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;QueueA\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size;\n    ...\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;dequeue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implementation here\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;isEmpty\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    ...\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;myQueue.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implementation of regular methods goes like this:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; QueueA\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isEmpty\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;size == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\n{\n    QueueA\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; Q;\n\n    ...\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn\u0026apos;t know the type is can\u0026apos;t compile it. In .Net it can because all objects derive from the Object class. This is not .Net.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A way to have separate implementation is as follows.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//inner_foo.h\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T param)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//foo.tpp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;inner_foo.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; Foo\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;(T param)\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//implementation\u0026lt;/span\u0026gt;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//foo.h\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;foo.tpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//main.cpp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;foo.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;inner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I suggest looking at this gcc page which discusses the tradeoffs between the \u0026quot;cfront\u0026quot; and \u0026quot;borland\u0026quot; model for template instantiations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc-4.6.4/gcc/Template-Instantiation.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://gcc.gnu.org/onlinedocs/gcc-4.6.4/gcc/Template-Instantiation.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026quot;borland\u0026quot; model corresponds to what the author suggests, providing the full template definition, and having things compiled multiple times.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It contains explicit recommendations concerning using manual and automatic template instantiation.  For example, the \u0026quot;-repo\u0026quot; option can be used to collect templates which need to be instantiated.  Or another option is to disable automatic template instantiations using \u0026quot;-fno-implicit-templates\u0026quot; to force manual template instantiation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In my experience, I rely on the C++ Standard Library and Boost templates being instantiated for each compilation unit (using a template library).  For my large template classes, I do manual template instantiation, once, for the types I need.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is my approach because I am providing a working program, not a template library for use in other programs.  The author of the book, Josuttis, works a lot on template libraries.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I was really worried about speed, I suppose I would explore using Precompiled Headers \n\u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;which is gaining support in many compilers.  However, I think precompiled headers would be difficult with template header files.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another reason that it\u0026apos;s a good idea to write both declarations and definitions in header files is for readability. Suppose there\u0026apos;s such a template function in Utility.h:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; one, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; theOther)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And in the Utility.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Utility.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; one, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; other)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; one \u0026amp;lt; other ? one : other;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This requires every T class here to implement the less than operator (\u0026amp;lt;). It will throw a compiler error when you compare two class instances that haven\u0026apos;t implemented the \u0026quot;\u0026amp;lt;\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore if you separate the template declaration and definition, you won\u0026apos;t be able to only read the header file to see the ins and outs of this template in order to use this API on your own classes, though the compiler will tell you in this case about which operator needs to be overridden.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can actually define your template class inside a .template file rather than a .cpp file. Whoever is saying you can only define it inside a header file is wrong. This is something that works all the way back to c++ 98.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Don\u0026apos;t forget to have your compiler treat your .template file as a c++ file to keep the intelli sense. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is an example of this for a dynamic array class.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; dynarray_h\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; dynarray_h\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacity_;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size_;\n    T* data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;explicit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacity=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DynArray\u0026amp;amp; d1);\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;();\n    T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[]( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; index);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; d1);\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pop_back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;front\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dynarray.template\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is how you get the header file\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now inside you .template file you define your functions just how you normally would.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nDynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacity){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (capacity \u0026amp;gt;= size){\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;size_ = size;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;capacity_ = capacity;\n        data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[capacity];\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//    for (int i = 0; i \u0026amp;lt; size; ++i) {\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//        data[i] = 0;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//    }\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nDynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DynArray\u0026amp;amp; d1){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//clear();\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//delete [] data;\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;copy\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;size_ = d1.size_;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;capacity_ = d1.capacity_;\n    data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;()];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i){\n        data[i] = d1.data[i];\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nDynArray\u0026amp;lt;T\u0026amp;gt;::~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DynArray\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] data;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nT\u0026amp;amp; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[]( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; index){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(index);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; d1){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n    }\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;assign\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;size_ = d1.size_;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;capacity_ = d1.capacity_;\n    data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;()];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i){\n        data[i] = d1.data[i];\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//delete [] d1.data;\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; size_;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; capacity_;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i){\n        data[i] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    }\n    size_ = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    capacity_ = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;()) {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;grow\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//redo the array\u0026lt;/span\u0026gt;\n        T* copy = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[capacity_ + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;40\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i) {\n            copy[i] = data[i];\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] data;\n        data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[ capacity_ * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;capacity\u0026lt;/span\u0026gt;() * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; ++i) {\n            data[i] = copy[i];\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] copy;\n        capacity_ *= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    }\n    data[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()] = n;\n    ++size_;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pop_back\u0026lt;/span\u0026gt;(){\n    data[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    --size_;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nT\u0026amp;amp; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (n \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;invalid index\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data[n];\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nT\u0026amp;amp; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;back\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector is empty\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;];\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\nT\u0026amp;amp; DynArray\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;front\u0026lt;/span\u0026gt;(){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector is empty\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":31,"title":"Why can templates only be implemented in the header file?","content":"\n                \n\u0026lt;p\u0026gt;Quote from \u0026lt;a href=\u0026quot;http://books.google.com/books?id=n9VEG2Gp5pkC\u0026amp;amp;pg=PA10\u0026amp;amp;lpg=PA10\u0026amp;amp;dq=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22\u0026amp;amp;source=bl\u0026amp;amp;ots=Ref8pl8dPX\u0026amp;amp;sig=t4K5gvxtBblpcujNxodpwMfei8I\u0026amp;amp;hl=en\u0026amp;amp;ei=qkR6TvbiGojE0AHq4IzqAg\u0026amp;amp;sa=X\u0026amp;amp;oi=book_result\u0026amp;amp;ct=result\u0026amp;amp;resnum=3\u0026amp;amp;ved=0CC8Q6AEwAg#v=onepage\u0026amp;amp;q=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22\u0026amp;amp;f=false\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The C++ standard library: a tutorial and handbook\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The only portable way of using templates at the moment is to implement them in header files by using inline functions.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Why is this?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Clarification: header files are not the \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; portable solution. But they are the most convenient portable solution.)\u0026lt;/p\u0026gt;\n    ","slug":"why-can-templates-only-be-implemented-in-the-header-file-1657384341933","postType":"QUESTION","createdAt":"2022-07-09T16:32:21.000Z","updatedAt":"2022-07-09T16:32:21.000Z","tags":[{"id":104,"name":"templates","slug":"templates","createdAt":"2022-07-09T16:32:22.000Z","updatedAt":"2022-07-09T16:32:22.000Z","Questions_Tags":{"questionId":31,"tagId":104}}],"relatedQuestions":[{"title":"Why can templates only be implemented in the header file?","slug":"why-can-templates-only-be-implemented-in-the-header-file-1657384341933","tags":[{"name":"templates","Questions_Tags":{"questionId":31,"tagId":104}}]}]},"randomQuestions":[{"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"AsyncTask Android example","slug":"asynctask-android-example-1657388127898"},{"title":"How do I count the occurrences of a list item?","slug":"how-do-i-count-the-occurrences-of-a-list-item-1657387916234"},{"title":"Variables are not behaving as expected","slug":"variables-are-not-behaving-as-expected-1657384865672"},{"title":"Do DOM tree elements with IDs become global properties?","slug":"do-dom-tree-elements-with-ids-become-global-properties-1657387475110"},{"title":"How to get all possible combinations of a lists elements?","slug":"how-to-get-all-possible-combinations-of-a-list's-elements-1657388271070"},{"title":"How to print a number with commas as thousands separators in JavaScript","slug":"how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379"},{"title":"What is the (function() { } )() construct in JavaScript?","slug":"what-is-the-(function()-)()-construct-in-javascript-1657385508348"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"How to compare arrays in JavaScript?","slug":"how-to-compare-arrays-in-javascript-1657387352277"},{"title":"How do I import a module given the full path?","slug":"how-do-i-import-a-module-given-the-full-path-1657388139965"},{"title":"What is JSONP, and why was it created?","slug":"what-is-jsonp-and-why-was-it-created-1657387770563"},{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},{"title":"How do I print my Java object without getting \"SomeType@2f92e0f4\"?","slug":"how-do-i-print-my-java-object-without-getting-\"sometype@2f92e0f4\"-1657384731950"},{"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"The Definitive C Book Guide and List","slug":"the-definitive-c-book-guide-and-list-1657384747653"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-can-templates-only-be-implemented-in-the-header-file-1657384341933"},"buildId":"XDXakEY6gSPdgAODPxtjg","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>