<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="inheritance,object-slicing,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-is-object-slicing-1657384506425","name":"Questions"}}]}</script><title>What is object slicing? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="In c++ what is object slicing and when does it occur?
    "/><meta property="og:title" content="What is object slicing? | Solution Checker"/><meta property="og:description" content="In c++ what is object slicing and when does it occur?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is object slicing?","text":"In c++ what is object slicing and when does it occur?\n    ","answerCount":18,"upVoteCount":500,"suggestedAnswer":[{"text":"&quot;Slicing&quot; is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is &quot;sliced&quot; away.\n\nFor example, \n\nclass A {\n   int foo;\n};\n\nclass B : public A {\n   int bar;\n};\n\n\nSo an object of type B has two data members, foo and bar.\n\nThen if you were to write this:\n\nB b;\n\nA a = b;\n\n\nThen the information in b about member bar is lost in a.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you&apos;re dealing with two classes A and B, where B derives (publicly) from A.\n\nIn this situation, C++ lets you pass an instance of B to  A&apos;s assignment operator (and also to the copy constructor). This works because an instance of B can be converted to a const A&amp;, which is what assignment operators and copy-constructors expect their arguments to be.\n\nThe benign case\n\nB b;\nA a = b;\n\n\nNothing bad happens there - you asked for an instance of A which is a copy of B, and that&apos;s exactly what you get. Sure, a won&apos;t contain some of b&apos;s members, but how should it? It&apos;s an A, after all, not a B, so it hasn&apos;t even heard about these members, let alone would be able to store them.\n\nThe treacherous case\n\nB b1;\nB b2;\nA&amp; a_ref = b2;\na_ref = b1;\n//b2 now contains a mixture of b1 and b2!\n\n\nYou might think that b2 will be a copy of b1 afterward. But, alas, it&apos;s not! If you inspect it, you&apos;ll discover that b2 is a Frankensteinian creature, made from some chunks of b1 (the chunks that B inherits from A), and some chunks of b2 (the chunks that only B contains). Ouch!\n\nWhat happened? Well, C++ by default doesn&apos;t treat assignment operators as virtual. Thus, the line a_ref = b1 will call the assignment operator of A, not that of B. This is because, for non-virtual functions, the declared (formally: static) type (which is A&amp;) determines which function is called, as opposed to the actual (formally: dynamic) type (which would be B, since a_ref references an instance of B). Now, A&apos;s assignment operator obviously knows only about the members declared in A, so it will copy only those, leaving the members added in B unchanged.\n\nA solution\n\nAssigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator virtual. This will guarantee that it&apos;s always the actual type&apos;s assignment operator which is called, not the declared type&apos;s. The second step is to use dynamic_cast to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member assign(), since B&apos;s assign() will probably want to use A&apos;s assign() to copy A&apos;s, members.\n\nclass A {\npublic:\n  virtual A&amp; operator= (const A&amp; a) {\n    assign(a);\n    return *this;\n  }\n\nprotected:\n  void assign(const A&amp; a) {\n    // copy members of A from a to this\n  }\n};\n\nclass B : public A {\npublic:\n  virtual B&amp; operator= (const A&amp; a) {\n    if (const B* b = dynamic_cast&lt;const B*&gt;(&amp;a))\n      assign(*b);\n    else\n      throw bad_assignment();\n    return *this;\n  }\n\nprotected:\n  void assign(const B&amp; b) {\n    A::assign(b); // Let A&apos;s assign() copy members of A from b to this\n    // copy members of B from b to this\n  }\n};\n\n\nNote that, for pure convenience, B&apos;s operator= covariantly overrides the return type, since it knows that it&apos;s returning an instance of B.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"If You have a base class A and a derived class B, then You can do the following.\n\nvoid wantAnA(A myA)\n{\n   // work with myA\n}\n\nB derived;\n// work with the object &quot;derived&quot;\nwantAnA(derived);\n\n\nNow the method wantAnA needs a copy of derived. However, the object derived cannot be copied completely, as the class B could invent additional member variables which are not in its base class A.\n\nTherefore, to call wantAnA, the compiler will &quot;slice off&quot; all additional members of the derived class. The result might be an object you did not want to create, because\n\n\nit may be incomplete,\nit behaves like an A-object (all special behaviour of the class B is lost).\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Base class\nclass A {\npublic:\n    A() {}\n    A(const A&amp; a) {\n        cout &lt;&lt; &quot;&apos;A&apos; copy constructor&quot; &lt;&lt; endl;\n    }\n    virtual void run() const { cout &lt;&lt; &quot;I am an &apos;A&apos;&quot; &lt;&lt; endl; }\n};\n\n// Derived class\nclass B: public A {\npublic:\n    B():A() {}\n    B(const B&amp; a):A(a) {\n        cout &lt;&lt; &quot;&apos;B&apos; copy constructor&quot; &lt;&lt; endl;\n    }\n    virtual void run() const { cout &lt;&lt; &quot;I am a &apos;B&apos;&quot; &lt;&lt; endl; }\n};\n\nvoid g(const A &amp; a) {\n    a.run();\n}\n\nvoid h(const A a) {\n    a.run();\n}\n\nint main() {\n    cout &lt;&lt; &quot;Call by reference&quot; &lt;&lt; endl;\n    g(B());\n    cout &lt;&lt; endl &lt;&lt; &quot;Call by copy&quot; &lt;&lt; endl;\n    h(B());\n}\n\n\nThe output is:\n\nCall by reference\nI am a &apos;B&apos;\n\nCall by copy\n&apos;A&apos; copy constructor\nI am an &apos;A&apos;\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Third match in google for &quot;C++ slicing&quot; gives me this Wikipedia article http://en.wikipedia.org/wiki/Object_slicing and this (heated, but the first few posts define the problem) : http://bytes.com/forum/thread163565.html\n\nSo it&apos;s when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn&apos;t got room to store it, so the additional information gets &quot;sliced off&quot;.\n\nIf those links don&apos;t give enough info for a &quot;good answer&quot; please edit your question to let us know what more you&apos;re looking for.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.\n\nConsider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B&apos;s additional data. Then, when the additional data gets sliced off, p is pointing to garbage.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"In C++, a derived class object can be assigned to a base class object, but the other way is not possible.\n\nclass Base { int x, y; };\n\nclass Derived : public Base { int z, w; };\n\nint main() \n{\n    Derived d;\n    Base b = d; // Object Slicing,  z and w of d are sliced off\n}\n\n\nObject slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:\nclass A{\npublic:\n    virtual void Say(){\n        std::cout&lt;&lt;&quot;I am A&quot;&lt;&lt;std::endl;\n    }\n};\n\nclass B: public A{\npublic:\n    void Say() override{\n        std::cout&lt;&lt;&quot;I am B&quot;&lt;&lt;std::endl;\n    }\n};\n\nint main(){\n   B b;\n   A a1;\n   A a2=b;\n\n   b.Say(); // I am B\n   a1.Say(); // I am A\n   a2.Say(); // I am A   why???\n}\n\nB (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.\nTo solve this problem, a reference or pointer should be used\n A&amp; a2=b;\n a2.Say(); // I am B\n\nor\nA* a2 = &amp;b;\na2-&gt;Say(); // I am B\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.\n\nAlso thought someone should also mention what you should do to avoid slicing...\nGet a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.\n\nIt suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)\n\nYou can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve &quot;normal&quot; object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.\n\nThe short answers is that you slice the object by assigning a derived object to a base object by value, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn&apos;t exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"1. THE DEFINITION OF SLICING PROBLEM\n\nIf D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. \n\nEXAMPLE\n\nclass Pet\n{\n public:\n    string name;\n};\nclass Dog : public Pet\n{\npublic:\n    string breed;\n};\n\nint main()\n{   \n    Dog dog;\n    Pet pet;\n\n    dog.name = &quot;Tommy&quot;;\n    dog.breed = &quot;Kangal Dog&quot;;\n    pet = dog;\n    cout &lt;&lt; pet.breed; //ERROR\n\n\nAlthough the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the slicing problem.\n\n2. HOW TO FIX THE SLICING PROBLEM\n\nTo defeat the problem, we use pointers to dynamic variables.\n\nEXAMPLE\n\nPet *ptrP;\nDog *ptrD;\nptrD = new Dog;         \nptrD-&gt;name = &quot;Tommy&quot;;\nptrD-&gt;breed = &quot;Kangal Dog&quot;;\nptrP = ptrD;\ncout &lt;&lt; ((Dog *)ptrP)-&gt;breed; \n\n\nIn this case, none of the data members or member functions of the dynamic variable\nbeing pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"It seems to me, that slicing isn&apos;t so much a problem other than when your own classes and program are poorly architected/designed.\n\nIf I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.\n\nIt seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I&apos;m guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"OK, I&apos;ll give it a try after reading many posts explaining object slicing but not how it becomes problematic. \n\nThe vicious scenario that can result in memory corruption is the following:\n\n\nClass provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.\nClient copies and slices an instance of a derived class.\nClient calls a virtual member function that accesses the sliced-off state.\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    \n\nExplanation:\nConsider the following class declaration:\n\n           class baseclass\n          {\n                 ...\n                 baseclass &amp; operator =(const baseclass&amp;);\n                 baseclass(const baseclass&amp;);\n          }\n          void function( )\n          {\n                baseclass obj1=m;\n                obj1=m;\n          }\n\n\nAs baseclass copy functions don&apos;t know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. \n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"class A \n{ \n    int x; \n};  \n\nclass B \n{ \n    B( ) : x(1), c(&apos;a&apos;) { } \n    int x; \n    char c; \n};  \n\nint main( ) \n{ \n    A a; \n    B b; \n    a = b;     // b.c == &apos;a&apos; is &quot;sliced&quot; off\n    return 0; \n}\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.\n\nclass Base { \nint x;\n };\n\nclass Derived : public Base { \n int z; \n };\n\n int main() \n{\nDerived d;\nBase b = d; // Object Slicing,  z of d is sliced off\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.\nThis is called Object Slicing.\n\nHere is an Example: \n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nclass Base\n{\n    public:\n        int a;\n        int b;\n        int c;\n        Base()\n        {\n            a=10;\n            b=20;\n            c=30;\n        }\n};\nclass Derived : public Base\n{\n    public:\n        int d;\n        int e;\n        Derived()\n        {\n            d=40;\n            e=50;\n        }\n};\nint main()\n{\n    Derived d;\n    cout&lt;&lt;d.a&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;d.b&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;d.c&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;d.d&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;d.e&lt;&lt;&quot;\\n&quot;;\n\n\n    Base b = d;\n    cout&lt;&lt;b.a&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;b.b&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;b.c&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;b.d&lt;&lt;&quot;\\n&quot;;\n    cout&lt;&lt;b.e&lt;&lt;&quot;\\n&quot;;\n    return 0;\n}\n\n\nIt will generate:\n\n[Error] &apos;class Base&apos; has no member named &apos;d&apos;\n[Error] &apos;class Base&apos; has no member named &apos;e&apos;\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.\n\nLet&apos;s have an example from &quot;production code&quot; (or something that comes kind of close):\n\n\n\nLet&apos;s say we have something that dispatches actions. A control center UI for example.\nThis UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let&apos;s call it Action. So an Action has some member variables. For simplicity we just have 2, being a std::string name and a std::function&lt;void()&gt; f. Then it has an void activate() which just executes the f member.\n\nSo the UI gets a std::vector&lt;Action&gt; supplied. Imagine some functions like:\n\nvoid push_back(Action toAdd);\n\n\n\n\nNow we have established how it looks from the UI&apos;s perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the Action object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.\n\nSo the guy derives from Action to add his own flavour.\nHe passes an instance of his home-brewed class to the push_back but then the program goes haywire.\n\nSo what happened?\nAs you might have guessed: the object has been sliced.\n\nThe extra information from the instance has been lost, and f is now prone to undefined behaviour.\n\n\n\nI hope this example brings light about for those people who can&apos;t really imagine things when talking about As and Bs being derived in some manner.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-object-slicing-1657384506425#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-object-slicing-1657384506425"><h1>What is object slicing?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/object-slicing">object-slicing</a></div></div><div class="question-content mt-5">
                
<p>In c++ what is object slicing and when does it occur?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"Slicing" is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is "sliced" away.</p>

<p>For example, </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
   <span class="hljs-type">int</span> foo;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
   <span class="hljs-type">int</span> bar;
};
</code></pre>

<p>So an object of type <code>B</code> has two data members, <code>foo</code> and <code>bar</code>.</p>

<p>Then if you were to write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;

A a = b;
</code></pre>

<p>Then the information in <code>b</code> about member <code>bar</code> is lost in <code>a</code>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you're dealing with two classes <code>A</code> and <code>B</code>, where <code>B</code> derives (publicly) from <code>A</code>.</p>

<p>In this situation, C++ lets you pass an instance of <code>B</code> to  <code>A</code>'s assignment operator (and also to the copy constructor). This works because an instance of <code>B</code> can be converted to a <code>const A&amp;</code>, which is what assignment operators and copy-constructors expect their arguments to be.</p>

<h3>The benign case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;
A a = b;
</code></pre>

<p>Nothing bad happens there - you asked for an instance of <code>A</code> which is a copy of <code>B</code>, and that's exactly what you get. Sure, <code>a</code> won't contain some of <code>b</code>'s members, but how should it? It's an <code>A</code>, after all, not a <code>B</code>, so it hasn't even <em>heard</em> about these members, let alone would be able to store them.</p>

<h3>The treacherous case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b1;
B b2;
A&amp; a_ref = b2;
a_ref = b1;
<span class="hljs-comment">//b2 now contains a mixture of b1 and b2!</span>
</code></pre>

<p>You might think that <code>b2</code> will be a copy of <code>b1</code> afterward. But, alas, it's <strong>not</strong>! If you inspect it, you'll discover that <code>b2</code> is a Frankensteinian creature, made from some chunks of <code>b1</code> (the chunks that <code>B</code> inherits from <code>A</code>), and some chunks of <code>b2</code> (the chunks that only <code>B</code> contains). Ouch!</p>

<p>What happened? Well, C++ by default doesn't treat assignment operators as <code>virtual</code>. Thus, the line <code>a_ref = b1</code> will call the assignment operator of <code>A</code>, not that of <code>B</code>. This is because, for non-virtual functions, the <strong>declared</strong> (formally: <em>static</em>) type (which is <code>A&amp;</code>) determines which function is called, as opposed to the <strong>actual</strong> (formally: <em>dynamic</em>) type (which would be <code>B</code>, since <code>a_ref</code> references an instance of <code>B</code>). Now, <code>A</code>'s assignment operator obviously knows only about the members declared in <code>A</code>, so it will copy only those, leaving the members added in <code>B</code> unchanged.</p>

<h3>A solution</h3>

<p>Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator <em>virtual</em>. This will guarantee that it's always the <strong>actual</strong> type's assignment operator which is called, not the <strong>declared</strong> type's. The second step is to use <code>dynamic_cast</code> to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member <code>assign()</code>, since <code>B</code>'s <code>assign()</code> will probably want to use <code>A</code>'s <code>assign()</code> to copy <code>A</code>'s, members.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> A&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-built_in">assign</span>(a);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span> </span>{
    <span class="hljs-comment">// copy members of A from a to this</span>
  }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> B&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> B* b = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> B*&gt;(&amp;a))
      <span class="hljs-built_in">assign</span>(*b);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_assignment</span>();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> B&amp; b)</span> </span>{
    A::<span class="hljs-built_in">assign</span>(b); <span class="hljs-comment">// Let A's assign() copy members of A from b to this</span>
    <span class="hljs-comment">// copy members of B from b to this</span>
  }
};
</code></pre>

<p>Note that, for pure convenience, <code>B</code>'s <code>operator=</code> covariantly overrides the return type, since it <strong>knows</strong> that it's returning an instance of <code>B</code>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If You have a base class <code>A</code> and a derived class <code>B</code>, then You can do the following.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wantAnA</span><span class="hljs-params">(A myA)</span>
</span>{
   <span class="hljs-comment">// work with myA</span>
}

B derived;
<span class="hljs-comment">// work with the object "derived"</span>
<span class="hljs-built_in">wantAnA</span>(derived);
</code></pre>

<p>Now the method <code>wantAnA</code> needs a copy of <code>derived</code>. However, the object <code>derived</code> cannot be copied completely, as the class <code>B</code> could invent additional member variables which are not in its base class <code>A</code>.</p>

<p>Therefore, to call <code>wantAnA</code>, the compiler will "slice off" all additional members of the derived class. The result might be an object you did not want to create, because</p>

<ul>
<li>it may be incomplete,</li>
<li>it behaves like an <code>A</code>-object (all special behaviour of the class <code>B</code> is lost).</li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// Base class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) {
        cout &lt;&lt; <span class="hljs-string">"'A' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am an 'A'"</span> &lt;&lt; endl; }
};

<span class="hljs-comment">// Derived class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">B</span>():<span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; a):<span class="hljs-built_in">A</span>(a) {
        cout &lt;&lt; <span class="hljs-string">"'B' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am a 'B'"</span> &lt;&lt; endl; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp; a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> A a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">"Call by reference"</span> &lt;&lt; endl;
    <span class="hljs-built_in">g</span>(<span class="hljs-built_in">B</span>());
    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">"Call by copy"</span> &lt;&lt; endl;
    <span class="hljs-built_in">h</span>(<span class="hljs-built_in">B</span>());
}
</code></pre>

<p>The output is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Call by reference
I am a <span class="hljs-string">'B'</span>

Call by copy
<span class="hljs-string">'A'</span> copy constructor
I am an <span class="hljs-string">'A'</span>
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Third match in google for "C++ slicing" gives me this Wikipedia article <a href="http://en.wikipedia.org/wiki/Object_slicing" rel="noreferrer">http://en.wikipedia.org/wiki/Object_slicing</a> and this (heated, but the first few posts define the problem) : <a href="http://bytes.com/forum/thread163565.html" rel="noreferrer">http://bytes.com/forum/thread163565.html</a></p>

<p>So it's when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn't got room to store it, so the additional information gets "sliced off".</p>

<p>If those links don't give enough info for a "good answer" please edit your question to let us know what more you're looking for.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.</p>

<p>Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B's additional data. Then, when the additional data gets sliced off, p is pointing to garbage.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C++, a derived class object can be assigned to a base class object, but the other way is not possible.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { <span class="hljs-type">int</span> x, y; };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { <span class="hljs-type">int</span> z, w; };

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    Derived d;
    Base b = d; <span class="hljs-comment">// Object Slicing,  z and w of d are sliced off</span>
}
</code></pre>

<p>Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am A"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am B"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
   B b;
   A a1;
   A a2=b;

   b.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
   a1.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A</span>
   a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A   why???</span>
}
</code></pre>
<p>B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.</p>
<p>To solve this problem, a reference or pointer should be used</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> A&amp; a2=b;
 a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
<p>or</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A* a2 = &amp;b;
a2-&gt;<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.</p>

<p>Also thought someone should also mention what you should do to avoid slicing...
Get a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.</p>

<p>It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)</p>

<p>You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve "normal" object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.</p>

<p>The short answers is that you slice the object by assigning a derived object to a base object <em>by value</em>, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn't exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>1. THE DEFINITION OF SLICING PROBLEM</strong></p>

<p>If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. </p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>
{
 <span class="hljs-keyword">public</span>:
    string name;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Pet
{
<span class="hljs-keyword">public</span>:
    string breed;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   
    Dog dog;
    Pet pet;

    dog.name = <span class="hljs-string">"Tommy"</span>;
    dog.breed = <span class="hljs-string">"Kangal Dog"</span>;
    pet = dog;
    cout &lt;&lt; pet.breed; <span class="hljs-comment">//ERROR</span>
</code></pre>

<p>Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the <strong>slicing problem</strong>.</p>

<p><strong>2. HOW TO FIX THE SLICING PROBLEM</strong></p>

<p>To defeat the problem, we use pointers to dynamic variables.</p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Pet *ptrP;
Dog *ptrD;
ptrD = <span class="hljs-keyword">new</span> Dog;         
ptrD-&gt;name = <span class="hljs-string">"Tommy"</span>;
ptrD-&gt;breed = <span class="hljs-string">"Kangal Dog"</span>;
ptrP = ptrD;
cout &lt;&lt; ((Dog *)ptrP)-&gt;breed; 
</code></pre>

<p>In this case, none of the data members or member functions of the dynamic variable
being pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It seems to me, that slicing isn't so much a problem other than when your own classes and program are poorly architected/designed.</p>

<p>If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.</p>

<p>It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I'm guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>OK, I'll give it a try after reading many posts explaining object slicing but not how it becomes problematic. </p>

<p>The vicious scenario that can result in memory corruption is the following:</p>

<ul>
<li>Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.</li>
<li>Client copies and slices an instance of a derived class.</li>
<li>Client calls a virtual member function that accesses the sliced-off state.</li>
</ul>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    </p>

<p><strong>Explanation:</strong>
Consider the following class declaration:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">           <span class="hljs-keyword">class</span> <span class="hljs-title class_">baseclass</span>
          {
                 ...
                 baseclass &amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> baseclass&amp;);
                 <span class="hljs-built_in">baseclass</span>(<span class="hljs-type">const</span> baseclass&amp;);
          }
          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">( )</span>
          </span>{
                baseclass obj1=m;
                obj1=m;
          }
</code></pre>

<p>As baseclass copy functions don't know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. </p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> 
{ 
    <span class="hljs-type">int</span> x; 
};  

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> 
{ 
    <span class="hljs-built_in">B</span>( ) : <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">c</span>(<span class="hljs-string">'a'</span>) { } 
    <span class="hljs-type">int</span> x; 
    <span class="hljs-type">char</span> c; 
};  

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span> 
</span>{ 
    A a; 
    B b; 
    a = b;     <span class="hljs-comment">// b.c == 'a' is "sliced" off</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { 
<span class="hljs-type">int</span> x;
 };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { 
 <span class="hljs-type">int</span> z; 
 };

 <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
Derived d;
Base b = d; <span class="hljs-comment">// Object Slicing,  z of d is sliced off</span>
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.
This is called Object Slicing.</p>

<p><strong>Here is an Example:</strong> </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> a;
        <span class="hljs-type">int</span> b;
        <span class="hljs-type">int</span> c;
        <span class="hljs-built_in">Base</span>()
        {
            a=<span class="hljs-number">10</span>;
            b=<span class="hljs-number">20</span>;
            c=<span class="hljs-number">30</span>;
        }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> d;
        <span class="hljs-type">int</span> e;
        <span class="hljs-built_in">Derived</span>()
        {
            d=<span class="hljs-number">40</span>;
            e=<span class="hljs-number">50</span>;
        }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Derived d;
    cout&lt;&lt;d.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.e&lt;&lt;<span class="hljs-string">"\n"</span>;


    Base b = d;
    cout&lt;&lt;b.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.e&lt;&lt;<span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><strong>It will generate:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'d'</span>
[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'e'</span>
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/object-slicing">object-slicing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.</p>

<p>Let's have an example from "production code" (or something that comes kind of close):</p>

<hr>

<p>Let's say we have something that dispatches actions. A control center UI for example.<br>
This UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let's call it <code>Action</code>. So an <code>Action</code> has some member variables. For simplicity we just have 2, being a <code>std::string name</code> and a <code>std::function&lt;void()&gt; f</code>. Then it has an <code>void activate()</code> which just executes the <code>f</code> member.</p>

<p>So the UI gets a <code>std::vector&lt;Action&gt;</code> supplied. Imagine some functions like:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(Action toAdd)</span></span>;
</code></pre>

<hr>

<p>Now we have established how it looks from the UI's perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the <code>Action</code> object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.</p>

<p>So the guy derives from <code>Action</code> to add his own flavour.<br>
He passes an instance of his home-brewed class to the <code>push_back</code> but then the program goes haywire.</p>

<p>So what happened?<br>
As you <em>might</em> have guessed: the object has been sliced.</p>

<p>The extra information from the instance has been lost, and <code>f</code> is now prone to undefined behaviour.</p>

<hr>

<p>I hope this example brings light about for those people who can't really imagine things when talking about <code>A</code>s and <code>B</code>s being derived in some manner.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219">How can I read and parse CSV files in C++?</a><a href="/questions/how-to-convert-string-representation-of-list-to-a-list-1657387384181">How to convert string representation of list to a list</a><a href="/questions/how-do-i-properly-compare-strings-in-c-1657387467202">How do I properly compare strings in C?</a><a href="/questions/how-to-deal-with-settingwithcopywarning-in-pandas-1657384778377">How to deal with SettingWithCopyWarning in Pandas</a><a href="/questions/simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169">Simulating group_concat MySQL function in Microsoft SQL Server 2005?</a><a href="/questions/how-can-i-iterate-through-two-lists-in-parallel-1657387278930">How can I iterate through two lists in parallel?</a><a href="/questions/where-should-i-put-lessscriptgreater-tags-in-html-markup-1657388350798">Where should I put &lt;script&gt; tags in HTML markup?</a><a href="/questions/what-is-sql-injection-duplicate-1657387944486">What is SQL injection? [duplicate]</a><a href="/questions/split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823">Split comma-separated strings in a column into separate rows</a><a href="/questions/should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399">Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/convert-form-data-to-javascript-object-with-jquery-1657388036834">Convert form data to JavaScript object with jQuery</a><a href="/questions/how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115">How to iterate over rows in a DataFrame in Pandas</a><a href="/questions/do-i-cast-the-result-of-malloc-1657384271583">Do I cast the result of malloc?</a><a href="/questions/how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658">How can I upload files to a server using JSP/Servlet?</a><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a><a href="/questions/how-can-i-parse-a-json-file-with-php-duplicate-1657388002325">How can I parse a JSON file with PHP? [duplicate]</a><a href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a><a href="/questions/what-does-a-%22cannot-find-symbol%22-or-%22cannot-resolve-symbol%22-error-mean-1657384492160">What does a &quot;Cannot find symbol&quot; or &quot;Cannot resolve symbol&quot; error mean?</a><a href="/questions/how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428">How do you convert a byte array to a hexadecimal string, and vice versa?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026quot;Slicing\u0026quot; is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is \u0026quot;sliced\u0026quot; away.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; foo;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bar;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So an object of type \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; has two data members, \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you were to write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\n\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then the information in \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; about member \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is lost in \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you\u0026apos;re dealing with two classes \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; derives (publicly) from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this situation, C++ lets you pass an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; to  \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator (and also to the copy constructor). This works because an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; can be converted to a \u0026lt;code\u0026gt;const A\u0026amp;amp;\u0026lt;/code\u0026gt;, which is what assignment operators and copy-constructors expect their arguments to be.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The benign case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Nothing bad happens there - you asked for an instance of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; which is a copy of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, and that\u0026apos;s exactly what you get. Sure, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; won\u0026apos;t contain some of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;\u0026apos;s members, but how should it? It\u0026apos;s an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, after all, not a \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, so it hasn\u0026apos;t even \u0026lt;em\u0026gt;heard\u0026lt;/em\u0026gt; about these members, let alone would be able to store them.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The treacherous case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b1;\nB b2;\nA\u0026amp;amp; a_ref = b2;\na_ref = b1;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//b2 now contains a mixture of b1 and b2!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might think that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; will be a copy of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; afterward. But, alas, it\u0026apos;s \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;! If you inspect it, you\u0026apos;ll discover that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; is a Frankensteinian creature, made from some chunks of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; (the chunks that \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; inherits from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;), and some chunks of \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; (the chunks that only \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; contains). Ouch!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What happened? Well, C++ by default doesn\u0026apos;t treat assignment operators as \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt;. Thus, the line \u0026lt;code\u0026gt;a_ref = b1\u0026lt;/code\u0026gt; will call the assignment operator of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, not that of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. This is because, for non-virtual functions, the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;static\u0026lt;/em\u0026gt;) type (which is \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026lt;/code\u0026gt;) determines which function is called, as opposed to the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;dynamic\u0026lt;/em\u0026gt;) type (which would be \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;a_ref\u0026lt;/code\u0026gt; references an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;). Now, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator obviously knows only about the members declared in \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, so it will copy only those, leaving the members added in \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; unchanged.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;A solution\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator \u0026lt;em\u0026gt;virtual\u0026lt;/em\u0026gt;. This will guarantee that it\u0026apos;s always the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; type\u0026apos;s assignment operator which is called, not the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; type\u0026apos;s. The second step is to use \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; will probably want to use \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; to copy \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s, members.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; A\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(a);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of A from a to this\u0026lt;/span\u0026gt;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B* b = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B*\u0026amp;gt;(\u0026amp;amp;a))\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(*b);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad_assignment\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; b)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    A::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Let A\u0026apos;s assign() copy members of A from b to this\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of B from b to this\u0026lt;/span\u0026gt;\n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that, for pure convenience, \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt; covariantly overrides the return type, since it \u0026lt;strong\u0026gt;knows\u0026lt;/strong\u0026gt; that it\u0026apos;s returning an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If You have a base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and a derived class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then You can do the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A myA)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with myA\u0026lt;/span\u0026gt;\n}\n\nB derived;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with the object \u0026quot;derived\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;(derived);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the method \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt; needs a copy of \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt;. However, the object \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt; cannot be copied completely, as the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; could invent additional member variables which are not in its base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore, to call \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt;, the compiler will \u0026quot;slice off\u0026quot; all additional members of the derived class. The result might be an object you did not want to create, because\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;it may be incomplete,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it behaves like an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;-object (all special behaviour of the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is lost).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Base class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;A\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am an \u0026apos;A\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Derived class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;():\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; a):\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;B\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am a \u0026apos;B\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A \u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by reference\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n    cout \u0026amp;lt;\u0026amp;lt; endl \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by copy\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Call by reference\nI am a \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;\n\nCall by copy\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt; copy constructor\nI am an \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Third match in google for \u0026quot;C++ slicing\u0026quot; gives me this Wikipedia article \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Object_slicing\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Object_slicing\u0026lt;/a\u0026gt; and this (heated, but the first few posts define the problem) : \u0026lt;a href=\u0026quot;http://bytes.com/forum/thread163565.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://bytes.com/forum/thread163565.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So it\u0026apos;s when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn\u0026apos;t got room to store it, so the additional information gets \u0026quot;sliced off\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If those links don\u0026apos;t give enough info for a \u0026quot;good answer\u0026quot; please edit your question to let us know what more you\u0026apos;re looking for.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B\u0026apos;s additional data. Then, when the additional data gets sliced off, p is pointing to garbage.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C++, a derived class object can be assigned to a base class object, but the other way is not possible.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, y; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z, w; };\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\n    Derived d;\n    Base b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z and w of d are sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am A\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am B\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n   B b;\n   A a1;\n   A a2=b;\n\n   b.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n   a1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A\u0026lt;/span\u0026gt;\n   a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A   why???\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To solve this problem, a reference or pointer should be used\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; A\u0026amp;amp; a2=b;\n a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A* a2 = \u0026amp;amp;b;\na2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also thought someone should also mention what you should do to avoid slicing...\nGet a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve \u0026quot;normal\u0026quot; object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The short answers is that you slice the object by assigning a derived object to a base object \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn\u0026apos;t exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. THE DEFINITION OF SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Pet\u0026lt;/span\u0026gt;\n{\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string name;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Pet\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string breed;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{   \n    Dog dog;\n    Pet pet;\n\n    dog.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\n    dog.breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\n    pet = dog;\n    cout \u0026amp;lt;\u0026amp;lt; pet.breed; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ERROR\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the \u0026lt;strong\u0026gt;slicing problem\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. HOW TO FIX THE SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To defeat the problem, we use pointers to dynamic variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Pet *ptrP;\nDog *ptrD;\nptrD = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Dog;         \nptrD-\u0026amp;gt;name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\nptrD-\u0026amp;gt;breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\nptrP = ptrD;\ncout \u0026amp;lt;\u0026amp;lt; ((Dog *)ptrP)-\u0026amp;gt;breed; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, none of the data members or member functions of the dynamic variable\nbeing pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It seems to me, that slicing isn\u0026apos;t so much a problem other than when your own classes and program are poorly architected/designed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I\u0026apos;m guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;OK, I\u0026apos;ll give it a try after reading many posts explaining object slicing but not how it becomes problematic. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The vicious scenario that can result in memory corruption is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client copies and slices an instance of a derived class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client calls a virtual member function that accesses the sliced-off state.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Explanation:\u0026lt;/strong\u0026gt;\nConsider the following class declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;\n          {\n                 ...\n                 baseclass \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n                 \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n          }\n          \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt;\n          \u0026lt;/span\u0026gt;{\n                baseclass obj1=m;\n                obj1=m;\n          }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As baseclass copy functions don\u0026apos;t know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;( ) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;) { } \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{ \n    A a; \n    B b; \n    a = b;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b.c == \u0026apos;a\u0026apos; is \u0026quot;sliced\u0026quot; off\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z; \n };\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\nDerived d;\nBase b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z of d is sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.\nThis is called Object Slicing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Here is an Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bits/stdc++.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;()\n        {\n            a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n            b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n            c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; e;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;()\n        {\n            d=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;40\u0026lt;/span\u0026gt;;\n            e=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Derived d;\n    cout\u0026amp;lt;\u0026amp;lt;d.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n\n    Base b = d;\n    cout\u0026amp;lt;\u0026amp;lt;b.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It will generate:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;\n[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;e\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s have an example from \u0026quot;production code\u0026quot; (or something that comes kind of close):\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we have something that dispatches actions. A control center UI for example.\u0026lt;br\u0026gt;\nThis UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let\u0026apos;s call it \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt;. So an \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; has some member variables. For simplicity we just have 2, being a \u0026lt;code\u0026gt;std::string name\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;std::function\u0026amp;lt;void()\u0026amp;gt; f\u0026lt;/code\u0026gt;. Then it has an \u0026lt;code\u0026gt;void activate()\u0026lt;/code\u0026gt; which just executes the \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; member.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the UI gets a \u0026lt;code\u0026gt;std::vector\u0026amp;lt;Action\u0026amp;gt;\u0026lt;/code\u0026gt; supplied. Imagine some functions like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Action toAdd)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now we have established how it looks from the UI\u0026apos;s perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the guy derives from \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; to add his own flavour.\u0026lt;br\u0026gt;\nHe passes an instance of his home-brewed class to the \u0026lt;code\u0026gt;push_back\u0026lt;/code\u0026gt; but then the program goes haywire.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So what happened?\u0026lt;br\u0026gt;\nAs you \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; have guessed: the object has been sliced.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The extra information from the instance has been lost, and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is now prone to undefined behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this example brings light about for those people who can\u0026apos;t really imagine things when talking about \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;s and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;s being derived in some manner.\u0026lt;/p\u0026gt;\n    "],"id":78,"title":"What is object slicing?","content":"\n                \n\u0026lt;p\u0026gt;In c++ what is object slicing and when does it occur?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-object-slicing-1657384506425","postType":"QUESTION","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","tags":[{"id":285,"name":"inheritance","slug":"inheritance","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":285}},{"id":286,"name":"object-slicing","slug":"object-slicing","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":286}}],"relatedQuestions":[{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425","tags":[{"name":"inheritance","Questions_Tags":{"questionId":78,"tagId":285}},{"name":"object-slicing","Questions_Tags":{"questionId":78,"tagId":286}}]}]},"randomQuestions":[{"title":"How can I read and parse CSV files in C++?","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},{"title":"How to convert string representation of list to a list","slug":"how-to-convert-string-representation-of-list-to-a-list-1657387384181"},{"title":"How do I properly compare strings in C?","slug":"how-do-i-properly-compare-strings-in-c-1657387467202"},{"title":"How to deal with SettingWithCopyWarning in Pandas","slug":"how-to-deal-with-settingwithcopywarning-in-pandas-1657384778377"},{"title":"Simulating group_concat MySQL function in Microsoft SQL Server 2005?","slug":"simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169"},{"title":"How can I iterate through two lists in parallel?","slug":"how-can-i-iterate-through-two-lists-in-parallel-1657387278930"},{"title":"Where should I put \u003cscript\u003e tags in HTML markup?","slug":"where-should-i-put-lessscriptgreater-tags-in-html-markup-1657388350798"},{"title":"What is SQL injection? [duplicate]","slug":"what-is-sql-injection-duplicate-1657387944486"},{"title":"Split comma-separated strings in a column into separate rows","slug":"split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"Convert form data to JavaScript object with jQuery","slug":"convert-form-data-to-javascript-object-with-jquery-1657388036834"},{"title":"How to iterate over rows in a DataFrame in Pandas","slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115"},{"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583"},{"title":"How can I upload files to a server using JSP/Servlet?","slug":"how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"How can I parse a JSON file with PHP? [duplicate]","slug":"how-can-i-parse-a-json-file-with-php-duplicate-1657388002325"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"What does a \"Cannot find symbol\" or \"Cannot resolve symbol\" error mean?","slug":"what-does-a-\"cannot-find-symbol\"-or-\"cannot-resolve-symbol\"-error-mean-1657384492160"},{"title":"How do you convert a byte array to a hexadecimal string, and vice versa?","slug":"how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-object-slicing-1657384506425"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>