<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="istream,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","name":"Questions"}}]}</script><title>Why does std::getline() skip input after a formatted extraction? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I have the following piece of code that prompts the user for their cat&#x27;s age and name:
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    int age;
    std::string name;

    std::cin &gt;&gt; age;
    std::getline(std::cin, name);
    
    if (std::cin)
    {
        std::cout &lt;&lt; &quot;My cat is &quot; &lt;&lt; age &lt;&lt; &quot; years old and their name is &quot; &lt;&lt; name &lt;&lt; std::endl;
    }
}

What I find is that the age has been successfully read, but not the name. Here is the input and output:

Input:

&quot;10&quot;
&quot;Mr. Whiskers&quot;

Output:

&quot;My cat is 10 years old and their name is &quot;


Why has the name been omitted from the output? I&#x27;ve given the proper input, but the code somehow ignores it. Why does this happen?
    "/><meta property="og:title" content="Why does std::getline() skip input after a formatted extraction? | Solution Checker"/><meta property="og:description" content="I have the following piece of code that prompts the user for their cat&#x27;s age and name:
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    int age;
    std::string name;

    std::cin &gt;&gt; age;
    std::getline(std::cin, name);
    
    if (std::cin)
    {
        std::cout &lt;&lt; &quot;My cat is &quot; &lt;&lt; age &lt;&lt; &quot; years old and their name is &quot; &lt;&lt; name &lt;&lt; std::endl;
    }
}

What I find is that the age has been successfully read, but not the name. Here is the input and output:

Input:

&quot;10&quot;
&quot;Mr. Whiskers&quot;

Output:

&quot;My cat is 10 years old and their name is &quot;


Why has the name been omitted from the output? I&#x27;ve given the proper input, but the code somehow ignores it. Why does this happen?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why does std::getline() skip input after a formatted extraction?","text":"I have the following piece of code that prompts the user for their cat&apos;s age and name:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    int age;\n    std::string name;\n\n    std::cin &gt;&gt; age;\n    std::getline(std::cin, name);\n    \n    if (std::cin)\n    {\n        std::cout &lt;&lt; &quot;My cat is &quot; &lt;&lt; age &lt;&lt; &quot; years old and their name is &quot; &lt;&lt; name &lt;&lt; std::endl;\n    }\n}\n\nWhat I find is that the age has been successfully read, but not the name. Here is the input and output:\n\nInput:\n\n&quot;10&quot;\n&quot;Mr. Whiskers&quot;\n\nOutput:\n\n&quot;My cat is 10 years old and their name is &quot;\n\n\nWhy has the name been omitted from the output? I&apos;ve given the proper input, but the code somehow ignores it. Why does this happen?\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"Why does this happen?\nThis has little to do with the input you provided yourself but rather with the default behavior std::getline() has. When you provided your input for the age (std::cin &gt;&gt; age), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed Enter:\n\n&quot;10\\n&quot;\n\n\nA newline is always appended to your input when you select Enter or Return when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into age until the next I/O operation where it is either discarded or read. When the flow of control reaches std::getline(), it will see &quot;\\nMr. Whiskers&quot; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of std::getline() is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.\nSolution\ncin.ignore()\nTo fix this, one option is to skip over the newline before doing std::getline(). You can do this by calling std::cin.ignore() after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.\nstd::cin &gt;&gt; age;\nstd::cin.ignore();\nstd::getline(std::cin, name);\n\nassert(std::cin); \n// Success!\n\nstd::ws\nAnother way to discard the whitespace is to use the std::ws function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:\nstd::cin &gt;&gt; age;\nstd::getline(std::cin &gt;&gt; std::ws, name);\n\nassert(std::cin);\n// Success!\n\nThe std::cin &gt;&gt; std::ws expression is executed before the std::getline() call (and after the std::cin &gt;&gt; age call) so that the newline character is removed.\nThe difference is that ignore() discards only 1 character (or N characters when given a parameter), and std::ws continues to ignore whitespace until it finds a non-whitespace character. So if you don&apos;t know how much whitespace will precede the next token you should consider using this.\nMatch the operations\nWhen you run into an issue like this it&apos;s usually because you&apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That&apos;s what operator&gt;&gt;() is for. Unformatted input operations are anything other than that, like std::getline(), std::cin.read(), std::cin.get(), etc. Those functions don&apos;t care about the format of the input and only process raw text.\nIf you stick to using a single type of formatting then you can avoid this annoying issue:\n// Unformatted I/O\nstd::string age, name;\nstd::getline(std::cin, age);\nstd::getline(std::cin, name);\n\nor\n// Formatted I/O\nint age;\nstd::string firstName, lastName;\nstd::cin &gt;&gt; age &gt;&gt; firstName &gt;&gt; lastName;\n\nIf you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Everything will be OK if you change your initial code in the following way:\n\nif ((cin &gt;&gt; name).get() &amp;&amp; std::getline(cin, state))\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This happens because an implicit line feed also known as newline character \\n is appended to all user input from a terminal as it&apos;s telling the stream to start a new line. You can safely account for this by using std::getline when checking for multiple lines of user input. The default behavior of std::getline will read everything up to and including the newline character \\n from the input stream object which is std::cin in this case.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string name;\n    std::string state;\n\n    if (std::getline(std::cin, name) &amp;&amp; std::getline(std::cin, state))\n    {\n        std::cout &lt;&lt; &quot;Your name is &quot; &lt;&lt; name &lt;&lt; &quot; and you live in &quot; &lt;&lt; state;\n    }\n    return 0;\n}\n\n\n\nInput:\n\n&quot;John&quot;\n&quot;New Hampshire&quot;\n\nOutput:\n\n&quot;Your name is John and you live in New Hampshire&quot;\n\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Since everyone above has answered the problem for input 10\\nMr Whisker\\n, I would like to answer a different approach. all the solution above published the code for if the buffer is like 10\\nMr Whisker\\n. but what if we don&apos;t know how user will behave giving input. the user might type 10\\n\\nMr. Whisker\\n or 10 \\n\\n Mr. whisker\\n by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.\nstring StringInput()  //returns null-terminated string\n{\n    string input;\n    getline(cin, input);\n    while(input.length()==0)//keep taking input until valid string is taken\n    {\n        getline(cin, input);\n    }\n    return input.c_str();\n}\n\nSo, the answer would be:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    int age;\n    std::string name;\n\n    std::cin &gt;&gt; age;\n    name = StringInput();\n    \n    std::cout &lt;&lt; &quot;My cat is &quot; &lt;&lt; age &lt;&lt; &quot; years old and their name is &quot; &lt;&lt; name &lt;&lt; std::endl;\n    \n}\n\nExtra:\nIf user inputs a \\n10\\n \\nmr. whiskey;\nTo check whether int input is valid or not, this function can be used to check int input (program will have undefined behavior if char is given as input instead of int):\n\n//instead of &quot;std::cin&gt;&gt;age;&quot; use &quot;get_untill_int(&amp;age);&quot; in main function.\nvoid get_Untill_Int(int* pInput)//keep taking input untill input is `int or float`\n{\n    cin&gt;&gt; *pInput;\n    /*-----------check input validation----------------*/\n    while (!cin) \n    {\n        cin.clear();\n        cin.ignore(100, &apos;\\n&apos;);\n        cout&lt;&lt;&quot;Invalid Input Type.\\nEnter again: &quot;;\n        cin &gt;&gt;*pInput;\n    }\n    /*-----------checked input validation-------------*/\n}\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called std::ws. And then, you can simply use\nstd::getline(std::cin &gt;&gt; std::ws, name);\n\nThat should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.\nIf we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use\n.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &apos;\\n&apos;); to eliminate the wrong stuff.\nPlease read here\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"><h1>Why does std::getline() skip input after a formatted extraction?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/istream">istream</a></div></div><div class="question-content mt-5">
                
<p>I have the following piece of code that prompts the user for their cat's age and name:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> age;
    std::string name;

    std::cin &gt;&gt; age;
    std::<span class="hljs-built_in">getline</span>(std::cin, name);
    
    <span class="hljs-keyword">if</span> (std::cin)
    {
        std::cout &lt;&lt; <span class="hljs-string">"My cat is "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years old and their name is "</span> &lt;&lt; name &lt;&lt; std::endl;
    }
}
</code></pre>
<p>What I find is that the age has been successfully read, but not the name. Here is the input and output:</p>
<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Input:

<span class="hljs-string">"10"</span>
<span class="hljs-string">"Mr. Whiskers"</span>

Output:

<span class="hljs-string">"My cat is 10 years old and their name is "</span>
</code></pre>
</blockquote>
<p>Why has the name been omitted from the output? I've given the proper input, but the code somehow ignores it. Why does this happen?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/istream">istream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Why does this happen?</h1>
<p>This has little to do with the input you provided yourself but rather with the default behavior <code>std::getline()</code> has. When you provided your input for the age (<code>std::cin &gt;&gt; age</code>), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed <kbd>Enter</kbd>:</p>
<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-string">"10\n"</span>
</code></pre>
</blockquote>
<p>A newline is always appended to your input when you select <kbd>Enter</kbd> or <kbd>Return</kbd> when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into <code>age</code> until the next I/O operation where it is either discarded or read. When the flow of control reaches <code>std::getline()</code>, it will see <code>"\nMr. Whiskers"</code> and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of <code>std::getline()</code> is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.</p>
<h1>Solution</h1>
<h2><code>cin.ignore()</code></h2>
<p>To fix this, one option is to skip over the newline before doing <code>std::getline()</code>. You can do this by calling <code>std::cin.ignore()</code> after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cin &gt;&gt; age;
std::cin.<span class="hljs-built_in">ignore</span>();
std::<span class="hljs-built_in">getline</span>(std::cin, name);

<span class="hljs-built_in">assert</span>(std::cin); 
<span class="hljs-comment">// Success!</span>
</code></pre>
<h2><code>std::ws</code></h2>
<p>Another way to discard the whitespace is to use the <code>std::ws</code> function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cin &gt;&gt; age;
std::<span class="hljs-built_in">getline</span>(std::cin &gt;&gt; std::ws, name);

<span class="hljs-built_in">assert</span>(std::cin);
<span class="hljs-comment">// Success!</span>
</code></pre>
<p>The <code>std::cin &gt;&gt; std::ws</code> expression is executed before the <code>std::getline()</code> call (and after the <code>std::cin &gt;&gt; age</code> call) so that the newline character is removed.</p>
<p>The difference is that <code>ignore()</code> discards only 1 character (or N characters when given a parameter), and <code>std::ws</code> continues to ignore whitespace until it finds a non-whitespace character. So if you don't know how much whitespace will precede the next token you should consider using this.</p>
<h2>Match the operations</h2>
<p>When you run into an issue like this it's usually because you're combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That's what <code>operator&gt;&gt;()</code> is for. Unformatted input operations are anything other than that, like <code>std::getline()</code>, <code>std::cin.read()</code>, <code>std::cin.get()</code>, etc. Those functions don't care about the format of the input and only process raw text.</p>
<p>If you stick to using a single type of formatting then you can avoid this annoying issue:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Unformatted I/O</span>
std::string age, name;
std::<span class="hljs-built_in">getline</span>(std::cin, age);
std::<span class="hljs-built_in">getline</span>(std::cin, name);
</code></pre>
<p>or</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Formatted I/O</span>
<span class="hljs-type">int</span> age;
std::string firstName, lastName;
std::cin &gt;&gt; age &gt;&gt; firstName &gt;&gt; lastName;
</code></pre>
<p>If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/istream">istream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Everything will be OK if you change your initial code in the following way:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span> ((cin &gt;&gt; name).<span class="hljs-built_in">get</span>() &amp;&amp; std::<span class="hljs-built_in">getline</span>(cin, state))
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/istream">istream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This happens because an implicit line feed also known as newline character <code>\n</code> is appended to all user input from a terminal as it's telling the stream to start a new line. You can safely account for this by using <a href="http://en.cppreference.com/w/cpp/string/basic_string/getline" rel="nofollow noreferrer"><code>std::getline</code></a> when checking for multiple lines of user input. The default behavior of <code>std::getline</code> will read everything up to and including the newline character <code>\n</code> from the input stream object which is <code>std::cin</code> in this case.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name;
    std::string state;

    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">getline</span>(std::cin, name) &amp;&amp; std::<span class="hljs-built_in">getline</span>(std::cin, state))
    {
        std::cout &lt;&lt; <span class="hljs-string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" and you live in "</span> &lt;&lt; state;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Input:

<span class="hljs-string">"John"</span>
<span class="hljs-string">"New Hampshire"</span>

Output:

<span class="hljs-string">"Your name is John and you live in New Hampshire"</span>
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/istream">istream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since everyone above has answered the problem for input <code>10\nMr Whisker\n</code>, I would like to answer a different approach. all the solution above published the code for if the buffer is like <code>10\nMr Whisker\n</code>. but what if we don't know how user will behave giving input. the user might type <code>10\n\nMr. Whisker\n</code> or <code>10 \n\n Mr. whisker\n</code> by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">StringInput</span><span class="hljs-params">()</span>  <span class="hljs-comment">//returns null-terminated string</span>
</span>{
    string input;
    <span class="hljs-built_in">getline</span>(cin, input);
    <span class="hljs-keyword">while</span>(input.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>)<span class="hljs-comment">//keep taking input until valid string is taken</span>
    {
        <span class="hljs-built_in">getline</span>(cin, input);
    }
    <span class="hljs-keyword">return</span> input.<span class="hljs-built_in">c_str</span>();
}
</code></pre>
<p>So, the answer would be:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> age;
    std::string name;

    std::cin &gt;&gt; age;
    name = <span class="hljs-built_in">StringInput</span>();
    
    std::cout &lt;&lt; <span class="hljs-string">"My cat is "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years old and their name is "</span> &lt;&lt; name &lt;&lt; std::endl;
    
}
</code></pre>
<p><strong>Extra:</strong></p>
<p>If user inputs <code>a \n10\n \nmr. whiskey</code>;
To check whether <code>int</code> input is valid or not, this function can be used to check <code>int</code> input (program will have undefined behavior if <code>char</code> is given as input instead of <code>int</code>):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">
<span class="hljs-comment">//instead of "std::cin&gt;&gt;age;" use "get_untill_int(&amp;age);" in main function.</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_Untill_Int</span><span class="hljs-params">(<span class="hljs-type">int</span>* pInput)</span><span class="hljs-comment">//keep taking input untill input is `int or float`</span>
</span>{
    cin&gt;&gt; *pInput;
    <span class="hljs-comment">/*-----------check input validation----------------*/</span>
    <span class="hljs-keyword">while</span> (!cin) 
    {
        cin.<span class="hljs-built_in">clear</span>();
        cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">100</span>, <span class="hljs-string">'\n'</span>);
        cout&lt;&lt;<span class="hljs-string">"Invalid Input Type.\nEnter again: "</span>;
        cin &gt;&gt;*pInput;
    }
    <span class="hljs-comment">/*-----------checked input validation-------------*/</span>
}
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/istream">istream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called <a href="https://en.cppreference.com/w/cpp/io/manip/ws" rel="nofollow noreferrer">std::ws</a>. And then, you can simply use</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::<span class="hljs-built_in">getline</span>(std::cin &gt;&gt; std::ws, name);
</code></pre>
<p>That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.</p>
<p>If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use</p>
<p><code>.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code> to eliminate the wrong stuff.</p>
<p>Please read <a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore" rel="nofollow noreferrer">here</a></p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/disable-same-origin-policy-in-chrome-1657387743804">Disable same origin policy in Chrome</a><a href="/questions/how-do-i-add-a-delay-in-a-javascript-loop-1657388544679">How do I add a delay in a JavaScript loop?</a><a href="/questions/trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490">Trouble with UTF-8 characters; what I see is not what I stored</a><a href="/questions/reshaping-data.frame-from-wide-to-long-format-1657384678522">Reshaping data.frame from wide to long format</a><a href="/questions/how-to-filter-object-array-based-on-attributes-1657388211247">How to filter object array based on attributes?</a><a href="/questions/what-is-the-difference-between-%22inner-join%22-and-%22outer-join%22-1657387501982">What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;?</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a><a href="/questions/how-should-a-model-be-structured-in-mvc-closed-1657388394807">How should a model be structured in MVC? [closed]</a><a href="/questions/how-do-i-make-a-redirect-in-php-1657387381903">How do I make a redirect in PHP?</a><a href="/questions/what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752">What are the basic rules and idioms for operator overloading?</a><a href="/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679">Is JavaScript a pass-by-reference or pass-by-value language?</a><a href="/questions/how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855">How can I convert ereg expressions to preg in PHP?</a><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a><a href="/questions/how-do-i-correctly-clone-a-javascript-object-1657387325850">How do I correctly clone a JavaScript object?</a><a href="/questions/how-to-filter-pandas-dataframe-using-&#x27;in&#x27;-and-&#x27;not-in&#x27;-like-in-sql-1657387371355">How to filter Pandas dataframe using &#x27;in&#x27; and &#x27;not in&#x27; like in SQL</a><a href="/questions/how-do-you-use-a-variable-in-a-regular-expression-1657387939007">How do you use a variable in a regular expression?</a><a href="/questions/how-do-i-declare-a-2d-array-in-c++-using-new-1657388441163">How do I declare a 2d array in C++ using new?</a><a href="/questions/ggplot-with-2-y-axes-on-each-side-and-different-scales-1657388519163">ggplot with 2 y axes on each side and different scales</a><a href="/questions/why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476">Why do we always prefer using parameters in SQL statements?</a><a href="/questions/how-to-store-objects-in-html5-localstorage-1657387568907">How to store objects in HTML5 localStorage</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Why does this happen?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;This has little to do with the input you provided yourself but rather with the default behavior \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; has. When you provided your input for the age (\u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age\u0026lt;/code\u0026gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed \u0026lt;kbd\u0026gt;Enter\u0026lt;/kbd\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;10\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;A newline is always appended to your input when you select \u0026lt;kbd\u0026gt;Enter\u0026lt;/kbd\u0026gt; or \u0026lt;kbd\u0026gt;Return\u0026lt;/kbd\u0026gt; when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; until the next I/O operation where it is either discarded or read. When the flow of control reaches \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;, it will see \u0026lt;code\u0026gt;\u0026quot;\\nMr. Whiskers\u0026quot;\u0026lt;/code\u0026gt; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Solution\u0026lt;/h1\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;cin.ignore()\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;To fix this, one option is to skip over the newline before doing \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;. You can do this by calling \u0026lt;code\u0026gt;std::cin.ignore()\u0026lt;/code\u0026gt; after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age;\nstd::cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ignore\u0026lt;/span\u0026gt;();\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(std::cin); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Success!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Another way to discard the whitespace is to use the \u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age;\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin \u0026amp;gt;\u0026amp;gt; std::ws, name);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(std::cin);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Success!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; std::ws\u0026lt;/code\u0026gt; expression is executed before the \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; call (and after the \u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age\u0026lt;/code\u0026gt; call) so that the newline character is removed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The difference is that \u0026lt;code\u0026gt;ignore()\u0026lt;/code\u0026gt; discards only 1 character (or N characters when given a parameter), and \u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; continues to ignore whitespace until it finds a non-whitespace character. So if you don\u0026apos;t know how much whitespace will precede the next token you should consider using this.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Match the operations\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When you run into an issue like this it\u0026apos;s usually because you\u0026apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That\u0026apos;s what \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;()\u0026lt;/code\u0026gt; is for. Unformatted input operations are anything other than that, like \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::cin.read()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::cin.get()\u0026lt;/code\u0026gt;, etc. Those functions don\u0026apos;t care about the format of the input and only process raw text.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you stick to using a single type of formatting then you can avoid this annoying issue:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Unformatted I/O\u0026lt;/span\u0026gt;\nstd::string age, name;\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, age);\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Formatted I/O\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\nstd::string firstName, lastName;\nstd::cin \u0026amp;gt;\u0026amp;gt; age \u0026amp;gt;\u0026amp;gt; firstName \u0026amp;gt;\u0026amp;gt; lastName;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Everything will be OK if you change your initial code in the following way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((cin \u0026amp;gt;\u0026amp;gt; name).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;() \u0026amp;amp;\u0026amp;amp; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, state))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This happens because an implicit line feed also known as newline character \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; is appended to all user input from a terminal as it\u0026apos;s telling the stream to start a new line. You can safely account for this by using \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/string/basic_string/getline\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::getline\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when checking for multiple lines of user input. The default behavior of \u0026lt;code\u0026gt;std::getline\u0026lt;/code\u0026gt; will read everything up to and including the newline character \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; from the input stream object which is \u0026lt;code\u0026gt;std::cin\u0026lt;/code\u0026gt; in this case.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::string name;\n    std::string state;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name) \u0026amp;amp;\u0026amp;amp; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, state))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Your name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; and you live in \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; state;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Input:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;New Hampshire\u0026quot;\u0026lt;/span\u0026gt;\n\nOutput:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Your name is John and you live in New Hampshire\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since everyone above has answered the problem for input \u0026lt;code\u0026gt;10\\nMr Whisker\\n\u0026lt;/code\u0026gt;, I would like to answer a different approach. all the solution above published the code for if the buffer is like \u0026lt;code\u0026gt;10\\nMr Whisker\\n\u0026lt;/code\u0026gt;. but what if we don\u0026apos;t know how user will behave giving input. the user might type \u0026lt;code\u0026gt;10\\n\\nMr. Whisker\\n\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;10 \\n\\n Mr. whisker\\n\u0026lt;/code\u0026gt; by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringInput\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//returns null-terminated string\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    string input;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, input);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(input.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;()==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//keep taking input until valid string is taken\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, input);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; input.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So, the answer would be:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n    std::string name;\n\n    std::cin \u0026amp;gt;\u0026amp;gt; age;\n    name = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringInput\u0026lt;/span\u0026gt;();\n    \n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; age \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; years old and their name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; std::endl;\n    \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Extra:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If user inputs \u0026lt;code\u0026gt;a \\n10\\n \\nmr. whiskey\u0026lt;/code\u0026gt;;\nTo check whether \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; input is valid or not, this function can be used to check \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; input (program will have undefined behavior if \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; is given as input instead of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//instead of \u0026quot;std::cin\u0026amp;gt;\u0026amp;gt;age;\u0026quot; use \u0026quot;get_untill_int(\u0026amp;amp;age);\u0026quot; in main function.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get_Untill_Int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pInput)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//keep taking input untill input is `int or float`\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    cin\u0026amp;gt;\u0026amp;gt; *pInput;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------check input validation----------------*/\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!cin) \n    {\n        cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ignore\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n        cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Invalid Input Type.\\nEnter again: \u0026quot;\u0026lt;/span\u0026gt;;\n        cin \u0026amp;gt;\u0026amp;gt;*pInput;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------checked input validation-------------*/\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/io/manip/ws\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;std::ws\u0026lt;/a\u0026gt;. And then, you can simply use\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin \u0026amp;gt;\u0026amp;gt; std::ws, name);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;.ignore(std::numeric_limits\u0026amp;lt;std::streamsize\u0026amp;gt;::max(), \u0026apos;\\n\u0026apos;);\u0026lt;/code\u0026gt; to eliminate the wrong stuff.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please read \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/io/basic_istream/ignore\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":145,"title":"Why does std::getline() skip input after a formatted extraction?","content":"\n                \n\u0026lt;p\u0026gt;I have the following piece of code that prompts the user for their cat\u0026apos;s age and name:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n    std::string name;\n\n    std::cin \u0026amp;gt;\u0026amp;gt; age;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::cin)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; age \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; years old and their name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What I find is that the age has been successfully read, but not the name. Here is the input and output:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Input:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;10\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mr. Whiskers\u0026quot;\u0026lt;/span\u0026gt;\n\nOutput:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is 10 years old and their name is \u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Why has the name been omitted from the output? I\u0026apos;ve given the proper input, but the code somehow ignores it. Why does this happen?\u0026lt;/p\u0026gt;\n    ","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","postType":"QUESTION","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","tags":[{"id":528,"name":"istream","slug":"istream","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","Questions_Tags":{"questionId":145,"tagId":528}}],"relatedQuestions":[{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","tags":[{"name":"istream","Questions_Tags":{"questionId":145,"tagId":528}}]}]},"randomQuestions":[{"title":"Disable same origin policy in Chrome","slug":"disable-same-origin-policy-in-chrome-1657387743804"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"Trouble with UTF-8 characters; what I see is not what I stored","slug":"trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490"},{"title":"Reshaping data.frame from wide to long format","slug":"reshaping-data.frame-from-wide-to-long-format-1657384678522"},{"title":"How to filter object array based on attributes?","slug":"how-to-filter-object-array-based-on-attributes-1657388211247"},{"title":"What is the difference between \"INNER JOIN\" and \"OUTER JOIN\"?","slug":"what-is-the-difference-between-\"inner-join\"-and-\"outer-join\"-1657387501982"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"How should a model be structured in MVC? [closed]","slug":"how-should-a-model-be-structured-in-mvc-closed-1657388394807"},{"title":"How do I make a redirect in PHP?","slug":"how-do-i-make-a-redirect-in-php-1657387381903"},{"title":"What are the basic rules and idioms for operator overloading?","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752"},{"title":"Is JavaScript a pass-by-reference or pass-by-value language?","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},{"title":"How can I convert ereg expressions to preg in PHP?","slug":"how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"How do I correctly clone a JavaScript object?","slug":"how-do-i-correctly-clone-a-javascript-object-1657387325850"},{"title":"How to filter Pandas dataframe using 'in' and 'not in' like in SQL","slug":"how-to-filter-pandas-dataframe-using-'in'-and-'not-in'-like-in-sql-1657387371355"},{"title":"How do you use a variable in a regular expression?","slug":"how-do-you-use-a-variable-in-a-regular-expression-1657387939007"},{"title":"How do I declare a 2d array in C++ using new?","slug":"how-do-i-declare-a-2d-array-in-c++-using-new-1657388441163"},{"title":"ggplot with 2 y axes on each side and different scales","slug":"ggplot-with-2-y-axes-on-each-side-and-different-scales-1657388519163"},{"title":"Why do we always prefer using parameters in SQL statements?","slug":"why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476"},{"title":"How to store objects in HTML5 localStorage","slug":"how-to-store-objects-in-html5-localstorage-1657387568907"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>