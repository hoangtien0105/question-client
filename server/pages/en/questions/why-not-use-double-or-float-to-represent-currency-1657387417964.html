<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="currency,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-not-use-double-or-float-to-represent-currency-1657387417964","name":"Questions"}}]}</script><title>Why not use Double or Float to represent currency? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I&#x27;ve always been told never to represent money with double or float types, and this time I pose the question to you: why? 

I&#x27;m sure there is a very good reason, I simply do not know what it is.
    "/><meta property="og:title" content="Why not use Double or Float to represent currency? | Solution Checker"/><meta property="og:description" content="I&#x27;ve always been told never to represent money with double or float types, and this time I pose the question to you: why? 

I&#x27;m sure there is a very good reason, I simply do not know what it is.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why not use Double or Float to represent currency?","text":"I&apos;ve always been told never to represent money with double or float types, and this time I pose the question to you: why? \n\nI&apos;m sure there is a very good reason, I simply do not know what it is.\n    ","answerCount":16,"upVoteCount":500,"suggestedAnswer":[{"text":"Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn&apos;t just for Java, it&apos;s for any programming language that uses base 2 floating-point types.\nIn base 10, you can write 10.25 as 1025 * 10-2 (an integer times a power of 10). IEEE-754 floating-point numbers are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2-4 (an integer times a power of two), which is also equal to 10.25. That&apos;s not how the numbers are represented in memory, but the math implications are the same.\nEven in base 10, this notation cannot accurately represent most simple fractions. For instance, you can&apos;t represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3&apos;s and a small exponent, like 333333333 * 10-10, but it is not accurate: if you multiply that by 3, you won&apos;t get 1.\nHowever, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10-2, so it doesn&apos;t really matter that 1/3 can&apos;t be represented.\nThe problem with floats and doubles is that the vast majority of money-like numbers don&apos;t have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they&apos;re integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.01 and you multiply it by 10, you won&apos;t get 0.1. Instead you will get something like 0.099999999786...\nRepresenting money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you&apos;ll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.\nA solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the BigDecimal class, and C# has the decimal type.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"From Bloch, J., Effective Java, (2nd ed, Item 48. 3rd ed, Item 60):\n\nThe float and double types are\nparticularly ill-suited for monetary\ncalculations because it is impossible\nto represent 0.1 (or any other\nnegative power of ten) as a float or\ndouble exactly.\nFor example, suppose you have $1.03\nand you spend 42c. How much money do\nyou have left?\nSystem.out.println(1.03 - .42);\n\nprints out 0.6100000000000001.\nThe right way to solve this problem is\nto use BigDecimal, int or long\nfor monetary calculations.\n\nThough BigDecimal has some caveats (please see currently accepted answer).\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are &quot;wrong&quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.\n\nEven if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.\n\nUsing a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.\n\nAssume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.\n\nIf you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I&apos;m troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.\n\nIf your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.\n\nThe problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,\n\nSystem.out.println(1000000.0f + 1.2f - 1000000.0f);\n\n\nresults in\n\n1.1875\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I&apos;ll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.\n\nPeople calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.\n\nOf course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn&apos;t want to touch floating point numbers with a ten foot pole.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:\n\ngroovy:000&gt; new BigDecimal(1.0F)\n===&gt; 1\ngroovy:000&gt; new BigDecimal(1.01F)\n===&gt; 1.0099999904632568359375\n\n\nthis probably isn&apos;t how you want to represent $1.01.\n\nThe problem is that the IEEE spec doesn&apos;t have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can&apos;t close their account, it&apos;s better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.\n\nIt&apos;s not that the error isn&apos;t controllable if you round: see this article by Peter Lawrey. It&apos;s just easier not to have to round in the first place. Most applications that handle money don&apos;t call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"While it&apos;s true that floating point type can represent only approximatively decimal data, it&apos;s also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.\n\nUsually because the double type has a precision less than 16 figures. If you require better precision it&apos;s not a suitable type. Also approximations can accumulate.\n\nIt must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.\n\nFor example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.\n\nConcluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.\n\nConsider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.\n\nPrecision 14\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611\n\nPrecision 15\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110\n\nPrecision 16\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101\n\nPrecision 17\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611011\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611013\n\nPrecision 18\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110111\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110125\n\nPrecision 19\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101111\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101252\n\n\n\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.MathContext;\n\npublic class Exercise {\n    public static void main(String[] args) throws IllegalArgumentException,\n            SecurityException, IllegalAccessException,\n            InvocationTargetException, NoSuchMethodException {\n        String amount = &quot;56789.012345&quot;;\n        String quantity = &quot;1111111111&quot;;\n        int [] precisions = new int [] {14, 15, 16, 17, 18, 19};\n        for (int i = 0; i &lt; precisions.length; i++) {\n            int precision = precisions[i];\n            System.out.println(String.format(&quot;Precision %d&quot;, precision));\n            System.out.println(&quot;------------------------------------------------------&quot;);\n            execute(&quot;BigDecimalNoRound&quot;, amount, quantity, precision);\n            execute(&quot;DoubleNoRound&quot;, amount, quantity, precision);\n            execute(&quot;BigDecimal&quot;, amount, quantity, precision);\n            execute(&quot;Double&quot;, amount, quantity, precision);\n            System.out.println();\n        }\n    }\n\n    private static void execute(String test, String amount, String quantity,\n            int precision) throws IllegalArgumentException, SecurityException,\n            IllegalAccessException, InvocationTargetException,\n            NoSuchMethodException {\n        Method impl = Exercise.class.getMethod(&quot;divideUsing&quot; + test, String.class,\n                String.class, int.class);\n        String price;\n        try {\n            price = (String) impl.invoke(null, amount, quantity, precision);\n        } catch (InvocationTargetException e) {\n            price = e.getTargetException().getMessage();\n        }\n        System.out.println(String.format(&quot;%-30s: %s / %s = %s&quot;, test, amount,\n                quantity, price));\n    }\n\n    public static String divideUsingDoubleNoRound(String amount,\n            String quantity, int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        String price = Double.toString(price0);\n        return price;\n    }\n\n    public static String divideUsingDouble(String amount, String quantity,\n            int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        MathContext precision0 = new MathContext(precision);\n        String price = new BigDecimal(price0, precision0)\n                .toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimal(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n        MathContext precision0 = new MathContext(precision);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0, precision0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimalNoRound(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesnt produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.\n\n    // floating point calculation\n    final double amount1 = 2.0;\n    final double amount2 = 1.1;\n    System.out.println(&quot;difference between 2.0 and 1.1 using double is: &quot; + (amount1 - amount2));\n\n    // Use BigDecimal for financial calculation\n    final BigDecimal amount3 = new BigDecimal(&quot;2.0&quot;);\n    final BigDecimal amount4 = new BigDecimal(&quot;1.1&quot;);\n    System.out.println(&quot;difference between 2.0 and 1.1 using BigDecimal is: &quot; + (amount3.subtract(amount4)));\n\n\nOutput:\n\ndifference between 2.0 and 1.1 using double is: 0.8999999999999999\ndifference between 2.0 and 1.1 using BigDecimal is: 0.9\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"As said earlier &quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, youll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.&quot;\nFinally Java has a standard way to work with Currency And Money!\nJSR 354: Money and Currency API\nJSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:\nJSR 354: Money and Currency API Download\nThe specification consists of the following things:\n\n\nAn API for handling e. g. monetary amounts and currencies\nAPIs to support interchangeable implementations\nFactories for creating instances of the implementation classes\nFunctionality for calculations, conversion and formatting of monetary            amounts\nJava API for working with Money and Currencies, which is planned to be included in Java 9.\nAll specification classes and interfaces are located in the javax.money.* package.\n\n\nSample Examples of JSR 354: Money and Currency API:\nAn example of creating a MonetaryAmount and printing it to the console looks like this:\nMonetaryAmountFactory&lt;?&gt; amountFactory = Monetary.getDefaultAmountFactory();\nMonetaryAmount monetaryAmount = amountFactory.setCurrency(Monetary.getCurrency(&quot;EUR&quot;)).setNumber(12345.67).create();\nMonetaryAmountFormat format = MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\nWhen using the reference implementation API, the necessary code is much simpler:\nMonetaryAmount monetaryAmount = Money.of(12345.67, &quot;EUR&quot;);\nMonetaryAmountFormat format = MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\nThe API also supports calculations with MonetaryAmounts:\nMonetaryAmount monetaryAmount = Money.of(12345.67, &quot;EUR&quot;);\nMonetaryAmount otherMonetaryAmount = monetaryAmount.divide(2).add(Money.of(5, &quot;EUR&quot;));\n\nCurrencyUnit and MonetaryAmount\n// getting CurrencyUnits by locale\nCurrencyUnit yen = MonetaryCurrencies.getCurrency(Locale.JAPAN);\nCurrencyUnit canadianDollar = MonetaryCurrencies.getCurrency(Locale.CANADA);\n\nMonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:\nMonetaryAmount monetaryAmount = Money.of(123.45, euro);\nCurrencyUnit currency = monetaryAmount.getCurrency();\nNumberValue numberValue = monetaryAmount.getNumber();\n\nint intValue = numberValue.intValue(); // 123\ndouble doubleValue = numberValue.doubleValue(); // 123.45\nlong fractionDenominator = numberValue.getAmountFractionDenominator(); // 100\nlong fractionNumerator = numberValue.getAmountFractionNumerator(); // 45\nint precision = numberValue.getPrecision(); // 5\n\n// NumberValue extends java.lang.Number.\n// So we assign numberValue to a variable of type Number\nNumber number = numberValue;\n\nMonetaryAmounts can be rounded using a rounding operator:\nCurrencyUnit usd = MonetaryCurrencies.getCurrency(&quot;USD&quot;);\nMonetaryAmount dollars = Money.of(12.34567, usd);\nMonetaryOperator roundingOperator = MonetaryRoundings.getRounding(usd);\nMonetaryAmount roundedDollars = dollars.with(roundingOperator); // USD 12.35\n\nWhen working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.\nList&lt;MonetaryAmount&gt; amounts = new ArrayList&lt;&gt;();\namounts.add(Money.of(2, &quot;EUR&quot;));\namounts.add(Money.of(42, &quot;USD&quot;));\namounts.add(Money.of(7, &quot;USD&quot;));\namounts.add(Money.of(13.37, &quot;JPY&quot;));\namounts.add(Money.of(18, &quot;USD&quot;));\n\nCustom MonetaryAmount operations\n// A monetary operator that returns 10% of the input MonetaryAmount\n// Implemented using Java 8 Lambdas\nMonetaryOperator tenPercentOperator = (MonetaryAmount amount) -&gt; {\n    BigDecimal baseAmount = amount.getNumber().numberValue(BigDecimal.class);\n    BigDecimal tenPercent = baseAmount.multiply(new BigDecimal(&quot;0.1&quot;));\n    return Money.of(tenPercent, amount.getCurrency());\n};\n\nMonetaryAmount dollars = Money.of(12.34567, &quot;USD&quot;);\n\n// apply tenPercentOperator to MonetaryAmount\nMonetaryAmount tenPercentDollars = dollars.with(tenPercentOperator); // USD 1.234567\n\nResources:\nHandling money and currencies in Java with JSR 354\nLooking into the Java 9 Money and Currency API (JSR 354)\nSee Also: JSR 354 - Currency and Money\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them. \n\nIt doesn&apos;t mean though that doubles can never be used for that purpose. \n\nI have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead. \n\nIt&apos;s the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.\n\nYou can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.\n\nYou can refer to guava&apos;s FuzzyCompare method to get more idea. The parameter tolerance is the key. \nWe dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.\n\nAlso, there might be situations when you&apos;re tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values &quot;0.5&quot; &amp; &quot;0.6 - 0.1&quot; will cause a big mess.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"If your computation involves various steps, arbitrary precision arithmetic won&apos;t cover you 100%.\n\nThe only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.\n\nArbitrary precision won&apos;t help because there always can be numbers that has so many decimal places, or some results such as 0.6666666... No arbitrary representation will cover the last example. So you will have small errors in each step.\n\nThese errors will add-up, may eventually become not easy to ignore anymore. This is called Error Propagation.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.\n\nComing from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn&apos;t use a double or float in a mathematical calculation is that I would lose too much information.\n\nWhat are the alternatives? There are many (and many more of which I am not aware!).\n\nBigDecimal in Java is native to the Java language.\nApfloat is another arbitrary-precision library for Java.\n\nThe decimal data type in C# is Microsoft&apos;s .NET alternative for 28 significant figures.\n\nSciPy (Scientific Python) can probably also handle financial calculations (I haven&apos;t tried, but I suspect so).\n\nThe GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.\n\nThere are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.\n\nThere are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.\n\nI&apos;m not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven&apos;t tried the other solutions I&apos;ve listed, but they are probably very good as well.\n\nFor me, I like BigDecimal because of the methods it supports. C#&apos;s decimal is very nice, but I haven&apos;t had the chance to work with it as much as I&apos;d like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you&apos;re using the divide method.\n\nYou might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"To add on previous answers, there is also the option of implementing Joda-Money in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java module name is org.joda.money.\nIt requires Java SE 8 or later and has no dependencies.\n\nTo be more precise, there is a compile-time dependency but it is not\nrequired.\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.joda&lt;/groupId&gt;\n  &lt;artifactId&gt;joda-money&lt;/artifactId&gt;\n  &lt;version&gt;1.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n\nExamples of using Joda Money:\n  // create a monetary value\n  Money money = Money.parse(&quot;USD 23.87&quot;);\n  \n  // add another amount with safe double conversion\n  CurrencyUnit usd = CurrencyUnit.of(&quot;USD&quot;);\n  money = money.plus(Money.of(usd, 12.43d));\n  \n  // subtracts an amount in dollars\n  money = money.minusMajor(2);\n  \n  // multiplies by 3.5 with rounding\n  money = money.multipliedBy(3.5d, RoundingMode.DOWN);\n  \n  // compare two amounts\n  boolean bigAmount = money.isGreaterThan(dailyWage);\n  \n  // convert to GBP using a supplied rate\n  BigDecimal conversionRate = ...;  // obtained from code outside Joda-Money\n  Money moneyGBP = money.convertedTo(CurrencyUnit.GBP, conversionRate, RoundingMode.HALF_UP);\n  \n  // use a BigMoney for more complex calculations where scale matters\n  BigMoney moneyCalc = money.toBigMoney();\n\n\nDocumentation:\nhttp://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html\nImplementation examples:\nhttps://www.programcreek.com/java-api-examples/?api=org.joda.money.Money\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Float is binary form of Decimal with different design; they are two different things. There are little errors between two types when converted to each other. Also, float is designed to represent infinite large number of values for scientific. That means it is designed to lost precision to extreme small and extreme large number with that fixed number of bytes. Decimal can&apos;t represent infinite number of values, it bounds to just that number of decimal digits. So Float and Decimal are for different purpose.\n\nThere are some ways to manage the error for currency value:\n\n\nUse long integer and count in cents instead.\nUse double precision, keep your significant digits to 15 only so decimal can be exactly simulated. Round before presenting values; Round often when doing calculations.\nUse a decimal library like Java BigDecimal so you don&apos;t need to use double to simulate decimal.\n\n\np.s. it is interesting to know that most brands of handheld scientific calculators works on decimal instead of float. So no one complaint float conversion errors.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Take a look at this simple example: it looks like logically correct, but in real world this can return unexpected results if not threated correctly:\n0.1 x 10 = 1   , so:\ndouble total = 0.0;\n\n// adds 10 cents, 10 times\nfor (int i = 0; i &lt; 10; i++) {\n    total += 0.1;  // adds 10 cents\n}\n\nLog.d(&quot;result: &quot;, &quot;current total: &quot; + total);\n\n// looks like total equals to 1.0, don&apos;t?\n\n// now, do reverse\nfor (int i = 0; i &lt; 10; i++) {\n    total -= 0.1;  // removes 10 cents\n}\n\n// total should be equals to 0.0, right?\nLog.d(&quot;result: &quot;, &quot;current total: &quot; + total);\nif (total == 0.0) {\n    Log.d(&quot;result: &quot;, &quot;is total equal to ZERO? YES, of course!!&quot;);\n} else {\n    Log.d(&quot;result: &quot;, &quot;is total equal to ZERO? No...&quot;);\n    // so be careful comparing equality in this cases!!!\n}\n\nOUTPUT:\n result: current total: 0.9999999999999999\n result: current total: 2.7755575615628914E-17   \n result: is total equal to ZERO? No... \n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"American currency can easily be represented with dollar and cent amounts.  Integers are 100% precise, while floating point binary numbers do not exactly match floating point decimals.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-not-use-double-or-float-to-represent-currency-1657387417964#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-not-use-double-or-float-to-represent-currency-1657387417964"><h1>Why not use Double or Float to represent currency?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/currency">currency</a></div></div><div class="question-content mt-5">
                
<p>I've always been told <em>never</em> to represent money with <code>double</code> or <code>float</code> types, and this time I pose the question to you: why? </p>

<p>I'm sure there is a very good reason, I simply do not know what it is.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</p>
<p>In base 10, you can write 10.25 as 1025 * 10<sup>-2</sup> (an integer times a power of 10). <a href="http://en.wikipedia.org/wiki/IEEE_floating_point" rel="noreferrer">IEEE-754 floating-point numbers</a> are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2<sup>-4</sup> (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</p>
<p>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10<sup>-10</sup>, but it is not accurate: if you multiply that by 3, you won't get&nbsp;1.</p>
<p>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10<sup>-2</sup>, so it doesn't really matter that 1/3 can't be represented.</p>
<p>The problem with floats and doubles is that the <em>vast majority</em> of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.01 and you multiply it by&nbsp;10, you won't get&nbsp;0.1. Instead you will get something like 0.099999999786...</p>
<p>Representing money as a <code>double</code> or <code>float</code> will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</p>
<p>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html" rel="noreferrer"><code>BigDecimal</code></a> class, and C# has the <a href="http://msdn.microsoft.com/en-us/library/364x0z75.aspx" rel="noreferrer"><code>decimal</code></a> type.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>From Bloch, J., Effective Java, (2nd ed, Item 48. 3rd ed, Item 60):</strong></p>
<blockquote>
<p>The <code>float</code> and <code>double</code> types are
particularly ill-suited for monetary
calculations because it is impossible
to represent 0.1 (or any other
negative power of ten) as a <code>float</code> or
<code>double</code> exactly.</p>
<p>For example, suppose you have $1.03
and you spend 42c. How much money do
you have left?</p>
<pre><code>System.out.println(1.03 - .42);
</code></pre>
<p>prints out <code>0.6100000000000001</code>.</p>
<p>The right way to solve this problem is
to use <code>BigDecimal</code>, <code>int</code> or <code>long</code>
for monetary calculations.</p>
</blockquote>
<p>Though <code>BigDecimal</code> has some caveats (please see currently accepted answer).</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are "wrong" in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.</p>

<p>Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.</p>

<p>Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.</p>

<p>Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.</p>

<p>If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.</p>

<p>If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.</p>

<p>The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,</p>

<pre><code>System.out.println(1000000.0f + 1.2f - 1000000.0f);
</code></pre>

<p>results in</p>

<pre><code>1.1875
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.</p>

<p>People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.</p>

<p>Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn't want to touch floating point numbers with a ten foot pole.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:</p>

<pre><code>groovy:000&gt; new BigDecimal(1.0F)
===&gt; 1
groovy:000&gt; new BigDecimal(1.01F)
===&gt; 1.0099999904632568359375
</code></pre>

<p>this probably isn't how you want to represent $1.01.</p>

<p>The problem is that the IEEE spec doesn't have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can't close their account, it's better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.</p>

<p>It's not that the error isn't controllable if you round: <a href="http://vanillajava.blogspot.com/2011/08/double-your-money-again.html" rel="noreferrer">see this article by Peter Lawrey</a>. It's just easier not to have to round in the first place. Most applications that handle money don't call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While it's true that floating point type can represent only approximatively decimal data, it's also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.</p>

<p>Usually because the double type has a precision less than 16 figures. If you require better precision it's not a suitable type. Also approximations can accumulate.</p>

<p>It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.</p>

<p>For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.</p>

<p>Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.</p>

<p>Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.</p>

<pre><code>Precision 14
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611
Double                        : 56789.012345 / 1111111111 = 0.000051110111115611

Precision 15
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110
Double                        : 56789.012345 / 1111111111 = 0.0000511101111156110

Precision 16
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101
Double                        : 56789.012345 / 1111111111 = 0.00005111011111561101

Precision 17
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611011
Double                        : 56789.012345 / 1111111111 = 0.000051110111115611013

Precision 18
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110111
Double                        : 56789.012345 / 1111111111 = 0.0000511101111156110125

Precision 19
------------------------------------------------------
BigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.
DoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5
BigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101111
Double                        : 56789.012345 / 1111111111 = 0.00005111011111561101252
</code></pre>

<hr>

<pre><code>import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.MathContext;

public class Exercise {
    public static void main(String[] args) throws IllegalArgumentException,
            SecurityException, IllegalAccessException,
            InvocationTargetException, NoSuchMethodException {
        String amount = "56789.012345";
        String quantity = "1111111111";
        int [] precisions = new int [] {14, 15, 16, 17, 18, 19};
        for (int i = 0; i &lt; precisions.length; i++) {
            int precision = precisions[i];
            System.out.println(String.format("Precision %d", precision));
            System.out.println("------------------------------------------------------");
            execute("BigDecimalNoRound", amount, quantity, precision);
            execute("DoubleNoRound", amount, quantity, precision);
            execute("BigDecimal", amount, quantity, precision);
            execute("Double", amount, quantity, precision);
            System.out.println();
        }
    }

    private static void execute(String test, String amount, String quantity,
            int precision) throws IllegalArgumentException, SecurityException,
            IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {
        Method impl = Exercise.class.getMethod("divideUsing" + test, String.class,
                String.class, int.class);
        String price;
        try {
            price = (String) impl.invoke(null, amount, quantity, precision);
        } catch (InvocationTargetException e) {
            price = e.getTargetException().getMessage();
        }
        System.out.println(String.format("%-30s: %s / %s = %s", test, amount,
                quantity, price));
    }

    public static String divideUsingDoubleNoRound(String amount,
            String quantity, int precision) {
        // acceptance
        double amount0 = Double.parseDouble(amount);
        double quantity0 = Double.parseDouble(quantity);

        //calculation
        double price0 = amount0 / quantity0;

        // presentation
        String price = Double.toString(price0);
        return price;
    }

    public static String divideUsingDouble(String amount, String quantity,
            int precision) {
        // acceptance
        double amount0 = Double.parseDouble(amount);
        double quantity0 = Double.parseDouble(quantity);

        //calculation
        double price0 = amount0 / quantity0;

        // presentation
        MathContext precision0 = new MathContext(precision);
        String price = new BigDecimal(price0, precision0)
                .toString();
        return price;
    }

    public static String divideUsingBigDecimal(String amount, String quantity,
            int precision) {
        // acceptance
        BigDecimal amount0 = new BigDecimal(amount);
        BigDecimal quantity0 = new BigDecimal(quantity);
        MathContext precision0 = new MathContext(precision);

        //calculation
        BigDecimal price0 = amount0.divide(quantity0, precision0);

        // presentation
        String price = price0.toString();
        return price;
    }

    public static String divideUsingBigDecimalNoRound(String amount, String quantity,
            int precision) {
        // acceptance
        BigDecimal amount0 = new BigDecimal(amount);
        BigDecimal quantity0 = new BigDecimal(quantity);

        //calculation
        BigDecimal price0 = amount0.divide(quantity0);

        // presentation
        String price = price0.toString();
        return price;
    }
}
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesnt produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.</p>

<pre><code>    // floating point calculation
    final double amount1 = 2.0;
    final double amount2 = 1.1;
    System.out.println("difference between 2.0 and 1.1 using double is: " + (amount1 - amount2));

    // Use BigDecimal for financial calculation
    final BigDecimal amount3 = new BigDecimal("2.0");
    final BigDecimal amount4 = new BigDecimal("1.1");
    System.out.println("difference between 2.0 and 1.1 using BigDecimal is: " + (amount3.subtract(amount4)));
</code></pre>

<p>Output:</p>

<pre><code>difference between 2.0 and 1.1 using double is: 0.8999999999999999
difference between 2.0 and 1.1 using BigDecimal is: 0.9
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As said earlier "Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, youll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required."</p>
<p><strong>Finally Java has a standard way to work with Currency And Money!</strong></p>
<p><strong>JSR 354: Money and Currency API</strong></p>
<p>JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:</p>
<p><a href="https://jcp.org/en/jsr/detail?id=354" rel="noreferrer">JSR 354: Money and Currency API Download</a></p>
<p><strong>The specification consists of the following things:</strong></p>
<blockquote>
<ol>
<li>An API for handling e. g. monetary amounts and currencies</li>
<li>APIs to support interchangeable implementations</li>
<li>Factories for creating instances of the implementation classes</li>
<li>Functionality for calculations, conversion and formatting of monetary            amounts</li>
<li>Java API for working with Money and Currencies, which is planned to be included in Java 9.</li>
<li>All specification classes and interfaces are located in the javax.money.* package.</li>
</ol>
</blockquote>
<p><strong>Sample Examples of JSR 354: Money and Currency API:</strong></p>
<p>An example of creating a MonetaryAmount and printing it to the console looks like this:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">MonetaryAmountFactory&lt;?&gt; amountFactory = Monetary.getDefaultAmountFactory();
<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">monetaryAmount</span> <span class="hljs-operator">=</span> amountFactory.setCurrency(Monetary.getCurrency(<span class="hljs-string">"EUR"</span>)).setNumber(<span class="hljs-number">12345.67</span>).create();
<span class="hljs-type">MonetaryAmountFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> MonetaryFormats.getAmountFormat(Locale.getDefault());
System.out.println(format.format(monetaryAmount));
</code></pre>
<p>When using the reference implementation API, the necessary code is much simpler:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">monetaryAmount</span> <span class="hljs-operator">=</span> Money.of(<span class="hljs-number">12345.67</span>, <span class="hljs-string">"EUR"</span>);
<span class="hljs-type">MonetaryAmountFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> MonetaryFormats.getAmountFormat(Locale.getDefault());
System.out.println(format.format(monetaryAmount));
</code></pre>
<p>The API also supports calculations with MonetaryAmounts:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">monetaryAmount</span> <span class="hljs-operator">=</span> Money.of(<span class="hljs-number">12345.67</span>, <span class="hljs-string">"EUR"</span>);
<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">otherMonetaryAmount</span> <span class="hljs-operator">=</span> monetaryAmount.divide(<span class="hljs-number">2</span>).add(Money.of(<span class="hljs-number">5</span>, <span class="hljs-string">"EUR"</span>));
</code></pre>
<p>CurrencyUnit and MonetaryAmount</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// getting CurrencyUnits by locale</span>
<span class="hljs-type">CurrencyUnit</span> <span class="hljs-variable">yen</span> <span class="hljs-operator">=</span> MonetaryCurrencies.getCurrency(Locale.JAPAN);
<span class="hljs-type">CurrencyUnit</span> <span class="hljs-variable">canadianDollar</span> <span class="hljs-operator">=</span> MonetaryCurrencies.getCurrency(Locale.CANADA);
</code></pre>
<p>MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">monetaryAmount</span> <span class="hljs-operator">=</span> Money.of(<span class="hljs-number">123.45</span>, euro);
<span class="hljs-type">CurrencyUnit</span> <span class="hljs-variable">currency</span> <span class="hljs-operator">=</span> monetaryAmount.getCurrency();
<span class="hljs-type">NumberValue</span> <span class="hljs-variable">numberValue</span> <span class="hljs-operator">=</span> monetaryAmount.getNumber();

<span class="hljs-type">int</span> <span class="hljs-variable">intValue</span> <span class="hljs-operator">=</span> numberValue.intValue(); <span class="hljs-comment">// 123</span>
<span class="hljs-type">double</span> <span class="hljs-variable">doubleValue</span> <span class="hljs-operator">=</span> numberValue.doubleValue(); <span class="hljs-comment">// 123.45</span>
<span class="hljs-type">long</span> <span class="hljs-variable">fractionDenominator</span> <span class="hljs-operator">=</span> numberValue.getAmountFractionDenominator(); <span class="hljs-comment">// 100</span>
<span class="hljs-type">long</span> <span class="hljs-variable">fractionNumerator</span> <span class="hljs-operator">=</span> numberValue.getAmountFractionNumerator(); <span class="hljs-comment">// 45</span>
<span class="hljs-type">int</span> <span class="hljs-variable">precision</span> <span class="hljs-operator">=</span> numberValue.getPrecision(); <span class="hljs-comment">// 5</span>

<span class="hljs-comment">// NumberValue extends java.lang.Number.</span>
<span class="hljs-comment">// So we assign numberValue to a variable of type Number</span>
<span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> numberValue;
</code></pre>
<p>MonetaryAmounts can be rounded using a rounding operator:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">CurrencyUnit</span> <span class="hljs-variable">usd</span> <span class="hljs-operator">=</span> MonetaryCurrencies.getCurrency(<span class="hljs-string">"USD"</span>);
<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">dollars</span> <span class="hljs-operator">=</span> Money.of(<span class="hljs-number">12.34567</span>, usd);
<span class="hljs-type">MonetaryOperator</span> <span class="hljs-variable">roundingOperator</span> <span class="hljs-operator">=</span> MonetaryRoundings.getRounding(usd);
<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">roundedDollars</span> <span class="hljs-operator">=</span> dollars.with(roundingOperator); <span class="hljs-comment">// USD 12.35</span>
</code></pre>
<p>When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;MonetaryAmount&gt; amounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
amounts.add(Money.of(<span class="hljs-number">2</span>, <span class="hljs-string">"EUR"</span>));
amounts.add(Money.of(<span class="hljs-number">42</span>, <span class="hljs-string">"USD"</span>));
amounts.add(Money.of(<span class="hljs-number">7</span>, <span class="hljs-string">"USD"</span>));
amounts.add(Money.of(<span class="hljs-number">13.37</span>, <span class="hljs-string">"JPY"</span>));
amounts.add(Money.of(<span class="hljs-number">18</span>, <span class="hljs-string">"USD"</span>));
</code></pre>
<p>Custom MonetaryAmount operations</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// A monetary operator that returns 10% of the input MonetaryAmount</span>
<span class="hljs-comment">// Implemented using Java 8 Lambdas</span>
<span class="hljs-type">MonetaryOperator</span> <span class="hljs-variable">tenPercentOperator</span> <span class="hljs-operator">=</span> (MonetaryAmount amount) -&gt; {
    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">baseAmount</span> <span class="hljs-operator">=</span> amount.getNumber().numberValue(BigDecimal.class);
    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">tenPercent</span> <span class="hljs-operator">=</span> baseAmount.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.1"</span>));
    <span class="hljs-keyword">return</span> Money.of(tenPercent, amount.getCurrency());
};

<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">dollars</span> <span class="hljs-operator">=</span> Money.of(<span class="hljs-number">12.34567</span>, <span class="hljs-string">"USD"</span>);

<span class="hljs-comment">// apply tenPercentOperator to MonetaryAmount</span>
<span class="hljs-type">MonetaryAmount</span> <span class="hljs-variable">tenPercentDollars</span> <span class="hljs-operator">=</span> dollars.with(tenPercentOperator); <span class="hljs-comment">// USD 1.234567</span>
</code></pre>
<p>Resources:</p>
<p><a href="https://blog.oio.de/2015/12/17/handling-money-and-currencies-in-java-with-jsr-354/" rel="noreferrer">Handling money and currencies in Java with JSR 354</a></p>
<p><a href="https://dzone.com/articles/looking-java-9-money-and" rel="noreferrer">Looking into the Java 9 Money and Currency API (JSR 354)</a></p>
<p>See Also: <a href="http://javamoney.github.io/" rel="noreferrer">JSR 354 - Currency and Money</a></p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them. </p>

<p>It doesn't mean though that doubles can never be used for that purpose. </p>

<p>I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead. </p>

<p>It's the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.</p>

<p>You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.</p>

<p>You can refer to guava's FuzzyCompare method to get more idea. The parameter tolerance is the key. 
We dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.</p>

<p>Also, there might be situations when you're tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values "0.5" &amp; "0.6 - 0.1" will cause a big mess.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If your computation involves various steps, arbitrary precision arithmetic won't cover you 100%.</p>

<p>The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.</p>

<p>Arbitrary precision won't help because there always can be numbers that has so many decimal places, or some results such as <code>0.6666666</code>... No arbitrary representation will cover the last example. So you will have small errors in each step.</p>

<p>These errors will add-up, may eventually become not easy to ignore anymore. This is called <a href="http://en.wikipedia.org/wiki/Propagation_of_uncertainty" rel="nofollow noreferrer">Error Propagation</a>.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.</p>

<p>Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn't use a double or float in a mathematical calculation is that I would lose too much information.</p>

<p>What are the alternatives? There are many (and many more of which I am not aware!).</p>

<p>BigDecimal in Java is native to the Java language.
Apfloat is another arbitrary-precision library for Java.</p>

<p>The decimal data type in C# is Microsoft's .NET alternative for 28 significant figures.</p>

<p>SciPy (Scientific Python) can probably also handle financial calculations (I haven't tried, but I suspect so).</p>

<p>The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.</p>

<p>There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.</p>

<p>There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.</p>

<p>I'm not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven't tried the other solutions I've listed, but they are probably very good as well.</p>

<p>For me, I like BigDecimal because of the methods it supports. C#'s decimal is very nice, but I haven't had the chance to work with it as much as I'd like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you're using the divide method.</p>

<p>You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To add on previous answers, there is also the option of implementing <strong>Joda-Money</strong> in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java module name is org.joda.money.</p>
<p>It requires Java SE 8 or later and has no dependencies.</p>
<blockquote>
<p>To be more precise, there is a compile-time dependency but it is not
required.</p>
</blockquote>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.joda&lt;/groupId&gt;
  &lt;artifactId&gt;joda-money&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Examples of using Joda Money:</p>
<pre><code>  // create a monetary value
  Money money = Money.parse("USD 23.87");
  
  // add another amount with safe double conversion
  CurrencyUnit usd = CurrencyUnit.of("USD");
  money = money.plus(Money.of(usd, 12.43d));
  
  // subtracts an amount in dollars
  money = money.minusMajor(2);
  
  // multiplies by 3.5 with rounding
  money = money.multipliedBy(3.5d, RoundingMode.DOWN);
  
  // compare two amounts
  boolean bigAmount = money.isGreaterThan(dailyWage);
  
  // convert to GBP using a supplied rate
  BigDecimal conversionRate = ...;  // obtained from code outside Joda-Money
  Money moneyGBP = money.convertedTo(CurrencyUnit.GBP, conversionRate, RoundingMode.HALF_UP);
  
  // use a BigMoney for more complex calculations where scale matters
  BigMoney moneyCalc = money.toBigMoney();
</code></pre>
<blockquote>
<p>Documentation:
<a href="http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html" rel="nofollow noreferrer">http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html</a></p>
<p>Implementation examples:
<a href="https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money" rel="nofollow noreferrer">https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money</a></p>
</blockquote>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Float is binary form of Decimal with different design; they are two different things. There are little errors between two types when converted to each other. Also, float is designed to represent infinite large number of values for scientific. That means it is designed to lost precision to extreme small and extreme large number with that fixed number of bytes. Decimal can't represent infinite number of values, it bounds to just that number of decimal digits. So Float and Decimal are for different purpose.</p>

<p>There are some ways to manage the error for currency value:</p>

<ol>
<li><p>Use long integer and count in cents instead.</p></li>
<li><p>Use double precision, keep your significant digits to 15 only so decimal can be exactly simulated. Round before presenting values; Round often when doing calculations.</p></li>
<li><p>Use a decimal library like Java BigDecimal so you don't need to use double to simulate decimal.</p></li>
</ol>

<p>p.s. it is interesting to know that most brands of handheld scientific calculators works on decimal instead of float. So no one complaint float conversion errors.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Take a look at this simple example: it looks like logically correct, but in real world this can return unexpected results if not threated correctly:</p>
<p>0.1 x 10 = 1   , so:</p>
<pre><code>double total = 0.0;

// adds 10 cents, 10 times
for (int i = 0; i &lt; 10; i++) {
    total += 0.1;  // adds 10 cents
}

Log.d("result: ", "current total: " + total);

// looks like total equals to 1.0, don't?

// now, do reverse
for (int i = 0; i &lt; 10; i++) {
    total -= 0.1;  // removes 10 cents
}

// total should be equals to 0.0, right?
Log.d("result: ", "current total: " + total);
if (total == 0.0) {
    Log.d("result: ", "is total equal to ZERO? YES, of course!!");
} else {
    Log.d("result: ", "is total equal to ZERO? No...");
    // so be careful comparing equality in this cases!!!
}
</code></pre>
<p>OUTPUT:</p>
<pre><code> result: current total: 0.9999999999999999
 result: current total: 2.7755575615628914E-17   
 result: is total equal to ZERO? No... 
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/currency">currency</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>American currency can easily be represented with dollar and cent amounts.  Integers are 100% precise, while floating point binary numbers do not exactly match floating point decimals.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-save-an-activity-state-using-the-save-instance-state-1657387429981">How can I save an activity state using the save instance state?</a><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291">What is the scope of variables in JavaScript?</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296">Get all unique values in a JavaScript array (remove duplicates)</a><a href="/questions/what-are-the-rules-for-javascript&#x27;s-automatic-semicolon-insertion-(asi)-1657387472789">What are the rules for JavaScript&#x27;s automatic semicolon insertion (ASI)?</a><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a><a href="/questions/jquery-dollar-is-not-defined-1657388385731">JQuery - $ is not defined</a><a href="/questions/i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561">I just assigned a variable, but echo $variable shows something else</a><a href="/questions/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407">Why does printf not flush after the call unless a newline is in the format string?</a><a href="/questions/how-to-sum-a-variable-by-group-1657384838148">How to sum a variable by group</a><a href="/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414">Templated check for the existence of a class member function?</a><a href="/questions/firebase-query-if-child-of-child-contains-a-value-1657387841291">Firebase query if child of child contains a value</a><a href="/questions/get-top-1-row-of-each-group-1657387438304">Get top 1 row of each group</a><a href="/questions/non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240">Non-static variable cannot be referenced from a static context</a><a href="/questions/how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843">How do I make Git forget about a file that was tracked, but is now in .gitignore?</a><a href="/questions/unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171">Unfortunately MyApp has stopped. How can I solve this?</a><a href="/questions/efficiently-convert-rows-to-columns-in-sql-server-1657387919213">Efficiently convert rows to columns in sql server</a><a href="/questions/how-do-i-pass-javascript-variables-to-php-1657388157033">How do I pass JavaScript variables to PHP?</a><a href="/questions/why-use-integer-instead-of-long-1657388012352">Why Use Integer Instead of Long?</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn\u0026apos;t just for Java, it\u0026apos;s for any programming language that uses base 2 floating-point types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In base 10, you can write 10.25 as 1025 * 10\u0026lt;sup\u0026gt;-2\u0026lt;/sup\u0026gt; (an integer times a power of 10). \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/IEEE_floating_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IEEE-754 floating-point numbers\u0026lt;/a\u0026gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2\u0026lt;sup\u0026gt;-4\u0026lt;/sup\u0026gt; (an integer times a power of two), which is also equal to 10.25. That\u0026apos;s not how the numbers are represented in memory, but the math implications are the same.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can\u0026apos;t represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3\u0026apos;s and a small exponent, like 333333333 * 10\u0026lt;sup\u0026gt;-10\u0026lt;/sup\u0026gt;, but it is not accurate: if you multiply that by 3, you won\u0026apos;t get\u0026amp;nbsp;1.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10\u0026lt;sup\u0026gt;-2\u0026lt;/sup\u0026gt;, so it doesn\u0026apos;t really matter that 1/3 can\u0026apos;t be represented.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The problem with floats and doubles is that the \u0026lt;em\u0026gt;vast majority\u0026lt;/em\u0026gt; of money-like numbers don\u0026apos;t have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they\u0026apos;re integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.01 and you multiply it by\u0026amp;nbsp;10, you won\u0026apos;t get\u0026amp;nbsp;0.1. Instead you will get something like 0.099999999786...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Representing money as a \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you\u0026apos;ll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; class, and C# has the \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;decimal\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;From Bloch, J., Effective Java, (2nd ed, Item 48. 3rd ed, Item 60):\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; types are\nparticularly ill-suited for monetary\ncalculations because it is impossible\nto represent 0.1 (or any other\nnegative power of ten) as a \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; or\n\u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; exactly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, suppose you have $1.03\nand you spend 42c. How much money do\nyou have left?\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;System.out.println(1.03 - .42);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;prints out \u0026lt;code\u0026gt;0.6100000000000001\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The right way to solve this problem is\nto use \u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt;\nfor monetary calculations.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Though \u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt; has some caveats (please see currently accepted answer).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are \u0026quot;wrong\u0026quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;System.out.println(1000000.0f + 1.2f - 1000000.0f);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results in\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;1.1875\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn\u0026apos;t want to touch floating point numbers with a ten foot pole.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;groovy:000\u0026amp;gt; new BigDecimal(1.0F)\n===\u0026amp;gt; 1\ngroovy:000\u0026amp;gt; new BigDecimal(1.01F)\n===\u0026amp;gt; 1.0099999904632568359375\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;this probably isn\u0026apos;t how you want to represent $1.01.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem is that the IEEE spec doesn\u0026apos;t have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can\u0026apos;t close their account, it\u0026apos;s better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s not that the error isn\u0026apos;t controllable if you round: \u0026lt;a href=\u0026quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;see this article by Peter Lawrey\u0026lt;/a\u0026gt;. It\u0026apos;s just easier not to have to round in the first place. Most applications that handle money don\u0026apos;t call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While it\u0026apos;s true that floating point type can represent only approximatively decimal data, it\u0026apos;s also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usually because the double type has a precision less than 16 figures. If you require better precision it\u0026apos;s not a suitable type. Also approximations can accumulate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Precision 14\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611\n\nPrecision 15\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110\n\nPrecision 16\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101\n\nPrecision 17\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611011\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611013\n\nPrecision 18\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110111\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110125\n\nPrecision 19\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101111\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101252\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.MathContext;\n\npublic class Exercise {\n    public static void main(String[] args) throws IllegalArgumentException,\n            SecurityException, IllegalAccessException,\n            InvocationTargetException, NoSuchMethodException {\n        String amount = \u0026quot;56789.012345\u0026quot;;\n        String quantity = \u0026quot;1111111111\u0026quot;;\n        int [] precisions = new int [] {14, 15, 16, 17, 18, 19};\n        for (int i = 0; i \u0026amp;lt; precisions.length; i++) {\n            int precision = precisions[i];\n            System.out.println(String.format(\u0026quot;Precision %d\u0026quot;, precision));\n            System.out.println(\u0026quot;------------------------------------------------------\u0026quot;);\n            execute(\u0026quot;BigDecimalNoRound\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;DoubleNoRound\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;BigDecimal\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;Double\u0026quot;, amount, quantity, precision);\n            System.out.println();\n        }\n    }\n\n    private static void execute(String test, String amount, String quantity,\n            int precision) throws IllegalArgumentException, SecurityException,\n            IllegalAccessException, InvocationTargetException,\n            NoSuchMethodException {\n        Method impl = Exercise.class.getMethod(\u0026quot;divideUsing\u0026quot; + test, String.class,\n                String.class, int.class);\n        String price;\n        try {\n            price = (String) impl.invoke(null, amount, quantity, precision);\n        } catch (InvocationTargetException e) {\n            price = e.getTargetException().getMessage();\n        }\n        System.out.println(String.format(\u0026quot;%-30s: %s / %s = %s\u0026quot;, test, amount,\n                quantity, price));\n    }\n\n    public static String divideUsingDoubleNoRound(String amount,\n            String quantity, int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        String price = Double.toString(price0);\n        return price;\n    }\n\n    public static String divideUsingDouble(String amount, String quantity,\n            int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        MathContext precision0 = new MathContext(precision);\n        String price = new BigDecimal(price0, precision0)\n                .toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimal(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n        MathContext precision0 = new MathContext(precision);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0, precision0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimalNoRound(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesnt produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;    // floating point calculation\n    final double amount1 = 2.0;\n    final double amount2 = 1.1;\n    System.out.println(\u0026quot;difference between 2.0 and 1.1 using double is: \u0026quot; + (amount1 - amount2));\n\n    // Use BigDecimal for financial calculation\n    final BigDecimal amount3 = new BigDecimal(\u0026quot;2.0\u0026quot;);\n    final BigDecimal amount4 = new BigDecimal(\u0026quot;1.1\u0026quot;);\n    System.out.println(\u0026quot;difference between 2.0 and 1.1 using BigDecimal is: \u0026quot; + (amount3.subtract(amount4)));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;difference between 2.0 and 1.1 using double is: 0.8999999999999999\ndifference between 2.0 and 1.1 using BigDecimal is: 0.9\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As said earlier \u0026quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, youll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Finally Java has a standard way to work with Currency And Money!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;JSR 354: Money and Currency API\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jcp.org/en/jsr/detail?id=354\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSR 354: Money and Currency API Download\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The specification consists of the following things:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;An API for handling e. g. monetary amounts and currencies\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;APIs to support interchangeable implementations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Factories for creating instances of the implementation classes\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functionality for calculations, conversion and formatting of monetary            amounts\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Java API for working with Money and Currencies, which is planned to be included in Java 9.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All specification classes and interfaces are located in the javax.money.* package.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sample Examples of JSR 354: Money and Currency API:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An example of creating a MonetaryAmount and printing it to the console looks like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;MonetaryAmountFactory\u0026amp;lt;?\u0026amp;gt; amountFactory = Monetary.getDefaultAmountFactory();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; amountFactory.setCurrency(Monetary.getCurrency(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;)).setNumber(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;).create();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmountFormat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When using the reference implementation API, the necessary code is much simpler:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmountFormat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The API also supports calculations with MonetaryAmounts:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;otherMonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.divide(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;).add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;CurrencyUnit and MonetaryAmount\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// getting CurrencyUnits by locale\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;yen\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(Locale.JAPAN);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;canadianDollar\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(Locale.CANADA);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123.45\u0026lt;/span\u0026gt;, euro);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;currency\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.getCurrency();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NumberValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;numberValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.getNumber();\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;intValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.intValue(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 123\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;doubleValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.doubleValue(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 123.45\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fractionDenominator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getAmountFractionDenominator(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fractionNumerator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getAmountFractionNumerator(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 45\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;precision\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getPrecision(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// NumberValue extends java.lang.Number.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// So we assign numberValue to a variable of type Number\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;number\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;MonetaryAmounts can be rounded using a rounding operator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;usd\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.34567\u0026lt;/span\u0026gt;, usd);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;roundingOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryRoundings.getRounding(usd);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;roundedDollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dollars.with(roundingOperator); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// USD 12.35\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;MonetaryAmount\u0026amp;gt; amounts = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13.37\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;JPY\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Custom MonetaryAmount operations\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A monetary operator that returns 10% of the input MonetaryAmount\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Implemented using Java 8 Lambdas\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercentOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (MonetaryAmount amount) -\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;baseAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; amount.getNumber().numberValue(BigDecimal.class);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercent\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; baseAmount.multiply(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0.1\u0026quot;\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Money.of(tenPercent, amount.getCurrency());\n};\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.34567\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// apply tenPercentOperator to MonetaryAmount\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercentDollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dollars.with(tenPercentOperator); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// USD 1.234567\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Resources:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://blog.oio.de/2015/12/17/handling-money-and-currencies-in-java-with-jsr-354/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Handling money and currencies in Java with JSR 354\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://dzone.com/articles/looking-java-9-money-and\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Looking into the Java 9 Money and Currency API (JSR 354)\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See Also: \u0026lt;a href=\u0026quot;http://javamoney.github.io/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSR 354 - Currency and Money\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t mean though that doubles can never be used for that purpose. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can refer to guava\u0026apos;s FuzzyCompare method to get more idea. The parameter tolerance is the key. \nWe dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, there might be situations when you\u0026apos;re tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values \u0026quot;0.5\u0026quot; \u0026amp;amp; \u0026quot;0.6 - 0.1\u0026quot; will cause a big mess.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If your computation involves various steps, arbitrary precision arithmetic won\u0026apos;t cover you 100%.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Arbitrary precision won\u0026apos;t help because there always can be numbers that has so many decimal places, or some results such as \u0026lt;code\u0026gt;0.6666666\u0026lt;/code\u0026gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These errors will add-up, may eventually become not easy to ignore anymore. This is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Error Propagation\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn\u0026apos;t use a double or float in a mathematical calculation is that I would lose too much information.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What are the alternatives? There are many (and many more of which I am not aware!).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BigDecimal in Java is native to the Java language.\nApfloat is another arbitrary-precision library for Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The decimal data type in C# is Microsoft\u0026apos;s .NET alternative for 28 significant figures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;SciPy (Scientific Python) can probably also handle financial calculations (I haven\u0026apos;t tried, but I suspect so).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven\u0026apos;t tried the other solutions I\u0026apos;ve listed, but they are probably very good as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For me, I like BigDecimal because of the methods it supports. C#\u0026apos;s decimal is very nice, but I haven\u0026apos;t had the chance to work with it as much as I\u0026apos;d like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you\u0026apos;re using the divide method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To add on previous answers, there is also the option of implementing \u0026lt;strong\u0026gt;Joda-Money\u0026lt;/strong\u0026gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java module name is org.joda.money.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It requires Java SE 8 or later and has no dependencies.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;To be more precise, there is a compile-time dependency but it is not\nrequired.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;dependency\u0026amp;gt;\n  \u0026amp;lt;groupId\u0026amp;gt;org.joda\u0026amp;lt;/groupId\u0026amp;gt;\n  \u0026amp;lt;artifactId\u0026amp;gt;joda-money\u0026amp;lt;/artifactId\u0026amp;gt;\n  \u0026amp;lt;version\u0026amp;gt;1.0.1\u0026amp;lt;/version\u0026amp;gt;\n\u0026amp;lt;/dependency\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Examples of using Joda Money:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;  // create a monetary value\n  Money money = Money.parse(\u0026quot;USD 23.87\u0026quot;);\n  \n  // add another amount with safe double conversion\n  CurrencyUnit usd = CurrencyUnit.of(\u0026quot;USD\u0026quot;);\n  money = money.plus(Money.of(usd, 12.43d));\n  \n  // subtracts an amount in dollars\n  money = money.minusMajor(2);\n  \n  // multiplies by 3.5 with rounding\n  money = money.multipliedBy(3.5d, RoundingMode.DOWN);\n  \n  // compare two amounts\n  boolean bigAmount = money.isGreaterThan(dailyWage);\n  \n  // convert to GBP using a supplied rate\n  BigDecimal conversionRate = ...;  // obtained from code outside Joda-Money\n  Money moneyGBP = money.convertedTo(CurrencyUnit.GBP, conversionRate, RoundingMode.HALF_UP);\n  \n  // use a BigMoney for more complex calculations where scale matters\n  BigMoney moneyCalc = money.toBigMoney();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Documentation:\n\u0026lt;a href=\u0026quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Implementation examples:\n\u0026lt;a href=\u0026quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Float is binary form of Decimal with different design; they are two different things. There are little errors between two types when converted to each other. Also, float is designed to represent infinite large number of values for scientific. That means it is designed to lost precision to extreme small and extreme large number with that fixed number of bytes. Decimal can\u0026apos;t represent infinite number of values, it bounds to just that number of decimal digits. So Float and Decimal are for different purpose.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are some ways to manage the error for currency value:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use long integer and count in cents instead.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use double precision, keep your significant digits to 15 only so decimal can be exactly simulated. Round before presenting values; Round often when doing calculations.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use a decimal library like Java BigDecimal so you don\u0026apos;t need to use double to simulate decimal.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;p.s. it is interesting to know that most brands of handheld scientific calculators works on decimal instead of float. So no one complaint float conversion errors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take a look at this simple example: it looks like logically correct, but in real world this can return unexpected results if not threated correctly:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;0.1 x 10 = 1   , so:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;double total = 0.0;\n\n// adds 10 cents, 10 times\nfor (int i = 0; i \u0026amp;lt; 10; i++) {\n    total += 0.1;  // adds 10 cents\n}\n\nLog.d(\u0026quot;result: \u0026quot;, \u0026quot;current total: \u0026quot; + total);\n\n// looks like total equals to 1.0, don\u0026apos;t?\n\n// now, do reverse\nfor (int i = 0; i \u0026amp;lt; 10; i++) {\n    total -= 0.1;  // removes 10 cents\n}\n\n// total should be equals to 0.0, right?\nLog.d(\u0026quot;result: \u0026quot;, \u0026quot;current total: \u0026quot; + total);\nif (total == 0.0) {\n    Log.d(\u0026quot;result: \u0026quot;, \u0026quot;is total equal to ZERO? YES, of course!!\u0026quot;);\n} else {\n    Log.d(\u0026quot;result: \u0026quot;, \u0026quot;is total equal to ZERO? No...\u0026quot;);\n    // so be careful comparing equality in this cases!!!\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;OUTPUT:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; result: current total: 0.9999999999999999\n result: current total: 2.7755575615628914E-17   \n result: is total equal to ZERO? No... \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;American currency can easily be represented with dollar and cent amounts.  Integers are 100% precise, while floating point binary numbers do not exactly match floating point decimals.\u0026lt;/p\u0026gt;\n    "],"id":254,"title":"Why not use Double or Float to represent currency?","content":"\n                \n\u0026lt;p\u0026gt;I\u0026apos;ve always been told \u0026lt;em\u0026gt;never\u0026lt;/em\u0026gt; to represent money with \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; types, and this time I pose the question to you: why? \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m sure there is a very good reason, I simply do not know what it is.\u0026lt;/p\u0026gt;\n    ","slug":"why-not-use-double-or-float-to-represent-currency-1657387417964","postType":"QUESTION","createdAt":"2022-07-09T17:23:37.000Z","updatedAt":"2022-07-09T17:23:37.000Z","tags":[{"id":1641,"name":"currency","slug":"currency","createdAt":"2022-07-09T17:23:38.000Z","updatedAt":"2022-07-09T17:23:38.000Z","Questions_Tags":{"questionId":254,"tagId":1641}}],"relatedQuestions":[{"title":"Why not use Double or Float to represent currency?","slug":"why-not-use-double-or-float-to-represent-currency-1657387417964","tags":[{"name":"currency","Questions_Tags":{"questionId":254,"tagId":1641}}]}]},"randomQuestions":[{"title":"How can I save an activity state using the save instance state?","slug":"how-can-i-save-an-activity-state-using-the-save-instance-state-1657387429981"},{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"Get all unique values in a JavaScript array (remove duplicates)","slug":"get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296"},{"title":"What are the rules for JavaScript's automatic semicolon insertion (ASI)?","slug":"what-are-the-rules-for-javascript's-automatic-semicolon-insertion-(asi)-1657387472789"},{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"I just assigned a variable, but echo $variable shows something else","slug":"i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561"},{"title":"Why does printf not flush after the call unless a newline is in the format string?","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"Templated check for the existence of a class member function?","slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414"},{"title":"Firebase query if child of child contains a value","slug":"firebase-query-if-child-of-child-contains-a-value-1657387841291"},{"title":"Get top 1 row of each group","slug":"get-top-1-row-of-each-group-1657387438304"},{"title":"Non-static variable cannot be referenced from a static context","slug":"non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"Unfortunately MyApp has stopped. How can I solve this?","slug":"unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171"},{"title":"Efficiently convert rows to columns in sql server","slug":"efficiently-convert-rows-to-columns-in-sql-server-1657387919213"},{"title":"How do I pass JavaScript variables to PHP?","slug":"how-do-i-pass-javascript-variables-to-php-1657388157033"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-not-use-double-or-float-to-represent-currency-1657387417964"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>