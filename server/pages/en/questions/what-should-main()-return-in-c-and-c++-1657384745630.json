{"pageProps":{"data":{"answer":["\n&lt;p&gt;The return value for &lt;code&gt;main&lt;/code&gt; indicates how the program exited. Normal exit is represented by a 0 return value from &lt;code&gt;main&lt;/code&gt;. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, &lt;code&gt;void main()&lt;/code&gt; is prohibited by the C++ standard and should not be used. The valid C++ &lt;code&gt;main&lt;/code&gt; signatures are:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* argv[])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is equivalent to&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It is also worth noting that in C++, &lt;code&gt;int main()&lt;/code&gt; can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether &lt;code&gt;return 0;&lt;/code&gt; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  &lt;/p&gt;\n\n&lt;p&gt;Efficiency is not an issue with the &lt;code&gt;main&lt;/code&gt; function. It can only be entered and left once (marking the program&apos;s start and termination) according to the C++ standard. For C, re-entering &lt;code&gt;main()&lt;/code&gt; is allowed, but should be avoided.&lt;/p&gt;\n    ","\n&lt;p&gt;The accepted answer appears to be targetted for C++, so I thought I&apos;d add an answer that pertains to C, and this differs in a few ways. There were also some changes made between ISO/IEC 9899:1989 (C90) and ISO/IEC 9899:1999 (C99).&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;main()&lt;/code&gt; should be declared as either:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; **argv)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Or equivalent. For example, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; is equivalent to the second one. In C90, the &lt;code&gt;int&lt;/code&gt; return type can be omitted as it is a default, but in C99 and newer, the &lt;code&gt;int&lt;/code&gt; return type may not be omitted.&lt;/p&gt;\n&lt;p&gt;If an implementation permits it, &lt;code&gt;main()&lt;/code&gt; can be declared in other ways (e.g., &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;), but this makes the program implementation defined, and no longer strictly conforming.&lt;/p&gt;\n&lt;p&gt;The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; for a successful termination, and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; for an unsuccessful termination. Any other values are non-standard and implementation defined. In C90, &lt;code&gt;main()&lt;/code&gt; must have an explicit &lt;code&gt;return&lt;/code&gt; statement at the end to avoid undefined behaviour. In C99 and newer, you may omit the return statement from &lt;code&gt;main()&lt;/code&gt;. If you do, and &lt;code&gt;main()&lt;/code&gt; finished, there is an implicit &lt;code&gt;return 0&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Finally, there is nothing wrong from a standards point of view with calling &lt;code&gt;main()&lt;/code&gt; &lt;em&gt;recursively&lt;/em&gt; from a C program.&lt;/p&gt;\n    ","\n&lt;h2&gt;Standard C  Hosted Environment&lt;/h2&gt;\n\n&lt;p&gt;For a hosted environment (that&apos;s the normal one), the C11 standard (ISO/IEC 9899:2011) says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;5.1.2.2.1 Program startup&lt;/h3&gt;\n  \n  &lt;p&gt;The function called at program startup is named &lt;code&gt;main&lt;/code&gt;. The implementation declares no\n  prototype for this function. It shall be defined with a return type of &lt;code&gt;int&lt;/code&gt; and with no\n  parameters:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;or with two parameters (referred to here as &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;, though any names may be\n  used, as they are local to the function in which they are declared):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;or equivalent;&lt;sup&gt;10)&lt;/sup&gt; or in some other implementation-defined manner.&lt;/p&gt;\n  \n  &lt;p&gt;If they are declared, the parameters to the main function shall obey the following\n  constraints:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;The value of &lt;code&gt;argc&lt;/code&gt; shall be nonnegative.&lt;/li&gt;\n  &lt;li&gt;&lt;code&gt;argv[argc]&lt;/code&gt; shall be a null pointer.&lt;/li&gt;\n  &lt;li&gt;If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the array members &lt;code&gt;argv[0]&lt;/code&gt; through\n  &lt;code&gt;argv[argc-1]&lt;/code&gt; inclusive shall contain pointers to strings, which are given\n  implementation-defined values by the host environment prior to program startup. The\n  intent is to supply to the program information determined prior to program startup\n  from elsewhere in the hosted environment. If the host environment is not capable of\n  supplying strings with letters in both uppercase and lowercase, the implementation\n  shall ensure that the strings are received in lowercase.&lt;/li&gt;\n  &lt;li&gt;If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt;\n  represents the program name; &lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the\n  program name is not available from the host environment. If the value of &lt;code&gt;argc&lt;/code&gt; is\n  greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt;\n  represent the program parameters.&lt;/li&gt;\n  &lt;li&gt;The parameters &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; and the strings pointed to by the &lt;code&gt;argv&lt;/code&gt; array shall\n  be modifiable by the program, and retain their last-stored values between program\n  startup and program termination.&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;&lt;sup&gt;10)&lt;/sup&gt; Thus, &lt;code&gt;int&lt;/code&gt; can be replaced by a typedef name defined as &lt;code&gt;int&lt;/code&gt;, or the type of &lt;code&gt;argv&lt;/code&gt; can be written as\n  &lt;code&gt;char **argv&lt;/code&gt;, and so on.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h3&gt;Program termination in C99 or C11&lt;/h3&gt;\n\n&lt;p&gt;The value returned from &lt;code&gt;main()&lt;/code&gt; is transmitted to the &apos;environment&apos; in an implementation-defined way.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;5.1.2.2.3 Program termination&lt;/h3&gt;\n  \n  &lt;p&gt;1 If the return type of the &lt;code&gt;main&lt;/code&gt; function is a type compatible with &lt;code&gt;int&lt;/code&gt;, a return from the\n  initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value\n  returned by the &lt;code&gt;main&lt;/code&gt; function as its argument;&lt;sup&gt;11)&lt;/sup&gt; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the\n  &lt;code&gt;main&lt;/code&gt; function returns a value of 0. If the return type is not compatible with &lt;code&gt;int&lt;/code&gt;, the\n  termination status returned to the host environment is unspecified.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;sup&gt;11)&lt;/sup&gt; In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in &lt;code&gt;main&lt;/code&gt;\n  will have ended in the former case, even where they would not have in the latter.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Note that &lt;code&gt;0&lt;/code&gt; is mandated as &apos;success&apos;. You can use &lt;code&gt;EXIT_FAILURE&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; from &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; if you prefer, but 0 is well established, and so is 1. See also &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;Exit codes greater than 255  possible?&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;In C89 (and hence in Microsoft C), there is no statement about what happens if the &lt;code&gt;main()&lt;/code&gt; function returns but does not specify a return value; it therefore leads to undefined behaviour.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;7.22.4.4 The &lt;code&gt;exit&lt;/code&gt; function&lt;/h3&gt;\n  \n  &lt;p&gt;¶5 Finally, control is returned to the host environment. If the value of &lt;code&gt;status&lt;/code&gt; is zero or &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;successful termination&lt;/em&gt; is returned. If the value of &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;unsuccessful termination&lt;/em&gt; is returned. Otherwise the status returned is implementation-defined.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;Standard C++  Hosted Environment&lt;/h2&gt;\n\n&lt;p&gt;The C++11 standard (ISO/IEC 14882:2011) says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;3.6.1 Main function [basic.start.main]&lt;/h3&gt;\n  \n  &lt;p&gt;¶1 A program shall contain a global function called main, which is the designated start of the program. [...]&lt;/p&gt;\n  \n  &lt;p&gt;¶2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;* argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;In the latter form &lt;code&gt;argc&lt;/code&gt; shall be the number of arguments passed to the program from the environment\n  in which the program is run. If &lt;code&gt;argc&lt;/code&gt; is nonzero these arguments shall be supplied in &lt;code&gt;argv[0]&lt;/code&gt;\n  through &lt;code&gt;argv[argc-1]&lt;/code&gt; as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and &lt;code&gt;argv[0]&lt;/code&gt; shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or &lt;code&gt;&quot;&quot;&lt;/code&gt;. The value of &lt;code&gt;argc&lt;/code&gt; shall be non-negative. The value of &lt;code&gt;argv[argc]&lt;/code&gt;\n  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after &lt;code&gt;argv&lt;/code&gt;. end\n  note ]&lt;/p&gt;\n  \n  &lt;p&gt;¶3 The function &lt;code&gt;main&lt;/code&gt; shall not be used within a program. The linkage (3.5) of &lt;code&gt;main&lt;/code&gt; is implementation-defined. [...]&lt;/p&gt;\n  \n  &lt;p&gt;¶5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic\n  storage duration) and calling &lt;code&gt;std::exit&lt;/code&gt; with the return value as the argument. If control reaches the end\n  of main without encountering a return statement, the effect is that of executing&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-kotlin&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The C++ standard explicitly says &quot;It [the main function] shall have a return type of type &lt;code&gt;int&lt;/code&gt;, but otherwise its type is implementation defined&quot;, and requires the same two signatures as the C standard to be supported as options. So a &apos;void main()&apos; is directly not allowed by the C++ standard, though there&apos;s nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling &lt;code&gt;main&lt;/code&gt; (but the C standard does not).&lt;/p&gt;\n\n&lt;p&gt;There&apos;s a paragraph of §18.5 &lt;strong&gt;Start and termination&lt;/strong&gt; in the C++11 standard that is identical to the paragraph from §7.22.4.4 &lt;strong&gt;The &lt;code&gt;exit&lt;/code&gt; function&lt;/strong&gt; in the C11 standard (quoted above), apart from a footnote (which simply documents that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; are defined in &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;).&lt;/p&gt;\n\n&lt;h2&gt;Standard C  Common Extension&lt;/h2&gt;\n\n&lt;p&gt;Classically, Unix systems support a third variant:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; **argv, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; **envp&lt;/span&gt;)&lt;/span&gt; { ... }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via &apos;&lt;code&gt;extern char **environ;&lt;/code&gt;&apos;.  This global variable is unique among those in POSIX in that it does not have a header that declares it.&lt;/p&gt;\n\n&lt;p&gt;This is recognized by the C standard as a common extension, documented in Annex J:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;J.5.1 Environment arguments&lt;/h3&gt;\n  \n  &lt;p&gt;¶1 In a hosted environment, the main function receives a third argument, &lt;code&gt;char *envp[]&lt;/code&gt;,\n  that points to a null-terminated array of pointers to &lt;code&gt;char&lt;/code&gt;, each of which points to a string\n  that provides information about the environment for this execution of the program (5.1.2.2.1).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;Microsoft C&lt;/h2&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot; rel=&quot;noreferrer&quot;&gt;Microsoft VS 2010&lt;/a&gt; compiler is interesting. The web site says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The declaration syntax for main is&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;or, optionally,&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *argv[], &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *envp[]&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;Alternatively, the &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;wmain&lt;/code&gt; functions can be declared as returning &lt;code&gt;void&lt;/code&gt; (no return value). If you declare &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; is declared as &lt;code&gt;void&lt;/code&gt;, you must use the &lt;code&gt;exit&lt;/code&gt; function.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with &lt;code&gt;void main()&lt;/code&gt; does exit  and the MS web site is silent too.&lt;/p&gt;\n\n&lt;p&gt;Interestingly, MS does not prescribe the two-argument version of &lt;code&gt;main()&lt;/code&gt; that the C and C++ standards require. It only prescribes a three argument form where the third argument is &lt;code&gt;char **envp&lt;/code&gt;, a pointer to a list of environment variables.&lt;/p&gt;\n\n&lt;p&gt;The Microsoft page also lists some other alternatives  &lt;code&gt;wmain()&lt;/code&gt; which takes wide character strings, and some more.&lt;/p&gt;\n\n&lt;p&gt;The Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot; rel=&quot;noreferrer&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2005&lt;/a&gt; version of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot; rel=&quot;noreferrer&quot;&gt;this page&lt;/a&gt; does not list &lt;code&gt;void main()&lt;/code&gt; as an alternative.  The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot; rel=&quot;noreferrer&quot;&gt;versions&lt;/a&gt; from Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot; rel=&quot;noreferrer&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2008&lt;/a&gt; onwards do.&lt;/p&gt;\n\n&lt;h2&gt;Standard C  Freestanding Environment&lt;/h2&gt;\n\n&lt;p&gt;As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called &lt;code&gt;main&lt;/code&gt; and there are no constraints on its return type.  The standard says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;5.1.2 Execution environments&lt;/h3&gt;\n  \n  &lt;p&gt;Two execution environments are defined: freestanding and hosted. In both cases,\n  program startup occurs when a designated C function is called by the execution\n  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.&lt;/p&gt;\n  \n  &lt;h3&gt;5.1.2.1 Freestanding environment&lt;/h3&gt;\n  \n  &lt;p&gt;In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.&lt;/p&gt;\n  \n  &lt;p&gt;The effect of program termination in a freestanding environment is implementation-defined.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The cross-reference to clause 4 Conformance refers to this:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;¶5 A &lt;em&gt;strictly conforming program&lt;/em&gt; shall use only those features of the language and library specified in this International Standard.&lt;sup&gt;3)&lt;/sup&gt; It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.&lt;/p&gt;\n  \n  &lt;p&gt;¶6 The two forms of conforming implementation are &lt;em&gt;hosted&lt;/em&gt; and &lt;em&gt;freestanding&lt;/em&gt;. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; shall accept any strictly conforming program. A &lt;em&gt;conforming freestanding implementation&lt;/em&gt; shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;,\n  &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;, and\n  &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. A conforming implementation may have extensions (including\n  additional library functions), provided they do not alter the behavior of any strictly conforming program.&lt;sup&gt;4)&lt;/sup&gt;&lt;/p&gt;\n  \n  &lt;p&gt;¶7 A &lt;em&gt;conforming program&lt;/em&gt; is one that is acceptable to a conforming implementation.&lt;sup&gt;5)&lt;/sup&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;sup&gt;3)&lt;/sup&gt; A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; __STDC_IEC_559__ &lt;span class=&quot;hljs-comment&quot;&gt;/* FE_UPWARD defined */&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;fesetround&lt;/span&gt;(FE_UPWARD);\n    &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;&lt;sup&gt;4)&lt;/sup&gt; This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;sup&gt;5)&lt;/sup&gt; Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It is noticeable that the only header required of a freestanding environment that actually defines any functions is &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (and even those may be  and often are  just macros).&lt;/p&gt;\n\n&lt;h2&gt;Standard C++  Freestanding Environment&lt;/h2&gt;\n\n&lt;p&gt;Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;1.4 Implementation compliance [intro.compliance]&lt;/h3&gt;\n  \n  &lt;p&gt;¶7 Two kinds of implementations are defined: a &lt;em&gt;hosted implementation&lt;/em&gt; and a &lt;em&gt;freestanding implementation&lt;/em&gt;. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding\n  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).&lt;/p&gt;\n  \n  &lt;p&gt;¶8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.&lt;/p&gt;\n  \n  &lt;p&gt;¶9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.&lt;sup&gt;3&lt;/sup&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;sup&gt;3)&lt;/sup&gt; This documentation also defines implementation-defined behavior; see 1.9.&lt;/p&gt;\n  \n  &lt;h3&gt;17.6.1.3 Freestanding implementations [compliance]&lt;/h3&gt;\n  \n  &lt;p&gt;Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.&lt;/p&gt;\n  \n  &lt;p&gt;A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.&lt;/p&gt;\n  \n  &lt;p&gt;The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;atexit&lt;/code&gt;, &lt;code&gt;at_quick_exit&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;quick_exit&lt;/code&gt; (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.&lt;/p&gt;\n  \n  &lt;p&gt;Table 16  C++ headers for freestanding implementations&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;Subclause                           Header(s)\n                                    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ciso646&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.2  Types                         &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstddef&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.3  Implementation properties     &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cfloat&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;limits&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;climits&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.4  Integer types                 &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstdint&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.5  Start and termination         &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstdlib&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.6  Dynamic memory management     &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;new&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.7  Type identification           &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;typeinfo&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.8  Exception handling            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;exception&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.9  Initializer lists             &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;initializer_list&lt;/span&gt;&amp;gt;&lt;/span&gt;\n18.10 Other runtime support         &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstdalign&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstdarg&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cstdbool&lt;/span&gt;&amp;gt;&lt;/span&gt;\n20.9  Type traits                   &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;type_traits&lt;/span&gt;&amp;gt;&lt;/span&gt;\n29    Atomics                       &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;atomic&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;What about using &lt;code&gt;int main()&lt;/code&gt; in C?&lt;/h2&gt;\n\n&lt;p&gt;The standard §5.1.2.2.1 of the C11 standard shows the preferred notation &amp;nbsp;&lt;code&gt;int main(void)&lt;/code&gt;  but there are also two examples in the standard which show &lt;code&gt;int main()&lt;/code&gt;: &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot; rel=&quot;noreferrer&quot;&gt;§6.5.3.4 ¶8&lt;/a&gt; and &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot; rel=&quot;noreferrer&quot;&gt;§6.7.6.3 ¶20&lt;/a&gt;.  Now, it is important to note that examples are not &apos;normative&apos;; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes &lt;code&gt;int main()&lt;/code&gt; in an example, it suggests that &lt;code&gt;int main()&lt;/code&gt; is not forbidden, even if it is not the preferred notation.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;6.5.3.4 The &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators&lt;/h3&gt;\n  \n  &lt;p&gt;&lt;/p&gt;\n  \n  &lt;p&gt;¶8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fsize3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; b[n+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]; &lt;span class=&quot;hljs-comment&quot;&gt;// variable length array&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; b; &lt;span class=&quot;hljs-comment&quot;&gt;// execution time sizeof&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; size;\n    size = &lt;span class=&quot;hljs-built_in&quot;&gt;fsize3&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// fsize3 returns 13&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;I believe that &lt;code&gt;main()&lt;/code&gt; should return either &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; or &lt;code&gt;EXIT_FAILURE&lt;/code&gt;. They are defined in &lt;code&gt;stdlib.h&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C90 hosted environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Allowed forms &lt;sup&gt;1&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n\nmain (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)\nmain (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])\n&lt;span class=&quot;hljs-comment&quot;&gt;/*... etc, similar forms with implicit int */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Comments:&lt;/p&gt;\n&lt;p&gt;The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed &quot;implicit int&quot; for return type and function parameters. No other form is allowed.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C90 freestanding environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Any form or name of main is allowed &lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C99 hosted environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Allowed forms &lt;sup&gt;3&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* or in some other implementation-defined manner. */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Comments:&lt;/p&gt;\n&lt;p&gt;C99 removed &quot;implicit int&quot; so &lt;code&gt;main()&lt;/code&gt; is no longer valid.&lt;/p&gt;\n&lt;p&gt;A strange, ambiguous sentence &quot;or in some other implementation-defined manner&quot; has been introduced. This can either be interpreted as &quot;the parameters to &lt;code&gt;int main()&lt;/code&gt; may vary&quot; or as &quot;main can have any implementation-defined form&quot;.&lt;/p&gt;\n&lt;p&gt;Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not conforming by citing the standard in itself, since it is is ambiguous.&lt;/p&gt;\n&lt;p&gt;However, to allow completely wild forms of &lt;code&gt;main()&lt;/code&gt; was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to &lt;code&gt;int main&lt;/code&gt; &lt;sup&gt;4&lt;/sup&gt;.&lt;/p&gt;\n&lt;p&gt;Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int &lt;sup&gt;5&lt;/sup&gt;. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C99 freestanding environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Any form or name of main is allowed &lt;sup&gt;6&lt;/sup&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C11 hosted environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Allowed forms &lt;sup&gt;7&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* or in some other implementation-defined manner. */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C11 freestanding environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Any form or name of main is allowed &lt;sup&gt;8&lt;/sup&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Note that &lt;code&gt;int main()&lt;/code&gt; was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;(void)&lt;/code&gt; have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;6.11.6 Function declarators&lt;/p&gt;\n&lt;p&gt;The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C++03 hosted environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Allowed forms &lt;sup&gt;9&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Comments:&lt;/p&gt;\n&lt;p&gt;Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C++03 freestanding environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;10&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// implementation-defined name, or &lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C++11 hosted environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Allowed forms &lt;sup&gt;11&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Comments:&lt;/p&gt;\n&lt;p&gt;The text of the standard has been changed but it has the same meaning.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C++11 freestanding environment&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;12&lt;/sup&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// implementation-defined name, or &lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;ANSI X3.159-1989 2.1.2.2 Hosted environment. &quot;Program startup&quot;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; } \n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;or with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;ANSI X3.159-1989 2.1.2.1 Freestanding environment:&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;In a freestanding environment (in which C program execution may take\nplace without any benefit of an operating system), the name and type\nof the function called at program startup are implementation-defined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;3&quot;&gt;\n&lt;li&gt;ISO 9899:1999 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; } \n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;or with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;or equivalent;9) or in some other implementation-defined\nmanner.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;4&quot;&gt;\n&lt;li&gt;Rationale for International Standard  Programming Languages  C, Revision 5.10. 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.1 Program startup&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The behavior of the arguments to main, and of the interaction of exit, main and atexit\n(see §7.20.4.2) has been codified to curb some unwanted variety in the representation of argv\nstrings, and in the meaning of values returned by main.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The specification of argc and argv as arguments to main recognizes extensive prior practice.\nargv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;main is the only function that may portably be declared either with zero or two arguments. (The number of other functions arguments must match exactly between invocation and definition.)\nThis special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see §J.5.1.).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;5&quot;&gt;\n&lt;li&gt;ISO 9899:1999 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.3 Program termination&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the &lt;code&gt;}&lt;/code&gt; that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;6&quot;&gt;\n&lt;li&gt;ISO 9899:1999 5.1.2.1 Freestanding environment&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;7&quot;&gt;\n&lt;li&gt;ISO 9899:2011 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;This section is identical to the C99 one cited above.&lt;/p&gt;\n&lt;ol start=&quot;8&quot;&gt;\n&lt;li&gt;ISO 9899:1999 5.1.2.1 Freestanding environment&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;This section is identical to the C99 one cited above.&lt;/p&gt;\n&lt;ol start=&quot;9&quot;&gt;\n&lt;li&gt;ISO 14882:2003 3.6.1 Main function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;and&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;* argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=&quot;10&quot;&gt;\n&lt;li&gt;ISO 14882:2003 3.6.1 Main function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;It is implementation-defined whether a program in a freestanding environment is required to define a main function.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;11&quot;&gt;\n&lt;li&gt;ISO 14882:2011 3.6.1 Main function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall\nallow both&lt;/p&gt;\n&lt;p&gt; a function of () returning int and&lt;/p&gt;\n&lt;p&gt; a function of (int, pointer to pointer to char) returning int&lt;/p&gt;\n&lt;p&gt;as the type of main (8.3.5).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=&quot;12&quot;&gt;\n&lt;li&gt;ISO 14882:2011 3.6.1 Main function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;This section is identical to the C++03 one cited above.&lt;/p&gt;\n    ","\n&lt;p&gt;Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;main()&lt;/code&gt; in C89 and K&amp;amp;R C unspecified return types default to int`.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-kotlin&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;? &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;?\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol&gt;\n&lt;li&gt;If you do not write a return statement in &lt;code&gt;int main()&lt;/code&gt;, the closing &lt;code&gt;}&lt;/code&gt; will return 0 by default.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;(In c++ and c99 onwards only, for c90 you must write return statement. Please see &lt;a href=&quot;https://stackoverflow.com/questions/8677672/why-main-does-not-return-0-here&quot;&gt;Why main does not return 0 here?&lt;/a&gt;)&lt;/p&gt;\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;&lt;code&gt;return 0&lt;/code&gt; or &lt;code&gt;return 1&lt;/code&gt; will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of &lt;code&gt;main()&lt;/code&gt;.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;See &lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;How can I get what my main function has returned?&lt;/a&gt;.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-shell&quot;&gt;&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;./a.out&lt;/span&gt;\n&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; $?&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This way you can see that it is the variable &lt;code&gt;$?&lt;/code&gt; which receives the least significant byte of the return value of &lt;code&gt;main()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;In Unix and DOS scripting, &lt;code&gt;return 0&lt;/code&gt; on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.&lt;/p&gt;\n    ","\n&lt;p&gt;Keep in mind that,even though you&apos;re returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).&lt;/p&gt;\n    ","\n&lt;p&gt;The return value can be used by the operating system to check how the program was closed.&lt;/p&gt;\n\n&lt;p&gt;Return value 0 usually means OK in most operating systems (the ones I can think of anyway).&lt;/p&gt;\n\n&lt;p&gt;It also can be checked when you call a process yourself, and see if the program exited and finished properly.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s &lt;strong&gt;NOT&lt;/strong&gt; just a programming convention.&lt;/p&gt;\n    ","\n&lt;p&gt;The return value of &lt;code&gt;main()&lt;/code&gt; shows how the program exited. If the return value is &lt;code&gt;zero&lt;/code&gt; it means that the execution was successful while any non-zero value will represent that something went bad in the execution.&lt;/p&gt;\n    ","\n&lt;p&gt;Returning 0 should tell the programmer that the program has successfully finished the job.&lt;/p&gt;\n    ","\n&lt;h2&gt;Omit &lt;code&gt;return 0&lt;/code&gt;&lt;/h2&gt;\n\n&lt;p&gt;When a C or C++ program reaches the end of &lt;code&gt;main&lt;/code&gt; the compiler will automatically generate code to return 0, so there is no need to put &lt;code&gt;return 0;&lt;/code&gt; explicitly at the end of &lt;code&gt;main&lt;/code&gt;.  &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; when I make this suggestion, it&apos;s almost invariably followed by one of two kinds of comments:  &quot;I didn&apos;t know that.&quot; or &quot;That&apos;s bad advice!&quot;  My rationale is that it&apos;s safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;[...] a return from the initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value returned by the &lt;code&gt;main&lt;/code&gt; function as its argument; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the &lt;code&gt;main&lt;/code&gt; function returns a value of 0.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit &lt;code&gt;return;&lt;/code&gt; statements at the end of a &lt;code&gt;void&lt;/code&gt; function.  Reasons against omitting seem to boil down to &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&quot;it looks weird&quot;&lt;/a&gt;.  If, like me, you&apos;re curious about the rationale for the change to the C standard &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;read this question&lt;/a&gt;.  Also note that in the early 1990s this was considered &quot;sloppy practice&quot; because it was undefined behavior (although widely supported) at the time.  &lt;/p&gt;\n\n&lt;p&gt;Additionally, the &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot; rel=&quot;nofollow noreferrer&quot;&gt;C++ Core Guidelines&lt;/a&gt; contains multiple instances of omitting &lt;code&gt;return 0;&lt;/code&gt; at the end of &lt;code&gt;main&lt;/code&gt; and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.&lt;/p&gt;\n\n&lt;p&gt;So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you&apos;ll know that it&apos;s explicitly supported by the standard and you&apos;ll know what it means.&lt;/p&gt;\n    ","\n&lt;p&gt;What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.\nIf the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.&lt;/p&gt;\n\n&lt;p&gt;If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.&lt;/p&gt;\n\n&lt;p&gt;In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is a small demonstration of the usage of return codes...&lt;/p&gt;\n\n&lt;p&gt;When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is some example in order to check how grep works.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;When you execute the grep command a process is created. Once it is through (and didn&apos;t break) it returns some code between 0 and 255. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;$ &lt;span class=&quot;hljs-keyword&quot;&gt;grep&lt;/span&gt; order myfile\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you do&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;echo &lt;span class=&quot;hljs-variable&quot;&gt;$?&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you will get a 0. Why? Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot; rel=&quot;nofollow&quot;&gt;grep&lt;/a&gt; found a match and returned an exit code 0, which is the usual value for exiting with a success. Let&apos;s check it out again but with something that is not inside our text file and thus no match will be found:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;grep foo myfile\n&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;echo &lt;span class=&quot;hljs-variable&quot;&gt;$?&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since grep failed to match the token &quot;foo&quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).&lt;/p&gt;\n\n&lt;p&gt;Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-shell&quot;&gt;&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;grep foo myfile&lt;/span&gt;\n&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;CHECK=$?&lt;/span&gt;\n&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;[ &lt;span class=&quot;hljs-variable&quot;&gt;$CHECK&lt;/span&gt; -eq 0] &amp;amp;&amp;amp; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Match found&apos;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;[ &lt;span class=&quot;hljs-variable&quot;&gt;$CHECK&lt;/span&gt; -ne 0] &amp;amp;&amp;amp; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;No match was found&apos;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;No match was found&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;After the second line nothing is printed to the terminal since &quot;foo&quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.&lt;/p&gt;\n\n&lt;p&gt;As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;What is the correct (most efficient) way to define the main() function in C and C++  int main() or void main()  and why?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Those words &quot;(most efficient)&quot; don&apos;t change the question.  Unless you&apos;re in a freestanding environment, there is one universally correct way to declare &lt;code&gt;main()&lt;/code&gt;, and that&apos;s as returning int.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;What should &lt;code&gt;main()&lt;/code&gt; return in C and C++?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It&apos;s not what &lt;em&gt;should&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; return, it&apos;s what &lt;em&gt;does&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; return.  &lt;code&gt;main()&lt;/code&gt; is, of course, a function that someone else calls.  You don&apos;t have any control over the code that calls &lt;code&gt;main()&lt;/code&gt;.  Therefore, you must declare &lt;code&gt;main()&lt;/code&gt; with a type-correct signature to match its caller.  You simply don&apos;t have any choice in the matter.  You don&apos;t have to ask yourself what&apos;s more or less efficient, or what&apos;s better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If int main() then return 1 or return 0?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it&apos;s defined by the interface you&apos;re supposed to be conforming to.&lt;/p&gt;\n    ","\n&lt;p&gt;In C, the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Section 5.1.2.2.1 of the C11 standard&lt;/a&gt; (emphasis mine):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;It shall be defined with a &lt;strong&gt;return type of &lt;code&gt;int&lt;/code&gt;&lt;/strong&gt; and with no\nparameters:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or with two parameters (referred to here as &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;, though\nany names may be used, as they are local to the function in which they\nare declared):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *argv[]&lt;/span&gt;)&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;However for some beginners like me, an abstract example would allow me to get a grasp on it:&lt;/p&gt;\n&lt;p&gt;When you write a method in your program, e.g. &lt;code&gt;int read_file(char filename[LEN]);&lt;/code&gt;, then you want, as the caller of this method to know if everything went well (because failures can happen, e.g. file could not be found). By checking the return value of the method you can know if everything went well or not, it&apos;s a mechanism for the method to signal you about its successful execution (or not), and let the caller (you, e.g. in your main method) decide how to handle an unexpected failure.&lt;/p&gt;\n&lt;p&gt;So now imagine I write a C program for a micro-mechanism which is used in a more complex system. When the system calls the micro-mechanism, it wants to know if everything went as expected, so that it can handle any potential error. If the C program&apos;s main method would return void, then how would the calling-system know about the execution of its subsystem (the micro-mechanism)? It cannot, that&apos;s why main() returns int, in order to communicate to its caller a successful (or not) execution.&lt;/p&gt;\n&lt;p&gt;In other words:&lt;/p&gt;\n&lt;p&gt;The rational is that the host environment (i.e. Operating System (OS)) needs to know if the program finished correctly. Without an int-compatible type as a return type (eg. void), the &quot;status returned to the host environment is unspecified&quot; (i.e. undefined behavior on most OS).&lt;/p&gt;\n    ","\n&lt;p&gt;On Windows, if a program crashes due to an access violation, the exit code will be &lt;code&gt;STATUS_ACCESS_VIOLATION (0xC0000005)&lt;/code&gt;.  Similar for other kinds of crashes from an x86 exception as well.&lt;/p&gt;\n&lt;p&gt;So there are things other than what you return from &lt;code&gt;main&lt;/code&gt; or pass to &lt;code&gt;exit&lt;/code&gt; that can cause an exit code to be seen.&lt;/p&gt;\n    "],"id":141,"title":"What should main() return in C and C++?","content":"\n                \n&lt;p&gt;What is the correct (most efficient) way to define the &lt;code&gt;main()&lt;/code&gt; function in C and C++ — &lt;code&gt;int main()&lt;/code&gt; or &lt;code&gt;void main()&lt;/code&gt; — and why? And how about the arguments?\nIf &lt;code&gt;int main()&lt;/code&gt; then &lt;code&gt;return 1&lt;/code&gt; or &lt;code&gt;return 0&lt;/code&gt;?&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;em&gt;There are numerous duplicates of this question, including:&lt;/em&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2108192/what-are-the-valid-signatures-for-cs-main-function/&quot;&gt;What are the valid signatures for C&apos;s &lt;code&gt;main()&lt;/code&gt; function?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17715008/the-return-type-of-main-function/&quot;&gt;The return type of &lt;code&gt;main()&lt;/code&gt; function&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/636829/difference-between-void-main-and-int-main&quot;&gt;Difference between &lt;code&gt;void main()&lt;/code&gt; and &lt;code&gt;int main()&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1621574/mains-signature-in-c&quot;&gt;&lt;code&gt;main()&lt;/code&gt;&apos;s signature in C++&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt;What is the proper declaration of &lt;code&gt;main()&lt;/code&gt;?&lt;/a&gt; — For C++, with a very good answer indeed.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8692120/styles-of-main-functions-in-c&quot;&gt;Styles of &lt;code&gt;main()&lt;/code&gt; functions in C&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10915713/return-type-of-main-method-in-c&quot;&gt;Return type of &lt;code&gt;main()&lt;/code&gt; method in C&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9356510/int-main-vs-void-main-in-c&quot;&gt;&lt;code&gt;int main()&lt;/code&gt; vs &lt;code&gt;void main()&lt;/code&gt; in C&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Related:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5191965/c-int-mainint-argc-char-argv&quot;&gt;C++ — &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5217395/c-int-mainint-argc-char-argv&quot;&gt;C++ — &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable&quot;&gt;Is &lt;code&gt;char *envp[]&lt;/code&gt; as a third argument to &lt;code&gt;main()&lt;/code&gt; portable?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18402853/must-the-int-main-function-return-a-value-in-all-compilers&quot;&gt;Must the &lt;code&gt;int main()&lt;/code&gt; function return a value in all compilers?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5296163/why-is-the-type-of-the-main-function-in-c-and-c-left-to-the-user-to-define&quot;&gt;Why is the type of the &lt;code&gt;main()&lt;/code&gt; function in C and C++ left to the user to define?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22239/why-does-int-main-compile&quot;&gt;Why does &lt;code&gt;int main(){}&lt;/code&gt; compile?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26470912/legal-definitions-of-main-in-c14&quot;&gt;Legal definitions of &lt;code&gt;main()&lt;/code&gt; in C++14?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","slug":"what-should-main()-return-in-c-and-c++-1657384745630","postType":"QUESTION","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","tags":[{"id":515,"name":"return-value","slug":"return-value","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":515}},{"id":516,"name":"main","slug":"main","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":516}},{"id":517,"name":"return-type","slug":"return-type","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":517}}],"relatedQuestions":[{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630","tags":[{"name":"return-value","Questions_Tags":{"questionId":141,"tagId":515}},{"name":"main","Questions_Tags":{"questionId":141,"tagId":516}},{"name":"return-type","Questions_Tags":{"questionId":141,"tagId":517}}]}]},"randomQuestions":[{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"PHP - Failed to open stream : No such file or directory","slug":"php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896"},{"title":"Aggregate / summarize multiple variables per group (e.g. sum, mean)","slug":"aggregate-summarize-multiple-variables-per-group-(e.g.-sum-mean)-1657387764061"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"What does this symbol mean in JavaScript?","slug":"what-does-this-symbol-mean-in-javascript-1657387632971"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"What is a raw type and why shouldn't we use it?","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079"},{"title":"Do DOM tree elements with IDs become global properties?","slug":"do-dom-tree-elements-with-ids-become-global-properties-1657387475110"},{"title":"How to reshape data from long to wide format","slug":"how-to-reshape-data-from-long-to-wide-format-1657384486421"},{"title":"What is DOM Event delegation?","slug":"what-is-dom-event-delegation-1657387625599"},{"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608"},{"title":"Crash or \"segmentation fault\" when data is copied/scanned/read to an uninitialized pointer","slug":"crash-or-\"segmentation-fault\"-when-data-is-copiedscannedread-to-an-uninitialized-pointer-1657387520581"},{"title":"Is there a built in function for string natural sort?","slug":"is-there-a-built-in-function-for-string-natural-sort-1657388069553"},{"title":"Converting string into datetime","slug":"converting-string-into-datetime-1657387717295"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"Post an HTML Table to ADO.NET DataTable","slug":"post-an-html-table-to-ado.net-datatable-1657387462723"},{"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597"},{"title":"List of lists changes reflected across sublists unexpectedly","slug":"list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720"},{"title":"JavaScript property access: dot notation vs. brackets?","slug":"javascript-property-access:-dot-notation-vs.-brackets-1657384717494"}]},"__N_SSG":true}