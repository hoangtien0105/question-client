<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is The Rule of Three? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
What does copying an object mean?
What are the copy constructor and the copy assignment operator?
When do I need to declare them myself?
How can I prevent my objects from being copied?

    "/><meta property="og:title" content="What is The Rule of Three? | Solutions Checker"/><meta property="og:description" content="
What does copying an object mean?
What are the copy constructor and the copy assignment operator?
When do I need to declare them myself?
How can I prevent my objects from being copied?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is The Rule of Three?","text":"\nWhat does copying an object mean?\nWhat are the copy constructor and the copy assignment operator?\nWhen do I need to declare them myself?\nHow can I prevent my objects from being copied?\n\n    ","answerCount":8,"upVoteCount":500,"suggestedAnswer":[{"text":"Introduction\nC++ treats variables of user-defined types with value semantics.\nThis means that objects are implicitly copied in various contexts,\nand we should understand what &quot;copying an object&quot; actually means.\nLet us consider a simple example:\nclass person\n{\n    std::string name;\n    int age;\n\npublic:\n\n    person(const std::string&amp; name, int age) : name(name), age(age)\n    {\n    }\n};\n\nint main()\n{\n    person a(&quot;Bjarne Stroustrup&quot;, 60);\n    person b(a);   // What happens here?\n    b = a;         // And here?\n}\n\n(If you are puzzled by the name(name), age(age) part,\nthis is called a member initializer list.)\nSpecial member functions\nWhat does it mean to copy a person object?\nThe main function shows two distinct copying scenarios.\nThe initialization person b(a); is performed by the copy constructor.\nIts job is to construct a fresh object based on the state of an existing object.\nThe assignment b = a is performed by the copy assignment operator.\nIts job is generally a little more complicated,\nbecause the target object is already in some valid state that needs to be dealt with.\nSince we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,\nthese are implicitly defined for us. Quote from the standard:\n\nThe [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.\n[ Note: The implementation will implicitly declare these member functions\nfor some class types when the program does not explicitly declare them.\nThe implementation will implicitly define them if they are used. [...] end note ]\n[n3126.pdf section 12 ยง1]\n\nBy default, copying an object means copying its members:\n\nThe implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.\n[n3126.pdf section 12.8 ยง16]\n\n\nThe implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment\nof its subobjects.\n[n3126.pdf section 12.8 ยง30]\n\nImplicit definitions\nThe implicitly-defined special member functions for person look like this:\n// 1. copy constructor\nperson(const person&amp; that) : name(that.name), age(that.age)\n{\n}\n\n// 2. copy assignment operator\nperson&amp; operator=(const person&amp; that)\n{\n    name = that.name;\n    age = that.age;\n    return *this;\n}\n\n// 3. destructor\n~person()\n{\n}\n\nMemberwise copying is exactly what we want in this case:\nname and age are copied, so we get a self-contained, independent person object.\nThe implicitly-defined destructor is always empty.\nThis is also fine in this case since we did not acquire any resources in the constructor.\nThe members&apos; destructors are implicitly called after the person destructor is finished:\n\nAfter executing the body of the destructor and destroying any automatic objects allocated within the body,\na destructor for class X calls the destructors for X&apos;s direct [...] members\n[n3126.pdf 12.4 ยง6]\n\nManaging resources\nSo when should we declare those special member functions explicitly?\nWhen our class manages a resource, that is,\nwhen an object of the class is responsible for that resource.\nThat usually means the resource is acquired in the constructor\n(or passed into the constructor) and released in the destructor.\nLet us go back in time to pre-standard C++.\nThere was no such thing as std::string, and programmers were in love with pointers.\nThe person class might have looked like this:\nclass person\n{\n    char* name;\n    int age;\n\npublic:\n\n    // the constructor acquires a resource:\n    // in this case, dynamic memory obtained via new[]\n    person(const char* the_name, int the_age)\n    {\n        name = new char[strlen(the_name) + 1];\n        strcpy(name, the_name);\n        age = the_age;\n    }\n\n    // the destructor must release this resource via delete[]\n    ~person()\n    {\n        delete[] name;\n    }\n};\n\nEven today, people still write classes in this style and get into trouble:\n&quot;I pushed a person into a vector and now I get crazy memory errors!&quot;\nRemember that by default, copying an object means copying its members,\nbut copying the name member merely copies a pointer, not the character array it points to!\nThis has several unpleasant effects:\n\nChanges via a can be observed via b.\nOnce b is destroyed, a.name is a dangling pointer.\nIf a is destroyed, deleting the dangling pointer yields undefined behavior.\nSince the assignment does not take into account what name pointed to before the assignment,\nsooner or later you will get memory leaks all over the place.\n\nExplicit definitions\nSince memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:\n// 1. copy constructor\nperson(const person&amp; that)\n{\n    name = new char[strlen(that.name) + 1];\n    strcpy(name, that.name);\n    age = that.age;\n}\n\n// 2. copy assignment operator\nperson&amp; operator=(const person&amp; that)\n{\n    if (this != &amp;that)\n    {\n        delete[] name;\n        // This is a dangerous point in the flow of execution!\n        // We have temporarily invalidated the class invariants,\n        // and the next statement might throw an exception,\n        // leaving the object in an invalid state :(\n        name = new char[strlen(that.name) + 1];\n        strcpy(name, that.name);\n        age = that.age;\n    }\n    return *this;\n}\n\nNote the difference between initialization and assignment:\nwe must tear down the old state before assigning to name to prevent memory leaks.\nAlso, we have to protect against self-assignment of the form x = x.\nWithout that check, delete[] name would delete the array containing the source string,\nbecause when you write x = x, both this-&gt;name and that.name contain the same pointer.\nException safety\nUnfortunately, this solution will fail if new char[...] throws an exception due to memory exhaustion.\nOne possible solution is to introduce a local variable and reorder the statements:\n// 2. copy assignment operator\nperson&amp; operator=(const person&amp; that)\n{\n    char* local_name = new char[strlen(that.name) + 1];\n    // If the above statement throws,\n    // the object is still in the same state as before.\n    // None of the following statements will throw an exception :)\n    strcpy(local_name, that.name);\n    delete[] name;\n    name = local_name;\n    age = that.age;\n    return *this;\n}\n\nThis also takes care of self-assignment without an explicit check.\nAn even more robust solution to this problem is the copy-and-swap idiom,\nbut I will not go into the details of exception safety here.\nI only mentioned exceptions to make the following point: Writing classes that manage resources is hard.\nNoncopyable resources\nSome resources cannot or should not be copied, such as file handles or mutexes.\nIn that case, simply declare the copy constructor and copy assignment operator as private without giving a definition:\nprivate:\n\n    person(const person&amp; that);\n    person&amp; operator=(const person&amp; that);\n\nAlternatively, you can inherit from boost::noncopyable or declare them as deleted (in C++11 and above):\nperson(const person&amp; that) = delete;\nperson&amp; operator=(const person&amp; that) = delete;\n\nThe rule of three\nSometimes you need to implement a class that manages a resource.\n(Never manage multiple resources in a single class,\nthis will only lead to pain.)\nIn that case, remember the rule of three:\n\nIf you need to explicitly declare either the destructor,\ncopy constructor or copy assignment operator yourself,\nyou probably need to explicitly declare all three of them.\n\n(Unfortunately, this &quot;rule&quot; is not enforced by the C++ standard or any compiler I am aware of.)\nThe rule of five\nFrom C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.\nAn example with the signatures:\nclass person\n{\n    std::string name;\n    int age;\n\npublic:\n    person(const std::string&amp; name, int age);        // Ctor\n    person(const person &amp;) = default;                // 1/5: Copy Ctor\n    person(person &amp;&amp;) noexcept = default;            // 4/5: Move Ctor\n    person&amp; operator=(const person &amp;) = default;     // 2/5: Copy Assignment\n    person&amp; operator=(person &amp;&amp;) noexcept = default; // 5/5: Move Assignment\n    ~person() noexcept = default;                    // 3/5: Dtor\n};\n\nThe rule of zero\nThe rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.\nAdvice\nMost of the time, you do not need to manage a resource yourself,\nbecause an existing class such as std::string already does it for you.\nJust compare the simple code using a std::string member\nto the convoluted and error-prone alternative using a char* and you should be convinced.\nAs long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The Rule of Three is a rule of thumb for C++, basically saying \n\n\n  If your class needs any of\n  \n  \n  a copy constructor,\n  an assignment operator, \n  or a destructor, \n  \n  \n  defined explictly, then it is likely to need all three of them.\n\n\nThe reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing. \n\nIf there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not defining) the copy constructor and assignment operator as private. \n\n(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The law of the big three is as specified above.\n\nAn easy example, in plain English, of the kind of problem it solves:\n\nNon default destructor\n\nYou allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.\n\nYou might think that this is job done. \n\nThe problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.\n\nOnce, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.\n\nTherefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.\n\nAssignment operator and copy constructor\n\nYou allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.\n\nThis means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.\n\nTo resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.\n\n    MyClass x(a, b);\n    MyClass y(c, d);\n    x = y; // This is a shallow copy if assignment operator is not provided\n\n\nIf MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"What does copying an object mean? \nThere are a few ways you can copy objects--let&apos;s talk about the 2 kinds you&apos;re most likely referring to--deep copy and shallow copy.\n\nSince we&apos;re in an object-oriented language (or at least are assuming so), let&apos;s say you have a piece of memory allocated.  Since it&apos;s an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let&apos;s say we have a class of Car as follows:\n\nclass Car //A very simple class just to demonstrate what these definitions mean.\n//It&apos;s pseudocode C++/Javaish, I assume strings do not need to be allocated.\n{\nprivate String sPrintColor;\nprivate String sModel;\nprivate String sMake;\n\npublic changePaint(String newColor)\n{\n   this.sPrintColor = newColor;\n}\n\npublic Car(String model, String make, String color) //Constructor\n{\n   this.sPrintColor = color;\n   this.sModel = model;\n   this.sMake = make;\n}\n\npublic ~Car() //Destructor\n{\n//Because we did not create any custom types, we aren&apos;t adding more code.\n//Anytime your object goes out of scope / program collects garbage / etc. this guy gets called + all other related destructors.\n//Since we did not use anything but strings, we have nothing additional to handle.\n//The assumption is being made that the 3 strings will be handled by string&apos;s destructor and that it is being called automatically--if this were not the case you would need to do it here.\n}\n\npublic Car(const Car &amp;other) // Copy Constructor\n{\n   this.sPrintColor = other.sPrintColor;\n   this.sModel = other.sModel;\n   this.sMake = other.sMake;\n}\npublic Car &amp;operator =(const Car &amp;other) // Assignment Operator\n{\n   if(this != &amp;other)\n   {\n      this.sPrintColor = other.sPrintColor;\n      this.sModel = other.sModel;\n      this.sMake = other.sMake;\n   }\n   return *this;\n}\n\n}\n\n\nA deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.\n\nCar car1 = new Car(&quot;mustang&quot;, &quot;ford&quot;, &quot;red&quot;);\nCar car2 = car1; //Call the copy constructor\ncar2.changePaint(&quot;green&quot;);\n//car2 is now green but car1 is still red.\n\n\nNow let&apos;s do something strange.  Let&apos;s say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It&apos;s usually a mistake to do this and in classes is usually the blanket it&apos;s discussed under.)  Pretend that anytime you ask about car2, you&apos;re really resolving a pointer to car1&apos;s memory space...that&apos;s more or less what a shallow copy is.\n\n//Shallow copy example\n//Assume we&apos;re in C++ because it&apos;s standard behavior is to shallow copy objects if you do not have a constructor written for an operation.\n//Now let&apos;s assume I do not have any code for the assignment or copy operations like I do above...with those now gone, C++ will use the default.\n\n Car car1 = new Car(&quot;ford&quot;, &quot;mustang&quot;, &quot;red&quot;); \n Car car2 = car1; \n car2.changePaint(&quot;green&quot;);//car1 is also now green \n delete car2;/*I get rid of my car which is also really your car...I told C++ to resolve \n the address of where car2 exists and delete the memory...which is also\n the memory associated with your car.*/\n car1.changePaint(&quot;red&quot;);/*program will likely crash because this area is\n no longer allocated to the program.*/\n\n\nSo regardless of what language you&apos;re writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.\n\nWhat are the copy constructor and the copy assignment operator?\nI have already used them above.  The copy constructor is called when you type code such as Car car2 = car1;  Essentially if you declare a variable and assign it in one line, that&apos;s when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--car2 = car1;.  Notice car2 isn&apos;t declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you&apos;re satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.\n\nWhen do I need to declare them myself? \nIf you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it &apos;by accident&apos; and didn&apos;t make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?\n\nHow can I prevent my objects from being copied?\nOverride all of the ways you&apos;re allowed to allocate memory for your object with a private function is a reasonable start.  If you really don&apos;t want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.  \n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"\n  When do I need to declare them myself?\n\n\nThe Rule of Three states that if you declare any of a \n\n\ncopy constructor\ncopy assignment operator\ndestructor\n\n\nthen you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that \n\n\nwhatever resource management was being done in one copy operation probably needed to be done in the other copy operation and \nthe class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that\nmanage memory (e.g., the STL containers that perform dynamic memory management) all declare the big three: both copy operations and a destructor.\n\n\nA consequence of the Rule of Three is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldnt be automatically generated, because they wouldnt do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.\n\n\n  How can I prevent my objects from being copied?\n\n\nDeclare copy constructor &amp; copy assignment operator as private access specifier.\n\nclass MemoryBlock\n{\npublic:\n\n//code here\n\nprivate:\nMemoryBlock(const MemoryBlock&amp; other)\n{\n   cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;\n}\n\n// Copy assignment operator.\nMemoryBlock&amp; operator=(const MemoryBlock&amp; other)\n{\n return *this;\n}\n};\n\nint main()\n{\n   MemoryBlock a;\n   MemoryBlock b(a);\n}\n\n\nIn C++11 onwards you can also declare copy constructor &amp; assignment operator deleted\n\nclass MemoryBlock\n{\npublic:\nMemoryBlock(const MemoryBlock&amp; other) = delete\n\n// Copy assignment operator.\nMemoryBlock&amp; operator=(const MemoryBlock&amp; other) =delete\n};\n\n\nint main()\n{\n   MemoryBlock a;\n   MemoryBlock b(a);\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Many of the existing answers already touch the copy constructor, assignment operator and destructor.\nHowever, in post C++11, the introduction of move semantic may expand this beyond 3.\n\nRecently Michael Claisse gave a talk that touches this topic:\nhttp://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.\n\nCopy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.\n\nCopy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.\n\nThere are quick examples:\n\n// default constructor\nMy_Class a;\n\n// copy constructor\nMy_Class b(a);\n\n// copy constructor\nMy_Class c = a;\n\n// copy assignment operator\nb = a;\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-rule-of-three-1657384390295#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-rule-of-three-1657384390295"><h1>What is The Rule of Three?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/rule-of-three">rule-of-three</a></div></div><div class="question-content mt-5">
                
<ul>
<li>What does <em>copying an object</em> mean?</li>
<li>What are the <em>copy constructor</em> and the <em>copy assignment operator</em>?</li>
<li>When do I need to declare them myself?</li>
<li>How can I prevent my objects from being copied?</li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Introduction</h1>
<p>C++ treats variables of user-defined types with <em>value semantics</em>.
This means that objects are implicitly copied in various contexts,
and we should understand what "copying an object" actually means.</p>
<p>Let us consider a simple example:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>
{
    std::string name;
    <span class="hljs-type">int</span> age;

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> age) : <span class="hljs-built_in">name</span>(name), <span class="hljs-built_in">age</span>(age)
    {
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">"Bjarne Stroustrup"</span>, <span class="hljs-number">60</span>)</span></span>;
    <span class="hljs-function">person <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;   <span class="hljs-comment">// What happens here?</span>
    b = a;         <span class="hljs-comment">// And here?</span>
}
</code></pre>
<p>(If you are puzzled by the <code>name(name), age(age)</code> part,
this is called a <a href="https://stackoverflow.com/questions/1272680/">member initializer list</a>.)</p>
<h1>Special member functions</h1>
<p>What does it mean to copy a <code>person</code> object?
The <code>main</code> function shows two distinct copying scenarios.
The initialization <code>person b(a);</code> is performed by the <em>copy constructor</em>.
Its job is to construct a fresh object based on the state of an existing object.
The assignment <code>b = a</code> is performed by the <em>copy assignment operator</em>.
Its job is generally a little more complicated,
because the target object is already in some valid state that needs to be dealt with.</p>
<p>Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,
these are implicitly defined for us. Quote from the standard:</p>
<blockquote>
<p>The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.
[ <em>Note</em>: <strong>The implementation will implicitly declare these member functions
for some class types when the program does not explicitly declare them.</strong>
The implementation will implicitly define them if they are used. [...] <em>end note</em> ]
[n3126.pdf section 12 ยง1]</p>
</blockquote>
<p>By default, copying an object means copying its members:</p>
<blockquote>
<p>The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.
[n3126.pdf section 12.8 ยง16]</p>
</blockquote>
<blockquote>
<p>The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment
of its subobjects.
[n3126.pdf section 12.8 ยง30]</p>
</blockquote>
<h2>Implicit definitions</h2>
<p>The implicitly-defined special member functions for <code>person</code> look like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// 1. copy constructor</span>
<span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person&amp; that) : <span class="hljs-built_in">name</span>(that.name), <span class="hljs-built_in">age</span>(that.age)
{
}

<span class="hljs-comment">// 2. copy assignment operator</span>
person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person&amp; that)
{
    name = that.name;
    age = that.age;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">// 3. destructor</span>
~<span class="hljs-built_in">person</span>()
{
}
</code></pre>
<p>Memberwise copying is exactly what we want in this case:
<code>name</code> and <code>age</code> are copied, so we get a self-contained, independent <code>person</code> object.
The implicitly-defined destructor is always empty.
This is also fine in this case since we did not acquire any resources in the constructor.
The members' destructors are implicitly called after the <code>person</code> destructor is finished:</p>
<blockquote>
<p>After executing the body of the destructor and destroying any automatic objects allocated within the body,
a destructor for class X calls the destructors for X's direct [...] members
[n3126.pdf 12.4 ยง6]</p>
</blockquote>
<h1>Managing resources</h1>
<p>So when should we declare those special member functions explicitly?
When our class <em>manages a resource</em>, that is,
when an object of the class is <em>responsible</em> for that resource.
That usually means the resource is <em>acquired</em> in the constructor
(or passed into the constructor) and <em>released</em> in the destructor.</p>
<p>Let us go back in time to pre-standard C++.
There was no such thing as <code>std::string</code>, and programmers were in love with pointers.
The <code>person</code> class might have looked like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>
{
    <span class="hljs-type">char</span>* name;
    <span class="hljs-type">int</span> age;

<span class="hljs-keyword">public</span>:

    <span class="hljs-comment">// the constructor acquires a resource:</span>
    <span class="hljs-comment">// in this case, dynamic memory obtained via new[]</span>
    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* the_name, <span class="hljs-type">int</span> the_age)
    {
        name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(the_name) + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(name, the_name);
        age = the_age;
    }

    <span class="hljs-comment">// the destructor must release this resource via delete[]</span>
    ~<span class="hljs-built_in">person</span>()
    {
        <span class="hljs-keyword">delete</span>[] name;
    }
};
</code></pre>
<p>Even today, people still write classes in this style and get into trouble:
"<em>I pushed a person into a vector and now I get crazy memory errors!</em>"
Remember that by default, copying an object means copying its members,
but copying the <code>name</code> member merely copies a pointer, <em>not</em> the character array it points to!
This has several unpleasant effects:</p>
<ol>
<li>Changes via <code>a</code> can be observed via <code>b</code>.</li>
<li>Once <code>b</code> is destroyed, <code>a.name</code> is a dangling pointer.</li>
<li>If <code>a</code> is destroyed, deleting the dangling pointer yields <a href="https://stackoverflow.com/questions/2397984/">undefined behavior</a>.</li>
<li>Since the assignment does not take into account what <code>name</code> pointed to before the assignment,
sooner or later you will get memory leaks all over the place.</li>
</ol>
<h2>Explicit definitions</h2>
<p>Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// 1. copy constructor</span>
<span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person&amp; that)
{
    name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(that.name) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(name, that.name);
    age = that.age;
}

<span class="hljs-comment">// 2. copy assignment operator</span>
person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person&amp; that)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;that)
    {
        <span class="hljs-keyword">delete</span>[] name;
        <span class="hljs-comment">// This is a dangerous point in the flow of execution!</span>
        <span class="hljs-comment">// We have temporarily invalidated the class invariants,</span>
        <span class="hljs-comment">// and the next statement might throw an exception,</span>
        <span class="hljs-comment">// leaving the object in an invalid state :(</span>
        name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(that.name) + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(name, that.name);
        age = that.age;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p>Note the difference between initialization and assignment:
we must tear down the old state before assigning to <code>name</code> to prevent memory leaks.
Also, we have to protect against self-assignment of the form <code>x = x</code>.
Without that check, <code>delete[] name</code> would delete the array containing the <em>source</em> string,
because when you write <code>x = x</code>, both <code>this-&gt;name</code> and <code>that.name</code> contain the same pointer.</p>
<h2>Exception safety</h2>
<p>Unfortunately, this solution will fail if <code>new char[...]</code> throws an exception due to memory exhaustion.
One possible solution is to introduce a local variable and reorder the statements:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// 2. copy assignment operator</span>
person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person&amp; that)
{
    <span class="hljs-type">char</span>* local_name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(that.name) + <span class="hljs-number">1</span>];
    <span class="hljs-comment">// If the above statement throws,</span>
    <span class="hljs-comment">// the object is still in the same state as before.</span>
    <span class="hljs-comment">// None of the following statements will throw an exception :)</span>
    <span class="hljs-built_in">strcpy</span>(local_name, that.name);
    <span class="hljs-keyword">delete</span>[] name;
    name = local_name;
    age = that.age;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p>This also takes care of self-assignment without an explicit check.
An even more robust solution to this problem is the <a href="https://stackoverflow.com/questions/3279543/">copy-and-swap idiom</a>,
but I will not go into the details of exception safety here.
I only mentioned exceptions to make the following point: <strong>Writing classes that manage resources is hard.</strong></p>
<h2>Noncopyable resources</h2>
<p>Some resources cannot or should not be copied, such as file handles or mutexes.
In that case, simply declare the copy constructor and copy assignment operator as <code>private</code> without giving a definition:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">private</span>:

    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person&amp; that);
    person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person&amp; that);
</code></pre>
<p>Alternatively, you can inherit from <code>boost::noncopyable</code> or declare them as deleted (in C++11 and above):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person&amp; that) = <span class="hljs-keyword">delete</span>;
person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person&amp; that) = <span class="hljs-keyword">delete</span>;
</code></pre>
<h2>The rule of three</h2>
<p>Sometimes you need to implement a class that manages a resource.
(Never manage multiple resources in a single class,
this will only lead to pain.)
In that case, remember the <strong>rule of three</strong>:</p>
<blockquote>
<p>If you need to explicitly declare either the destructor,
copy constructor or copy assignment operator yourself,
you probably need to explicitly declare all three of them.</p>
</blockquote>
<p>(Unfortunately, this "rule" is not enforced by the C++ standard or any compiler I am aware of.)</p>
<h2>The rule of five</h2>
<p>From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.</p>
<p>An example with the signatures:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>
{
    std::string name;
    <span class="hljs-type">int</span> age;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> age);        <span class="hljs-comment">// Ctor</span>
    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;) = <span class="hljs-keyword">default</span>;                <span class="hljs-comment">// 1/5: Copy Ctor</span>
    <span class="hljs-built_in">person</span>(person &amp;&amp;) <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;            <span class="hljs-comment">// 4/5: Move Ctor</span>
    person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> person &amp;) = <span class="hljs-keyword">default</span>;     <span class="hljs-comment">// 2/5: Copy Assignment</span>
    person&amp; <span class="hljs-keyword">operator</span>=(person &amp;&amp;) <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 5/5: Move Assignment</span>
    ~<span class="hljs-built_in">person</span>() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;                    <span class="hljs-comment">// 3/5: Dtor</span>
};
</code></pre>
<h2>The rule of zero</h2>
<p>The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.</p>
<h1>Advice</h1>
<p>Most of the time, you do not need to manage a resource yourself,
because an existing class such as <code>std::string</code> already does it for you.
Just compare the simple code using a <code>std::string</code> member
to the convoluted and error-prone alternative using a <code>char*</code> and you should be convinced.
As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29" rel="noreferrer">Rule of Three</a> is a rule of thumb for C++, basically saying </p>

<blockquote>
  <p>If your class needs any of</p>
  
  <ul>
  <li>a <strong>copy constructor</strong>,</li>
  <li>an <strong>assignment operator</strong>, </li>
  <li>or a <strong>destructor</strong>, </li>
  </ul>
  
  <p>defined explictly, then it is likely to need <strong>all three of them</strong>.</p>
</blockquote>

<p>The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing. </p>

<p>If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not <em><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632">defining</a></em>) the copy constructor and assignment operator as <code>private</code>. </p>

<p>(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The law of the big three is as specified above.</p>

<p>An easy example, in plain English, of the kind of problem it solves:</p>

<p><strong>Non default destructor</strong></p>

<p>You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.</p>

<p>You might think that this is job done. </p>

<p>The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.</p>

<p>Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.</p>

<p>Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.</p>

<p><strong>Assignment operator and copy constructor</strong></p>

<p>You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.</p>

<p>This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.</p>

<p>To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-function">MyClass <span class="hljs-title">x</span><span class="hljs-params">(a, b)</span></span>;
    <span class="hljs-function">MyClass <span class="hljs-title">y</span><span class="hljs-params">(c, d)</span></span>;
    x = y; <span class="hljs-comment">// This is a shallow copy if assignment operator is not provided</span>
</code></pre>

<p>If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What does copying an object mean? 
There are a few ways you can copy objects--let's talk about the 2 kinds you're most likely referring to--deep copy and shallow copy.</p>

<p>Since we're in an object-oriented language (or at least are assuming so), let's say you have a piece of memory allocated.  Since it's an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let's say we have a class of Car as follows:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-comment">//A very simple class just to demonstrate what these definitions mean.</span>
<span class="hljs-comment">//It's pseudocode C++/Javaish, I assume strings do not need to be allocated.</span>
{
<span class="hljs-keyword">private</span> String sPrintColor;
<span class="hljs-keyword">private</span> String sModel;
<span class="hljs-keyword">private</span> String sMake;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">changePaint</span><span class="hljs-params">(String newColor)</span>
</span>{
   <span class="hljs-keyword">this</span>.sPrintColor = newColor;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String model, String make, String color)</span> <span class="hljs-comment">//Constructor</span>
</span>{
   <span class="hljs-keyword">this</span>.sPrintColor = color;
   <span class="hljs-keyword">this</span>.sModel = model;
   <span class="hljs-keyword">this</span>.sMake = make;
}

<span class="hljs-keyword">public</span> ~<span class="hljs-built_in">Car</span>() <span class="hljs-comment">//Destructor</span>
{
<span class="hljs-comment">//Because we did not create any custom types, we aren't adding more code.</span>
<span class="hljs-comment">//Anytime your object goes out of scope / program collects garbage / etc. this guy gets called + all other related destructors.</span>
<span class="hljs-comment">//Since we did not use anything but strings, we have nothing additional to handle.</span>
<span class="hljs-comment">//The assumption is being made that the 3 strings will be handled by string's destructor and that it is being called automatically--if this were not the case you would need to do it here.</span>
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-type">const</span> Car &amp;other)</span> <span class="hljs-comment">// Copy Constructor</span>
</span>{
   <span class="hljs-keyword">this</span>.sPrintColor = other.sPrintColor;
   <span class="hljs-keyword">this</span>.sModel = other.sModel;
   <span class="hljs-keyword">this</span>.sMake = other.sMake;
}
<span class="hljs-keyword">public</span> Car &amp;<span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> Car &amp;other) <span class="hljs-comment">// Assignment Operator</span>
{
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other)
   {
      <span class="hljs-keyword">this</span>.sPrintColor = other.sPrintColor;
      <span class="hljs-keyword">this</span>.sModel = other.sModel;
      <span class="hljs-keyword">this</span>.sMake = other.sMake;
   }
   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

}
</code></pre>

<p>A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Car car1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>(<span class="hljs-string">"mustang"</span>, <span class="hljs-string">"ford"</span>, <span class="hljs-string">"red"</span>);
Car car2 = car1; <span class="hljs-comment">//Call the copy constructor</span>
car2.<span class="hljs-built_in">changePaint</span>(<span class="hljs-string">"green"</span>);
<span class="hljs-comment">//car2 is now green but car1 is still red.</span>
</code></pre>

<p>Now let's do something strange.  Let's say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It's usually a mistake to do this and in classes is usually the blanket it's discussed under.)  Pretend that anytime you ask about car2, you're really resolving a pointer to car1's memory space...that's more or less what a shallow copy is.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Shallow copy example</span>
<span class="hljs-comment">//Assume we're in C++ because it's standard behavior is to shallow copy objects if you do not have a constructor written for an operation.</span>
<span class="hljs-comment">//Now let's assume I do not have any code for the assignment or copy operations like I do above...with those now gone, C++ will use the default.</span>

 Car car1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>(<span class="hljs-string">"ford"</span>, <span class="hljs-string">"mustang"</span>, <span class="hljs-string">"red"</span>); 
 Car car2 = car1; 
 car2.<span class="hljs-built_in">changePaint</span>(<span class="hljs-string">"green"</span>);<span class="hljs-comment">//car1 is also now green </span>
 <span class="hljs-keyword">delete</span> car2;<span class="hljs-comment">/*I get rid of my car which is also really your car...I told C++ to resolve 
 the address of where car2 exists and delete the memory...which is also
 the memory associated with your car.*/</span>
 car1.<span class="hljs-built_in">changePaint</span>(<span class="hljs-string">"red"</span>);<span class="hljs-comment">/*program will likely crash because this area is
 no longer allocated to the program.*/</span>
</code></pre>

<p>So regardless of what language you're writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.</p>

<p>What are the copy constructor and the copy assignment operator?
I have already used them above.  The copy constructor is called when you type code such as <code>Car car2 = car1;</code>  Essentially if you declare a variable and assign it in one line, that's when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--<code>car2 = car1;</code>.  Notice <code>car2</code> isn't declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you're satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.</p>

<p>When do I need to declare them myself? 
If you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it 'by accident' and didn't make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?</p>

<p>How can I prevent my objects from being copied?
Override all of the ways you're allowed to allocate memory for your object with a private function is a reasonable start.  If you really don't want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.  </p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>When do I need to declare them myself?</p>
</blockquote>

<p>The Rule of Three states that if you declare any of a </p>

<ol>
<li>copy constructor</li>
<li>copy assignment operator</li>
<li>destructor</li>
</ol>

<p>then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that </p>

<ul>
<li><p>whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and </p></li>
<li><p>the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that
manage memory (e.g., the STL containers that perform dynamic memory management) all declare the big three: both copy operations and a destructor.</p></li>
</ul>

<p><strong>A consequence of the Rule of Three</strong> is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldnt be automatically generated, because they wouldnt do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.</p>

<blockquote>
  <p>How can I prevent my objects from being copied?</p>
</blockquote>

<p>Declare copy constructor &amp; copy assignment operator as private access specifier.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryBlock</span>
{
<span class="hljs-keyword">public</span>:

<span class="hljs-comment">//code here</span>

<span class="hljs-keyword">private</span>:
<span class="hljs-built_in">MemoryBlock</span>(<span class="hljs-type">const</span> MemoryBlock&amp; other)
{
   cout&lt;&lt;<span class="hljs-string">"copy constructor"</span>&lt;&lt;endl;
}

<span class="hljs-comment">// Copy assignment operator.</span>
MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MemoryBlock&amp; other)
{
 <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   MemoryBlock a;
   <span class="hljs-function">MemoryBlock <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;
}
</code></pre>

<p>In C++11 onwards you can also declare copy constructor &amp; assignment operator deleted</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryBlock</span>
{
<span class="hljs-keyword">public</span>:
<span class="hljs-built_in">MemoryBlock</span>(<span class="hljs-type">const</span> MemoryBlock&amp; other) = <span class="hljs-keyword">delete</span>

<span class="hljs-comment">// Copy assignment operator.</span>
MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MemoryBlock&amp; other) =<span class="hljs-keyword">delete</span>
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   MemoryBlock a;
   <span class="hljs-function">MemoryBlock <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Many of the existing answers already touch the copy constructor, assignment operator and destructor.
However, in post C++11, the introduction of move semantic may expand this beyond 3.</p>

<p>Recently Michael Claisse gave a talk that touches this topic:
<a href="http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class" rel="noreferrer">http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class</a></p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-constructor">copy-constructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/assignment-operator">assignment-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rule-of-three">rule-of-three</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.</p>

<p>Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.</p>

<p>Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.</p>

<p>There are quick examples:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// default constructor</span>
My_Class a;

<span class="hljs-comment">// copy constructor</span>
<span class="hljs-function">My_Class <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;

<span class="hljs-comment">// copy constructor</span>
My_Class c = a;

<span class="hljs-comment">// copy assignment operator</span>
b = a;
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/mergeflatten-an-array-of-arrays-1657387827427">Merge/flatten an array of arrays</a><a href="/questions/how-can-i-read-inputs-as-numbers-1657384503324">How can I read inputs as numbers?</a><a href="/questions/randomize-a-listlesstgreater-1657388172793">Randomize a List&lt;T&gt;</a><a href="/questions/retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457">Retrieve only the queried element in an object array in MongoDB collection</a><a href="/questions/how-do-i-make-a-list-of-data-frames-1657385480437">How do I make a list of data frames?</a><a href="/questions/iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824">Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop</a><a href="/questions/switch-between-two-frames-in-tkinter-1657388528781">Switch between two frames in tkinter?</a><a href="/questions/why-do-regex-constructors-need-to-be-double-escaped-1657388004942">Why do regex constructors need to be double escaped?</a><a href="/questions/how-do-i-count-the-occurrences-of-a-list-item-1657387916234">How do I count the occurrences of a list item?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544">How do you get the footer to stay at the bottom of a Web page?</a><a href="/questions/is-java-%22pass-by-reference%22-or-%22pass-by-value%22-1657384319828">Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;?</a><a href="/questions/sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292">SQL select only rows with max value on a column [duplicate]</a><a href="/questions/undefined-behavior-and-sequence-points-1657384639493">Undefined behavior and sequence points</a><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329">What is the copy-and-swap idiom?</a><a href="/questions/why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458">Why does jQuery or a DOM method such as getElementById not find the element?</a><a href="/questions/how-to-filter-object-array-based-on-attributes-1657388211247">How to filter object array based on attributes?</a><a href="/questions/copy-array-by-value-1657387649531">Copy array by value</a><a href="/questions/how-do-i-return-the-response-from-an-asynchronous-call-1657384208012">How do I return the response from an asynchronous call?</a><a href="/questions/disable-same-origin-policy-in-chrome-1657387743804">Disable same origin policy in Chrome</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Introduction\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;C++ treats variables of user-defined types with \u0026lt;em\u0026gt;value semantics\u0026lt;/em\u0026gt;.\nThis means that objects are implicitly copied in various contexts,\nand we should understand what \u0026quot;copying an object\u0026quot; actually means.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let us consider a simple example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;\n{\n    std::string name;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; name, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;(name), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;age\u0026lt;/span\u0026gt;(age)\n    {\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;person \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Bjarne Stroustrup\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;60\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;person \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// What happens here?\u0026lt;/span\u0026gt;\n    b = a;         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// And here?\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(If you are puzzled by the \u0026lt;code\u0026gt;name(name), age(age)\u0026lt;/code\u0026gt; part,\nthis is called a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1272680/\u0026quot;\u0026gt;member initializer list\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Special member functions\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;What does it mean to copy a \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object?\nThe \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function shows two distinct copying scenarios.\nThe initialization \u0026lt;code\u0026gt;person b(a);\u0026lt;/code\u0026gt; is performed by the \u0026lt;em\u0026gt;copy constructor\u0026lt;/em\u0026gt;.\nIts job is to construct a fresh object based on the state of an existing object.\nThe assignment \u0026lt;code\u0026gt;b = a\u0026lt;/code\u0026gt; is performed by the \u0026lt;em\u0026gt;copy assignment operator\u0026lt;/em\u0026gt;.\nIts job is generally a little more complicated,\nbecause the target object is already in some valid state that needs to be dealt with.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,\nthese are implicitly defined for us. Quote from the standard:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.\n[ \u0026lt;em\u0026gt;Note\u0026lt;/em\u0026gt;: \u0026lt;strong\u0026gt;The implementation will implicitly declare these member functions\nfor some class types when the program does not explicitly declare them.\u0026lt;/strong\u0026gt;\nThe implementation will implicitly define them if they are used. [...] \u0026lt;em\u0026gt;end note\u0026lt;/em\u0026gt; ]\n[n3126.pdf section 12 ยง1]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;By default, copying an object means copying its members:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.\n[n3126.pdf section 12.8 ยง16]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment\nof its subobjects.\n[n3126.pdf section 12.8 ยง30]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Implicit definitions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The implicitly-defined special member functions for \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; look like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1. copy constructor\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;(that.name), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;age\u0026lt;/span\u0026gt;(that.age)\n{\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2. copy assignment operator\u0026lt;/span\u0026gt;\nperson\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that)\n{\n    name = that.name;\n    age = that.age;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3. destructor\u0026lt;/span\u0026gt;\n~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;()\n{\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Memberwise copying is exactly what we want in this case:\n\u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; are copied, so we get a self-contained, independent \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object.\nThe implicitly-defined destructor is always empty.\nThis is also fine in this case since we did not acquire any resources in the constructor.\nThe members\u0026apos; destructors are implicitly called after the \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; destructor is finished:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;After executing the body of the destructor and destroying any automatic objects allocated within the body,\na destructor for class X calls the destructors for X\u0026apos;s direct [...] members\n[n3126.pdf 12.4 ยง6]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h1\u0026gt;Managing resources\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;So when should we declare those special member functions explicitly?\nWhen our class \u0026lt;em\u0026gt;manages a resource\u0026lt;/em\u0026gt;, that is,\nwhen an object of the class is \u0026lt;em\u0026gt;responsible\u0026lt;/em\u0026gt; for that resource.\nThat usually means the resource is \u0026lt;em\u0026gt;acquired\u0026lt;/em\u0026gt; in the constructor\n(or passed into the constructor) and \u0026lt;em\u0026gt;released\u0026lt;/em\u0026gt; in the destructor.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let us go back in time to pre-standard C++.\nThere was no such thing as \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;, and programmers were in love with pointers.\nThe \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; class might have looked like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* name;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the constructor acquires a resource:\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// in this case, dynamic memory obtained via new[]\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* the_name, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; the_age)\n    {\n        name = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(the_name) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(name, the_name);\n        age = the_age;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the destructor must release this resource via delete[]\u0026lt;/span\u0026gt;\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] name;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Even today, people still write classes in this style and get into trouble:\n\u0026quot;\u0026lt;em\u0026gt;I pushed a person into a vector and now I get crazy memory errors!\u0026lt;/em\u0026gt;\u0026quot;\nRemember that by default, copying an object means copying its members,\nbut copying the \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; member merely copies a pointer, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; the character array it points to!\nThis has several unpleasant effects:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Changes via \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; can be observed via \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Once \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is destroyed, \u0026lt;code\u0026gt;a.name\u0026lt;/code\u0026gt; is a dangling pointer.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is destroyed, deleting the dangling pointer yields \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2397984/\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Since the assignment does not take into account what \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; pointed to before the assignment,\nsooner or later you will get memory leaks all over the place.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;h2\u0026gt;Explicit definitions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1. copy constructor\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that)\n{\n    name = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(that.name) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(name, that.name);\n    age = that.age;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2. copy assignment operator\u0026lt;/span\u0026gt;\nperson\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; != \u0026amp;amp;that)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] name;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a dangerous point in the flow of execution!\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We have temporarily invalidated the class invariants,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the next statement might throw an exception,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// leaving the object in an invalid state :(\u0026lt;/span\u0026gt;\n        name = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(that.name) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(name, that.name);\n        age = that.age;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note the difference between initialization and assignment:\nwe must tear down the old state before assigning to \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; to prevent memory leaks.\nAlso, we have to protect against self-assignment of the form \u0026lt;code\u0026gt;x = x\u0026lt;/code\u0026gt;.\nWithout that check, \u0026lt;code\u0026gt;delete[] name\u0026lt;/code\u0026gt; would delete the array containing the \u0026lt;em\u0026gt;source\u0026lt;/em\u0026gt; string,\nbecause when you write \u0026lt;code\u0026gt;x = x\u0026lt;/code\u0026gt;, both \u0026lt;code\u0026gt;this-\u0026amp;gt;name\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;that.name\u0026lt;/code\u0026gt; contain the same pointer.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Exception safety\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately, this solution will fail if \u0026lt;code\u0026gt;new char[...]\u0026lt;/code\u0026gt; throws an exception due to memory exhaustion.\nOne possible solution is to introduce a local variable and reorder the statements:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2. copy assignment operator\u0026lt;/span\u0026gt;\nperson\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that)\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* local_name = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(that.name) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If the above statement throws,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the object is still in the same state as before.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// None of the following statements will throw an exception :)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(local_name, that.name);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] name;\n    name = local_name;\n    age = that.age;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This also takes care of self-assignment without an explicit check.\nAn even more robust solution to this problem is the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3279543/\u0026quot;\u0026gt;copy-and-swap idiom\u0026lt;/a\u0026gt;,\nbut I will not go into the details of exception safety here.\nI only mentioned exceptions to make the following point: \u0026lt;strong\u0026gt;Writing classes that manage resources is hard.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Noncopyable resources\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Some resources cannot or should not be copied, such as file handles or mutexes.\nIn that case, simply declare the copy constructor and copy assignment operator as \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt; without giving a definition:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that);\n    person\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, you can inherit from \u0026lt;code\u0026gt;boost::noncopyable\u0026lt;/code\u0026gt; or declare them as deleted (in C++11 and above):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\nperson\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person\u0026amp;amp; that) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;The rule of three\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Sometimes you need to implement a class that manages a resource.\n(Never manage multiple resources in a single class,\nthis will only lead to pain.)\nIn that case, remember the \u0026lt;strong\u0026gt;rule of three\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If you need to explicitly declare either the destructor,\ncopy constructor or copy assignment operator yourself,\nyou probably need to explicitly declare all three of them.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;(Unfortunately, this \u0026quot;rule\u0026quot; is not enforced by the C++ standard or any compiler I am aware of.)\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;The rule of five\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An example with the signatures:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;\n{\n    std::string name;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; name, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age);        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Ctor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person \u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1/5: Copy Ctor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;(person \u0026amp;amp;\u0026amp;amp;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;noexcept\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 4/5: Move Ctor\u0026lt;/span\u0026gt;\n    person\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; person \u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2/5: Copy Assignment\u0026lt;/span\u0026gt;\n    person\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(person \u0026amp;amp;\u0026amp;amp;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;noexcept\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5/5: Move Assignment\u0026lt;/span\u0026gt;\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;noexcept\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3/5: Dtor\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;The rule of zero\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Advice\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Most of the time, you do not need to manage a resource yourself,\nbecause an existing class such as \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt; already does it for you.\nJust compare the simple code using a \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt; member\nto the convoluted and error-prone alternative using a \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; and you should be convinced.\nAs long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Rule of Three\u0026lt;/a\u0026gt; is a rule of thumb for C++, basically saying \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If your class needs any of\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;a \u0026lt;strong\u0026gt;copy constructor\u0026lt;/strong\u0026gt;,\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;an \u0026lt;strong\u0026gt;assignment operator\u0026lt;/strong\u0026gt;, \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;or a \u0026lt;strong\u0026gt;destructor\u0026lt;/strong\u0026gt;, \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;defined explictly, then it is likely to need \u0026lt;strong\u0026gt;all three of them\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632\u0026quot;\u0026gt;defining\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;) the copy constructor and assignment operator as \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The law of the big three is as specified above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An easy example, in plain English, of the kind of problem it solves:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Non default destructor\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might think that this is job done. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Assignment operator and copy constructor\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyClass \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a, b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyClass \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(c, d)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    x = y; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a shallow copy if assignment operator is not provided\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What does copying an object mean? \nThere are a few ways you can copy objects--let\u0026apos;s talk about the 2 kinds you\u0026apos;re most likely referring to--deep copy and shallow copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since we\u0026apos;re in an object-oriented language (or at least are assuming so), let\u0026apos;s say you have a piece of memory allocated.  Since it\u0026apos;s an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let\u0026apos;s say we have a class of Car as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//A very simple class just to demonstrate what these definitions mean.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//It\u0026apos;s pseudocode C++/Javaish, I assume strings do not need to be allocated.\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String sPrintColor;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String sModel;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String sMake;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;changePaint\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String newColor)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sPrintColor = newColor;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String model, String make, String color)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Constructor\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sPrintColor = color;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sModel = model;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sMake = make;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Destructor\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Because we did not create any custom types, we aren\u0026apos;t adding more code.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Anytime your object goes out of scope / program collects garbage / etc. this guy gets called + all other related destructors.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Since we did not use anything but strings, we have nothing additional to handle.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The assumption is being made that the 3 strings will be handled by string\u0026apos;s destructor and that it is being called automatically--if this were not the case you would need to do it here.\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Car \u0026amp;amp;other)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy Constructor\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sPrintColor = other.sPrintColor;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sModel = other.sModel;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sMake = other.sMake;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Car \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Car \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assignment Operator\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; != \u0026amp;amp;other)\n   {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sPrintColor = other.sPrintColor;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sModel = other.sModel;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.sMake = other.sMake;\n   }\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Car car1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;mustang\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ford\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;red\u0026quot;\u0026lt;/span\u0026gt;);\nCar car2 = car1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Call the copy constructor\u0026lt;/span\u0026gt;\ncar2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;changePaint\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;green\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//car2 is now green but car1 is still red.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now let\u0026apos;s do something strange.  Let\u0026apos;s say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It\u0026apos;s usually a mistake to do this and in classes is usually the blanket it\u0026apos;s discussed under.)  Pretend that anytime you ask about car2, you\u0026apos;re really resolving a pointer to car1\u0026apos;s memory space...that\u0026apos;s more or less what a shallow copy is.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Shallow copy example\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Assume we\u0026apos;re in C++ because it\u0026apos;s standard behavior is to shallow copy objects if you do not have a constructor written for an operation.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Now let\u0026apos;s assume I do not have any code for the assignment or copy operations like I do above...with those now gone, C++ will use the default.\u0026lt;/span\u0026gt;\n\n Car car1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ford\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;mustang\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;red\u0026quot;\u0026lt;/span\u0026gt;); \n Car car2 = car1; \n car2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;changePaint\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;green\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//car1 is also now green \u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; car2;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*I get rid of my car which is also really your car...I told C++ to resolve \n the address of where car2 exists and delete the memory...which is also\n the memory associated with your car.*/\u0026lt;/span\u0026gt;\n car1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;changePaint\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;red\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*program will likely crash because this area is\n no longer allocated to the program.*/\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So regardless of what language you\u0026apos;re writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What are the copy constructor and the copy assignment operator?\nI have already used them above.  The copy constructor is called when you type code such as \u0026lt;code\u0026gt;Car car2 = car1;\u0026lt;/code\u0026gt;  Essentially if you declare a variable and assign it in one line, that\u0026apos;s when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--\u0026lt;code\u0026gt;car2 = car1;\u0026lt;/code\u0026gt;.  Notice \u0026lt;code\u0026gt;car2\u0026lt;/code\u0026gt; isn\u0026apos;t declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you\u0026apos;re satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When do I need to declare them myself? \nIf you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it \u0026apos;by accident\u0026apos; and didn\u0026apos;t make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How can I prevent my objects from being copied?\nOverride all of the ways you\u0026apos;re allowed to allocate memory for your object with a private function is a reasonable start.  If you really don\u0026apos;t want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When do I need to declare them myself?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The Rule of Three states that if you declare any of a \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;copy constructor\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;copy assignment operator\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;destructor\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that\nmanage memory (e.g., the STL containers that perform dynamic memory management) all declare the big three: both copy operations and a destructor.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A consequence of the Rule of Three\u0026lt;/strong\u0026gt; is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldnt be automatically generated, because they wouldnt do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;How can I prevent my objects from being copied?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Declare copy constructor \u0026amp;amp; copy assignment operator as private access specifier.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MemoryBlock\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//code here\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MemoryBlock\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; MemoryBlock\u0026amp;amp; other)\n{\n   cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;copy constructor\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;endl;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy assignment operator.\u0026lt;/span\u0026gt;\nMemoryBlock\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; MemoryBlock\u0026amp;amp; other)\n{\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   MemoryBlock a;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MemoryBlock \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In C++11 onwards you can also declare copy constructor \u0026amp;amp; assignment operator deleted\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MemoryBlock\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MemoryBlock\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; MemoryBlock\u0026amp;amp; other) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy assignment operator.\u0026lt;/span\u0026gt;\nMemoryBlock\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; MemoryBlock\u0026amp;amp; other) =\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   MemoryBlock a;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MemoryBlock \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Many of the existing answers already touch the copy constructor, assignment operator and destructor.\nHowever, in post C++11, the introduction of move semantic may expand this beyond 3.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Recently Michael Claisse gave a talk that touches this topic:\n\u0026lt;a href=\u0026quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are quick examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// default constructor\u0026lt;/span\u0026gt;\nMy_Class a;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy constructor\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;My_Class \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy constructor\u0026lt;/span\u0026gt;\nMy_Class c = a;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy assignment operator\u0026lt;/span\u0026gt;\nb = a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":46,"title":"What is The Rule of Three?","content":"\n                \n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;What does \u0026lt;em\u0026gt;copying an object\u0026lt;/em\u0026gt; mean?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What are the \u0026lt;em\u0026gt;copy constructor\u0026lt;/em\u0026gt; and the \u0026lt;em\u0026gt;copy assignment operator\u0026lt;/em\u0026gt;?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When do I need to declare them myself?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;How can I prevent my objects from being copied?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-is-the-rule-of-three-1657384390295","postType":"QUESTION","createdAt":"2022-07-09T16:33:10.000Z","updatedAt":"2022-07-09T16:33:10.000Z","tags":[{"id":162,"name":"copy-constructor","slug":"copy-constructor","createdAt":"2022-07-09T16:33:10.000Z","updatedAt":"2022-07-09T16:33:10.000Z","Questions_Tags":{"questionId":46,"tagId":162}},{"id":163,"name":"assignment-operator","slug":"assignment-operator","createdAt":"2022-07-09T16:33:10.000Z","updatedAt":"2022-07-09T16:33:10.000Z","Questions_Tags":{"questionId":46,"tagId":163}},{"id":164,"name":"rule-of-three","slug":"rule-of-three","createdAt":"2022-07-09T16:33:10.000Z","updatedAt":"2022-07-09T16:33:10.000Z","Questions_Tags":{"questionId":46,"tagId":164}}],"relatedQuestions":[{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295","tags":[{"name":"copy-constructor","Questions_Tags":{"questionId":46,"tagId":162}},{"name":"assignment-operator","Questions_Tags":{"questionId":46,"tagId":163}},{"name":"rule-of-three","Questions_Tags":{"questionId":46,"tagId":164}}]}]},"randomQuestions":[{"title":"Merge/flatten an array of arrays","slug":"mergeflatten-an-array-of-arrays-1657387827427"},{"title":"How can I read inputs as numbers?","slug":"how-can-i-read-inputs-as-numbers-1657384503324"},{"title":"Randomize a List\u003cT\u003e","slug":"randomize-a-listlesstgreater-1657388172793"},{"title":"Retrieve only the queried element in an object array in MongoDB collection","slug":"retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457"},{"title":"How do I make a list of data frames?","slug":"how-do-i-make-a-list-of-data-frames-1657385480437"},{"title":"Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop","slug":"iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824"},{"title":"Switch between two frames in tkinter?","slug":"switch-between-two-frames-in-tkinter-1657388528781"},{"title":"Why do regex constructors need to be double escaped?","slug":"why-do-regex-constructors-need-to-be-double-escaped-1657388004942"},{"title":"How do I count the occurrences of a list item?","slug":"how-do-i-count-the-occurrences-of-a-list-item-1657387916234"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"How do you get the footer to stay at the bottom of a Web page?","slug":"how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544"},{"title":"Is Java \"pass-by-reference\" or \"pass-by-value\"?","slug":"is-java-\"pass-by-reference\"-or-\"pass-by-value\"-1657384319828"},{"title":"SQL select only rows with max value on a column [duplicate]","slug":"sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292"},{"title":"Undefined behavior and sequence points","slug":"undefined-behavior-and-sequence-points-1657384639493"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"Why does jQuery or a DOM method such as getElementById not find the element?","slug":"why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458"},{"title":"How to filter object array based on attributes?","slug":"how-to-filter-object-array-based-on-attributes-1657388211247"},{"title":"Copy array by value","slug":"copy-array-by-value-1657387649531"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"Disable same origin policy in Chrome","slug":"disable-same-origin-policy-in-chrome-1657387743804"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-rule-of-three-1657384390295"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>