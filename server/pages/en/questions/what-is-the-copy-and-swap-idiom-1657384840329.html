<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the copy-and-swap idiom? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is the copy-and-swap idiom and when should it be used? What problems does it solve? Does it change for C++11?
Related:

What are your favorite C++ Coding Style idioms:  Copy-swap
Copy constructor and = operator overload in C++: is a common function possible?
What is copy elision and how it optimizes copy-and-swap idiom
C++: dynamically allocating an array of objects?

    "/><meta property="og:title" content="What is the copy-and-swap idiom? | Solutions Checker"/><meta property="og:description" content="What is the copy-and-swap idiom and when should it be used? What problems does it solve? Does it change for C++11?
Related:

What are your favorite C++ Coding Style idioms:  Copy-swap
Copy constructor and = operator overload in C++: is a common function possible?
What is copy elision and how it optimizes copy-and-swap idiom
C++: dynamically allocating an array of objects?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the copy-and-swap idiom?","text":"What is the copy-and-swap idiom and when should it be used? What problems does it solve? Does it change for C++11?\nRelated:\n\nWhat are your favorite C++ Coding Style idioms:  Copy-swap\nCopy constructor and = operator overload in C++: is a common function possible?\nWhat is copy elision and how it optimizes copy-and-swap idiom\nC++: dynamically allocating an array of objects?\n\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"Overview\nWhy do we need the copy-and-swap idiom?\nAny class that manages a resource (a wrapper, like a smart pointer) needs to implement The Big Three. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?\nThe copy-and-swap idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee.\nHow does it work?\nConceptually, it works by using the copy-constructor&apos;s functionality to create a local copy of the data, then takes the copied data with a swap function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.\nIn order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a swap function.\nA swap function is a non-throwing function that swaps two objects of a class, member for member. We might be tempted to use std::swap instead of providing our own, but this would be impossible; std::swap uses the copy-constructor and copy-assignment operator within its implementation, and we&apos;d ultimately be trying to define the assignment operator in terms of itself!\n(Not only that, but unqualified calls to swap will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that std::swap would entail.)\n\nAn in-depth explanation\nThe goal\nLet&apos;s consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:\n#include &lt;algorithm&gt; // std::copy\n#include &lt;cstddef&gt; // std::size_t\n\nclass dumb_array\n{\npublic:\n    // (default) constructor\n    dumb_array(std::size_t size = 0)\n        : mSize(size),\n          mArray(mSize ? new int[mSize]() : nullptr)\n    {\n    }\n\n    // copy-constructor\n    dumb_array(const dumb_array&amp; other)\n        : mSize(other.mSize),\n          mArray(mSize ? new int[mSize] : nullptr)\n    {\n        // note that this is non-throwing, because of the data\n        // types being used; more attention to detail with regards\n        // to exceptions must be given in a more general case, however\n        std::copy(other.mArray, other.mArray + mSize, mArray);\n    }\n\n    // destructor\n    ~dumb_array()\n    {\n        delete [] mArray;\n    }\n\nprivate:\n    std::size_t mSize;\n    int* mArray;\n};\n\nThis class almost manages the array successfully, but it needs operator= to work correctly.\nA failed solution\nHere&apos;s how a naive implementation might look:\n// the hard part\ndumb_array&amp; operator=(const dumb_array&amp; other)\n{\n    if (this != &amp;other) // (1)\n    {\n        // get rid of the old data...\n        delete [] mArray; // (2)\n        mArray = nullptr; // (2) *(see footnote for rationale)\n\n        // ...and put in the new\n        mSize = other.mSize; // (3)\n        mArray = mSize ? new int[mSize] : nullptr; // (3)\n        std::copy(other.mArray, other.mArray + mSize, mArray); // (3)\n    }\n\n    return *this;\n}\n\nAnd we say we&apos;re finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as (n).\n\nThe first is the self-assignment test.\nThis check serves two purposes: it&apos;s an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.\nIt would be better if the operator could work properly without it.\n\nThe second is that it only provides a basic exception guarantee. If new int[mSize] fails, *this will have been modified. (Namely, the size is wrong and the data is gone!)\nFor a strong exception guarantee, it would need to be something akin to:\n dumb_array&amp; operator=(const dumb_array&amp; other)\n {\n     if (this != &amp;other) // (1)\n     {\n         // get the new data ready before we replace the old\n         std::size_t newSize = other.mSize;\n         int* newArray = newSize ? new int[newSize]() : nullptr; // (3)\n         std::copy(other.mArray, other.mArray + newSize, newArray); // (3)\n\n         // replace the old data (all are non-throwing)\n         delete [] mArray;\n         mSize = newSize;\n         mArray = newArray;\n     }\n\n     return *this;\n }\n\n\nThe code has expanded! Which leads us to the third problem: code duplication.\n\n\nOur assignment operator effectively duplicates all the code we&apos;ve already written elsewhere, and that&apos;s a terrible thing.\nIn our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.\n(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one?\nWhile this may seem to be a valid concern, and indeed it requires non-trivial try/catch clauses, this is a non-issue.\nThat&apos;s because a class should manage one resource only!)\nA successful solution\nAs mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a swap function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called &quot;The Big Three and A Half&quot;: any time your class manages a resource it also makes sense to provide a swap function.\nWe need to add swap functionality to our class, and we do that as follows:\nclass dumb_array\n{\npublic:\n    // ...\n\n    friend void swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow\n    {\n        // enable ADL (not necessary in our case, but good practice)\n        using std::swap;\n\n        // by swapping the members of two objects,\n        // the two objects are effectively swapped\n        swap(first.mSize, second.mSize);\n        swap(first.mArray, second.mArray);\n    }\n\n    // ...\n};\n\n(Here is the explanation why public friend swap.) Now not only can we swap our dumb_array&apos;s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.\nWithout further ado, our assignment operator is:\ndumb_array&amp; operator=(dumb_array other) // (1)\n{\n    swap(*this, other); // (2)\n\n    return *this;\n}\n\nAnd that&apos;s it! With one fell swoop, all three problems are elegantly tackled at once.\nWhy does it work?\nWe first notice an important choice: the parameter argument is taken by-value. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):\ndumb_array&amp; operator=(const dumb_array&amp; other)\n{\n    dumb_array temp(other);\n    swap(*this, temp);\n\n    return *this;\n}\n\nWe lose an important optimization opportunity. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you&apos;re going to make a copy of something in a function, let the compiler do it in the parameter list.)\nEither way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.\nObserve that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won&apos;t even enter the function if construction of the copy fails, and it&apos;s therefore not possible to alter the state of *this. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)\nAt this point we are home-free, because swap is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter&apos;s scope ends and its destructor is called.)\nBecause the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of operator=. (Additionally, we no longer have a performance penalty on non-self-assignments.)\nAnd that is the copy-and-swap idiom.\nWhat about C++11?\nThe next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now The Rule of Four (and a half). Why? Because not only do we need to be able to copy-construct our resource, we need to move-construct it as well.\nLuckily for us, this is easy:\nclass dumb_array\n{\npublic:\n    // ...\n\n    // move constructor\n    dumb_array(dumb_array&amp;&amp; other) noexcept \n        : dumb_array() // initialize via default constructor, C++11 only\n    {\n        swap(*this, other);\n    }\n\n    // ...\n};\n\nWhat&apos;s going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.\nSo what we&apos;ve done is simple: initialize via the default constructor (a C++11 feature), then swap with other; we know a default constructed instance of our class can safely be assigned and destructed, so we know other will be able to do the same, after swapping.\n(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)\nWhy does that work?\nThat is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:\ndumb_array&amp; operator=(dumb_array other); // (1)\n\nNow, if other is being initialized with an rvalue, it will be move-constructed. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will automatically pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)\nAnd so concludes the copy-and-swap idiom.\n\nFootnotes\n*Why do we set mArray to null? Because if any further code in the operator throws, the destructor of dumb_array might be called; and if that happens without setting it to null, we attempt to delete memory that&apos;s already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.\nThere are other claims that we should specialize std::swap for our type, provide an in-class swap along-side a free-function swap, etc. But this is all unnecessary: any proper use of swap will be through an unqualified call, and our function will be found through ADL. One function will do.\nThe reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.\nThe move constructor should generally be noexcept, otherwise some code (e.g. std::vector resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn&apos;t throw exceptions.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Assignment, at its heart, is two steps: tearing down the object&apos;s old state and building its new state as a copy of some other object&apos;s state. \n\nBasically, that&apos;s what the destructor and the copy constructor do, so the first idea would be to delegate the work to them. However, since destruction mustn&apos;t fail, while construction might, we actually want to do it the other way around: first perform the constructive part and, if that succeeded, then do the destructive part. The copy-and-swap idiom is a way to do just that: It first calls a class&apos; copy constructor to create a temporary object, then swaps its data with the temporary&apos;s, and then lets the temporary&apos;s destructor destroy the old state.\nSince swap() is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object. \n\nIn its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator: \n\nT&amp; operator=(T tmp)\n{\n    this-&gt;swap(tmp);\n    return *this;\n}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"There are some good answers already.  I&apos;ll focus mainly on what I think they lack - an explanation of the &quot;cons&quot; with the copy-and-swap idiom....\n\n\n  What is the copy-and-swap idiom?\n\n\nA way of implementing the assignment operator in terms of a swap function:\n\nX&amp; operator=(X rhs)\n{\n    swap(rhs);\n    return *this;\n}\n\n\nThe fundamental idea is that:\n\n\nthe most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)\nthat acquisition can be attempted before modifying the current state of the object (i.e. *this) if a copy of the new value is made, which is why rhs is accepted by value (i.e. copied) rather than by reference\nswapping the state of the local copy rhs and *this is usually relatively easy to do without potential failure/exceptions, given the local copy doesn&apos;t need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being moved from in &gt;= C++11)\n\n\n\n  When should it be used?  (Which problems does it solve [/create]?)\n\n\n\nWhen you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a swap with strong exception guarantee, and ideally one that can&apos;t fail/throw..\nWhen you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, swap and destructor functions.\n\n\nSelf-assignment done as a copy-and-swap avoids oft-overlooked edge cases.\n\n\nWhen any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. \n\n\n\n\n swap throwing: it&apos;s generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don&apos;t have a throw-free swap, or for which swapping has to be implemented as X tmp = lhs; lhs = rhs; rhs = tmp; and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 std::string&apos;s as James comments on another answer:\n\n\n  @wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions.  James McNellis Dec 22 &apos;10 at 15:24 \n\n\n\n\n assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with x = f(x); code where f is (perhaps only for some #ifdef branches) a macro ala #define f(x) x or a function returning a reference to x, or even (likely inefficient but concise) code like x = c1 ? x * 2 : c2 ? x / 2 : x;).  For example:\n\nstruct X\n{\n    T* p_;\n    size_t size_;\n    X&amp; operator=(const X&amp; rhs)\n    {\n        delete[] p_;  // OUCH!\n        p_ = new T[size_ = rhs.size_];\n        std::copy(p_, rhs.p_, rhs.p_ + rhs.size_);\n    }\n    ...\n};\n\n\nOn self-assignment, the above code delete&apos;s x.p_;, points p_ at a newly allocated heap region, then attempts to read the uninitialised data therein (Undefined Behaviour), if that doesn&apos;t do anything too weird, copy attempts a self-assignment to every just-destructed &apos;T&apos;!\n\n\n\n The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator&apos;s parameter is copy-constructed):\n\nstruct Client\n{\n    IP_Address ip_address_;\n    int socket_;\n    X(const X&amp; rhs)\n      : ip_address_(rhs.ip_address_), socket_(connect(rhs.ip_address_))\n    { }\n};\n\n\nHere, a hand-written Client::operator= might check if *this is already connected to the same server as rhs (perhaps sending a &quot;reset&quot; code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that&apos;s another matter ;-P).\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"This answer is more like an addition and a slight modification to the answers above.\n\nIn some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn&apos;t make sense. So if you declare/define your swap function like this:\n\nfriend void swap(A&amp; first, A&amp; second) {\n\n    std::swap(first.size, second.size);\n    std::swap(first.arr, second.arr);\n\n}\n\n\n... the compiler will yell at you when you call the swap function: \n\n\n\nThis has something to do with a friend function being called and this object being passed as a parameter.\n\n\n\nA way around this is to not use friend keyword and redefine the swap function:\n\nvoid swap(A&amp; other) {\n\n    std::swap(size, other.size);\n    std::swap(arr, other.arr);\n\n}\n\n\nThis time, you can just call swap and pass in other, thus making the compiler happy:\n\n\n\n\n\nAfter all, you don&apos;t need to use a friend function to swap 2 objects. It makes just as much sense to make swap a member function that has one other object as a parameter.\n\nYou already have access to this object, so passing it in as a parameter is technically redundant. \n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.\n\nFor concreteness, let us consider a container std::vector&lt;T, A&gt;, where A is some stateful allocator type, and we&apos;ll compare the following functions:\n\nvoid fs(std::vector&lt;T, A&gt; &amp; a, std::vector&lt;T, A&gt; &amp; b)\n{ \n    a.swap(b);\n    b.clear(); // not important what you do with b\n}\n\nvoid fm(std::vector&lt;T, A&gt; &amp; a, std::vector&lt;T, A&gt; &amp; b)\n{\n    a = std::move(b);\n}\n\n\nThe purpose of both functions fs and fm is to give a the state that b had initially. However, there is a hidden question: What happens if a.get_allocator() != b.get_allocator()? The answer is: It depends. Let&apos;s write AT = std::allocator_traits&lt;A&gt;.\n\n\nIf AT::propagate_on_container_move_assignment is std::true_type, then fm reassigns the allocator of a with the value of b.get_allocator(), otherwise it does not, and a continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of a and b is not compatible.\nIf AT::propagate_on_container_swap is std::true_type, then fs swaps both data and allocators in the expected fashion.\nIf AT::propagate_on_container_swap is std::false_type, then we need a dynamic check.\n\n\nIf a.get_allocator() == b.get_allocator(), then the two containers use compatible storage, and swapping proceeds in the usual fashion.\nHowever, if a.get_allocator() != b.get_allocator(), the program has undefined behaviour (cf. [container.requirements.general/8].\n\n\n\nThe upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That&apos;s a somewhat &quot;advanced use case&quot;, but it&apos;s not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-copy-and-swap-idiom-1657384840329#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329"><h1>What is the copy-and-swap idiom?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div><div class="question-content mt-5">
                
<p>What is the copy-and-swap idiom and when should it be used? What problems does it solve? Does it change for C++11?</p>
<p>Related:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/276173/what-are-your-favorite-c-coding-style-idioms/2034447#2034447">What are your favorite C++ Coding Style idioms:  Copy-swap</a></li>
<li><a href="https://stackoverflow.com/questions/1734628/copy-constructor-and-operator-overload-in-c-is-a-common-function-possible/1734640#1734640">Copy constructor and = operator overload in C++: is a common function possible?</a></li>
<li><a href="https://stackoverflow.com/questions/2143787/what-is-copy-elision-and-how-it-optimizes-copy-and-swap-idiom">What is copy elision and how it optimizes copy-and-swap idiom</a></li>
<li><a href="https://stackoverflow.com/questions/255612/c-dynamically-allocating-an-array-of-objects/255744#255744">C++: dynamically allocating an array of objects?</a></li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Overview</h1>
<h3>Why do we need the copy-and-swap idiom?</h3>
<p>Any class that manages a resource (a <em>wrapper</em>, like a smart pointer) needs to implement <a href="https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three">The Big Three</a>. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?</p>
<p>The <em>copy-and-swap idiom</em> is the solution, and elegantly assists the assignment operator in achieving two things: avoiding <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noreferrer">code duplication</a>, and providing a <a href="http://en.wikipedia.org/wiki/Exception_guarantees" rel="noreferrer">strong exception guarantee</a>.</p>
<h3>How does it work?</h3>
<p><a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616">Conceptually</a>, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a <code>swap</code> function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.</p>
<p>In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a <code>swap</code> function.</p>
<p>A swap function is a <em>non-throwing</em> function that swaps two objects of a class, member for member. We might be tempted to use <code>std::swap</code> instead of providing our own, but this would be impossible; <code>std::swap</code> uses the copy-constructor and copy-assignment operator within its implementation, and we'd ultimately be trying to define the assignment operator in terms of itself!</p>
<p>(Not only that, but unqualified calls to <code>swap</code> will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that <code>std::swap</code> would entail.)</p>
<hr>
<h1>An in-depth explanation</h1>
<h3>The goal</h3>
<p>Let's consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// std::copy</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// std::size_t</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">dumb_array</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// (default) constructor</span>
    <span class="hljs-built_in">dumb_array</span>(std::<span class="hljs-type">size_t</span> size = <span class="hljs-number">0</span>)
        : <span class="hljs-built_in">mSize</span>(size),
          <span class="hljs-built_in">mArray</span>(mSize ? <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[mSize]() : <span class="hljs-literal">nullptr</span>)
    {
    }

    <span class="hljs-comment">// copy-constructor</span>
    <span class="hljs-built_in">dumb_array</span>(<span class="hljs-type">const</span> dumb_array&amp; other)
        : <span class="hljs-built_in">mSize</span>(other.mSize),
          <span class="hljs-built_in">mArray</span>(mSize ? <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[mSize] : <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-comment">// note that this is non-throwing, because of the data</span>
        <span class="hljs-comment">// types being used; more attention to detail with regards</span>
        <span class="hljs-comment">// to exceptions must be given in a more general case, however</span>
        std::<span class="hljs-built_in">copy</span>(other.mArray, other.mArray + mSize, mArray);
    }

    <span class="hljs-comment">// destructor</span>
    ~<span class="hljs-built_in">dumb_array</span>()
    {
        <span class="hljs-keyword">delete</span> [] mArray;
    }

<span class="hljs-keyword">private</span>:
    std::<span class="hljs-type">size_t</span> mSize;
    <span class="hljs-type">int</span>* mArray;
};
</code></pre>
<p>This class almost manages the array successfully, but it needs <code>operator=</code> to work correctly.</p>
<h3>A failed solution</h3>
<p>Here's how a naive implementation might look:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// the hard part</span>
dumb_array&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> dumb_array&amp; other)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-comment">// (1)</span>
    {
        <span class="hljs-comment">// get rid of the old data...</span>
        <span class="hljs-keyword">delete</span> [] mArray; <span class="hljs-comment">// (2)</span>
        mArray = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// (2) *(see footnote for rationale)</span>

        <span class="hljs-comment">// ...and put in the new</span>
        mSize = other.mSize; <span class="hljs-comment">// (3)</span>
        mArray = mSize ? <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[mSize] : <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// (3)</span>
        std::<span class="hljs-built_in">copy</span>(other.mArray, other.mArray + mSize, mArray); <span class="hljs-comment">// (3)</span>
    }

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p>And we say we're finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as <code>(n)</code>.</p>
<ol>
<li><p>The first is the self-assignment test.<br>
This check serves two purposes: it's an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.<br>
It would be better if the operator could work properly without it.</p>
</li>
<li><p>The second is that it only provides a basic exception guarantee. If <code>new int[mSize]</code> fails, <code>*this</code> will have been modified. (Namely, the size is wrong and the data is gone!)<br>
For a strong exception guarantee, it would need to be something akin to:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> dumb_array&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> dumb_array&amp; other)
 {
     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-comment">// (1)</span>
     {
         <span class="hljs-comment">// get the new data ready before we replace the old</span>
         std::<span class="hljs-type">size_t</span> newSize = other.mSize;
         <span class="hljs-type">int</span>* newArray = newSize ? <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[newSize]() : <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// (3)</span>
         std::<span class="hljs-built_in">copy</span>(other.mArray, other.mArray + newSize, newArray); <span class="hljs-comment">// (3)</span>

         <span class="hljs-comment">// replace the old data (all are non-throwing)</span>
         <span class="hljs-keyword">delete</span> [] mArray;
         mSize = newSize;
         mArray = newArray;
     }

     <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
 }
</code></pre>
</li>
<li><p>The code has expanded! Which leads us to the third problem: code duplication.</p>
</li>
</ol>
<p>Our assignment operator effectively duplicates all the code we've already written elsewhere, and that's a terrible thing.</p>
<p>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.</p>
<p>(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one?<br>
While this may seem to be a valid concern, and indeed it requires non-trivial <code>try</code>/<code>catch</code> clauses, this is a non-issue.<br>
That's because a class should manage <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noreferrer"><em>one resource only</em></a>!)</p>
<h3>A successful solution</h3>
<p>As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a <code>swap</code> function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called "The Big Three and A Half": any time your class manages a resource it also makes sense to provide a <code>swap</code> function.</p>
<p>We need to add swap functionality to our class, and we do that as follows:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dumb_array</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(dumb_array&amp; first, dumb_array&amp; second)</span> <span class="hljs-comment">// nothrow</span>
    </span>{
        <span class="hljs-comment">// enable ADL (not necessary in our case, but good practice)</span>
        <span class="hljs-keyword">using</span> std::swap;

        <span class="hljs-comment">// by swapping the members of two objects,</span>
        <span class="hljs-comment">// the two objects are effectively swapped</span>
        <span class="hljs-built_in">swap</span>(first.mSize, second.mSize);
        <span class="hljs-built_in">swap</span>(first.mArray, second.mArray);
    }

    <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>(<a href="https://stackoverflow.com/questions/5695548/public-friend-swap-member-function">Here</a> is the explanation why <code>public friend swap</code>.) Now not only can we swap our <code>dumb_array</code>'s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.</p>
<p>Without further ado, our assignment operator is:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">dumb_array&amp; <span class="hljs-keyword">operator</span>=(dumb_array other) <span class="hljs-comment">// (1)</span>
{
    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, other); <span class="hljs-comment">// (2)</span>

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p>And that's it! With one fell swoop, all three problems are elegantly tackled at once.</p>
<h3>Why does it work?</h3>
<p>We first notice an important choice: the parameter argument is taken <em>by-value</em>. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">dumb_array&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> dumb_array&amp; other)
{
    dumb_array <span class="hljs-built_in">temp</span>(other);
    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, temp);

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p>We lose an <a href="https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/" rel="noreferrer">important optimization opportunity</a>. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.)</p>
<p>Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.</p>
<p>Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won't even enter the function if construction of the copy fails, and it's therefore not possible to alter the state of <code>*this</code>. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)</p>
<p>At this point we are home-free, because <code>swap</code> is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter's scope ends and its destructor is called.)</p>
<p>Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of <code>operator=</code>. (Additionally, we no longer have a performance penalty on non-self-assignments.)</p>
<p>And that is the copy-and-swap idiom.</p>
<h2>What about C++11?</h2>
<p>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now <strong>The Rule of Four</strong> (and a half). Why? Because not only do we need to be able to copy-construct our resource, <a href="https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me">we need to move-construct it as well</a>.</p>
<p>Luckily for us, this is easy:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dumb_array</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// move constructor</span>
    <span class="hljs-built_in">dumb_array</span>(dumb_array&amp;&amp; other) <span class="hljs-keyword">noexcept</span> 
        : <span class="hljs-built_in">dumb_array</span>() <span class="hljs-comment">// initialize via default constructor, C++11 only</span>
    {
        <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, other);
    }

    <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>What's going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.</p>
<p>So what we've done is simple: initialize via the default constructor (a C++11 feature), then swap with <code>other</code>; we know a default constructed instance of our class can safely be assigned and destructed, so we know <code>other</code> will be able to do the same, after swapping.</p>
<p>(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)</p>
<h3>Why does that work?</h3>
<p>That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">dumb_array&amp; <span class="hljs-keyword">operator</span>=(dumb_array other); <span class="hljs-comment">// (1)</span>
</code></pre>
<p>Now, if <code>other</code> is being initialized with an rvalue, <em>it will be move-constructed</em>. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will <em>automatically</em> pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)</p>
<p>And so concludes the copy-and-swap idiom.</p>
<hr>
<h3>Footnotes</h3>
<p>*Why do we set <code>mArray</code> to null? Because if any further code in the operator throws, the destructor of <code>dumb_array</code> might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</p>
<p>There are other claims that we should specialize <code>std::swap</code> for our type, provide an in-class <code>swap</code> along-side a free-function <code>swap</code>, etc. But this is all unnecessary: any proper use of <code>swap</code> will be through an unqualified call, and our function will be found through <a href="http://en.wikipedia.org/wiki/Argument-dependent_name_lookup" rel="noreferrer">ADL</a>. One function will do.</p>
<p>The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.</p>
<p>The move constructor should generally be <code>noexcept</code>, otherwise some code (e.g. <code>std::vector</code> resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn't throw exceptions.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Assignment, at its heart, is two steps: <strong><em>tearing down the object's old state</em></strong> and <strong><em>building its new state as a copy</em></strong> of some other object's state. </p>

<p>Basically, that's what the <strong><em>destructor</em></strong> and the <strong><em>copy constructor</em></strong> do, so the first idea would be to delegate the work to them. However, since destruction mustn't fail, while construction might, <em>we actually want to do it the other way around</em>: <strong><em>first perform the constructive part</em></strong> and, if that succeeded, <strong><em>then do the destructive part</em></strong>. The copy-and-swap idiom is a way to do just that: It first calls a class' copy constructor to create a temporary object, then swaps its data with the temporary's, and then lets the temporary's destructor destroy the old state.<br>
Since <code>swap()</code> is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object. </p>

<p>In its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T&amp; <span class="hljs-keyword">operator</span>=(T tmp)
{
    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">swap</span>(tmp);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are some good answers already.  I'll focus <em>mainly</em> on what I think they lack - an explanation of the "cons" with the copy-and-swap idiom....</p>

<blockquote>
  <p>What is the copy-and-swap idiom?</p>
</blockquote>

<p>A way of implementing the assignment operator in terms of a swap function:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">X&amp; <span class="hljs-keyword">operator</span>=(X rhs)
{
    <span class="hljs-built_in">swap</span>(rhs);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>

<p>The fundamental idea is that:</p>

<ul>
<li><p>the most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)</p></li>
<li><p>that acquisition can be attempted <em>before</em> modifying the current state of the object (i.e. <code>*this</code>) if a copy of the new value is made, which is why <code>rhs</code> is accepted <em>by value</em> (i.e. copied) rather than <em>by reference</em></p></li>
<li><p>swapping the state of the local copy <code>rhs</code> and <code>*this</code> is <em>usually</em> relatively easy to do without potential failure/exceptions, given the local copy doesn't need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being <em>moved</em> from in &gt;= C++11)</p></li>
</ul>

<blockquote>
  <p>When should it be used?  (Which problems does it solve <strong>[/create]</strong>?)</p>
</blockquote>

<ul>
<li><p>When you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a <code>swap</code> with strong exception guarantee, and ideally one that can't fail/<code>throw</code>..</p></li>
<li><p>When you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, <code>swap</code> and destructor functions.</p>

<ul>
<li>Self-assignment done as a copy-and-swap avoids oft-overlooked edge cases.
<p></p></li>
</ul></li>
<li>When any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. </li>
</ul>

<hr>

<p> <code>swap</code> throwing: it's generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don't have a throw-free swap, or for which swapping has to be implemented as <code>X tmp = lhs; lhs = rhs; rhs = tmp;</code> and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 <code>std::string</code>'s as James comments on another answer:</p>

<blockquote>
  <p>@wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions.  James McNellis Dec 22 '10 at 15:24 </p>
</blockquote>

<hr>

<p> assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with <code>x = f(x);</code> code where <code>f</code> is (perhaps only for some <code>#ifdef</code> branches) a macro ala <code>#define f(x) x</code> or a function returning a reference to <code>x</code>, or even (likely inefficient but concise) code like <code>x = c1 ? x * 2 : c2 ? x / 2 : x;</code>).  For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>
{
    T* p_;
    <span class="hljs-type">size_t</span> size_;
    X&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> X&amp; rhs)
    {
        <span class="hljs-keyword">delete</span>[] p_;  <span class="hljs-comment">// OUCH!</span>
        p_ = <span class="hljs-keyword">new</span> T[size_ = rhs.size_];
        std::<span class="hljs-built_in">copy</span>(p_, rhs.p_, rhs.p_ + rhs.size_);
    }
    ...
};
</code></pre>

<p>On self-assignment, the above code delete's <code>x.p_;</code>, points <code>p_</code> at a newly allocated heap region, then attempts to read the <em>uninitialised</em> data therein (Undefined Behaviour), if that doesn't do anything too weird, <code>copy</code> attempts a self-assignment to every just-destructed 'T'!</p>

<hr>

<p> The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator's parameter is copy-constructed):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Client</span>
{
    IP_Address ip_address_;
    <span class="hljs-type">int</span> socket_;
    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp; rhs)
      : <span class="hljs-built_in">ip_address_</span>(rhs.ip_address_), <span class="hljs-built_in">socket_</span>(<span class="hljs-built_in">connect</span>(rhs.ip_address_))
    { }
};
</code></pre>

<p>Here, a hand-written <code>Client::operator=</code> might check if <code>*this</code> is already connected to the same server as <code>rhs</code> (perhaps sending a "reset" code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that's another matter ;-P).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This answer is more like an addition and a slight modification to the answers above.</p>

<p>In some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn't make sense. So if you declare/define your <code>swap</code> function like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(A&amp; first, A&amp; second)</span> </span>{

    std::<span class="hljs-built_in">swap</span>(first.size, second.size);
    std::<span class="hljs-built_in">swap</span>(first.arr, second.arr);

}
</code></pre>

<p>... the compiler will yell at you when you call the <code>swap</code> function: </p>

<p><img src="https://i.stack.imgur.com/OwEKE.jpg" alt="enter image description here"></p>

<p>This has something to do with a <code>friend</code> function being called and <code>this</code> object being passed as a parameter.</p>

<hr>

<p>A way around this is to not use <code>friend</code> keyword and redefine the <code>swap</code> function:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(A&amp; other)</span> </span>{

    std::<span class="hljs-built_in">swap</span>(size, other.size);
    std::<span class="hljs-built_in">swap</span>(arr, other.arr);

}
</code></pre>

<p>This time, you can just call <code>swap</code> and pass in <code>other</code>, thus making the compiler happy:</p>

<p><img src="https://i.stack.imgur.com/7XdNa.jpg" alt="enter image description here"></p>

<hr>

<p>After all, you don't <em>need</em> to use a <code>friend</code> function to swap 2 objects. It makes just as much sense to make <code>swap</code> a member function that has one <code>other</code> object as a parameter.</p>

<p>You already have access to <code>this</code> object, so passing it in as a parameter is technically redundant. </p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/copy-and-swap">copy-and-swap</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.</p>

<p>For concreteness, let us consider a container <code>std::vector&lt;T, A&gt;</code>, where <code>A</code> is some stateful allocator type, and we'll compare the following functions:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fs</span><span class="hljs-params">(std::vector&lt;T, A&gt; &amp; a, std::vector&lt;T, A&gt; &amp; b)</span>
</span>{ 
    a.<span class="hljs-built_in">swap</span>(b);
    b.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// not important what you do with b</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fm</span><span class="hljs-params">(std::vector&lt;T, A&gt; &amp; a, std::vector&lt;T, A&gt; &amp; b)</span>
</span>{
    a = std::<span class="hljs-built_in">move</span>(b);
}
</code></pre>

<p>The purpose of both functions <code>fs</code> and <code>fm</code> is to give <code>a</code> the state that <code>b</code> had initially. However, there is a hidden question: What happens if <code>a.get_allocator() != b.get_allocator()</code>? The answer is: It depends. Let's write <code>AT = std::allocator_traits&lt;A&gt;</code>.</p>

<ul>
<li><p>If <code>AT::propagate_on_container_move_assignment</code> is <code>std::true_type</code>, then <code>fm</code> reassigns the allocator of <code>a</code> with the value of <code>b.get_allocator()</code>, otherwise it does not, and <code>a</code> continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of <code>a</code> and <code>b</code> is not compatible.</p></li>
<li><p>If <code>AT::propagate_on_container_swap</code> is <code>std::true_type</code>, then <code>fs</code> swaps both data and allocators in the expected fashion.</p></li>
<li><p>If <code>AT::propagate_on_container_swap</code> is <code>std::false_type</code>, then we need a dynamic check.</p>

<ul>
<li>If <code>a.get_allocator() == b.get_allocator()</code>, then the two containers use compatible storage, and swapping proceeds in the usual fashion.</li>
<li>However, if <code>a.get_allocator() != b.get_allocator()</code>, the program has <em>undefined behaviour</em> (cf. [container.requirements.general/8].</li>
</ul></li>
</ul>

<p>The upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That's a somewhat "advanced use case", but it's not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-pivot-a-dataframe-1657384433802">How can I pivot a dataframe?</a><a href="/questions/when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205">When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?</a><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/what-is-dependency-injection-1657387953056">What is dependency injection?</a><a href="/questions/how-do-we-control-web-page-caching-across-all-browsers-1657387529059">How do we control web page caching, across all browsers?</a><a href="/questions/how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855">How can I convert ereg expressions to preg in PHP?</a><a href="/questions/what-is-a-lambda-expression-in-c++11-1657387999252">What is a lambda expression in C++11?</a><a href="/questions/how-do-i-make-a-redirect-in-php-1657387381903">How do I make a redirect in PHP?</a><a href="/questions/which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105">Which equals operator (== vs ===) should be used in JavaScript comparisons?</a><a href="/questions/what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469">What is a debugger and how can it help me diagnose problems?</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/the-model-item-passed-into-the-dictionary-is-of-type-..-but-this-dictionary-requires-a-model-item-of-type-1657388480874">The model item passed into the dictionary is of type .. but this dictionary requires a model item of type</a><a href="/questions/what-does-a-%22cannot-find-symbol%22-or-%22cannot-resolve-symbol%22-error-mean-1657384492160">What does a &quot;Cannot find symbol&quot; or &quot;Cannot resolve symbol&quot; error mean?</a><a href="/questions/how-can-i-do-a-full-outer-join-in-mysql-1657388175444">How can I do a FULL OUTER JOIN in MySQL?</a><a href="/questions/how-do-i-correctly-clone-a-javascript-object-1657387325850">How do I correctly clone a JavaScript object?</a><a href="/questions/accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932">Accessing an array out of bounds gives no error, why?</a><a href="/questions/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379">How to print a number with commas as thousands separators in JavaScript</a><a href="/questions/how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445">How to join (merge) data frames (inner, outer, left, right)</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/why-do-i-get-a-segmentation-fault-when-writing-to-a-%22char-*s%22-initialized-with-a-string-literal-but-not-%22char-s%22-1657385511046">Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Overview\u0026lt;/h1\u0026gt;\n\u0026lt;h3\u0026gt;Why do we need the copy-and-swap idiom?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Any class that manages a resource (a \u0026lt;em\u0026gt;wrapper\u0026lt;/em\u0026gt;, like a smart pointer) needs to implement \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\u0026quot;\u0026gt;The Big Three\u0026lt;/a\u0026gt;. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;copy-and-swap idiom\u0026lt;/em\u0026gt; is the solution, and elegantly assists the assignment operator in achieving two things: avoiding \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;code duplication\u0026lt;/a\u0026gt;, and providing a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Exception_guarantees\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;strong exception guarantee\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;How does it work?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616\u0026quot;\u0026gt;Conceptually\u0026lt;/a\u0026gt;, it works by using the copy-constructor\u0026apos;s functionality to create a local copy of the data, then takes the copied data with a \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A swap function is a \u0026lt;em\u0026gt;non-throwing\u0026lt;/em\u0026gt; function that swaps two objects of a class, member for member. We might be tempted to use \u0026lt;code\u0026gt;std::swap\u0026lt;/code\u0026gt; instead of providing our own, but this would be impossible; \u0026lt;code\u0026gt;std::swap\u0026lt;/code\u0026gt; uses the copy-constructor and copy-assignment operator within its implementation, and we\u0026apos;d ultimately be trying to define the assignment operator in terms of itself!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Not only that, but unqualified calls to \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that \u0026lt;code\u0026gt;std::swap\u0026lt;/code\u0026gt; would entail.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;An in-depth explanation\u0026lt;/h1\u0026gt;\n\u0026lt;h3\u0026gt;The goal\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::copy\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;cstddef\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::size_t\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (default) constructor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mSize\u0026lt;/span\u0026gt;(size),\n          \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mArray\u0026lt;/span\u0026gt;(mSize ? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[mSize]() : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\n    {\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy-constructor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; dumb_array\u0026amp;amp; other)\n        : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mSize\u0026lt;/span\u0026gt;(other.mSize),\n          \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mArray\u0026lt;/span\u0026gt;(mSize ? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[mSize] : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note that this is non-throwing, because of the data\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// types being used; more attention to detail with regards\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// to exceptions must be given in a more general case, however\u0026lt;/span\u0026gt;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(other.mArray, other.mArray + mSize, mArray);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// destructor\u0026lt;/span\u0026gt;\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] mArray;\n    }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; mSize;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* mArray;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This class almost manages the array successfully, but it needs \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt; to work correctly.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;A failed solution\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s how a naive implementation might look:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the hard part\u0026lt;/span\u0026gt;\ndumb_array\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; dumb_array\u0026amp;amp; other)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; != \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get rid of the old data...\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] mArray; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (2)\u0026lt;/span\u0026gt;\n        mArray = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (2) *(see footnote for rationale)\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...and put in the new\u0026lt;/span\u0026gt;\n        mSize = other.mSize; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n        mArray = mSize ? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[mSize] : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(other.mArray, other.mArray + mSize, mArray); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And we say we\u0026apos;re finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as \u0026lt;code\u0026gt;(n)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The first is the self-assignment test.\u0026lt;br\u0026gt;\nThis check serves two purposes: it\u0026apos;s an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.\u0026lt;br\u0026gt;\nIt would be better if the operator could work properly without it.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The second is that it only provides a basic exception guarantee. If \u0026lt;code\u0026gt;new int[mSize]\u0026lt;/code\u0026gt; fails, \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt; will have been modified. (Namely, the size is wrong and the data is gone!)\u0026lt;br\u0026gt;\nFor a strong exception guarantee, it would need to be something akin to:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; dumb_array\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; dumb_array\u0026amp;amp; other)\n {\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; != \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1)\u0026lt;/span\u0026gt;\n     {\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get the new data ready before we replace the old\u0026lt;/span\u0026gt;\n         std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; newSize = other.mSize;\n         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* newArray = newSize ? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[newSize]() : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n         std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(other.mArray, other.mArray + newSize, newArray); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// replace the old data (all are non-throwing)\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; [] mArray;\n         mSize = newSize;\n         mArray = newArray;\n     }\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The code has expanded! Which leads us to the third problem: code duplication.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Our assignment operator effectively duplicates all the code we\u0026apos;ve already written elsewhere, and that\u0026apos;s a terrible thing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one?\u0026lt;br\u0026gt;\nWhile this may seem to be a valid concern, and indeed it requires non-trivial \u0026lt;code\u0026gt;try\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;catch\u0026lt;/code\u0026gt; clauses, this is a non-issue.\u0026lt;br\u0026gt;\nThat\u0026apos;s because a class should manage \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Single_responsibility_principle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;one resource only\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;!)\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;A successful solution\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called \u0026quot;The Big Three and A Half\u0026quot;: any time your class manages a resource it also makes sense to provide a \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We need to add swap functionality to our class, and we do that as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;friend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(dumb_array\u0026amp;amp; first, dumb_array\u0026amp;amp; second)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nothrow\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// enable ADL (not necessary in our case, but good practice)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; std::swap;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// by swapping the members of two objects,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the two objects are effectively swapped\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(first.mSize, second.mSize);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(first.mArray, second.mArray);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5695548/public-friend-swap-member-function\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt; is the explanation why \u0026lt;code\u0026gt;public friend swap\u0026lt;/code\u0026gt;.) Now not only can we swap our \u0026lt;code\u0026gt;dumb_array\u0026lt;/code\u0026gt;\u0026apos;s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Without further ado, our assignment operator is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;dumb_array\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(dumb_array other) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, other); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (2)\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And that\u0026apos;s it! With one fell swoop, all three problems are elegantly tackled at once.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Why does it work?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;We first notice an important choice: the parameter argument is taken \u0026lt;em\u0026gt;by-value\u0026lt;/em\u0026gt;. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;dumb_array\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; dumb_array\u0026amp;amp; other)\n{\n    dumb_array \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;temp\u0026lt;/span\u0026gt;(other);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, temp);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We lose an \u0026lt;a href=\u0026quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;important optimization opportunity\u0026lt;/a\u0026gt;. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you\u0026apos;re going to make a copy of something in a function, let the compiler do it in the parameter list.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won\u0026apos;t even enter the function if construction of the copy fails, and it\u0026apos;s therefore not possible to alter the state of \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt;. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;At this point we are home-free, because \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter\u0026apos;s scope ends and its destructor is called.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt;. (Additionally, we no longer have a performance penalty on non-self-assignments.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And that is the copy-and-swap idiom.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;What about C++11?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now \u0026lt;strong\u0026gt;The Rule of Four\u0026lt;/strong\u0026gt; (and a half). Why? Because not only do we need to be able to copy-construct our resource, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me\u0026quot;\u0026gt;we need to move-construct it as well\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Luckily for us, this is easy:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move constructor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;(dumb_array\u0026amp;amp;\u0026amp;amp; other) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;noexcept\u0026lt;/span\u0026gt; \n        : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dumb_array\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialize via default constructor, C++11 only\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, other);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What\u0026apos;s going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So what we\u0026apos;ve done is simple: initialize via the default constructor (a C++11 feature), then swap with \u0026lt;code\u0026gt;other\u0026lt;/code\u0026gt;; we know a default constructed instance of our class can safely be assigned and destructed, so we know \u0026lt;code\u0026gt;other\u0026lt;/code\u0026gt; will be able to do the same, after swapping.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Why does that work?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;dumb_array\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(dumb_array other); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, if \u0026lt;code\u0026gt;other\u0026lt;/code\u0026gt; is being initialized with an rvalue, \u0026lt;em\u0026gt;it will be move-constructed\u0026lt;/em\u0026gt;. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will \u0026lt;em\u0026gt;automatically\u0026lt;/em\u0026gt; pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And so concludes the copy-and-swap idiom.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Footnotes\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;*Why do we set \u0026lt;code\u0026gt;mArray\u0026lt;/code\u0026gt; to null? Because if any further code in the operator throws, the destructor of \u0026lt;code\u0026gt;dumb_array\u0026lt;/code\u0026gt; might be called; and if that happens without setting it to null, we attempt to delete memory that\u0026apos;s already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are other claims that we should specialize \u0026lt;code\u0026gt;std::swap\u0026lt;/code\u0026gt; for our type, provide an in-class \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; along-side a free-function \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt;, etc. But this is all unnecessary: any proper use of \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; will be through an unqualified call, and our function will be found through \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ADL\u0026lt;/a\u0026gt;. One function will do.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The move constructor should generally be \u0026lt;code\u0026gt;noexcept\u0026lt;/code\u0026gt;, otherwise some code (e.g. \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; resizing logic) will use the copy constructor even when a move would make sense. Of course, only mark it noexcept if the code inside doesn\u0026apos;t throw exceptions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Assignment, at its heart, is two steps: \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;tearing down the object\u0026apos;s old state\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;building its new state as a copy\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; of some other object\u0026apos;s state. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, that\u0026apos;s what the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;destructor\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; and the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;copy constructor\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; do, so the first idea would be to delegate the work to them. However, since destruction mustn\u0026apos;t fail, while construction might, \u0026lt;em\u0026gt;we actually want to do it the other way around\u0026lt;/em\u0026gt;: \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;first perform the constructive part\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; and, if that succeeded, \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;then do the destructive part\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. The copy-and-swap idiom is a way to do just that: It first calls a class\u0026apos; copy constructor to create a temporary object, then swaps its data with the temporary\u0026apos;s, and then lets the temporary\u0026apos;s destructor destroy the old state.\u0026lt;br\u0026gt;\nSince \u0026lt;code\u0026gt;swap()\u0026lt;/code\u0026gt; is supposed to never fail, the only part which might fail is the copy-construction. That is performed first, and if it fails, nothing will be changed in the targeted object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In its refined form, copy-and-swap is implemented by having the copy performed by initializing the (non-reference) parameter of the assignment operator: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(T tmp)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(tmp);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are some good answers already.  I\u0026apos;ll focus \u0026lt;em\u0026gt;mainly\u0026lt;/em\u0026gt; on what I think they lack - an explanation of the \u0026quot;cons\u0026quot; with the copy-and-swap idiom....\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What is the copy-and-swap idiom?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;A way of implementing the assignment operator in terms of a swap function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(X rhs)\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(rhs);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The fundamental idea is that:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;the most error-prone part of assigning to an object is ensuring any resources the new state needs are acquired (e.g. memory, descriptors)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;that acquisition can be attempted \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; modifying the current state of the object (i.e. \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt;) if a copy of the new value is made, which is why \u0026lt;code\u0026gt;rhs\u0026lt;/code\u0026gt; is accepted \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt; (i.e. copied) rather than \u0026lt;em\u0026gt;by reference\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;swapping the state of the local copy \u0026lt;code\u0026gt;rhs\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;usually\u0026lt;/em\u0026gt; relatively easy to do without potential failure/exceptions, given the local copy doesn\u0026apos;t need any particular state afterwards (just needs state fit for the destructor to run, much as for an object being \u0026lt;em\u0026gt;moved\u0026lt;/em\u0026gt; from in \u0026amp;gt;= C++11)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When should it be used?  (Which problems does it solve \u0026lt;strong\u0026gt;[/create]\u0026lt;/strong\u0026gt;?)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When you want the assigned-to objected unaffected by an assignment that throws an exception, assuming you have or can write a \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; with strong exception guarantee, and ideally one that can\u0026apos;t fail/\u0026lt;code\u0026gt;throw\u0026lt;/code\u0026gt;..\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When you want a clean, easy to understand, robust way to define the assignment operator in terms of (simpler) copy constructor, \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; and destructor functions.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Self-assignment done as a copy-and-swap avoids oft-overlooked edge cases.\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When any performance penalty or momentarily higher resource usage created by having an extra temporary object during the assignment is not important to your application. \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt; \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; throwing: it\u0026apos;s generally possible to reliably swap data members that the objects track by pointer, but non-pointer data members that don\u0026apos;t have a throw-free swap, or for which swapping has to be implemented as \u0026lt;code\u0026gt;X tmp = lhs; lhs = rhs; rhs = tmp;\u0026lt;/code\u0026gt; and copy-construction or assignment may throw, still have the potential to fail leaving some data members swapped and others not.  This potential applies even to C++03 \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;\u0026apos;s as James comments on another answer:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;@wilhelmtell: In C++03, there is no mention of exceptions potentially thrown by std::string::swap (which is called by std::swap). In C++0x, std::string::swap is noexcept and must not throw exceptions.  James McNellis Dec 22 \u0026apos;10 at 15:24 \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt; assignment operator implementation that seems sane when assigning from a distinct object can easily fail for self-assignment.  While it might seem unimaginable that client code would even attempt self-assignment, it can happen relatively easily during algo operations on containers, with \u0026lt;code\u0026gt;x = f(x);\u0026lt;/code\u0026gt; code where \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is (perhaps only for some \u0026lt;code\u0026gt;#ifdef\u0026lt;/code\u0026gt; branches) a macro ala \u0026lt;code\u0026gt;#define f(x) x\u0026lt;/code\u0026gt; or a function returning a reference to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, or even (likely inefficient but concise) code like \u0026lt;code\u0026gt;x = c1 ? x * 2 : c2 ? x / 2 : x;\u0026lt;/code\u0026gt;).  For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\n{\n    T* p_;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size_;\n    X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p_;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OUCH!\u0026lt;/span\u0026gt;\n        p_ = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T[size_ = rhs.size_];\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(p_, rhs.p_, rhs.p_ + rhs.size_);\n    }\n    ...\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;On self-assignment, the above code delete\u0026apos;s \u0026lt;code\u0026gt;x.p_;\u0026lt;/code\u0026gt;, points \u0026lt;code\u0026gt;p_\u0026lt;/code\u0026gt; at a newly allocated heap region, then attempts to read the \u0026lt;em\u0026gt;uninitialised\u0026lt;/em\u0026gt; data therein (Undefined Behaviour), if that doesn\u0026apos;t do anything too weird, \u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt; attempts a self-assignment to every just-destructed \u0026apos;T\u0026apos;!\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt; The copy-and-swap idiom can introduce inefficiencies or limitations due to the use of an extra temporary (when the operator\u0026apos;s parameter is copy-constructed):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Client\u0026lt;/span\u0026gt;\n{\n    IP_Address ip_address_;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; socket_;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs)\n      : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ip_address_\u0026lt;/span\u0026gt;(rhs.ip_address_), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;socket_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;connect\u0026lt;/span\u0026gt;(rhs.ip_address_))\n    { }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, a hand-written \u0026lt;code\u0026gt;Client::operator=\u0026lt;/code\u0026gt; might check if \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt; is already connected to the same server as \u0026lt;code\u0026gt;rhs\u0026lt;/code\u0026gt; (perhaps sending a \u0026quot;reset\u0026quot; code if useful), whereas the copy-and-swap approach would invoke the copy-constructor which would likely be written to open a distinct socket connection then close the original one.  Not only could that mean a remote network interaction instead of a simple in-process variable copy, it could run afoul of client or server limits on socket resources or connections.  (Of course this class has a pretty horrid interface, but that\u0026apos;s another matter ;-P).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This answer is more like an addition and a slight modification to the answers above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In some versions of Visual Studio (and possibly other compilers) there is a bug that is really annoying and doesn\u0026apos;t make sense. So if you declare/define your \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;friend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A\u0026amp;amp; first, A\u0026amp;amp; second)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(first.size, second.size);\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(first.arr, second.arr);\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;... the compiler will yell at you when you call the \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function: \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/OwEKE.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has something to do with a \u0026lt;code\u0026gt;friend\u0026lt;/code\u0026gt; function being called and \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; object being passed as a parameter.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;A way around this is to not use \u0026lt;code\u0026gt;friend\u0026lt;/code\u0026gt; keyword and redefine the \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A\u0026amp;amp; other)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(size, other.size);\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(arr, other.arr);\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This time, you can just call \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; and pass in \u0026lt;code\u0026gt;other\u0026lt;/code\u0026gt;, thus making the compiler happy:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/7XdNa.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;After all, you don\u0026apos;t \u0026lt;em\u0026gt;need\u0026lt;/em\u0026gt; to use a \u0026lt;code\u0026gt;friend\u0026lt;/code\u0026gt; function to swap 2 objects. It makes just as much sense to make \u0026lt;code\u0026gt;swap\u0026lt;/code\u0026gt; a member function that has one \u0026lt;code\u0026gt;other\u0026lt;/code\u0026gt; object as a parameter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You already have access to \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; object, so passing it in as a parameter is technically redundant. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to add a word of warning when you are dealing with C++11-style allocator-aware containers. Swapping and assignment have subtly different semantics.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For concreteness, let us consider a container \u0026lt;code\u0026gt;std::vector\u0026amp;lt;T, A\u0026amp;gt;\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is some stateful allocator type, and we\u0026apos;ll compare the following functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fs\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;T, A\u0026amp;gt; \u0026amp;amp; a, std::vector\u0026amp;lt;T, A\u0026amp;gt; \u0026amp;amp; b)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{ \n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(b);\n    b.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not important what you do with b\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fm\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;T, A\u0026amp;gt; \u0026amp;amp; a, std::vector\u0026amp;lt;T, A\u0026amp;gt; \u0026amp;amp; b)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    a = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(b);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The purpose of both functions \u0026lt;code\u0026gt;fs\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;fm\u0026lt;/code\u0026gt; is to give \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; the state that \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; had initially. However, there is a hidden question: What happens if \u0026lt;code\u0026gt;a.get_allocator() != b.get_allocator()\u0026lt;/code\u0026gt;? The answer is: It depends. Let\u0026apos;s write \u0026lt;code\u0026gt;AT = std::allocator_traits\u0026amp;lt;A\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;AT::propagate_on_container_move_assignment\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;std::true_type\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;fm\u0026lt;/code\u0026gt; reassigns the allocator of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; with the value of \u0026lt;code\u0026gt;b.get_allocator()\u0026lt;/code\u0026gt;, otherwise it does not, and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; continues to use its original allocator. In that case, the data elements need to be swapped individually, since the storage of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is not compatible.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;AT::propagate_on_container_swap\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;std::true_type\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;fs\u0026lt;/code\u0026gt; swaps both data and allocators in the expected fashion.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;AT::propagate_on_container_swap\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;std::false_type\u0026lt;/code\u0026gt;, then we need a dynamic check.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;a.get_allocator() == b.get_allocator()\u0026lt;/code\u0026gt;, then the two containers use compatible storage, and swapping proceeds in the usual fashion.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;However, if \u0026lt;code\u0026gt;a.get_allocator() != b.get_allocator()\u0026lt;/code\u0026gt;, the program has \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; (cf. [container.requirements.general/8].\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The upshot is that swapping has become a non-trivial operation in C++11 as soon as your container starts supporting stateful allocators. That\u0026apos;s a somewhat \u0026quot;advanced use case\u0026quot;, but it\u0026apos;s not entirely unlikely, since move optimizations usually only become interesting once your class manages a resource, and memory is one of the most popular resources.\u0026lt;/p\u0026gt;\n    "],"id":167,"title":"What is the copy-and-swap idiom?","content":"\n                \n\u0026lt;p\u0026gt;What is the copy-and-swap idiom and when should it be used? What problems does it solve? Does it change for C++11?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Related:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/276173/what-are-your-favorite-c-coding-style-idioms/2034447#2034447\u0026quot;\u0026gt;What are your favorite C++ Coding Style idioms:  Copy-swap\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1734628/copy-constructor-and-operator-overload-in-c-is-a-common-function-possible/1734640#1734640\u0026quot;\u0026gt;Copy constructor and = operator overload in C++: is a common function possible?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2143787/what-is-copy-elision-and-how-it-optimizes-copy-and-swap-idiom\u0026quot;\u0026gt;What is copy elision and how it optimizes copy-and-swap idiom\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/255612/c-dynamically-allocating-an-array-of-objects/255744#255744\u0026quot;\u0026gt;C++: dynamically allocating an array of objects?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-is-the-copy-and-swap-idiom-1657384840329","postType":"QUESTION","createdAt":"2022-07-09T16:40:40.000Z","updatedAt":"2022-07-09T16:40:40.000Z","tags":[{"id":615,"name":"copy-and-swap","slug":"copy-and-swap","createdAt":"2022-07-09T16:40:40.000Z","updatedAt":"2022-07-09T16:40:40.000Z","Questions_Tags":{"questionId":167,"tagId":615}}],"relatedQuestions":[{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329","tags":[{"name":"copy-and-swap","Questions_Tags":{"questionId":167,"tagId":615}}]}]},"randomQuestions":[{"title":"How can I pivot a dataframe?","slug":"how-can-i-pivot-a-dataframe-1657384433802"},{"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"},{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"},{"title":"How do we control web page caching, across all browsers?","slug":"how-do-we-control-web-page-caching-across-all-browsers-1657387529059"},{"title":"How can I convert ereg expressions to preg in PHP?","slug":"how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How do I make a redirect in PHP?","slug":"how-do-i-make-a-redirect-in-php-1657387381903"},{"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"},{"title":"What is a debugger and how can it help me diagnose problems?","slug":"what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"The model item passed into the dictionary is of type .. but this dictionary requires a model item of type","slug":"the-model-item-passed-into-the-dictionary-is-of-type-..-but-this-dictionary-requires-a-model-item-of-type-1657388480874"},{"title":"What does a \"Cannot find symbol\" or \"Cannot resolve symbol\" error mean?","slug":"what-does-a-\"cannot-find-symbol\"-or-\"cannot-resolve-symbol\"-error-mean-1657384492160"},{"title":"How can I do a FULL OUTER JOIN in MySQL?","slug":"how-can-i-do-a-full-outer-join-in-mysql-1657388175444"},{"title":"How do I correctly clone a JavaScript object?","slug":"how-do-i-correctly-clone-a-javascript-object-1657387325850"},{"title":"Accessing an array out of bounds gives no error, why?","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"},{"title":"How to print a number with commas as thousands separators in JavaScript","slug":"how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379"},{"title":"How to join (merge) data frames (inner, outer, left, right)","slug":"how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"Why do I get a segmentation fault when writing to a \"char *s\" initialized with a string literal, but not \"char s[]\"?","slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-copy-and-swap-idiom-1657384840329"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>