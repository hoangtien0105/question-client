<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Iterator invalidation rules for C++ containers | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

What are the iterator invalidation rules for C++ containers?

(Note: This Q&amp;A is an entry in Stack Overflow&#x27;s C++ FAQ. Meta-discussion about the question itself should be posted on the Meta question that started all of this, not here.)

    "/><meta property="og:title" content="Iterator invalidation rules for C++ containers | Solutions Checker"/><meta property="og:description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

What are the iterator invalidation rules for C++ containers?

(Note: This Q&amp;A is an entry in Stack Overflow&#x27;s C++ FAQ. Meta-discussion about the question itself should be posted on the Meta question that started all of this, not here.)

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Iterator invalidation rules for C++ containers","text":"\n            \n        \n            \n                    \n                        \n                    \n                \n                    \n                        This question&apos;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \n                \n            \n        \n\n\n    \n\nWhat are the iterator invalidation rules for C++ containers?\n\n(Note: This Q&amp;A is an entry in Stack Overflow&apos;s C++ FAQ. Meta-discussion about the question itself should be posted on the Meta question that started all of this, not here.)\n\n    ","answerCount":6,"upVoteCount":500,"suggestedAnswer":[{"text":"C++03 (Source: Iterator Invalidation Rules (C++03))\n\n\n\nInsertion\n\nSequence containers\n\n\nvector: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.2.4.3/1]\ndeque: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.2.1.3/1]\nlist: all iterators and references unaffected [23.2.2.3/1]\n\n\nAssociative containers\n\n\n[multi]{set,map}: all iterators and references unaffected [23.1.2/8]\n\n\nContainer adaptors\n\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\n\n\nErasure\n\nSequence containers\n\n\nvector: every iterator and reference after the point of erase is invalidated [23.2.4.3/3]\ndeque: all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated) [23.2.1.3/4]\nlist: only the iterators and references to the erased element is invalidated [23.2.2.3/3]\n\n\nAssociative containers\n\n\n[multi]{set,map}: only iterators and references to the erased elements are invalidated [23.1.2/8]\n\n\nContainer adaptors\n\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\n\n\nResizing\n\n\nvector: as per insert/erase [23.2.4.2/6]\ndeque: as per insert/erase [23.2.1.2/1]\nlist: as per insert/erase [23.2.2.2/1]\n\n\n\n\nNote 1\n\n\n  Unless otherwise specified (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to a\n  library function shall not invalidate\n  iterators to, or change the values of,\n  objects within that container.\n  [23.1/11]\n\n\nNote 2\n\nIt&apos;s not clear in C++2003 whether &quot;end&quot; iterators are subject to the above rules; you should assume, anyway, that they are (as this is the case in practice).\n\nNote 3\n\nThe rules for invalidation of pointers are the sames as the rules for invalidation of references.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"C++11 (Source: Iterator Invalidation Rules (C++0x))\n\n\n\nInsertion\n\nSequence containers\n\n\nvector: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.3.6.5/1]\ndeque: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.3.3.4/1]\nlist: all iterators and references unaffected [23.3.5.4/1]\nforward_list: all iterators and references unaffected (applies to insert_after) [23.3.4.5/1]\narray: (n/a)\n\n\nAssociative containers\n\n\n[multi]{set,map}: all iterators and references unaffected [23.2.4/9]\n\n\nUnsorted associative containers\n\n\nunordered_[multi]{set,map}: all iterators invalidated when rehashing occurs, but references unaffected [23.2.5/8]. Rehashing does not occur if the insertion does not cause the container&apos;s size to exceed z * B where z is the maximum load factor and B the current number of buckets. [23.2.5/14]\n\n\nContainer adaptors\n\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\n\n\nErasure\n\nSequence containers\n\n\nvector: every iterator and reference at or after the point of erase is invalidated [23.3.6.5/3]\ndeque: erasing the last element invalidates only iterators and references to the erased elements and the past-the-end iterator; erasing the first element invalidates only iterators and references to the erased elements; erasing any other elements invalidates all iterators and references (including the past-the-end iterator) [23.3.3.4/4]\nlist: only the iterators and references to the erased element is invalidated [23.3.5.4/3]\nforward_list: only the iterators and references to the erased element is invalidated (applies to erase_after) [23.3.4.5/1]\narray: (n/a)\n\n\nAssociative containers\n\n\n[multi]{set,map}: only iterators and references to the erased elements are invalidated [23.2.4/9]\n\n\nUnordered associative containers\n\n\nunordered_[multi]{set,map}: only iterators and references to the erased elements are invalidated [23.2.5/13]\n\n\nContainer adaptors\n\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\n\n\nResizing\n\n\nvector: as per insert/erase [23.3.6.5/12]\ndeque: as per insert/erase [23.3.3.3/3]\nlist: as per insert/erase [23.3.5.3/1]\nforward_list: as per insert/erase [23.3.4.5/25]\narray: (n/a)\n\n\n\n\nNote 1\n\n\n  Unless otherwise specified (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to a\n  library function shall not invalidate\n  iterators to, or change the values of,\n  objects within that container.\n  [23.2.1/11]\n\n\nNote 2\n\n\n  no swap() function invalidates any\n  references, pointers, or iterators\n  referring to the elements of the\n  containers being swapped. [ Note: The\n  end() iterator does not refer to any\n  element, so it may be invalidated.\n  end note ] [23.2.1/10]\n\n\nNote 3\n\nOther than the above caveat regarding swap(), it&apos;s not clear whether &quot;end&quot; iterators are subject to the above listed per-container rules; you should assume, anyway, that they are.\n\nNote 4\n\nvector and all unordered associative containers support reserve(n) which guarantees that no automatic resizing will occur at least until the size of the container grows to n. Caution should be taken with unordered associative containers because a future proposal will allow the specification of a minimum load factor, which would allow rehashing to occur on insert after enough erase operations reduce the container size below the minimum; the guarantee should be considered potentially void after an erase.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"C++17 (All references are from the final working draft of CPP17 - n4659)\n\nInsertion\nSequence Containers\n\nvector:  The functions insert, emplace_back, emplace, push_back cause reallocation if the new size is greater than the old capacity. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. If no reallocation\nhappens, all the iterators and references before the insertion point remain valid. [26.3.11.5/1]\nWith respect to the reserve function, reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. No reallocation shall take place during insertions that happen after a call to reserve() until the time when an insertion would make the size of the vector greater than the value of capacity(). [26.3.11.3/6]\n\ndeque: An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has no effect on the validity of references to elements of the deque. [26.3.8.4/1]\n\nlist: Does not affect the validity of iterators and references. If an exception is thrown there are no effects. [26.3.10.4/1].\nThe insert, emplace_front, emplace_back, emplace, push_front, push_back functions are covered under this rule.\n\nforward_list: None of the overloads of insert_after shall affect the validity of iterators and references [26.3.9.5/1]\n\narray: As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.\n\n\nAssociative Containers\n\nAll Associative Containers: The insert and emplace members shall not affect the validity of iterators and references to the container [26.2.6/9]\n\nUnordered Associative Containers\n\nAll Unordered Associative Containers: Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. [26.2.7/9]\nThe insert and emplace members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. [26.2.7/14]\nThe insert and emplace members shall not affect the validity of iterators if (N+n) &lt;= z * B, where N is the number of elements in the container prior to the insert operation, n is the number of elements inserted, B is the containers bucket count, and z is the containers maximum load factor. [26.2.7/15]\n\nAll Unordered Associative Containers: In case of a merge operation  (e.g., a.merge(a2)), iterators referring to the transferred elements and all iterators referring to a will be invalidated, but iterators to elements remaining in a2 will remain valid. (Table 91  Unordered associative container requirements)\n\n\nContainer Adaptors\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\nErasure\nSequence Containers\n\nvector: The functions erase and pop_back invalidate iterators and references at or after the point of the erase. [26.3.11.5/3]\n\ndeque: An erase operation that erases the last element of a deque invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a deque but not the last element invalidates only iterators and references to the erased elements. An erase operation that erases neither the first element nor the last element of a deque invalidates the past-the-end iterator and all iterators and references to all the elements of the deque.\n[ Note: pop_front and pop_back are erase operations. end note ] [26.3.8.4/4]\n\nlist: Invalidates only the iterators and references to the erased elements. [26.3.10.4/3]. This applies to erase, pop_front, pop_back, clear functions.\nremove and remove_if member functions: Erases all the elements in the list referred by a list iterator i for which the following conditions hold: *i == value, pred(*i) != false. Invalidates only the iterators and references to the erased elements [26.3.10.5/15].\nunique member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1, last) for which *i == *(i-1) (for the version of unique with no arguments) or pred(*i, *(i - 1)) (for the version of unique with a predicate argument) holds. Invalidates only the iterators and references to the erased elements. [26.3.10.5/19]\n\nforward_list: erase_after shall invalidate only iterators and references to the erased elements. [26.3.9.5/1].\nremove and remove_if member functions - Erases all the elements in the list referred by a list iterator i for which the following conditions hold: *i == value (for remove()), pred(*i) is true (for remove_if()). Invalidates only the iterators and references to the erased elements. [26.3.9.6/12].\nunique member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1, last) for which *i == *(i-1) (for the version with no arguments) or pred(*i, *(i - 1)) (for the version with a predicate argument) holds. Invalidates only the iterators and references to the erased elements.  [26.3.9.6/16]\n\nAll Sequence Containers: clear invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator (Table 87  Sequence container requirements). But for forward_list, clear does not invalidate past-the-end iterators. [26.3.9.5/32]\n\nAll Sequence Containers: assign invalidates all references, pointers and\niterators referring to the elements of the container. For vector and deque, also invalidates the past-the-end iterator. (Table 87  Sequence container requirements)\n\n\nAssociative Containers\n\nAll Associative Containers: The erase members shall invalidate only iterators and references to the erased elements [26.2.6/9]\n\nAll Associative Containers: The extract members invalidate only iterators to the removed element; pointers and references to the removed element remain valid [26.2.6/10]\n\n\nContainer Adaptors\n\nstack: inherited from underlying container\nqueue: inherited from underlying container\npriority_queue: inherited from underlying container\n\n\nGeneral container requirements relating to iterator invalidation:\n\nUnless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [26.2.1/12]\n\nno swap() function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. end note ] [26.2.1/(11.6)]\n\n\nAs examples of the above requirements:\n\ntransform algorithm: The op and binary_op functions shall not invalidate iterators or subranges, or modify elements in the ranges [28.6.4/1]\n\naccumulate algorithm: In the range [first, last], binary_op shall neither modify elements nor invalidate iterators or subranges [29.8.2/1]\n\nreduce algorithm: binary_op shall neither invalidate iterators or subranges, nor modify elements in the range [first, last]. [29.8.3/5]\n\n\nand so on...\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"It is probably worth adding that an insert iterator of any kind (std::back_insert_iterator, std::front_insert_iterator, std::insert_iterator) is guaranteed to remain valid as long as all insertions are performed through this iterator and no other independent iterator-invalidating event occurs.\n\nFor example, when you are performing a series of insertion operations into a std::vector by using std::insert_iterator it is quite possible that these insertions will trigger vector reallocation, which will invalidate all iterators that &quot;point&quot; into that vector. However, the insert iterator in question is guaranteed to remain valid, i.e. you can safely continue the sequence of insertions. There&apos;s no need to worry about triggering vector reallocation at all.\n\nThis, again, applies only to insertions performed through the insert iterator itself. If iterator-invalidating event is triggered by some independent action on the container, then the insert iterator becomes invalidated as well in accordance with the general rules.\n\nFor example, this code\n\nstd::vector&lt;int&gt; v(10);\nstd::vector&lt;int&gt;::iterator it = v.begin() + 5;\nstd::insert_iterator&lt;std::vector&lt;int&gt; &gt; it_ins(v, it);\n\nfor (unsigned n = 20; n &gt; 0; --n)\n  *it_ins++ = rand();\n\n\nis guaranteed to perform a valid sequence of insertions into the vector, even if the vector &quot;decides&quot; to reallocate somewhere in the middle of this process. Iterator it will obviously become invalid, but it_ins will continue to remain valid.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Since this question draws so many votes and kind of becomes an FAQ, I guess it would be better to write a separate answer to mention one significant difference between C++03 and C++11 regarding the impact of std::vector&apos;s insertion operation on the validity of iterators and references with respect to reserve() and capacity(), which the most upvoted answer failed to notice.\n\nC++ 03:\n\n\n  Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector greater than the size specified in the most recent call to\n  reserve().\n\n\nC++11:\n\n\n  Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector greater than the value of capacity().\n\n\nSo in C++03, it is not &quot;unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated)&quot; as mentioned in the other answer, instead, it should be &quot;greater than the size specified in the most recent call to reserve()&quot;. This is one thing that C++03 differs from C++11. In C++03, once an insert() causes the size of the vector to reach the value specified in the previous reserve() call (which could well be smaller than the current capacity() since a reserve() could result a bigger capacity() than asked for), any subsequent insert() could cause reallocation and invalidate all the iterators and references. In C++11, this won&apos;t happen and you can always trust capacity() to know with certainty that the next reallocation won&apos;t take place before the size overpasses capacity().\n\nIn conclusion, if you are working with a C++03 vector and you want to make sure a reallocation won&apos;t happen when you perform insertion, it&apos;s the value of the argument you previously passed to reserve() that you should check the size against, not the return value of a call to capacity(), otherwise you may get yourself surprised at a &quot;premature&quot; reallocation.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Here is a nice summary table from cppreference.com:\n\n\n\nHere, insertion refers to any method which adds one or more elements to the container and erasure refers to any method which removes one or more elements from the container.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/iterator-invalidation-rules-for-c++-containers-1657387561090#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/iterator-invalidation-rules-for-c++-containers-1657387561090"><h1>Iterator invalidation rules for C++ containers</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>This question's answers are a <a href="/help/privileges/edit-community-wiki">community effort</a></b>. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>What are the iterator invalidation rules for C++ containers?</p>
<sub>
(<strong>Note:</strong> This Q&amp;A is an entry in <a href="https://stackoverflow.com/questions/tagged/c++-faq">Stack Overflow's C++ FAQ</a>. Meta-discussion about the question itself should be posted on <a href="https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag">the Meta question that started all of this</a>, not here.)
</sub>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C++03</strong> (Source: <a href="http://kera.name/articles/2011/06/iterator-invalidation-rules/" rel="noreferrer">Iterator Invalidation Rules (C++03)</a>)</p>

<hr>

<h1>Insertion</h1>

<p><em>Sequence containers</em></p>

<ul>
<li><code>vector</code>: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.2.4.3/1]</li>
<li><code>deque</code>: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.2.1.3/1]</li>
<li><code>list</code>: all iterators and references unaffected [23.2.2.3/1]</li>
</ul>

<p><em>Associative containers</em></p>

<ul>
<li><code>[multi]{set,map}</code>: all iterators and references unaffected [23.1.2/8]</li>
</ul>

<p><em>Container adaptors</em></p>

<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>

<hr>

<h1>Erasure</h1>

<p><em>Sequence containers</em></p>

<ul>
<li><code>vector</code>: every iterator and reference after the point of erase is invalidated [23.2.4.3/3]</li>
<li><code>deque</code>: all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated) [23.2.1.3/4]</li>
<li><code>list</code>: only the iterators and references to the erased element is invalidated [23.2.2.3/3]</li>
</ul>

<p><em>Associative containers</em></p>

<ul>
<li><code>[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.1.2/8]</li>
</ul>

<p><em>Container adaptors</em></p>

<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>

<hr>

<h1>Resizing</h1>

<ul>
<li><code>vector</code>: as per insert/erase [23.2.4.2/6]</li>
<li><code>deque</code>: as per insert/erase [23.2.1.2/1]</li>
<li><code>list</code>: as per insert/erase [23.2.2.2/1]</li>
</ul>

<hr>

<h2>Note 1</h2>

<blockquote>
  <p><strong>Unless otherwise specified</strong> (either
  explicitly or by defining a function
  in terms of other functions), invoking
  a container member function or passing
  a container as an argument to <strong>a
  library function shall not invalidate
  iterators</strong> to, or change the values of,
  objects within that container.
  [23.1/11]</p>
</blockquote>

<h2>Note 2</h2>

<p><a href="https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules">It's not clear in C++2003 whether "end" iterators are subject to the above rules</a>; you should assume, anyway, that they are (as this is the case in practice).</p>

<h2>Note 3</h2>

<p>The rules for invalidation of pointers are the sames as the rules for invalidation of references.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C++11</strong> (Source: <a href="http://kera.name/articles/2011/06/iterator-invalidation-rules-c0x/" rel="noreferrer">Iterator Invalidation Rules (C++0x)</a>)</p>

<hr>

<h1>Insertion</h1>

<p><em>Sequence containers</em></p>

<ul>
<li><code>vector</code>: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.3.6.5/1]</li>
<li><code>deque</code>: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.3.3.4/1]</li>
<li><code>list</code>: all iterators and references unaffected [23.3.5.4/1]</li>
<li><code>forward_list</code>: all iterators and references unaffected <em>(applies to <code>insert_after</code>)</em> [23.3.4.5/1]</li>
<li><code>array</code>: <em>(n/a)</em></li>
</ul>

<p><em>Associative containers</em></p>

<ul>
<li><code>[multi]{set,map}</code>: all iterators and references unaffected [23.2.4/9]</li>
</ul>

<p><em>Unsorted associative containers</em></p>

<ul>
<li><code>unordered_[multi]{set,map}</code>: all iterators invalidated when rehashing occurs, but references unaffected [23.2.5/8]. Rehashing does not occur if the insertion does not cause the container's size to exceed <code>z * B</code> where <code>z</code> is the maximum load factor and <code>B</code> the current number of buckets. [23.2.5/14]</li>
</ul>

<p><em>Container adaptors</em></p>

<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>

<hr>

<h1>Erasure</h1>

<p><em>Sequence containers</em></p>

<ul>
<li><code>vector</code>: every iterator and reference at or after the point of erase is invalidated [23.3.6.5/3]</li>
<li><code>deque</code>: erasing the last element invalidates only iterators and references to the erased elements and the past-the-end iterator; erasing the first element invalidates only iterators and references to the erased elements; erasing any other elements invalidates all iterators and references (including the past-the-end iterator) [23.3.3.4/4]</li>
<li><code>list</code>: only the iterators and references to the erased element is invalidated [23.3.5.4/3]</li>
<li><code>forward_list</code>: only the iterators and references to the erased element is invalidated <em>(applies to <code>erase_after</code>)</em> [23.3.4.5/1]</li>
<li><code>array</code>: <em>(n/a)</em></li>
</ul>

<p><em>Associative containers</em></p>

<ul>
<li><code>[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.2.4/9]</li>
</ul>

<p><em>Unordered associative containers</em></p>

<ul>
<li><code>unordered_[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.2.5/13]</li>
</ul>

<p><em>Container adaptors</em></p>

<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>

<hr>

<h1>Resizing</h1>

<ul>
<li><code>vector</code>: as per insert/erase [23.3.6.5/12]</li>
<li><code>deque</code>: as per insert/erase [23.3.3.3/3]</li>
<li><code>list</code>: as per insert/erase [23.3.5.3/1]</li>
<li><code>forward_list</code>: as per insert/erase [23.3.4.5/25]</li>
<li><code>array</code>: (n/a)</li>
</ul>

<hr>

<h2>Note 1</h2>

<blockquote>
  <p><strong>Unless otherwise specified</strong> (either
  explicitly or by defining a function
  in terms of other functions), invoking
  a container member function or passing
  a container as an argument to <strong>a
  library function shall not invalidate
  iterators</strong> to, or change the values of,
  objects within that container.
  [23.2.1/11]</p>
</blockquote>

<h2>Note 2</h2>

<blockquote>
  <p><strong>no swap() function invalidates any
  references, pointers, or iterators</strong>
  referring to the elements of the
  containers being swapped. [ Note: <strong>The
  end() iterator</strong> does not refer to any
  element, so it <strong>may be invalidated</strong>.
  end note ] [23.2.1/10]</p>
</blockquote>

<h2>Note 3</h2>

<p>Other than the above caveat regarding <code>swap()</code>, <a href="https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules">it's not clear whether "end" iterators are subject to the above listed per-container rules</a>; you should assume, anyway, that they are.</p>

<h2>Note 4</h2>

<p><code>vector</code> and all <em>unordered associative containers</em> support <code>reserve(n)</code> which guarantees that no automatic resizing will occur at least until the size of the container grows to <code>n</code>. Caution should be taken with <em>unordered associative containers</em> because a future proposal will allow the specification of a minimum load factor, which would allow rehashing to occur on <code>insert</code> after enough <code>erase</code> operations reduce the container size below the minimum; the guarantee should be considered potentially void after an <code>erase</code>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C++17</strong> (All references are from the final working draft of CPP17 - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf" rel="noreferrer">n4659</a>)</p>
<hr>
<h1>Insertion</h1>
<p><em>Sequence Containers</em></p>
<ul>
<li><p><code>vector</code>:  The functions <code>insert</code>, <code>emplace_back</code>, <code>emplace</code>, <code>push_back</code> cause reallocation if the new size is greater than the old capacity. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. If no reallocation
happens, all the iterators and references before the insertion point remain valid. [26.3.11.5/1]<br>
With respect to the <code>reserve</code> function, reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. No reallocation shall take place during insertions that happen after a call to <code>reserve()</code> until the time when an insertion would make the size of the vector greater than the value of <code>capacity()</code>. [26.3.11.3/6]</p>
</li>
<li><p><code>deque</code>: An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has no effect on the validity of references to elements of the deque. [26.3.8.4/1]</p>
</li>
<li><p><code>list</code>: Does not affect the validity of iterators and references. If an exception is thrown there are no effects. [26.3.10.4/1].<br>
The <code>insert</code>, <code>emplace_front</code>, <code>emplace_back</code>, <code>emplace</code>, <code>push_front</code>, <code>push_back</code> functions are covered under this rule.</p>
</li>
<li><p><code>forward_list</code>: None of the overloads of <code>insert_after</code> shall affect the validity of iterators and references [26.3.9.5/1]</p>
</li>
<li><p><code>array</code>: <a href="https://en.cppreference.com/w/cpp/container/array#Iterator_invalidation" rel="noreferrer">As a rule</a>, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.</p>
</li>
</ul>
<p><em>Associative Containers</em></p>
<ul>
<li><code>All Associative Containers</code>: The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators and references to the container [26.2.6/9]</li>
</ul>
<p><em>Unordered Associative Containers</em></p>
<ul>
<li><p><code>All Unordered Associative Containers</code>: Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. [26.2.7/9]<br>
The <code>insert</code> and <code>emplace</code> members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. [26.2.7/14]<br>
The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators if <code>(N+n) &lt;= z * B</code>, where <code>N</code> is the number of elements in the container prior to the insert operation, <code>n</code> is the number of elements inserted, <code>B</code> is the containers bucket count, and <code>z</code> is the containers maximum load factor. [26.2.7/15]</p>
</li>
<li><p><code>All Unordered Associative Containers</code>: In case of a merge operation  (e.g., <code>a.merge(a2)</code>), iterators referring to the transferred elements and all iterators referring to <code>a</code> will be invalidated, but iterators to elements remaining in <code>a2</code> will remain valid. (Table 91  Unordered associative container requirements)</p>
</li>
</ul>
<p><em>Container Adaptors</em></p>
<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>
<hr>
<h1>Erasure</h1>
<p><em>Sequence Containers</em></p>
<ul>
<li><p><code>vector</code>: The functions <code>erase</code> and <code>pop_back</code> invalidate iterators and references at or after the point of the erase. [26.3.11.5/3]</p>
</li>
<li><p><code>deque</code>: An erase operation that erases the last element of a <code>deque</code> invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a <code>deque</code> but not the last element invalidates only iterators and references to the erased elements. An erase operation that erases neither the first element nor the last element of a <code>deque</code> invalidates the past-the-end iterator and all iterators and references to all the elements of the <code>deque</code>.
[ Note: <code>pop_front</code> and <code>pop_back</code> are erase operations. end note ] [26.3.8.4/4]</p>
</li>
<li><p><code>list</code>: Invalidates only the iterators and references to the erased elements. [26.3.10.4/3]. This applies to <code>erase</code>, <code>pop_front</code>, <code>pop_back</code>, <code>clear</code> functions.<br>
<code>remove</code> and <code>remove_if</code> member functions: Erases all the elements in the list referred by a list iterator <code>i</code> for which the following conditions hold: <code>*i == value</code>, <code>pred(*i) != false</code>. Invalidates only the iterators and references to the erased elements [26.3.10.5/15].<br>
<code>unique</code> member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator <code>i</code> in the range <code>[first + 1, last)</code> for which <code>*i == *(i-1)</code> (for the version of unique with no arguments) or <code>pred(*i, *(i - 1))</code> (for the version of unique with a predicate argument) holds. Invalidates only the iterators and references to the erased elements. [26.3.10.5/19]</p>
</li>
<li><p><code>forward_list</code>: <code>erase_after</code> shall invalidate only iterators and references to the erased elements. [26.3.9.5/1].<br>
<code>remove</code> and <code>remove_if</code> member functions - Erases all the elements in the list referred by a list iterator i for which the following conditions hold: <code>*i == value</code> (for <code>remove()</code>), <code>pred(*i)</code> is true (for <code>remove_if()</code>). Invalidates only the iterators and references to the erased elements. [26.3.9.6/12].<br>
<code>unique</code> member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1, last) for which <code>*i == *(i-1)</code> (for the version with no arguments) or <code>pred(*i, *(i - 1))</code> (for the version with a predicate argument) holds. Invalidates only the iterators and references to the erased elements.  [26.3.9.6/16]</p>
</li>
<li><p><code>All Sequence Containers</code>: <code>clear</code> invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator (Table 87  Sequence container requirements). But for <code>forward_list</code>, <code>clear</code> does not invalidate past-the-end iterators. [26.3.9.5/32]</p>
</li>
<li><p><code>All Sequence Containers</code>: <code>assign</code> invalidates all references, pointers and
iterators referring to the elements of the container. For <code>vector</code> and <code>deque</code>, also invalidates the past-the-end iterator. (Table 87  Sequence container requirements)</p>
</li>
</ul>
<p><em>Associative Containers</em></p>
<ul>
<li><p><code>All Associative Containers</code>: The <code>erase</code> members shall invalidate only iterators and references to the erased elements [26.2.6/9]</p>
</li>
<li><p><code>All Associative Containers</code>: The <code>extract</code> members invalidate only iterators to the removed element; pointers and references to the removed element remain valid [26.2.6/10]</p>
</li>
</ul>
<p><em>Container Adaptors</em></p>
<ul>
<li><code>stack</code>: inherited from underlying container</li>
<li><code>queue</code>: inherited from underlying container</li>
<li><code>priority_queue</code>: inherited from underlying container</li>
</ul>
<hr>
<p><strong>General container requirements relating to iterator invalidation:</strong></p>
<ul>
<li><p>Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [26.2.1/12]</p>
</li>
<li><p>no <code>swap()</code> function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. end note ] [26.2.1/(11.6)]</p>
</li>
</ul>
<p><em>As examples of the above requirements:</em></p>
<ul>
<li><p><code>transform</code> algorithm: The <code>op</code> and <code>binary_op</code> functions shall not invalidate iterators or subranges, or modify elements in the ranges [28.6.4/1]</p>
</li>
<li><p><code>accumulate</code> algorithm: In the range [first, last], <code>binary_op</code> shall neither modify elements nor invalidate iterators or subranges [29.8.2/1]</p>
</li>
<li><p><code>reduce</code> algorithm: binary_op shall neither invalidate iterators or subranges, nor modify elements in the range [first, last]. [29.8.3/5]</p>
</li>
</ul>
<p>and so on...</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is probably worth adding that an insert iterator of any kind (<code>std::back_insert_iterator</code>, <code>std::front_insert_iterator</code>, <code>std::insert_iterator</code>) is guaranteed to remain valid as long as all insertions are performed through this iterator and no other independent iterator-invalidating event occurs.</p>

<p>For example, when you are performing a series of insertion operations into a <code>std::vector</code> by using <code>std::insert_iterator</code> it is quite possible that these insertions will trigger vector reallocation, which will invalidate all iterators that "point" into that vector. However, the insert iterator in question is guaranteed to remain valid, i.e. you can safely continue the sequence of insertions. There's no need to worry about triggering vector reallocation at all.</p>

<p>This, again, applies only to insertions performed through the insert iterator itself. If iterator-invalidating event is triggered by some independent action on the container, then the insert iterator becomes invalidated as well in accordance with the general rules.</p>

<p>For example, this code</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>;
std::insert_iterator&lt;std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">it_ins</span>(v, it);

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> n = <span class="hljs-number">20</span>; n &gt; <span class="hljs-number">0</span>; --n)
  *it_ins++ = <span class="hljs-built_in">rand</span>();
</code></pre>

<p>is guaranteed to perform a valid sequence of insertions into the vector, even if the vector "decides" to reallocate somewhere in the middle of this process. Iterator <code>it</code> will obviously become invalid, but <code>it_ins</code> will continue to remain valid.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since this question draws so many votes and kind of becomes an FAQ, I guess it would be better to write a separate answer to mention one significant difference between C++03 and C++11 regarding the impact of <code>std::vector</code>'s insertion operation on the validity of iterators and references with respect to <code>reserve()</code> and <code>capacity()</code>, which the most upvoted answer failed to notice.</p>

<p>C++ 03:</p>

<blockquote>
  <p>Reallocation invalidates all the references, pointers, and iterators
  referring to the elements in the sequence. It is guaranteed that no
  reallocation takes place during insertions that happen after a call to
  reserve() until the time when an insertion would make the size of the
  vector <strong>greater than the size specified in the most recent call to
  reserve()</strong>.</p>
</blockquote>

<p>C++11:</p>

<blockquote>
  <p>Reallocation invalidates all the references, pointers, and iterators
  referring to the elements in the sequence. It is guaranteed that no
  reallocation takes place during insertions that happen after a call to
  reserve() until the time when an insertion would make the size of the
  vector <strong>greater than the value of capacity()</strong>.</p>
</blockquote>

<p>So in C++03, it is not "<code>unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated)</code>" as mentioned in the other answer, instead, it should be "<code>greater than the size specified in the most recent call to reserve()</code>". This is one thing that C++03 differs from C++11. In C++03, once an <code>insert()</code> causes the size of the vector to reach the value specified in the previous <code>reserve()</code> call (which could well be smaller than the current <code>capacity()</code> since a <code>reserve()</code> could result a bigger <code>capacity()</code> than asked for), any subsequent <code>insert()</code> could cause reallocation and invalidate all the iterators and references. In C++11, this won't happen and you can always trust <code>capacity()</code> to know with certainty that the next reallocation won't take place before the size overpasses <code>capacity()</code>.</p>

<p>In conclusion, if you are working with a C++03 vector and you want to make sure a reallocation won't happen when you perform insertion, it's the value of the argument you previously passed to <code>reserve()</code> that you should check the size against, not the return value of a call to <code>capacity()</code>, otherwise you may get yourself surprised at a "<em>premature</em>" reallocation.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c++-standard-library">c++-standard-library</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a nice summary table from <a href="https://en.cppreference.com/w/cpp/container#Iterator_invalidation" rel="noreferrer">cppreference.com</a>:</p>

<p><a href="https://i.stack.imgur.com/qgST0.png" rel="noreferrer"><img src="https://i.stack.imgur.com/qgST0.png" alt="enter image description here"></a></p>

<p>Here, <strong>insertion</strong> refers to any method which adds one or more elements to the container and <strong>erasure</strong> refers to any method which removes one or more elements from the container.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/google-maps-js-api-v3-simple-multiple-marker-example-1657388073335">Google Maps JS API v3 - Simple Multiple Marker Example</a><a href="/questions/why-is-%22using-namespace-std%22-considered-bad-practice-1657384296377">Why is &quot;using namespace std;&quot; considered bad practice?</a><a href="/questions/how-to-remove-%22noise%22-from-gccclang-assembly-output-1657387612391">How to remove &quot;noise&quot; from GCC/clang assembly output?</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111">Is it safe to expose Firebase apiKey to the public?</a><a href="/questions/how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport-1657388316510">How can I tell if a DOM element is visible in the current viewport?</a><a href="/questions/javascript-property-access:-dot-notation-vs.-brackets-1657384717494">JavaScript property access: dot notation vs. brackets?</a><a href="/questions/how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553">How do I pass variables and data from PHP to JavaScript?</a><a href="/questions/php-parsesyntax-errors-and-how-to-solve-them-1657384264713">PHP parse/syntax errors; and how to solve them</a><a href="/questions/what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159">What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?</a><a href="/questions/why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458">Why does jQuery or a DOM method such as getElementById not find the element?</a><a href="/questions/how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855">How can I convert ereg expressions to preg in PHP?</a><a href="/questions/how-to-avoid-using-select-in-excel-vba-1657384286300">How to avoid using Select in Excel VBA</a><a href="/questions/how-do-i-return-the-response-from-an-asynchronous-call-1657384208012">How do I return the response from an asynchronous call?</a><a href="/questions/how-to-remove-the-space-between-inlineinline-block-elements-1657384532273">How to remove the space between inline/inline-block elements?</a><a href="/questions/is-floating-point-math-broken-1657384238910">Is floating point math broken?</a><a href="/questions/how-to-read-a-file-line-by-line-into-a-list-1657387865894">How to read a file line-by-line into a list?</a><a href="/questions/what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752">What are the basic rules and idioms for operator overloading?</a><a href="/questions/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407">Why does printf not flush after the call unless a newline is in the format string?</a><a href="/questions/why-does-date.parse-give-incorrect-results-1657384642821">Why does Date.parse give incorrect results?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++03\u0026lt;/strong\u0026gt; (Source: \u0026lt;a href=\u0026quot;http://kera.name/articles/2011/06/iterator-invalidation-rules/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Iterator Invalidation Rules (C++03)\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Insertion\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.2.4.3/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.2.1.3/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: all iterators and references unaffected [23.2.2.3/1]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[multi]{set,map}\u0026lt;/code\u0026gt;: all iterators and references unaffected [23.1.2/8]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Erasure\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: every iterator and reference after the point of erase is invalidated [23.2.4.3/3]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated) [23.2.1.3/4]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: only the iterators and references to the erased element is invalidated [23.2.2.3/3]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[multi]{set,map}\u0026lt;/code\u0026gt;: only iterators and references to the erased elements are invalidated [23.1.2/8]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Resizing\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: as per insert/erase [23.2.4.2/6]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: as per insert/erase [23.2.1.2/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: as per insert/erase [23.2.2.2/1]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 1\u0026lt;/h2\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unless otherwise specified\u0026lt;/strong\u0026gt; (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to \u0026lt;strong\u0026gt;a\n  library function shall not invalidate\n  iterators\u0026lt;/strong\u0026gt; to, or change the values of,\n  objects within that container.\n  [23.1/11]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules\u0026quot;\u0026gt;It\u0026apos;s not clear in C++2003 whether \u0026quot;end\u0026quot; iterators are subject to the above rules\u0026lt;/a\u0026gt;; you should assume, anyway, that they are (as this is the case in practice).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 3\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The rules for invalidation of pointers are the sames as the rules for invalidation of references.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++11\u0026lt;/strong\u0026gt; (Source: \u0026lt;a href=\u0026quot;http://kera.name/articles/2011/06/iterator-invalidation-rules-c0x/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Iterator Invalidation Rules (C++0x)\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Insertion\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.3.6.5/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.3.3.4/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: all iterators and references unaffected [23.3.5.4/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;: all iterators and references unaffected \u0026lt;em\u0026gt;(applies to \u0026lt;code\u0026gt;insert_after\u0026lt;/code\u0026gt;)\u0026lt;/em\u0026gt; [23.3.4.5/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;: \u0026lt;em\u0026gt;(n/a)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[multi]{set,map}\u0026lt;/code\u0026gt;: all iterators and references unaffected [23.2.4/9]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unsorted associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;unordered_[multi]{set,map}\u0026lt;/code\u0026gt;: all iterators invalidated when rehashing occurs, but references unaffected [23.2.5/8]. Rehashing does not occur if the insertion does not cause the container\u0026apos;s size to exceed \u0026lt;code\u0026gt;z * B\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt; is the maximum load factor and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; the current number of buckets. [23.2.5/14]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Erasure\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: every iterator and reference at or after the point of erase is invalidated [23.3.6.5/3]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: erasing the last element invalidates only iterators and references to the erased elements and the past-the-end iterator; erasing the first element invalidates only iterators and references to the erased elements; erasing any other elements invalidates all iterators and references (including the past-the-end iterator) [23.3.3.4/4]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: only the iterators and references to the erased element is invalidated [23.3.5.4/3]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;: only the iterators and references to the erased element is invalidated \u0026lt;em\u0026gt;(applies to \u0026lt;code\u0026gt;erase_after\u0026lt;/code\u0026gt;)\u0026lt;/em\u0026gt; [23.3.4.5/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;: \u0026lt;em\u0026gt;(n/a)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[multi]{set,map}\u0026lt;/code\u0026gt;: only iterators and references to the erased elements are invalidated [23.2.4/9]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unordered associative containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;unordered_[multi]{set,map}\u0026lt;/code\u0026gt;: only iterators and references to the erased elements are invalidated [23.2.5/13]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Resizing\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: as per insert/erase [23.3.6.5/12]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: as per insert/erase [23.3.3.3/3]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: as per insert/erase [23.3.5.3/1]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;: as per insert/erase [23.3.4.5/25]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;: (n/a)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 1\u0026lt;/h2\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unless otherwise specified\u0026lt;/strong\u0026gt; (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to \u0026lt;strong\u0026gt;a\n  library function shall not invalidate\n  iterators\u0026lt;/strong\u0026gt; to, or change the values of,\n  objects within that container.\n  [23.2.1/11]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 2\u0026lt;/h2\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;no swap() function invalidates any\n  references, pointers, or iterators\u0026lt;/strong\u0026gt;\n  referring to the elements of the\n  containers being swapped. [ Note: \u0026lt;strong\u0026gt;The\n  end() iterator\u0026lt;/strong\u0026gt; does not refer to any\n  element, so it \u0026lt;strong\u0026gt;may be invalidated\u0026lt;/strong\u0026gt;.\n  end note ] [23.2.1/10]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 3\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Other than the above caveat regarding \u0026lt;code\u0026gt;swap()\u0026lt;/code\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules\u0026quot;\u0026gt;it\u0026apos;s not clear whether \u0026quot;end\u0026quot; iterators are subject to the above listed per-container rules\u0026lt;/a\u0026gt;; you should assume, anyway, that they are.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Note 4\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; and all \u0026lt;em\u0026gt;unordered associative containers\u0026lt;/em\u0026gt; support \u0026lt;code\u0026gt;reserve(n)\u0026lt;/code\u0026gt; which guarantees that no automatic resizing will occur at least until the size of the container grows to \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;. Caution should be taken with \u0026lt;em\u0026gt;unordered associative containers\u0026lt;/em\u0026gt; because a future proposal will allow the specification of a minimum load factor, which would allow rehashing to occur on \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt; after enough \u0026lt;code\u0026gt;erase\u0026lt;/code\u0026gt; operations reduce the container size below the minimum; the guarantee should be considered potentially void after an \u0026lt;code\u0026gt;erase\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++17\u0026lt;/strong\u0026gt; (All references are from the final working draft of CPP17 - \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;n4659\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;Insertion\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence Containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;:  The functions \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;emplace_back\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;emplace\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;push_back\u0026lt;/code\u0026gt; cause reallocation if the new size is greater than the old capacity. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. If no reallocation\nhappens, all the iterators and references before the insertion point remain valid. [26.3.11.5/1]\u0026lt;br\u0026gt;\nWith respect to the \u0026lt;code\u0026gt;reserve\u0026lt;/code\u0026gt; function, reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. No reallocation shall take place during insertions that happen after a call to \u0026lt;code\u0026gt;reserve()\u0026lt;/code\u0026gt; until the time when an insertion would make the size of the vector greater than the value of \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt;. [26.3.11.3/6]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has no effect on the validity of references to elements of the deque. [26.3.8.4/1]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: Does not affect the validity of iterators and references. If an exception is thrown there are no effects. [26.3.10.4/1].\u0026lt;br\u0026gt;\nThe \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;emplace_front\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;emplace_back\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;emplace\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;push_front\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;push_back\u0026lt;/code\u0026gt; functions are covered under this rule.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;: None of the overloads of \u0026lt;code\u0026gt;insert_after\u0026lt;/code\u0026gt; shall affect the validity of iterators and references [26.3.9.5/1]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;: \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/container/array#Iterator_invalidation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;As a rule\u0026lt;/a\u0026gt;, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative Containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;All Associative Containers\u0026lt;/code\u0026gt;: The \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;emplace\u0026lt;/code\u0026gt; members shall not affect the validity of iterators and references to the container [26.2.6/9]\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unordered Associative Containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Unordered Associative Containers\u0026lt;/code\u0026gt;: Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. [26.2.7/9]\u0026lt;br\u0026gt;\nThe \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;emplace\u0026lt;/code\u0026gt; members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. [26.2.7/14]\u0026lt;br\u0026gt;\nThe \u0026lt;code\u0026gt;insert\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;emplace\u0026lt;/code\u0026gt; members shall not affect the validity of iterators if \u0026lt;code\u0026gt;(N+n) \u0026amp;lt;= z * B\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; is the number of elements in the container prior to the insert operation, \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is the number of elements inserted, \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is the containers bucket count, and \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt; is the containers maximum load factor. [26.2.7/15]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Unordered Associative Containers\u0026lt;/code\u0026gt;: In case of a merge operation  (e.g., \u0026lt;code\u0026gt;a.merge(a2)\u0026lt;/code\u0026gt;), iterators referring to the transferred elements and all iterators referring to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; will be invalidated, but iterators to elements remaining in \u0026lt;code\u0026gt;a2\u0026lt;/code\u0026gt; will remain valid. (Table 91  Unordered associative container requirements)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container Adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;Erasure\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Sequence Containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt;: The functions \u0026lt;code\u0026gt;erase\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;pop_back\u0026lt;/code\u0026gt; invalidate iterators and references at or after the point of the erase. [26.3.11.5/3]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;: An erase operation that erases the last element of a \u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt; invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a \u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt; but not the last element invalidates only iterators and references to the erased elements. An erase operation that erases neither the first element nor the last element of a \u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt; invalidates the past-the-end iterator and all iterators and references to all the elements of the \u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;.\n[ Note: \u0026lt;code\u0026gt;pop_front\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;pop_back\u0026lt;/code\u0026gt; are erase operations. end note ] [26.3.8.4/4]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;: Invalidates only the iterators and references to the erased elements. [26.3.10.4/3]. This applies to \u0026lt;code\u0026gt;erase\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;pop_front\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;pop_back\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; functions.\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;remove\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;remove_if\u0026lt;/code\u0026gt; member functions: Erases all the elements in the list referred by a list iterator \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; for which the following conditions hold: \u0026lt;code\u0026gt;*i == value\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;pred(*i) != false\u0026lt;/code\u0026gt;. Invalidates only the iterators and references to the erased elements [26.3.10.5/15].\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;unique\u0026lt;/code\u0026gt; member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; in the range \u0026lt;code\u0026gt;[first + 1, last)\u0026lt;/code\u0026gt; for which \u0026lt;code\u0026gt;*i == *(i-1)\u0026lt;/code\u0026gt; (for the version of unique with no arguments) or \u0026lt;code\u0026gt;pred(*i, *(i - 1))\u0026lt;/code\u0026gt; (for the version of unique with a predicate argument) holds. Invalidates only the iterators and references to the erased elements. [26.3.10.5/19]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;: \u0026lt;code\u0026gt;erase_after\u0026lt;/code\u0026gt; shall invalidate only iterators and references to the erased elements. [26.3.9.5/1].\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;remove\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;remove_if\u0026lt;/code\u0026gt; member functions - Erases all the elements in the list referred by a list iterator i for which the following conditions hold: \u0026lt;code\u0026gt;*i == value\u0026lt;/code\u0026gt; (for \u0026lt;code\u0026gt;remove()\u0026lt;/code\u0026gt;), \u0026lt;code\u0026gt;pred(*i)\u0026lt;/code\u0026gt; is true (for \u0026lt;code\u0026gt;remove_if()\u0026lt;/code\u0026gt;). Invalidates only the iterators and references to the erased elements. [26.3.9.6/12].\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;unique\u0026lt;/code\u0026gt; member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1, last) for which \u0026lt;code\u0026gt;*i == *(i-1)\u0026lt;/code\u0026gt; (for the version with no arguments) or \u0026lt;code\u0026gt;pred(*i, *(i - 1))\u0026lt;/code\u0026gt; (for the version with a predicate argument) holds. Invalidates only the iterators and references to the erased elements.  [26.3.9.6/16]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Sequence Containers\u0026lt;/code\u0026gt;: \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator (Table 87  Sequence container requirements). But for \u0026lt;code\u0026gt;forward_list\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; does not invalidate past-the-end iterators. [26.3.9.5/32]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Sequence Containers\u0026lt;/code\u0026gt;: \u0026lt;code\u0026gt;assign\u0026lt;/code\u0026gt; invalidates all references, pointers and\niterators referring to the elements of the container. For \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;deque\u0026lt;/code\u0026gt;, also invalidates the past-the-end iterator. (Table 87  Sequence container requirements)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Associative Containers\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Associative Containers\u0026lt;/code\u0026gt;: The \u0026lt;code\u0026gt;erase\u0026lt;/code\u0026gt; members shall invalidate only iterators and references to the erased elements [26.2.6/9]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;All Associative Containers\u0026lt;/code\u0026gt;: The \u0026lt;code\u0026gt;extract\u0026lt;/code\u0026gt; members invalidate only iterators to the removed element; pointers and references to the removed element remain valid [26.2.6/10]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Container Adaptors\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;stack\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;priority_queue\u0026lt;/code\u0026gt;: inherited from underlying container\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;General container requirements relating to iterator invalidation:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [26.2.1/12]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;no \u0026lt;code\u0026gt;swap()\u0026lt;/code\u0026gt; function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. end note ] [26.2.1/(11.6)]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;As examples of the above requirements:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;transform\u0026lt;/code\u0026gt; algorithm: The \u0026lt;code\u0026gt;op\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;binary_op\u0026lt;/code\u0026gt; functions shall not invalidate iterators or subranges, or modify elements in the ranges [28.6.4/1]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;accumulate\u0026lt;/code\u0026gt; algorithm: In the range [first, last], \u0026lt;code\u0026gt;binary_op\u0026lt;/code\u0026gt; shall neither modify elements nor invalidate iterators or subranges [29.8.2/1]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;reduce\u0026lt;/code\u0026gt; algorithm: binary_op shall neither invalidate iterators or subranges, nor modify elements in the range [first, last]. [29.8.3/5]\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;and so on...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is probably worth adding that an insert iterator of any kind (\u0026lt;code\u0026gt;std::back_insert_iterator\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::front_insert_iterator\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::insert_iterator\u0026lt;/code\u0026gt;) is guaranteed to remain valid as long as all insertions are performed through this iterator and no other independent iterator-invalidating event occurs.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, when you are performing a series of insertion operations into a \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; by using \u0026lt;code\u0026gt;std::insert_iterator\u0026lt;/code\u0026gt; it is quite possible that these insertions will trigger vector reallocation, which will invalidate all iterators that \u0026quot;point\u0026quot; into that vector. However, the insert iterator in question is guaranteed to remain valid, i.e. you can safely continue the sequence of insertions. There\u0026apos;s no need to worry about triggering vector reallocation at all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This, again, applies only to insertions performed through the insert iterator itself. If iterator-invalidating event is triggered by some independent action on the container, then the insert iterator becomes invalidated as well in accordance with the general rules.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, this code\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;v\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::iterator it = v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\nstd::insert_iterator\u0026amp;lt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;it_ins\u0026lt;/span\u0026gt;(v, it);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;; n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; --n)\n  *it_ins++ = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;rand\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is guaranteed to perform a valid sequence of insertions into the vector, even if the vector \u0026quot;decides\u0026quot; to reallocate somewhere in the middle of this process. Iterator \u0026lt;code\u0026gt;it\u0026lt;/code\u0026gt; will obviously become invalid, but \u0026lt;code\u0026gt;it_ins\u0026lt;/code\u0026gt; will continue to remain valid.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since this question draws so many votes and kind of becomes an FAQ, I guess it would be better to write a separate answer to mention one significant difference between C++03 and C++11 regarding the impact of \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;\u0026apos;s insertion operation on the validity of iterators and references with respect to \u0026lt;code\u0026gt;reserve()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt;, which the most upvoted answer failed to notice.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C++ 03:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector \u0026lt;strong\u0026gt;greater than the size specified in the most recent call to\n  reserve()\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector \u0026lt;strong\u0026gt;greater than the value of capacity()\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So in C++03, it is not \u0026quot;\u0026lt;code\u0026gt;unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated)\u0026lt;/code\u0026gt;\u0026quot; as mentioned in the other answer, instead, it should be \u0026quot;\u0026lt;code\u0026gt;greater than the size specified in the most recent call to reserve()\u0026lt;/code\u0026gt;\u0026quot;. This is one thing that C++03 differs from C++11. In C++03, once an \u0026lt;code\u0026gt;insert()\u0026lt;/code\u0026gt; causes the size of the vector to reach the value specified in the previous \u0026lt;code\u0026gt;reserve()\u0026lt;/code\u0026gt; call (which could well be smaller than the current \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt; since a \u0026lt;code\u0026gt;reserve()\u0026lt;/code\u0026gt; could result a bigger \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt; than asked for), any subsequent \u0026lt;code\u0026gt;insert()\u0026lt;/code\u0026gt; could cause reallocation and invalidate all the iterators and references. In C++11, this won\u0026apos;t happen and you can always trust \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt; to know with certainty that the next reallocation won\u0026apos;t take place before the size overpasses \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In conclusion, if you are working with a C++03 vector and you want to make sure a reallocation won\u0026apos;t happen when you perform insertion, it\u0026apos;s the value of the argument you previously passed to \u0026lt;code\u0026gt;reserve()\u0026lt;/code\u0026gt; that you should check the size against, not the return value of a call to \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt;, otherwise you may get yourself surprised at a \u0026quot;\u0026lt;em\u0026gt;premature\u0026lt;/em\u0026gt;\u0026quot; reallocation.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a nice summary table from \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/container#Iterator_invalidation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;cppreference.com\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/qgST0.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/qgST0.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;strong\u0026gt;insertion\u0026lt;/strong\u0026gt; refers to any method which adds one or more elements to the container and \u0026lt;strong\u0026gt;erasure\u0026lt;/strong\u0026gt; refers to any method which removes one or more elements from the container.\u0026lt;/p\u0026gt;\n    "],"id":304,"title":"Iterator invalidation rules for C++ containers","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;This question\u0026apos;s answers are a \u0026lt;a href=\u0026quot;/help/privileges/edit-community-wiki\u0026quot;\u0026gt;community effort\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt;. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;What are the iterator invalidation rules for C++ containers?\u0026lt;/p\u0026gt;\n\u0026lt;sub\u0026gt;\n(\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; This Q\u0026amp;amp;A is an entry in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/c++-faq\u0026quot;\u0026gt;Stack Overflow\u0026apos;s C++ FAQ\u0026lt;/a\u0026gt;. Meta-discussion about the question itself should be posted on \u0026lt;a href=\u0026quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\u0026quot;\u0026gt;the Meta question that started all of this\u0026lt;/a\u0026gt;, not here.)\n\u0026lt;/sub\u0026gt;\n    ","slug":"iterator-invalidation-rules-for-c++-containers-1657387561090","postType":"QUESTION","createdAt":"2022-07-09T17:26:01.000Z","updatedAt":"2022-07-09T17:26:01.000Z","tags":[{"id":1813,"name":"c++-standard-library","slug":"c++-standard-library","createdAt":"2022-07-09T17:26:01.000Z","updatedAt":"2022-07-09T17:26:01.000Z","Questions_Tags":{"questionId":304,"tagId":1813}}],"relatedQuestions":[{"title":"Iterator invalidation rules for C++ containers","slug":"iterator-invalidation-rules-for-c++-containers-1657387561090","tags":[{"name":"c++-standard-library","Questions_Tags":{"questionId":304,"tagId":1813}}]}]},"randomQuestions":[{"title":"Google Maps JS API v3 - Simple Multiple Marker Example","slug":"google-maps-js-api-v3-simple-multiple-marker-example-1657388073335"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"How to remove \"noise\" from GCC/clang assembly output?","slug":"how-to-remove-\"noise\"-from-gccclang-assembly-output-1657387612391"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"Is it safe to expose Firebase apiKey to the public?","slug":"is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111"},{"title":"How can I tell if a DOM element is visible in the current viewport?","slug":"how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport-1657388316510"},{"title":"JavaScript property access: dot notation vs. brackets?","slug":"javascript-property-access:-dot-notation-vs.-brackets-1657384717494"},{"title":"How do I pass variables and data from PHP to JavaScript?","slug":"how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?","slug":"what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159"},{"title":"Why does jQuery or a DOM method such as getElementById not find the element?","slug":"why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458"},{"title":"How can I convert ereg expressions to preg in PHP?","slug":"how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855"},{"title":"How to avoid using Select in Excel VBA","slug":"how-to-avoid-using-select-in-excel-vba-1657384286300"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"How to remove the space between inline/inline-block elements?","slug":"how-to-remove-the-space-between-inlineinline-block-elements-1657384532273"},{"title":"Is floating point math broken?","slug":"is-floating-point-math-broken-1657384238910"},{"title":"How to read a file line-by-line into a list?","slug":"how-to-read-a-file-line-by-line-into-a-list-1657387865894"},{"title":"What are the basic rules and idioms for operator overloading?","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752"},{"title":"Why does printf not flush after the call unless a newline is in the format string?","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407"},{"title":"Why does Date.parse give incorrect results?","slug":"why-does-date.parse-give-incorrect-results-1657384642821"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"iterator-invalidation-rules-for-c++-containers-1657387561090"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>