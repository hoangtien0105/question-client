{"pageProps":{"data":{"answer":["\n&lt;p&gt;Whereas one approach is to implement the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.icloneable.aspx&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;ICloneable&lt;/code&gt;&lt;/a&gt; interface (described &lt;a href=&quot;https://stackoverflow.com/questions/78536/cloning-objects-in-c/78568#78568&quot;&gt;here&lt;/a&gt;, so I won&apos;t regurgitate), here&apos;s a nice deep clone object copier I found on &lt;a href=&quot;http://www.codeproject.com/Articles/23832/Implementing-Deep-Cloning-via-Serializing-objects&quot; rel=&quot;noreferrer&quot;&gt;The Code Project&lt;/a&gt; a while ago and incorporated it into our code.\nAs mentioned elsewhere, it requires your objects to be serializable.&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.IO;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Runtime.Serialization;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Runtime.Serialization.Formatters.Binary;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Provides a method for performing a deep copy of an object.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Binary Serialization is used to perform the copy.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ObjectCopier&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Perform a deep copy of the object via serialization.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;The type of object being copied.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;The object instance to copy.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;A deep copy of the object.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T source&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T).IsSerializable)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArgumentException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;The type must be serializable.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;nameof&lt;/span&gt;(source));\n        }\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t serialize a null object, simply return the default for that object&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ReferenceEquals(source, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; Stream stream = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MemoryStream();\n        IFormatter formatter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BinaryFormatter();\n        formatter.Serialize(stream, source);\n        stream.Seek(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, SeekOrigin.Begin);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (T)formatter.Deserialize(stream);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The idea is that it serializes your object and then deserializes it into a fresh object. The benefit is that you don&apos;t have to concern yourself about cloning everything when an object gets too complex.&lt;/p&gt;\n&lt;p&gt;In case of you prefer to use the new &lt;a href=&quot;http://en.wikipedia.org/wiki/Extension_method&quot; rel=&quot;noreferrer&quot;&gt;extension methods&lt;/a&gt; of C# 3.0, change the method to have the following signature:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T source&lt;/span&gt;)&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now the method call simply becomes &lt;code&gt;objectBeingCloned.Clone();&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt; (January 10 2015) Thought I&apos;d revisit this, to mention I recently started using (Newtonsoft) Json to do this, it &lt;a href=&quot;http://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/&quot; rel=&quot;noreferrer&quot;&gt;should be&lt;/a&gt; lighter, and avoids the overhead of [Serializable] tags. (&lt;strong&gt;NB&lt;/strong&gt; @atconway has pointed out in the comments that private members are not cloned using the JSON method)&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Perform a deep Copy of the object, using Json as a serialization method. &lt;span class=&quot;hljs-doctag&quot;&gt;NOTE:&lt;/span&gt; Private members are not cloned using this method.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;The type of object being copied.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;The object instance to copy.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;The copied object.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;CloneJson&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T source&lt;/span&gt;)&lt;/span&gt;\n{            \n    &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t serialize a null object, simply return the default for that object&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ReferenceEquals(source, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// initialize inner objects individually&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// for example in default constructor some list property initialized with some values,&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// but in &apos;source&apos; these items are cleaned -&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// without ObjectCreationHandling.Replace default constructor values will be added to result&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; deserializeSettings = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JsonSerializerSettings {ObjectCreationHandling = ObjectCreationHandling.Replace};\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;(JsonConvert.SerializeObject(source), deserializeSettings);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I wanted a cloner for very simple objects of mostly primitives and lists.  If your object is out of the box JSON serializable then this method will do the trick.  This requires no modification or implementation of interfaces on the cloned class, just a JSON serializer like JSON.NET.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T source&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; serialized = JsonConvert.SerializeObject(source);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;(serialized);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also, you can use this extension method&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SystemExtension&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T source&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; serialized = JsonConvert.SerializeObject(source);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;(serialized);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The reason not to use &lt;a href=&quot;http://referencesource.microsoft.com/mscorlib/system/icloneable.cs.html#fb795e239ce05299&quot; rel=&quot;noreferrer&quot;&gt;ICloneable&lt;/a&gt; is &lt;strong&gt;not&lt;/strong&gt; because it doesn&apos;t have a generic interface.  &lt;a href=&quot;http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx&quot; rel=&quot;noreferrer&quot;&gt;The reason not to use it is because it&apos;s vague&lt;/a&gt;.  It doesn&apos;t make clear whether you&apos;re getting a shallow or a deep copy; that&apos;s up to the implementer.&lt;/p&gt;\n\n&lt;p&gt;Yes, &lt;code&gt;MemberwiseClone&lt;/code&gt; makes a shallow copy, but the opposite of &lt;code&gt;MemberwiseClone&lt;/code&gt; isn&apos;t &lt;code&gt;Clone&lt;/code&gt;; it would be, perhaps, &lt;code&gt;DeepClone&lt;/code&gt;, which doesn&apos;t exist.  When you use an object through its ICloneable interface, you can&apos;t know which kind of cloning the underlying object performs.  (And XML comments won&apos;t make it clear, because you&apos;ll get the interface comments rather than the ones on the object&apos;s Clone method.)&lt;/p&gt;\n\n&lt;p&gt;What I usually do is simply make a &lt;code&gt;Copy&lt;/code&gt; method that does exactly what I want.&lt;/p&gt;\n    ","\n&lt;p&gt;After much much reading about many of the options linked here, and possible solutions for this issue, I believe &lt;a href=&quot;https://developerscon.blogspot.com/2008/06/c-object-clone-wars.html&quot; rel=&quot;noreferrer&quot;&gt;all the options are summarized pretty well at &lt;em&gt;Ian P&lt;/em&gt;&apos;s link&lt;/a&gt; (all other options are variations of those) and the best solution is provided by &lt;a href=&quot;http://www.agiledeveloper.com/articles/cloning072002.htm&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Pedro77&lt;/em&gt;&apos;s link&lt;/a&gt; on the question comments.&lt;/p&gt;\n\n&lt;p&gt;So I&apos;ll just copy relevant parts of those 2 references here. That way we can have:&lt;/p&gt;\n\n&lt;h2&gt;The best thing to do for cloning objects in C sharp!&lt;/h2&gt;\n\n&lt;p&gt;First and foremost, those are all our options:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Manually with &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.icloneable&quot; rel=&quot;noreferrer&quot;&gt;ICloneable&lt;/a&gt;&lt;/strong&gt;, which is &lt;em&gt;Shallow&lt;/em&gt; and not &lt;em&gt;Type-Safe&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.memberwiseclone&quot; rel=&quot;noreferrer&quot;&gt;MemberwiseClone&lt;/a&gt;&lt;/strong&gt;, which uses ICloneable&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/3441/Base-class-for-cloning-an-object-in-C&quot; rel=&quot;noreferrer&quot;&gt;Reflection&lt;/a&gt;&lt;/strong&gt; by using &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.activator.createinstance&quot; rel=&quot;noreferrer&quot;&gt;Activator.CreateInstance&lt;/a&gt; and &lt;a href=&quot;https://github.com/Burtsev-Alexey/net-object-deep-copy/&quot; rel=&quot;noreferrer&quot;&gt;recursive MemberwiseClone&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.serializableattribute&quot; rel=&quot;noreferrer&quot;&gt;Serialization&lt;/a&gt;&lt;/strong&gt;, as pointed by &lt;a href=&quot;https://stackoverflow.com/a/78612/274502&quot;&gt;johnc&apos;s preferred answer&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Intermediate Language&lt;/strong&gt;, which I got no idea &lt;a href=&quot;https://whizzodev.blogspot.com/2008/03/object-cloning-using-il-in-c.html&quot; rel=&quot;noreferrer&quot;&gt;how works&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Extension Methods&lt;/strong&gt;, such as this &lt;a href=&quot;https://circlesandcrossesblogarchive.blogspot.com/2008/01/extension-methods-for-copying-or.html&quot; rel=&quot;noreferrer&quot;&gt;custom clone framework by Havard Straden&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha&quot; rel=&quot;noreferrer&quot;&gt;Expression Trees&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The &lt;a href=&quot;https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha&quot; rel=&quot;noreferrer&quot;&gt;article Fast Deep Copy by Expression Trees&lt;/a&gt;   has  also performance comparison of cloning by Serialization, Reflection and Expression Trees.&lt;/p&gt;\n\n&lt;h1&gt;Why I choose &lt;em&gt;ICloneable&lt;/em&gt; (i.e. manually)&lt;/h1&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.agiledeveloper.com/articles/cloning072002.htm&quot; rel=&quot;noreferrer&quot;&gt;Mr Venkat Subramaniam (redundant link here) explains in much detail why&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;All his article circles around an example that tries to be applicable for most cases, using 3 objects: &lt;em&gt;Person&lt;/em&gt;, &lt;em&gt;Brain&lt;/em&gt; and &lt;em&gt;City&lt;/em&gt;. We want to clone a person, which will have its own brain but the same city. You can either picture all problems any of the other methods above can bring or read the article.&lt;/p&gt;\n\n&lt;p&gt;This is my slightly modified version of his conclusion:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Copying an object by specifying &lt;code&gt;New&lt;/code&gt; followed by the class name often leads to code that is not extensible. Using clone, the application of prototype pattern, is a better way to achieve this. However, using clone as it is provided in C# (and Java) can be quite problematic as well. It is better to provide a protected (non-public) copy constructor and invoke that from the clone method. This gives us the ability to delegate the task of creating an object to an instance of a class itself, thus providing extensibility and also, safely creating the objects using the protected copy constructor.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Hopefully this implementation can make things clear:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;ICloneable&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; final Brain brain; &lt;span class=&quot;hljs-comment&quot;&gt;// brain is final since I do not want &lt;/span&gt;\n                &lt;span class=&quot;hljs-comment&quot;&gt;// any transplant on it once created!&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; age;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Brain aBrain, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; theAge&lt;/span&gt;)&lt;/span&gt;\n    {\n        brain = aBrain; \n        age = theAge;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Person another&lt;/span&gt;)&lt;/span&gt;\n    {\n        Brain refBrain = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;\n        {\n            refBrain = (Brain) another.brain.clone();\n            &lt;span class=&quot;hljs-comment&quot;&gt;// You can set the brain in the constructor&lt;/span&gt;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(CloneNotSupportedException e) {}\n        brain = refBrain;\n        age = another.age;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;This is person with &quot;&lt;/span&gt; + brain;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Not meant to sound rude as it reads!&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;hljs-title&quot;&gt;clone&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;);\n    }\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now consider having a class derive from Person.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SkilledPerson&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String theSkills;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SkilledPerson&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Brain aBrain, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; theAge, String skills&lt;/span&gt;)&lt;/span&gt;\n    {\n        super(aBrain, theAge);\n        theSkills = skills;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SkilledPerson&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;SkilledPerson another&lt;/span&gt;)&lt;/span&gt;\n    {\n        super(another);\n        theSkills = another.theSkills;\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;hljs-title&quot;&gt;clone&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SkilledPerson(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;SkilledPerson: &quot;&lt;/span&gt; + super.toString();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may try running the following code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;User&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;play&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Person p&lt;/span&gt;)&lt;/span&gt;\n    {\n        Person another = (Person) p.clone();\n        System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(p);\n        System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(another);\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt;\n    {\n        Person sam = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Brain(), &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n        play(sam);\n        SkilledPerson bob = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SkilledPerson(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SmarterBrain(), &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Writer&quot;&lt;/span&gt;);\n        play(bob);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output produced will be:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;This &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; person &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; Brain@&lt;span class=&quot;hljs-number&quot;&gt;1f&lt;/span&gt;cc69\nThis &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; person &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; Brain@&lt;span class=&quot;hljs-number&quot;&gt;253498&lt;/span&gt;\nSkilledPerson: This &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; person &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; SmarterBrain@&lt;span class=&quot;hljs-number&quot;&gt;1f&lt;/span&gt;ef6f\nSkilledPerson: This &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; person &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; SmarterBrain@&lt;span class=&quot;hljs-number&quot;&gt;209f&lt;/span&gt;4e\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Observe that, if we keep a count of the number of objects, the clone as implemented here will keep a correct count of the number of objects.&lt;/p&gt;\n    ","\n&lt;p&gt;I prefer a copy constructor to a clone. The intent is clearer.&lt;/p&gt;\n    ","\n&lt;p&gt;Simple extension method to copy all the public properties. Works for any objects and &lt;strong&gt;does not&lt;/strong&gt; require class to be &lt;code&gt;[Serializable]&lt;/code&gt;. Can be extended for other access level.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CopyTo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; S, &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; T &lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; pS &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; S.GetType().GetProperties() )\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; pT &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; T.GetType().GetProperties() )\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;( pT.Name != pS.Name ) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;\n            ( pT.GetSetMethod() ).Invoke( T, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] \n            { pS.GetGetMethod().Invoke( S, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; ) } );\n        }\n    };\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I&apos;ve just created &lt;strong&gt;&lt;a href=&quot;https://github.com/MarcinJuraszek/CloneExtensions&quot;&gt;&lt;code&gt;CloneExtensions&lt;/code&gt; library&lt;/a&gt;&lt;/strong&gt; project. It performs fast, deep clone using simple assignment operations generated by Expression Tree runtime code compilation.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;How to use it?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Instead of writing your own &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; methods with a tone of assignments between fields and properties make the program do it for yourself, using Expression Tree. &lt;code&gt;GetClone&amp;lt;T&amp;gt;()&lt;/code&gt; method marked as extension method allows you to simply call it on your instance:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; newInstance = source.GetClone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can choose what should be copied from &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;newInstance&lt;/code&gt; using &lt;code&gt;CloningFlags&lt;/code&gt; enum:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; newInstance \n    = source.GetClone(CloningFlags.Properties | CloningFlags.CollectionItems);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;What can be cloned?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Primitive (int, uint, byte, double, char, etc.), known immutable\ntypes (DateTime, TimeSpan, String) and delegates (including\nAction, Func, etc)&lt;/li&gt;\n&lt;li&gt;Nullable&lt;/li&gt;\n&lt;li&gt;T[] arrays&lt;/li&gt;\n&lt;li&gt;Custom classes and structs, including generic classes and structs.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Following class/struct members are cloned internally:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Values of public, not readonly fields&lt;/li&gt;\n&lt;li&gt;Values of public properties with both get and set accessors&lt;/li&gt;\n&lt;li&gt;Collection items for types implementing ICollection&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;How fast it is?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The solution is faster then reflection, because members information has to be gathered only once, before &lt;code&gt;GetClone&amp;lt;T&amp;gt;&lt;/code&gt; is used for the first time for given type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s also faster than serialization-based solution when you clone more then couple instances of the same type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;and more...&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Read more about generated expressions on &lt;a href=&quot;https://github.com/MarcinJuraszek/CloneExtensions/blob/master/EXPRESSION_TREES.md&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Sample expression debug listing for &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;.Lambda &lt;span class=&quot;hljs-meta&quot;&gt;#Lambda1&amp;lt;System.Func`4[System.Collections.Generic.List`1[System.Int32],CloneExtensions.CloningFlags,System.Collections.Generic.IDictionary`2[System.Type,System.Func`2[System.Object,System.Object]],System.Collections.Generic.List`1[System.Int32]]&amp;gt;(&lt;/span&gt;\n    System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32] $source,\n    CloneExtensions.CloningFlags $flags,\n    System.Collections.Generic.IDictionary`&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[System.Type,System.Func`&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[System.Object,System.Object]] $initializers) {\n    .Block(System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32] $target) {\n        .If ($source == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {\n            .Return &lt;span class=&quot;hljs-meta&quot;&gt;#Label1 { null }&lt;/span&gt;\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            .Call $initializers.ContainsKey(.Constant&amp;lt;System.Type&amp;gt;(System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32]))\n        ) {\n            $target = (System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32]).Call ($initializers.Item[.Constant&amp;lt;System.Type&amp;gt;(System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32])]\n            ).Invoke((System.Object)$source)\n        } .Else {\n            $target = .New System.Collections.Generic.List`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32]()\n        };\n        .If (\n            ((System.Byte)$flags &amp;amp; (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(Fields)) == (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(Fields)\n        ) {\n            .Default(System.Void)\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags &amp;amp; (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(Properties)) == (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(Properties)\n        ) {\n            .Block() {\n                $target.Capacity = .Call CloneExtensions.CloneFactory.GetClone(\n                    $source.Capacity,\n                    $flags,\n                    $initializers)\n            }\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags &amp;amp; (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(CollectionItems)) == (System.Byte).Constant&amp;lt;CloneExtensions.CloningFlags&amp;gt;(CollectionItems)\n        ) {\n            .Block(\n                System.Collections.Generic.IEnumerator`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32] $var1,\n                System.Collections.Generic.ICollection`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32] $var2) {\n                $var1 = (System.Collections.Generic.IEnumerator`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32]).Call $source.GetEnumerator();\n                $var2 = (System.Collections.Generic.ICollection`&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;[System.Int32])$target;\n                .Loop  {\n                    .If (.Call $var1.MoveNext() != False) {\n                        .Call $var2.Add(.Call CloneExtensions.CloneFactory.GetClone(\n                                $var1.Current,\n                                $flags,\n\n\n                         $initializers))\n                } .Else {\n                    .Break &lt;span class=&quot;hljs-meta&quot;&gt;#Label2 { }&lt;/span&gt;\n                }\n            }\n            .LabelTarget &lt;span class=&quot;hljs-meta&quot;&gt;#Label2:&lt;/span&gt;\n        }\n    } .Else {\n        .Default(System.Void)\n    };\n    .Label\n        $target\n    .LabelTarget &lt;span class=&quot;hljs-meta&quot;&gt;#Label1:&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;p&gt;what has the same meaning like following c# code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;(source, flags, initializers) =&amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(source == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(initializers.ContainsKey(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;))\n        target = (List&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;)initializers[&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;)].Invoke((&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;)source);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        target = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;();\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((flags &amp;amp; CloningFlags.Properties) == CloningFlags.Properties)\n    {\n        target.Capacity = target.Capacity.GetClone(flags, initializers);\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((flags &amp;amp; CloningFlags.CollectionItems) == CloningFlags.CollectionItems)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; targetCollection = (ICollection&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;)target;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; item &lt;span class=&quot;hljs-title&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;ICollection&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&lt;/span&gt;)source)&lt;/span&gt;\n        {\n            targetCollection.Add(item.Clone(flags, initializers));\n        }\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; target;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Isn&apos;t it quite like how you&apos;d write your own &lt;code&gt;Clone&lt;/code&gt; method for &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;?&lt;/p&gt;\n    ","\n&lt;p&gt;If you&apos;re already using a 3rd party application like &lt;a href=&quot;https://github.com/omuleanu/ValueInjecter&quot; rel=&quot;noreferrer&quot;&gt;ValueInjecter&lt;/a&gt; or &lt;a href=&quot;https://github.com/AutoMapper/AutoMapper&quot; rel=&quot;noreferrer&quot;&gt;Automapper&lt;/a&gt;, you can do something like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MyObject oldObj; &lt;span class=&quot;hljs-comment&quot;&gt;// The existing object to clone&lt;/span&gt;\n\nMyObject newObj = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyObject();\nnewObj.InjectFrom(oldObj); &lt;span class=&quot;hljs-comment&quot;&gt;// Using ValueInjecter syntax&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using this method you don&apos;t have to implement &lt;code&gt;ISerializable&lt;/code&gt; or &lt;code&gt;ICloneable&lt;/code&gt; on your objects. This is common with the MVC/MVVM pattern, so simple tools like this have been created.&lt;/p&gt;\n\n&lt;p&gt;see &lt;a href=&quot;https://github.com/omuleanu/ValueInjecter/blob/dae7956439cac8516979fe254a520a1942c5cdeb/Tests/Cloning.cs&quot; rel=&quot;noreferrer&quot;&gt;the ValueInjecter deep cloning sample on GitHub&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Well I was having problems using ICloneable in Silverlight, but I liked the idea of seralization, I can seralize XML, so I did this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SerializeHelper&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Michael White, Holly Springs Consulting, 2009&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//michael@hollyspringsconsulting.com&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;DeserializeXML&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; xmlData&lt;/span&gt;) \n        &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; T:&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;.IsNullOrEmpty(xmlData))\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;(T);\n\n        TextReader tr = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringReader(xmlData);\n        T DocItms = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; T();\n        XmlSerializer xms = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; XmlSerializer(DocItms.GetType());\n        DocItms = (T)xms.Deserialize(tr);\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; DocItms == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;(T) : DocItms;\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SeralizeObjectToXML&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T xmlObject&lt;/span&gt;)&lt;/span&gt;\n    {\n        StringBuilder sbTR = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder();\n        XmlSerializer xmsTR = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; XmlSerializer(xmlObject.GetType());\n        XmlWriterSettings xwsTR = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; XmlWriterSettings();\n        \n        XmlWriter xmwTR = XmlWriter.Create(sbTR, xwsTR);\n        xmsTR.Serialize(xmwTR,xmlObject);\n        \n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; sbTR.ToString();\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;CloneObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T objClone&lt;/span&gt;) \n        &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; T:&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; GetString = SerializeHelper.SeralizeObjectToXML&amp;lt;T&amp;gt;(objClone);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; SerializeHelper.DeserializeXML&amp;lt;T&amp;gt;(GetString);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The best is to implement an &lt;strong&gt;extension method&lt;/strong&gt; like&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;DeepClone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T originalObject&lt;/span&gt;)&lt;/span&gt;\n{ &lt;span class=&quot;hljs-comment&quot;&gt;/* the cloning code */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and then use it anywhere in the solution by&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; copy = anyObject.DeepClone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We can have the following three implementations:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/129395/2094687&quot;&gt;&lt;strong&gt;By Serialization&lt;/strong&gt;&lt;/a&gt; (the shortest code)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://github.com/Burtsev-Alexey/net-object-deep-copy/&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;By Reflection&lt;/strong&gt;&lt;/a&gt; - &lt;strong&gt;5x faster&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-by-Expression-Trees-C-Sharp&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;By Expression Trees&lt;/strong&gt;&lt;/a&gt; - &lt;strong&gt;20x faster&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;All linked methods are well working and were deeply tested.&lt;/p&gt;\n    ","\n&lt;p&gt;The short answer is you inherit from the ICloneable interface and then implement the .clone function. Clone should do a memberwise copy and perform a deep copy on any member that requires it, then return the resulting object. This is a recursive operation ( it requires that all members of the class you want to clone are either value types or implement ICloneable and that their members are either value types or implement ICloneable, and so on).&lt;/p&gt;\n\n&lt;p&gt;For a more detailed explanation on Cloning using ICloneable, check out &lt;a href=&quot;https://web.archive.org/web/20120113123300/http://www.ondotnet.com/pub/a/dotnet/2002/11/25/copying.html&quot; rel=&quot;noreferrer&quot;&gt;this article&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The &lt;em&gt;long&lt;/em&gt; answer is &quot;it depends&quot;. As mentioned by others, ICloneable is not supported by generics, requires special considerations for circular class references, and is actually viewed by some as a &lt;a href=&quot;http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx&quot; rel=&quot;noreferrer&quot;&gt;&quot;mistake&quot;&lt;/a&gt; in the .NET Framework. The serialization method depends on your objects being serializable, which they may not be and you may have no control over. There is still much debate in the community over which is the &quot;best&quot; practice. In reality, none of the solutions are the one-size fits all best practice for all situations like ICloneable was originally interpreted to be.&lt;/p&gt;\n\n&lt;p&gt;See the this &lt;a href=&quot;http://developerscon.blogspot.com/2008/06/c-object-clone-wars.html&quot; rel=&quot;noreferrer&quot;&gt;Developer&apos;s Corner article&lt;/a&gt; for a few more options (credit to Ian).&lt;/p&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;Basically you need to implement ICloneable interface and then realize object structure copying. &lt;/li&gt;\n&lt;li&gt;If it&apos;s deep copy of all members, you need to insure (not relating on solution you choose) that all children are clonable as well. &lt;/li&gt;\n&lt;li&gt;Sometimes you need to be aware of some restriction during this process, for example if you copying the ORM objects most of frameworks allow only one object attached to the session and you MUST NOT make clones of this object, or if it&apos;s possible you need to care about session attaching of these objects.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Cheers.&lt;/p&gt;\n    ","\n&lt;h2&gt;DeepCloner: Quick, easy, effective NuGet package to solve cloning&lt;/h2&gt;\n\n&lt;p&gt;After reading all answers I was surprised no one mentioned this excellent package: &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/force-net/DeepCloner&quot; rel=&quot;noreferrer&quot;&gt;DeepCloner GitHub project&lt;/a&gt;  &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://www.nuget.org/packages/DeepCloner&quot; rel=&quot;noreferrer&quot;&gt;DeepCloner NuGet package&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Elaborating a bit on its README, here are the reason why we chose it at work:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ul&gt;\n  &lt;li&gt;It can deep or shallow copy &lt;/li&gt;\n  &lt;li&gt;In deep cloning all object graph is maintained. &lt;/li&gt;\n  &lt;li&gt;Uses code-generation in runtime, as result cloning is blazingly fast&lt;/li&gt;\n  &lt;li&gt;Objects copied by internal structure, no methods or ctors called&lt;/li&gt;\n  &lt;li&gt;You don&apos;t need to mark classes somehow (like Serializable-attribute, or implement interfaces)&lt;/li&gt;\n  &lt;li&gt;No requirement to specify object type for cloning. Object can be casted to interface or as an abstract object (e.g. you can clone array of ints as abstract Array or IEnumerable; even null can be cloned without any errors)&lt;/li&gt;\n  &lt;li&gt;Cloned object doesn&apos;t have any ability to determine that he is clone (except with very specific methods)&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;h3&gt;Usage:&lt;/h3&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; deepClone = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; { Id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, Name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;222&quot;&lt;/span&gt; }.DeepClone();\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; shallowClone = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; { Id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, Name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;222&quot;&lt;/span&gt; }.ShallowClone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;Performance:&lt;/h3&gt;\n\n&lt;p&gt;The README contains a performance comparison of various cloning libraries and methods: &lt;a href=&quot;https://github.com/force-net/DeepCloner#performance&quot; rel=&quot;noreferrer&quot;&gt;DeepCloner Performance&lt;/a&gt;.&lt;/p&gt;\n\n&lt;h3&gt;Requirements:&lt;/h3&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;em&gt;.NET 4.0 or higher or .NET Standard 1.3 (.NET Core)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;em&gt;Requires Full Trust permission set or Reflection permission (MemberAccess)&lt;/em&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;EDIT: project is discontinued&lt;/p&gt;\n\n&lt;p&gt;If you want true cloning to unknown types you can take a look at\n&lt;a href=&quot;http://fastclone.codeplex.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;fastclone&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;That&apos;s expression based cloning working about 10 times faster than binary serialization and maintaining complete object graph integrity.&lt;/p&gt;\n\n&lt;p&gt;That means: if you refer multiple times to the same object in your hierachy, the clone will also have a single instance beeing referenced.&lt;/p&gt;\n\n&lt;p&gt;There is no need for interfaces, attributes or any other modification to the objects being cloned.&lt;/p&gt;\n    ","\n&lt;p&gt;Keep things simple and use &lt;a href=&quot;http://automapper.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;AutoMapper&lt;/a&gt; as others mentioned, it&apos;s a simple little library to map one object to another... To copy an object to another with the same type, all you need is three lines of code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MyType source = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyType();\nMapper.CreateMap&amp;lt;MyType, MyType&amp;gt;();\nMyType target = Mapper.Map&amp;lt;MyType, MyType&amp;gt;(source);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The target object is now a copy of the source object.\nNot simple enough? Create an extension method to use everywhere in your solution:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Copy&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T source&lt;/span&gt;)&lt;/span&gt;\n{\n    T copy = &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;(T);\n    Mapper.CreateMap&amp;lt;T, T&amp;gt;();\n    copy = Mapper.Map&amp;lt;T, T&amp;gt;(source);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; copy;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The extension method can be used as follow:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MyType copy = source.Copy();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In general, you implement the ICloneable interface and implement Clone yourself.\nC# objects have a built-in MemberwiseClone method that performs a shallow copy that can help you out for all the primitives.&lt;/p&gt;\n\n&lt;p&gt;For a deep copy, there is no way it can know how to automatically do it.&lt;/p&gt;\n    ","\n&lt;p&gt;I came up with this to overcome a &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot; rel=&quot;noreferrer&quot;&gt;.NET&lt;/a&gt; shortcoming having to manually deep copy List&amp;lt;T&amp;gt;.&lt;/p&gt;\n\n&lt;p&gt;I use this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IEnumerable&amp;lt;SpotPlacement&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;CloneList&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;List&amp;lt;SpotPlacement&amp;gt; spotPlacements&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (SpotPlacement sp &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; spotPlacements)\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;SpotPlacement&lt;/span&gt;)sp.&lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;()&lt;/span&gt;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And at another place:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;()&lt;/span&gt;\n{\n    OrderItem newOrderItem = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; OrderItem();\n    ...\n    newOrderItem._exactPlacements.AddRange(SpotPlacement.CloneList(_exactPlacements));\n    ...\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; newOrderItem;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I tried to come up with oneliner that does this, but it&apos;s not possible, due to yield not working inside anonymous method blocks.&lt;/p&gt;\n\n&lt;p&gt;Better still, use generic List&amp;lt;T&amp;gt; cloner:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Utility&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;ICloneable&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IEnumerable&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;CloneList&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;List&amp;lt;T&amp;gt; tl&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (T t &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; tl)\n        {\n            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;)t.&lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;()&lt;/span&gt;;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h3&gt;Q. Why would I choose this answer?&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Choose this answer if you want the fastest speed .NET is capable of.&lt;/li&gt;\n&lt;li&gt;Ignore this answer if you want a really, really easy method of cloning.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In other words, &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot; rel=&quot;noreferrer&quot;&gt;go with another answer unless you have a performance bottleneck that needs fixing, and you can prove it with a profiler&lt;/a&gt;.&lt;/p&gt;\n&lt;h3&gt;10x faster than other methods&lt;/h3&gt;\n&lt;p&gt;The following method of performing a deep clone is:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;10x faster than anything that involves serialization/deserialization;&lt;/li&gt;\n&lt;li&gt;Pretty darn close to the theoretical maximum speed .NET is capable of.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;And the method ...&lt;/h3&gt;\n&lt;p&gt;For ultimate speed, you can use &lt;strong&gt;Nested MemberwiseClone to do a deep copy&lt;/strong&gt;. Its almost the same speed as copying a value struct, and is much faster than (a) reflection or (b) serialization (as described in other answers on this page).&lt;/p&gt;\n&lt;p&gt;Note that &lt;strong&gt;if&lt;/strong&gt; you use &lt;strong&gt;Nested MemberwiseClone for a deep copy&lt;/strong&gt;, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.&lt;/p&gt;\n&lt;p&gt;Here is the output of the code showing the relative performance difference for 100,000 clones:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1.08 seconds for Nested MemberwiseClone on nested structs&lt;/li&gt;\n&lt;li&gt;4.77 seconds for Nested MemberwiseClone on nested classes&lt;/li&gt;\n&lt;li&gt;39.93 seconds for Serialization/Deserialization&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Using Nested MemberwiseClone on a class almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Demo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; of shallow &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; deep copy, &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; classes &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; MemberwiseClone:\n  Create Bob\n    Bob.Age=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, Bob.Purchase.Description=Lamborghini\n  Clone Bob &amp;gt;&amp;gt; BobsSon\n  Adjust BobsSon details\n    BobsSon.Age=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; clone, then adjusting BobsSon details will &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; affect Bob:\n    Bob.Age=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, Bob.Purchase.Description=Lamborghini\n  Elapsed time: &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;04.7795670&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30000000&lt;/span&gt;\n\nDemo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; of shallow &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; deep copy, &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; structs &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; copying:\n  Create Bob\n    Bob.Age=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, Bob.Purchase.Description=Lamborghini\n  Clone Bob &amp;gt;&amp;gt; BobsSon\n  Adjust BobsSon details:\n    BobsSon.Age=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; clone, then adjusting BobsSon details will &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; affect Bob:\n    Bob.Age=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, Bob.Purchase.Description=Lamborghini\n  Elapsed time: &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;01.0875454&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30000000&lt;/span&gt;\n\nDemo &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; of deep copy, &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;deserialize&lt;/span&gt;:\n  &lt;span class=&quot;hljs-title&quot;&gt;Elapsed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;time&lt;/span&gt;: 00:00:39.9339425,30000000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To understand how to do a deep copy using MemberwiseCopy, here is the demo project that was used to generate the times above:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Nested MemberwiseClone example. &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Added to demo how to deep copy a reference class.&lt;/span&gt;\n[&lt;span class=&quot;hljs-meta&quot;&gt;Serializable&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// Not required if using MemberwiseClone, only used for speed comparison using serialization.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; age, &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; description&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.Age = age;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.Purchase.Description = description;\n    }\n    [&lt;span class=&quot;hljs-meta&quot;&gt;Serializable&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// Not required if using MemberwiseClone&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PurchaseType&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; Description;\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; PurchaseType &lt;span class=&quot;hljs-title&quot;&gt;ShallowCopy&lt;/span&gt;()&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (PurchaseType)&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.MemberwiseClone();\n        }\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; PurchaseType Purchase = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PurchaseType();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; Age;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Add this if using nested MemberwiseClone.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This is a class, which is a reference type, so cloning is more difficult.&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Person &lt;span class=&quot;hljs-title&quot;&gt;ShallowCopy&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (Person)&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.MemberwiseClone();\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Add this if using nested MemberwiseClone.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This is a class, which is a reference type, so cloning is more difficult.&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Person &lt;span class=&quot;hljs-title&quot;&gt;DeepCopy&lt;/span&gt;()&lt;/span&gt;\n    {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Clone the root ...&lt;/span&gt;\n        Person other = (Person) &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.MemberwiseClone();\n            &lt;span class=&quot;hljs-comment&quot;&gt;// ... then clone the nested class.&lt;/span&gt;\n        other.Purchase = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.Purchase.ShallowCopy();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; other;\n    }\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;// Added to demo how to copy a value struct (this is easy - a deep copy happens by default)&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; PersonStruct\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PersonStruct&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; age, &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; description&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.Age = age;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.Purchase.Description = description;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; PurchaseType\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; Description;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; PurchaseType Purchase;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; Age;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This is a struct, which is a value type, so everything is a clone by default.&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; PersonStruct &lt;span class=&quot;hljs-title&quot;&gt;ShallowCopy&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (PersonStruct)&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This is a struct, which is a value type, so everything is a clone by default.&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; PersonStruct &lt;span class=&quot;hljs-title&quot;&gt;DeepCopy&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (PersonStruct)&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;\n    }\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;// Added only for a speed comparison.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyDeepCopy&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;DeepCopy&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T obj&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; result = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; ms = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MemoryStream())\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; formatter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BinaryFormatter();\n            formatter.Serialize(ms, obj);\n            ms.Position = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            result = (T)formatter.Deserialize(ms);\n            ms.Close();\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (T)result;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then, call the demo from main:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyMain&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n{\n    {\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Demo 1 of shallow and deep copy, using classes and MemberwiseCopy:\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; Bob = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lamborghini&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Create Bob\\n&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;&lt;/span&gt;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Clone Bob &amp;gt;&amp;gt; BobsSon\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; BobsSon = Bob.DeepCopy();\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Adjust BobsSon details\\n&quot;&lt;/span&gt;);\n        BobsSon.Age = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n        BobsSon.Purchase.Description = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Toy car&quot;&lt;/span&gt;;\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n&quot;&lt;/span&gt;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;&lt;/span&gt;, Bob.Age, Bob.Purchase.Description);\n        Debug.Assert(Bob.Age == &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n        Debug.Assert(Bob.Purchase.Description == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lamborghini&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sw = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Stopwatch();\n        sw.Start();\n        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; total = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;; i++)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Elapsed time: {0},{1}\\n\\n&quot;&lt;/span&gt;, sw.Elapsed, total);\n    }\n    {               \n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Demo 2 of shallow and deep copy, using structs:\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; Bob = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PersonStruct(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lamborghini&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Create Bob\\n&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;&lt;/span&gt;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Clone Bob &amp;gt;&amp;gt; BobsSon\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; BobsSon = Bob.DeepCopy();\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Adjust BobsSon details:\\n&quot;&lt;/span&gt;);\n        BobsSon.Age = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n        BobsSon.Purchase.Description = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Toy car&quot;&lt;/span&gt;;\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n&quot;&lt;/span&gt;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n&quot;&lt;/span&gt;);\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;&lt;/span&gt;, Bob.Age, Bob.Purchase.Description);                \n        Debug.Assert(Bob.Age == &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n        Debug.Assert(Bob.Purchase.Description == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lamborghini&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sw = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Stopwatch();\n        sw.Start();\n        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; total = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;; i++)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Elapsed time: {0},{1}\\n\\n&quot;&lt;/span&gt;, sw.Elapsed, total);\n    }\n    {\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Demo 3 of deep copy, using class and serialize/deserialize:\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; total = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sw = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Stopwatch();\n        sw.Start();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; Bob = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lamborghini&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;; i++)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; BobsSon = MyDeepCopy.DeepCopy&amp;lt;Person&amp;gt;(Bob);\n            total += BobsSon.Age;\n        }\n        Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Elapsed time: {0},{1}\\n&quot;&lt;/span&gt;, sw.Elapsed, total);\n    }\n    Console.ReadKey();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again, note that &lt;strong&gt;if&lt;/strong&gt; you use &lt;strong&gt;Nested MemberwiseClone for a deep copy&lt;/strong&gt;, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.&lt;/p&gt;\n&lt;h3&gt;Value types vs. References Types&lt;/h3&gt;\n&lt;p&gt;Note that when it comes to cloning an object, there is is a big difference between a &quot;&lt;strong&gt;struct&lt;/strong&gt;&quot; and a &quot;&lt;strong&gt;class&lt;/strong&gt;&quot;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;If you have a &quot;&lt;strong&gt;struct&lt;/strong&gt;&quot;, it&apos;s a &lt;strong&gt;value type&lt;/strong&gt; so you can just copy it, and the contents will be cloned (but it will only make a shallow clone unless you use the techniques in this post).&lt;/li&gt;\n&lt;li&gt;If you have a &quot;&lt;strong&gt;class&lt;/strong&gt;&quot;, it&apos;s a &lt;strong&gt;reference type&lt;/strong&gt;, so if you copy it, all you are doing is copying the pointer to it. To create a true clone, you have to be more creative, and use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx&quot; rel=&quot;noreferrer&quot;&gt;differences between value types and references types&lt;/a&gt; which creates another copy of the original object in memory.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;See &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx&quot; rel=&quot;noreferrer&quot;&gt;differences between value types and references types&lt;/a&gt;.&lt;/p&gt;\n&lt;h3&gt;Checksums to aid in debugging&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Cloning objects incorrectly can lead to very difficult-to-pin-down bugs. In production code, I tend to implement a checksum to double check that the object has been cloned properly, and hasn&apos;t been corrupted by another reference to it. This checksum can be switched off in Release mode.&lt;/li&gt;\n&lt;li&gt;I find this method quite useful: often, you only want to clone parts of the object, not the entire thing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Really useful for decoupling many threads from many other threads&lt;/h3&gt;\n&lt;p&gt;One excellent use case for this code is feeding clones of a nested class or struct into a queue, to implement the producer / consumer pattern.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;We can have one  (or more) threads modifying a class that they own, then pushing a complete copy of this class into a &lt;code&gt;ConcurrentQueue&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;We then have one (or more) threads pulling copies of these classes out and dealing with them.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This works extremely well in practice, and allows us to decouple many threads (the producers) from one or more threads (the consumers).&lt;/p&gt;\n&lt;p&gt;And this method is blindingly fast too: if we use nested structs, it&apos;s 35x faster than serializing/deserializing nested classes, and allows us to take advantage of all of the threads available on the machine.&lt;/p&gt;\n&lt;h1&gt;Update&lt;/h1&gt;\n&lt;p&gt;Apparently, ExpressMapper is as fast, if not faster, than hand coding such as above. I might have to see how they compare with a profiler.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;em&gt;Disclaimer: I&apos;m the author of the mentioned package.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;I was surprised how the top answers to this question in 2019 still use serialization or reflection. &lt;/p&gt;\n\n&lt;h2&gt;Serialization is limiting (requires attributes, specific constructors, etc.) and is very slow&lt;/h2&gt;\n\n&lt;p&gt;&lt;code&gt;BinaryFormatter&lt;/code&gt; requires the &lt;code&gt;Serializable&lt;/code&gt; attribute, &lt;code&gt;JsonConverter&lt;/code&gt; requires a parameterless constructor or attributes, neither handle read only fields or interfaces very well and both are 10-30x slower than necessary.&lt;/p&gt;\n\n&lt;h2&gt;Expression Trees&lt;/h2&gt;\n\n&lt;p&gt;You can instead use &lt;em&gt;Expression Trees&lt;/em&gt; or &lt;em&gt;Reflection.Emit&lt;/em&gt; to generate cloning code only once, then use that compiled code instead of slow reflection or serialization.&lt;/p&gt;\n\n&lt;p&gt;Having come across the problem myself and seeing no satisfactory solution, I decided to create a package that does just that and &lt;strong&gt;works with every type and is a almost as fast as custom written code&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;You can find the project on GitHub: &lt;a href=&quot;https://github.com/marcelltoth/ObjectCloner&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/marcelltoth/ObjectCloner&lt;/a&gt;&lt;/p&gt;\n\n&lt;h2&gt;Usage&lt;/h2&gt;\n\n&lt;p&gt;You can install it from NuGet. Either get the &lt;code&gt;ObjectCloner&lt;/code&gt; package and use it as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; clone = ObjectCloner.DeepClone(original);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if you don&apos;t mind polluting your object type with extensions get &lt;code&gt;ObjectCloner.Extensions&lt;/code&gt; as well and write:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; clone = original.DeepClone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Performance&lt;/h2&gt;\n\n&lt;p&gt;A simple benchmark of cloning a class hierarchy showed performance ~3x faster than using Reflection, ~12x faster than Newtonsoft.Json serialization and ~36x faster than the highly suggested &lt;code&gt;BinaryFormatter&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;ve seen it implemented through reflection as well. Basically there was a method that would iterate through the members of an object and appropriately copy them to the new object. When it reached reference types or collections I think it did a recursive call on itself. Reflection is expensive, but it worked pretty well.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is a deep copy implementation:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CloneObject&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; opSource&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;//grab the type and create a new instance of that type&lt;/span&gt;\n    Type opSourceType = opSource.GetType();\n    &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; opTarget = CreateInstanceOfType(opSourceType);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//grab the properties&lt;/span&gt;\n    PropertyInfo[] opPropertyInfo = opSourceType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//iterate over the properties and if it has a &apos;set&apos; method assign it from the source TO the target&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (PropertyInfo item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; opPropertyInfo)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (item.CanWrite)\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;//value types can simply be &apos;set&apos;&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (item.PropertyType.IsValueType || item.PropertyType.IsEnum || item.PropertyType.Equals(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(System.String)))\n            {\n                item.SetValue(opTarget, item.GetValue(opSource, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;), &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n            }\n            &lt;span class=&quot;hljs-comment&quot;&gt;//object/complex types need to recursively call this method until the end of the tree is reached&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n            {\n                &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; opPropertyValue = item.GetValue(opSource, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (opPropertyValue == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)\n                {\n                    item.SetValue(opTarget, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n                }\n                &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n                {\n                    item.SetValue(opTarget, CloneObject(opPropertyValue), &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n                }\n            }\n        }\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;//return the new item&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; opTarget;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As I couldn&apos;t find a cloner that meets all my requirements in different projects, I created a deep cloner that can be configured and adapted to different code structures instead of adapting my code to meet the cloners requirements. Its achieved by adding annotations to the code that shall be cloned or you just leave the code as it is to have the default behaviour. It uses reflection, type caches and is based on &lt;a href=&quot;https://fasterflect.codeplex.com/&quot; rel=&quot;noreferrer&quot;&gt;fasterflect&lt;/a&gt;. The cloning process is very fast for a huge amount of data and a high object hierarchy (compared to other reflection/serialization based algorithms). &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/kalisohn/CloneBehave&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/kalisohn/CloneBehave&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Also available as a nuget package:\n&lt;a href=&quot;https://www.nuget.org/packages/Clone.Behave/1.0.0&quot; rel=&quot;noreferrer&quot;&gt;https://www.nuget.org/packages/Clone.Behave/1.0.0&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;For example: The following code will deepClone Address, but only perform a shallow copy of the _currentJob field. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt; \n{\n  [&lt;span class=&quot;hljs-meta&quot;&gt;DeepClone(DeepCloneBehavior.Shallow)&lt;/span&gt;]\n  &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Job _currentJob;      \n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; Name { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Job CurrentJob \n  { \n    &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; _currentJob; }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;{ _currentJob = &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;; }\n  }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Person Manager { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Address&lt;/span&gt; \n{      \n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Person PersonLivingHere { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n}\n\nAddress adr = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Address();\nadr.PersonLivingHere = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;);\nadr.PersonLivingHere.BestFriend = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-string&quot;&gt;&quot;James&quot;&lt;/span&gt;);\nadr.PersonLivingHere.CurrentJob = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Job(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Programmer&quot;&lt;/span&gt;);\n\nAddress adrClone = adr.Clone();\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//RESULT&lt;/span&gt;\nadr.PersonLivingHere == adrClone.PersonLivingHere &lt;span class=&quot;hljs-comment&quot;&gt;//false&lt;/span&gt;\nadr.PersonLivingHere.Manager == adrClone.PersonLivingHere.Manager &lt;span class=&quot;hljs-comment&quot;&gt;//false&lt;/span&gt;\nadr.PersonLivingHere.CurrentJob == adrClone.PersonLivingHere.CurrentJob &lt;span class=&quot;hljs-comment&quot;&gt;//true&lt;/span&gt;\nadr.PersonLivingHere.CurrentJob.AnyProperty == adrClone.PersonLivingHere.CurrentJob.AnyProperty &lt;span class=&quot;hljs-comment&quot;&gt;//true&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Create an extension:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T theObject&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; jsonData = JsonConvert.SerializeObject(theObject);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;(jsonData);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And call it like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;NewObject = OldObject.Clone();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h1&gt;Code Generator&lt;/h1&gt;\n\n&lt;p&gt;We have seen a lot of ideas from serialization over manual implementation to reflection and I want to propose a totally different approach using the &lt;a href=&quot;https://github.com/Toxantron/CGbR#cloneable&quot; rel=&quot;noreferrer&quot;&gt;CGbR Code Generator&lt;/a&gt;. The generate clone method is memory and CPU efficient and therefor 300x faster as the standard DataContractSerializer.&lt;/p&gt;\n\n&lt;p&gt;All you need is a partial class definition with &lt;code&gt;ICloneable&lt;/code&gt; and the generator does the rest:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;partial&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Root&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;ICloneable&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Root&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; number&lt;/span&gt;)&lt;/span&gt;\n    {\n        _number = number;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; _number;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Partial[] Partials { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IList&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;ulong&lt;/span&gt;&amp;gt; Numbers { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Clone(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Root&lt;/span&gt;()&lt;/span&gt;\n    {\n    }\n} \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;partial&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Root&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Root &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; deep&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; copy = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Root();\n        &lt;span class=&quot;hljs-comment&quot;&gt;// All value types can be simply copied&lt;/span&gt;\n        copy._number = _number; \n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (deep)\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// In a deep clone the references are cloned &lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; tempPartials = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Partial[Partials.Length];\n            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Partials.Length; i++)\n            {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; = Partials[i];\n                &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;.Clone(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n                tempPartials[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;;\n            }\n            copy.Partials = tempPartials;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; tempNumbers = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;ulong&lt;/span&gt;&amp;gt;(Numbers.Count);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Numbers.Count; i++)\n            {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; = Numbers[i];\n                tempNumbers.Add(&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;);\n            }\n            copy.Numbers = tempNumbers;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// In a shallow clone only references are copied&lt;/span&gt;\n            copy.Partials = Partials; \n            copy.Numbers = Numbers; \n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; copy;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Latest version has a more null checks, but I left them out for better understanding.&lt;/p&gt;\n    ","\n&lt;p&gt;I like Copyconstructors like that:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AnyObject&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;AnyObject anyObject&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; property &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;AnyObject&lt;/span&gt;).&lt;span class=&quot;hljs-title&quot;&gt;GetProperties&lt;/span&gt;())&lt;/span&gt;\n        {\n            property.SetValue(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, property.GetValue(anyObject));\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; field &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;AnyObject&lt;/span&gt;).&lt;span class=&quot;hljs-title&quot;&gt;GetFields&lt;/span&gt;())&lt;/span&gt;\n        {\n            field.SetValue(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, field.GetValue(anyObject));\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you have more things to copy add them&lt;/p&gt;\n    ","\n&lt;p&gt;This method solved the problem for me:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; MyObj &lt;span class=&quot;hljs-title&quot;&gt;DeepCopy&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;MyObj source&lt;/span&gt;)&lt;/span&gt;\n        {\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; DeserializeSettings = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JsonSerializerSettings { ObjectCreationHandling = ObjectCreationHandling.Replace };\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;MyObj &amp;gt;(JsonConvert.SerializeObject(source), DeserializeSettings);\n\n        }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Use it like this: &lt;code&gt;MyObj a = DeepCopy(b);&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Here a solution fast and easy that worked for me without relaying on Serialization/Deserialization. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyClass&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; MyClass &lt;span class=&quot;hljs-title&quot;&gt;DeepClone&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; returnObj = (MyClass)MemberwiseClone();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; type = returnObj.GetType();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; fieldInfoArray = type.GetRuntimeFields().ToArray();\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; fieldInfo &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; fieldInfoArray)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; sourceFieldValue = fieldInfo.GetValue(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!(sourceFieldValue &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; MyClass))\n            {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;\n            }\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sourceObj = (MyClass)sourceFieldValue;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; clonedObj = sourceObj.DeepClone();\n            fieldInfo.SetValue(returnObj, clonedObj);\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; returnObj;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;:\nrequires &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Linq;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Reflection;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That&apos;s How I used it&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; MyClass &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;MyClass theObjectIneededToClone&lt;/span&gt;)&lt;/span&gt;\n{\n    MyClass clonedObj = theObjectIneededToClone.DeepClone();\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Follow these steps:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Define an &lt;code&gt;ISelf&amp;lt;T&amp;gt;&lt;/code&gt; with a read-only &lt;code&gt;Self&lt;/code&gt; property that returns &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;ICloneable&amp;lt;out T&amp;gt;&lt;/code&gt;, which derives from &lt;code&gt;ISelf&amp;lt;T&amp;gt;&lt;/code&gt; and includes a method &lt;code&gt;T Clone()&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Then define a &lt;code&gt;CloneBase&lt;/code&gt; type which implements a &lt;code&gt;protected virtual generic VirtualClone&lt;/code&gt; casting &lt;code&gt;MemberwiseClone&lt;/code&gt; to the passed-in type.  &lt;/li&gt;\n&lt;li&gt;Each derived type should implement &lt;code&gt;VirtualClone&lt;/code&gt; by calling the base clone method and then doing whatever needs to be done to properly clone those aspects of the derived type which the parent VirtualClone method hasn&apos;t yet handled.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;For maximum inheritance versatility, classes exposing public cloning functionality should be &lt;code&gt;sealed&lt;/code&gt;, but derive from a base class which is otherwise identical except for the lack of cloning.  Rather than passing variables of the explicit clonable type, take a parameter of type &lt;code&gt;ICloneable&amp;lt;theNonCloneableType&amp;gt;&lt;/code&gt;.  This will allow a routine that expects a cloneable derivative of  &lt;code&gt;Foo&lt;/code&gt; to work with a cloneable derivative of &lt;code&gt;DerivedFoo&lt;/code&gt;, but also allow the creation of non-cloneable derivatives of &lt;code&gt;Foo&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;As nearly all of the answers to this question have been unsatisfactory or plainly don&apos;t work in my situation, I have authored &lt;a href=&quot;https://github.com/replaysMike/AnyClone&quot; rel=&quot;noreferrer&quot;&gt;AnyClone&lt;/a&gt; which is entirely implemented with reflection and solved all of the needs here. I was unable to get serialization to work in a complicated scenario with complex structure, and &lt;code&gt;IClonable&lt;/code&gt; is less than ideal - in fact it shouldn&apos;t even be necessary.&lt;/p&gt;\n\n&lt;p&gt;Standard ignore attributes are supported using &lt;code&gt;[IgnoreDataMember]&lt;/code&gt;, &lt;code&gt;[NonSerialized]&lt;/code&gt;. Supports complex collections, properties without setters, readonly fields etc.&lt;/p&gt;\n\n&lt;p&gt;I hope it helps someone else out there who ran into the same problems I did.&lt;/p&gt;\n    ","\n&lt;p&gt;I have created a version of the accepted answer that works with both &apos;[Serializable]&apos; and &apos;[DataContract]&apos;. It has been a while since I wrote it, but if I remember correctly [DataContract] needed a different serializer.&lt;/p&gt;\n\n&lt;p&gt;Requires &lt;em&gt;System, System.IO, System.Runtime.Serialization, System.Runtime.Serialization.Formatters.Binary, System.Xml&lt;/em&gt;;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ObjectCopier&lt;/span&gt;\n{\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Perform a deep Copy of an object that is marked with &apos;[Serializable]&apos; or &apos;[DataContract]&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;The type of object being copied.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;The object instance to copy.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;The copied object.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;Clone&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T source&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T).IsSerializable == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; CloneUsingSerializable&amp;lt;T&amp;gt;(source);\n        }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (IsDataContract(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T)) == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; CloneUsingDataContracts&amp;lt;T&amp;gt;(source);\n        }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArgumentException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;The type must be Serializable or use DataContracts.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;source&quot;&lt;/span&gt;);\n    }\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Perform a deep Copy of an object that is marked with &apos;[Serializable]&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Found on http://stackoverflow.com/questions/78536/cloning-objects-in-c-sharp&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Uses code found on CodeProject, which allows free use in third party apps&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; - http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;The type of object being copied.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;The object instance to copy.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;The copied object.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;CloneUsingSerializable&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T source&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T).IsSerializable)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArgumentException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;The type must be serializable.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;source&quot;&lt;/span&gt;);\n        }\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t serialize a null object, simply return the default for that object&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (Object.ReferenceEquals(source, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;))\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;(T);\n        }\n\n        IFormatter formatter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BinaryFormatter();\n        Stream stream = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MemoryStream();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, SeekOrigin.Begin);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (T)formatter.Deserialize(stream);\n        }\n    }\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Perform a deep Copy of an object that is marked with &apos;[DataContract]&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;The type of object being copied.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;The object instance to copy.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;The copied object.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;CloneUsingDataContracts&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T source&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (IsDataContract(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T)) == &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArgumentException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;The type must be a data contract.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;source&quot;&lt;/span&gt;);\n        }\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ** Don&apos;t serialize a null object, simply return the default for that object&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (Object.ReferenceEquals(source, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;))\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;default&lt;/span&gt;(T);\n        }\n\n        DataContractSerializer dcs = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DataContractSerializer(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T));\n        &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt;(Stream stream = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MemoryStream())\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateBinaryWriter(stream))\n            {\n                dcs.WriteObject(writer, source);\n                writer.Flush();\n                stream.Seek(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, SeekOrigin.Begin);\n                &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; (XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))\n                {\n                    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (T)dcs.ReadObject(reader);\n                }\n            }\n        }\n    }\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Helper function to check if a class is a [DataContract]&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;type&quot;&amp;gt;&lt;/span&gt;The type of the object to check.&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;Boolean flag indicating if the class is a DataContract (true) or not (false) &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IsDataContract&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Type type&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] attributes = type.GetCustomAttributes(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(DataContractAttribute), &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; attributes.Length == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n} \n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":421,"title":"Deep cloning objects","content":"\n                \n&lt;p&gt;I want to do something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MyObject myObj = GetMyObj(); &lt;span class=&quot;hljs-comment&quot;&gt;// Create and fill a new object&lt;/span&gt;\nMyObject newObj = myObj.Clone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then make changes to the new object that are not reflected in the original object.&lt;/p&gt;\n\n&lt;p&gt;I don&apos;t often need this functionality, so when it&apos;s been necessary, I&apos;ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.&lt;/p&gt;\n\n&lt;p&gt;How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?&lt;/p&gt;\n    ","slug":"deep-cloning-objects-1657387930865","postType":"QUESTION","createdAt":"2022-07-09T17:32:10.000Z","updatedAt":"2022-07-09T17:32:10.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"Google Maps JS API v3 - Simple Multiple Marker Example","slug":"google-maps-js-api-v3-simple-multiple-marker-example-1657388073335"},{"title":"How to randomize (shuffle) a JavaScript array?","slug":"how-to-randomize-(shuffle)-a-javascript-array-1657384790171"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"Error in finding last used cell in Excel with VBA","slug":"error-in-finding-last-used-cell-in-excel-with-vba-1657384584748"},{"title":"Center one and right/left align other flexbox element","slug":"center-one-and-rightleft-align-other-flexbox-element-1657387899083"},{"title":"What methods of clearfix can I use?","slug":"what-methods-of-'clearfix'-can-i-use-1657387672727"},{"title":"How can I sanitize user input with PHP?","slug":"how-can-i-sanitize-user-input-with-php-1657387892329"},{"title":"Secure hash and salt for PHP passwords","slug":"secure-hash-and-salt-for-php-passwords-1657387363258"},{"title":"C++ Singleton design pattern","slug":"c++-singleton-design-pattern-1657387830040"},{"title":"mysqli or die, does it have to die?","slug":"mysqli-or-die-does-it-have-to-die-1657388533922"},{"title":"Crash or \"segmentation fault\" when data is copied/scanned/read to an uninitialized pointer","slug":"crash-or-\"segmentation-fault\"-when-data-is-copiedscannedread-to-an-uninitialized-pointer-1657387520581"},{"title":"Why JSF calls getters multiple times","slug":"why-jsf-calls-getters-multiple-times-1657388244489"},{"title":"Accessing an array out of bounds gives no error, why?","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"},{"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},{"title":"Collapse / concatenate / aggregate a column to a single comma separated string within each group","slug":"collapse-concatenate-aggregate-a-column-to-a-single-comma-separated-string-within-each-group-1657387870901"},{"title":"Where can I find documentation on formatting a date in JavaScript?","slug":"where-can-i-find-documentation-on-formatting-a-date-in-javascript-1657384878157"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057"}]},"__N_SSG":true}