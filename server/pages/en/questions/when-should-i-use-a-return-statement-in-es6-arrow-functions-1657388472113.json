{"pageProps":{"data":{"answer":["\n&lt;p&gt;Jackson has partially &lt;a href=&quot;https://stackoverflow.com/a/28135120/473961&quot;&gt;answered this&lt;/a&gt; in a similar question:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Implicit return, but only if there is no block.&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;This will result in errors when a one-liner expands to multiple lines and the programmer forgets to add a &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;\n  &lt;li&gt;Implicit return is syntactically ambiguous. &lt;code&gt;(name) =&amp;gt; {id: name}&lt;/code&gt;returns the object &lt;code&gt;{id: name}&lt;/code&gt;... right? Wrong. It returns &lt;code&gt;undefined&lt;/code&gt;. Those braces are an explicit block. &lt;code&gt;id:&lt;/code&gt; is a label.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I would add to this the definition of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&quot; rel=&quot;noreferrer&quot;&gt;block&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A block statement (or compound statement in other languages) is used to group zero or more statements. The block is delimited by a pair of curly brackets.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:\n&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: an empty block with an implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {})() \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: no block means implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name)(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return required inside block, but is missing.&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return in block exists&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: a block containing a single label. No explicit return.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: implicit return of expression ( ) which evaluates to an object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}))(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return inside block returns object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I understand this rule-of-thumb ... &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For functions that are effectively transforms (one-line-manipulations of arguments), return is implicit. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Candidates are:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// square-root &lt;/span&gt;\nvalue =&amp;gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(value)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// sum&lt;/span&gt;\n(a,b) =&amp;gt; a+b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For other operations (more than one-liners that require a block, return has to be explicit&lt;/p&gt;\n    ","\n&lt;p&gt;There&apos;s another case here.&lt;/p&gt;\n\n&lt;p&gt;When writing a functional component in React, you can use parentheses to wrap implicitly returned JSX.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FunctionalComponent&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;OtherComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s another case that gave me some trouble. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;tricky&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here we define a function returning an anonymous function.The &quot;tricky&quot; bit is that the function body for the outer function (the part begining with (bar) =&amp;gt; ...) visually looks like a &quot;block&quot;, but it&apos;s not. Since it&apos;s not, implicit return kicks in.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s how wrap would execute:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: foo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withoutfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withoutfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: nofoo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withoutfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The way I unpacked this to make sure I understood it was to &quot;unarrowify&quot; the functions.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the semantic equivalent of the first code block, simply making the body of wrap() do an explicit return. This definition produces the same results as above.  This is where the dots connect. Compare the first code block above with the one below, and it&apos;s clear that an arrow function itself is treated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body&quot; rel=&quot;noreferrer&quot;&gt;an expression, not a block, and has the implied return&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the explicit return way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The fully unarrowified version of wrap would be like this, which while not as compact as the fat arrowed up version, seems a lot easier to comprehend.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;no arrow functions&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; wrap = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  };\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the end, for others that may have to read my code, and future me, I think I&apos;d prefer to go the non arrow version which can be comprehended visually at first glance, rather than the arrow one which takes a fair bit of thought (and in my case experimentation) to grok.&lt;/p&gt;\n    ","\n&lt;p&gt;Arrow functions allow you to have an implicit return: values are returned without having to use the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;\n\n&lt;p&gt;It works when there is a on-line statement in the function body:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//&apos;test&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Another example, returning an object (remember to wrap the curly brackets in parentheses to avoid it being considered the wrapping function body brackets):&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//{value: &apos;test&apos;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Omitting the brackets {} and return keyword from an arrow function are ok if:\n(1) You wouldn&apos;t have any code (e.g. assignment statements) before the return statement and\n(2) You would be returning a single entity [Note: The single entity can be multiple lines.  If so, then all you need are regular parentheses() like the example below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;posts.&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;post&lt;/span&gt; =&amp;gt;&lt;/span&gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;{post.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    {post.title}\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n))\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":578,"title":"When should I use a return statement in ES6 arrow functions","content":"\n                \n&lt;p&gt;The new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; rel=&quot;noreferrer&quot;&gt;ES6 arrow functions&lt;/a&gt; say &lt;code&gt;return&lt;/code&gt; is implicit under some circumstances:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The expression is also the implicit return value of that function.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In what cases do I need to use &lt;code&gt;return&lt;/code&gt; with ES6 arrow functions?&lt;/p&gt;\n    ","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113","postType":"QUESTION","createdAt":"2022-07-09T17:41:12.000Z","updatedAt":"2022-07-09T17:41:12.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"},{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"},{"title":"Why does my recursive function return None?","slug":"why-does-my-recursive-function-return-none-1657387792894"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"What special characters must be escaped in regular expressions?","slug":"what-special-characters-must-be-escaped-in-regular-expressions-1657387465381"},{"title":"Storing Images in DB - Yea or Nay?","slug":"storing-images-in-db-yea-or-nay-1657387248067"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"How to append text to an existing file in Java?","slug":"how-to-append-text-to-an-existing-file-in-java-1657388492377"},{"title":"Difference between single and double quotes in Bash","slug":"difference-between-single-and-double-quotes-in-bash-1657385460827"},{"title":"Split comma-separated strings in a column into separate rows","slug":"split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},{"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583"},{"title":"Why is processing a sorted array faster than processing an unsorted array?","slug":"why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444"},{"title":"ggplot with 2 y axes on each side and different scales","slug":"ggplot-with-2-y-axes-on-each-side-and-different-scales-1657388519163"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"UTF-8 all the way through","slug":"utf-8-all-the-way-through-1657384323434"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"},{"title":"Query based on multiple where clauses in Firebase","slug":"query-based-on-multiple-where-clauses-in-firebase-1657387494547"},{"title":"Which characters are valid in CSS class names/selectors?","slug":"which-characters-are-valid-in-css-class-namesselectors-1657387959188"},{"title":"Accessing an array out of bounds gives no error, why?","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"}]},"__N_SSG":true}