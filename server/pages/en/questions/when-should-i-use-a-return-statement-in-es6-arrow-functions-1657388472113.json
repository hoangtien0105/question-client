{"pageProps":{"data":{"answer":["\n&lt;p&gt;Jackson has partially &lt;a href=&quot;https://stackoverflow.com/a/28135120/473961&quot;&gt;answered this&lt;/a&gt; in a similar question:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Implicit return, but only if there is no block.&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;This will result in errors when a one-liner expands to multiple lines and the programmer forgets to add a &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;\n  &lt;li&gt;Implicit return is syntactically ambiguous. &lt;code&gt;(name) =&amp;gt; {id: name}&lt;/code&gt;returns the object &lt;code&gt;{id: name}&lt;/code&gt;... right? Wrong. It returns &lt;code&gt;undefined&lt;/code&gt;. Those braces are an explicit block. &lt;code&gt;id:&lt;/code&gt; is a label.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I would add to this the definition of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&quot; rel=&quot;noreferrer&quot;&gt;block&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A block statement (or compound statement in other languages) is used to group zero or more statements. The block is delimited by a pair of curly brackets.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:\n&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: an empty block with an implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {})() \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: no block means implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name)(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return required inside block, but is missing.&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return in block exists&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: a block containing a single label. No explicit return.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: implicit return of expression ( ) which evaluates to an object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}))(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return inside block returns object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I understand this rule-of-thumb ... &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For functions that are effectively transforms (one-line-manipulations of arguments), return is implicit. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Candidates are:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// square-root &lt;/span&gt;\nvalue =&amp;gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(value)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// sum&lt;/span&gt;\n(a,b) =&amp;gt; a+b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For other operations (more than one-liners that require a block, return has to be explicit&lt;/p&gt;\n    ","\n&lt;p&gt;There&apos;s another case here.&lt;/p&gt;\n\n&lt;p&gt;When writing a functional component in React, you can use parentheses to wrap implicitly returned JSX.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FunctionalComponent&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;OtherComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s another case that gave me some trouble. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;tricky&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here we define a function returning an anonymous function.The &quot;tricky&quot; bit is that the function body for the outer function (the part begining with (bar) =&amp;gt; ...) visually looks like a &quot;block&quot;, but it&apos;s not. Since it&apos;s not, implicit return kicks in.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s how wrap would execute:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: foo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withoutfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withoutfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: nofoo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withoutfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The way I unpacked this to make sure I understood it was to &quot;unarrowify&quot; the functions.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the semantic equivalent of the first code block, simply making the body of wrap() do an explicit return. This definition produces the same results as above.  This is where the dots connect. Compare the first code block above with the one below, and it&apos;s clear that an arrow function itself is treated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body&quot; rel=&quot;noreferrer&quot;&gt;an expression, not a block, and has the implied return&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the explicit return way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The fully unarrowified version of wrap would be like this, which while not as compact as the fat arrowed up version, seems a lot easier to comprehend.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;no arrow functions&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; wrap = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  };\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the end, for others that may have to read my code, and future me, I think I&apos;d prefer to go the non arrow version which can be comprehended visually at first glance, rather than the arrow one which takes a fair bit of thought (and in my case experimentation) to grok.&lt;/p&gt;\n    ","\n&lt;p&gt;Arrow functions allow you to have an implicit return: values are returned without having to use the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;\n\n&lt;p&gt;It works when there is a on-line statement in the function body:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//&apos;test&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Another example, returning an object (remember to wrap the curly brackets in parentheses to avoid it being considered the wrapping function body brackets):&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//{value: &apos;test&apos;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Omitting the brackets {} and return keyword from an arrow function are ok if:\n(1) You wouldn&apos;t have any code (e.g. assignment statements) before the return statement and\n(2) You would be returning a single entity [Note: The single entity can be multiple lines.  If so, then all you need are regular parentheses() like the example below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;posts.&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;post&lt;/span&gt; =&amp;gt;&lt;/span&gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;{post.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    {post.title}\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n))\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":578,"title":"When should I use a return statement in ES6 arrow functions","content":"\n                \n&lt;p&gt;The new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; rel=&quot;noreferrer&quot;&gt;ES6 arrow functions&lt;/a&gt; say &lt;code&gt;return&lt;/code&gt; is implicit under some circumstances:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The expression is also the implicit return value of that function.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In what cases do I need to use &lt;code&gt;return&lt;/code&gt; with ES6 arrow functions?&lt;/p&gt;\n    ","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113","postType":"QUESTION","createdAt":"2022-07-09T17:41:12.000Z","updatedAt":"2022-07-09T17:41:12.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"How to reshape data from long to wide format","slug":"how-to-reshape-data-from-long-to-wide-format-1657384486421"},{"title":"How do I import a module given the full path?","slug":"how-do-i-import-a-module-given-the-full-path-1657388139965"},{"title":"How can I convert ereg expressions to preg in PHP?","slug":"how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855"},{"title":"Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()","slug":"truth-value-of-a-series-is-ambiguous.-use-a.empty-a.bool()-a.item()-a.any()-or-a.all()-1657387724259"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version","slug":"how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422"},{"title":"Persist variables between page loads","slug":"persist-variables-between-page-loads-1657388558452"},{"title":"How do I undo the most recent local commits in Git?","slug":"how-do-i-undo-the-most-recent-local-commits-in-git-1657388262945"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"How to get all possible combinations of a list’s elements?","slug":"how-to-get-all-possible-combinations-of-a-list's-elements-1657388271070"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"How does the \"this\" keyword work, and when should it be used?","slug":"how-does-the-\"this\"-keyword-work-and-when-should-it-be-used-1657384384385"},{"title":"What are the rules about using an underscore in a C++ identifier?","slug":"what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197"},{"title":"What is the (function() { } )() construct in JavaScript?","slug":"what-is-the-(function()-)()-construct-in-javascript-1657385508348"},{"title":"What does \"Fatal error: Unexpectedly found nil while unwrapping an Optional value\" mean?","slug":"what-does-\"fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value\"-mean-1657384593944"},{"title":"How to use ThreeTenABP in Android Project","slug":"how-to-use-threetenabp-in-android-project-1657384345704"},{"title":"How to filter Pandas dataframe using 'in' and 'not in' like in SQL","slug":"how-to-filter-pandas-dataframe-using-'in'-and-'not-in'-like-in-sql-1657387371355"},{"title":"Selenium - wait until element is present, visible and interactable","slug":"selenium-wait-until-element-is-present-visible-and-interactable-1657384820071"},{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"}]},"__N_SSG":true}