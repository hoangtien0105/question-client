{"pageProps":{"data":{"answer":["\n&lt;p&gt;Jackson has partially &lt;a href=&quot;https://stackoverflow.com/a/28135120/473961&quot;&gt;answered this&lt;/a&gt; in a similar question:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Implicit return, but only if there is no block.&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;This will result in errors when a one-liner expands to multiple lines and the programmer forgets to add a &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;\n  &lt;li&gt;Implicit return is syntactically ambiguous. &lt;code&gt;(name) =&amp;gt; {id: name}&lt;/code&gt;returns the object &lt;code&gt;{id: name}&lt;/code&gt;... right? Wrong. It returns &lt;code&gt;undefined&lt;/code&gt;. Those braces are an explicit block. &lt;code&gt;id:&lt;/code&gt; is a label.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I would add to this the definition of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&quot; rel=&quot;noreferrer&quot;&gt;block&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A block statement (or compound statement in other languages) is used to group zero or more statements. The block is delimited by a pair of curly brackets.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:\n&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: an empty block with an implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {})() \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: no block means implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name)(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return required inside block, but is missing.&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return in block exists&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: a block containing a single label. No explicit return.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: implicit return of expression ( ) which evaluates to an object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}))(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return inside block returns object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I understand this rule-of-thumb ... &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For functions that are effectively transforms (one-line-manipulations of arguments), return is implicit. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Candidates are:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// square-root &lt;/span&gt;\nvalue =&amp;gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(value)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// sum&lt;/span&gt;\n(a,b) =&amp;gt; a+b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For other operations (more than one-liners that require a block, return has to be explicit&lt;/p&gt;\n    ","\n&lt;p&gt;There&apos;s another case here.&lt;/p&gt;\n\n&lt;p&gt;When writing a functional component in React, you can use parentheses to wrap implicitly returned JSX.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FunctionalComponent&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;OtherComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s another case that gave me some trouble. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;tricky&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here we define a function returning an anonymous function.The &quot;tricky&quot; bit is that the function body for the outer function (the part begining with (bar) =&amp;gt; ...) visually looks like a &quot;block&quot;, but it&apos;s not. Since it&apos;s not, implicit return kicks in.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s how wrap would execute:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: foo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withoutfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withoutfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: nofoo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withoutfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The way I unpacked this to make sure I understood it was to &quot;unarrowify&quot; the functions.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the semantic equivalent of the first code block, simply making the body of wrap() do an explicit return. This definition produces the same results as above.  This is where the dots connect. Compare the first code block above with the one below, and it&apos;s clear that an arrow function itself is treated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body&quot; rel=&quot;noreferrer&quot;&gt;an expression, not a block, and has the implied return&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the explicit return way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The fully unarrowified version of wrap would be like this, which while not as compact as the fat arrowed up version, seems a lot easier to comprehend.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;no arrow functions&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; wrap = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  };\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the end, for others that may have to read my code, and future me, I think I&apos;d prefer to go the non arrow version which can be comprehended visually at first glance, rather than the arrow one which takes a fair bit of thought (and in my case experimentation) to grok.&lt;/p&gt;\n    ","\n&lt;p&gt;Arrow functions allow you to have an implicit return: values are returned without having to use the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;\n\n&lt;p&gt;It works when there is a on-line statement in the function body:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//&apos;test&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Another example, returning an object (remember to wrap the curly brackets in parentheses to avoid it being considered the wrapping function body brackets):&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//{value: &apos;test&apos;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Omitting the brackets {} and return keyword from an arrow function are ok if:\n(1) You wouldn&apos;t have any code (e.g. assignment statements) before the return statement and\n(2) You would be returning a single entity [Note: The single entity can be multiple lines.  If so, then all you need are regular parentheses() like the example below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;posts.&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;post&lt;/span&gt; =&amp;gt;&lt;/span&gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;{post.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    {post.title}\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n))\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":578,"title":"When should I use a return statement in ES6 arrow functions","content":"\n                \n&lt;p&gt;The new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; rel=&quot;noreferrer&quot;&gt;ES6 arrow functions&lt;/a&gt; say &lt;code&gt;return&lt;/code&gt; is implicit under some circumstances:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The expression is also the implicit return value of that function.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In what cases do I need to use &lt;code&gt;return&lt;/code&gt; with ES6 arrow functions?&lt;/p&gt;\n    ","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113","postType":"QUESTION","createdAt":"2022-07-09T17:41:12.000Z","updatedAt":"2022-07-09T17:41:12.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why should I not #include <bits/stdc++.h>?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"\"Least Astonishment\" and the Mutable Default Argument","slug":"\"least-astonishment\"-and-the-mutable-default-argument-1657384412508"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Scroll to an element with jQuery","slug":"scroll-to-an-element-with-jquery-1657388523178"},{"title":"How do we control web page caching, across all browsers?","slug":"how-do-we-control-web-page-caching-across-all-browsers-1657387529059"},{"title":"How to check if element is visible after scrolling?","slug":"how-to-check-if-element-is-visible-after-scrolling-1657387987960"},{"title":"getContactsFromFirebase() method return an empty list","slug":"getcontactsfromfirebase()-method-return-an-empty-list-1657388433928"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"How does Access-Control-Allow-Origin header work?","slug":"how-does-access-control-allow-origin-header-work-1657384881723"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"How do I expire a PHP session after 30 minutes?","slug":"how-do-i-expire-a-php-session-after-30-minutes-1657387990658"},{"title":"Is there a built in function for string natural sort?","slug":"is-there-a-built-in-function-for-string-natural-sort-1657388069553"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"How do I match any character across multiple lines in a regular expression?","slug":"how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720"},{"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"},{"title":"How do I Pandas group-by to get sum?","slug":"how-do-i-pandas-group-by-to-get-sum-1657387908708"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"}]},"__N_SSG":true}