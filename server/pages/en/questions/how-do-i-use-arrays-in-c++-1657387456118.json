{"pageProps":{"data":{"answer":["\n&lt;h1&gt;Arrays on the type level&lt;/h1&gt;\n\n&lt;p&gt;An array type is denoted as &lt;code&gt;T[n]&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the &lt;em&gt;element type&lt;/em&gt; and &lt;code&gt;n&lt;/code&gt; is a positive &lt;em&gt;size&lt;/em&gt;, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!std::is_same&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;], &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;distinct element type&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!std::is_same&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;],   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;distinct size&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. &lt;code&gt;sizeof(T[n])&lt;/code&gt; is equivalent to &lt;code&gt;n * sizeof(T)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Array-to-pointer decay&lt;/h2&gt;\n\n&lt;p&gt;The only &quot;connection&quot; between &lt;code&gt;T[n]&lt;/code&gt; and &lt;code&gt;T[m]&lt;/code&gt; is that both types can implicitly be &lt;em&gt;converted&lt;/em&gt; to &lt;code&gt;T*&lt;/code&gt;, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a &lt;code&gt;T*&lt;/code&gt; is required, you can provide a &lt;code&gt;T[n]&lt;/code&gt;, and the compiler will silently provide that pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;                  +---+---+---+---+---+---+---+---+\nthe_actual_array: |   |   |   |   |   |   |   |   |   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n                  +---+---+---+---+---+---+---+---+\n                    ^\n                    |\n                    |\n                    |\n                    |  pointer_to_the_first_element   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This conversion is known as &quot;array-to-pointer decay&quot;, and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (&lt;code&gt;T*&lt;/code&gt;). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of &lt;em&gt;any&lt;/em&gt; size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. &lt;a href=&quot;https://stackoverflow.com/questions/4261074/&quot;&gt;Pointers are extremely stupid&lt;/a&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Arrays are not pointers&lt;/h2&gt;\n\n&lt;p&gt;The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer &lt;em&gt;value&lt;/em&gt; is simply the address of the array. Note that the pointer is &lt;em&gt;not&lt;/em&gt; stored as part of the array itself (or anywhere else in memory). &lt;strong&gt;An array is not a pointer.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!std::is_same&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;], &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;an array is not a pointer&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One important context in which an array does &lt;em&gt;not&lt;/em&gt; decay into a pointer to its first element is when the &lt;code&gt;&amp;amp;&lt;/code&gt; operator is applied to it. In that case, the &lt;code&gt;&amp;amp;&lt;/code&gt; operator yields a pointer to the &lt;em&gt;entire&lt;/em&gt; array, not just a pointer to its first element. Although in that case the &lt;em&gt;values&lt;/em&gt; (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!std::is_same&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;(*)[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;distinct element type&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The following ASCII art explains this distinction:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;      +-----------------------------------+\n      | +---+---+---+---+---+---+---+---+ |\n+---&amp;gt; | |   |   |   |   |   |   |   |   | | &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n|     | +---+---+---+---+---+---+---+---+ |\n|     +---^-------------------------------+\n|         |\n|         |\n|         |\n|         |  pointer_to_the_first_element   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n|\n|  &lt;span class=&quot;hljs-function&quot;&gt;pointer_to_the_entire_array              &lt;span class=&quot;hljs-title&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*)&lt;/span&gt;[8]\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).&lt;/p&gt;\n\n&lt;p&gt;The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same &lt;em&gt;value&lt;/em&gt; (the same address), yet they are completely distinct types.&lt;/p&gt;\n\n&lt;p&gt;If you are unfamiliar with the C declarator syntax, the parenthesis in the type &lt;code&gt;int(*)[8]&lt;/code&gt; are essential:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;int(*)[8]&lt;/code&gt; is a pointer to an array of 8 integers.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;int*[8]&lt;/code&gt; is an array of 8 pointers, each element of type &lt;code&gt;int*&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h1&gt;Accessing elements&lt;/h1&gt;\n\n&lt;p&gt;C++ provides two syntactic variations to access individual elements of an array.\nNeither of them is superior to the other, and you should familiarize yourself with both.&lt;/p&gt;\n\n&lt;h2&gt;Pointer arithmetic&lt;/h2&gt;\n\n&lt;p&gt;Given a pointer &lt;code&gt;p&lt;/code&gt; to the first element of an array, the expression &lt;code&gt;p+i&lt;/code&gt; yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cout &amp;lt;&amp;lt; *(x+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; *(x+&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; std::endl;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If &lt;code&gt;x&lt;/code&gt; denotes an &lt;em&gt;array&lt;/em&gt;, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   +---+---+---+---+---+---+---+---+\nx: |   |   |   |   |   |   |   |   |   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n     |           |               |\nx+&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  |      x+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;  |          x+&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;  |     &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Note that the implicitly generated pointer has no name, so I wrote &lt;code&gt;x+0&lt;/code&gt; in order to identify it.)&lt;/p&gt;\n\n&lt;p&gt;If, on the other hand, &lt;code&gt;x&lt;/code&gt; denotes a &lt;em&gt;pointer&lt;/em&gt; to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which &lt;code&gt;i&lt;/code&gt; is going to be added already exists:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   +---+---+---+---+---+---+---+---+\n   |   |   |   |   |   |   |   |   |   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n   +-|-+         |               |\nx: | | |    x+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;  |          x+&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;  |     &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n   +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that in the depicted case, &lt;code&gt;x&lt;/code&gt; is a pointer &lt;em&gt;variable&lt;/em&gt; (discernible by the small box next to &lt;code&gt;x&lt;/code&gt;), but it could just as well be the result of a function returning a pointer (or any other expression of type &lt;code&gt;T*&lt;/code&gt;).&lt;/p&gt;\n\n&lt;h2&gt;Indexing operator&lt;/h2&gt;\n\n&lt;p&gt;Since the syntax &lt;code&gt;*(x+i)&lt;/code&gt; is a bit clumsy, C++ provides the alternative syntax &lt;code&gt;x[i]&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cout &amp;lt;&amp;lt; x[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; x[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;] &amp;lt;&amp;lt; std::endl;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Due to the fact that addition is commutative, the following code does exactly the same:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;[x] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;[x] &amp;lt;&amp;lt; std::endl;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The definition of the indexing operator leads to the following interesting equivalence:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;amp;x[i]  ==  &amp;amp;*(x+i)  ==  x+i\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; is generally &lt;em&gt;not&lt;/em&gt; equivalent to &lt;code&gt;x&lt;/code&gt;. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; be used interchangeably. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;T* p = &amp;amp;array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];  &lt;span class=&quot;hljs-comment&quot;&gt;// rewritten as &amp;amp;*(array+0), decay happens due to the addition&lt;/span&gt;\nT* q = array;      &lt;span class=&quot;hljs-comment&quot;&gt;// decay happens due to the assignment&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;On the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an &lt;em&gt;array&lt;/em&gt; to a pointer. Since this is meaningless (but &lt;em&gt;pointer&lt;/em&gt; to pointer assignment makes sense), array-to-pointer decay kicks in as usual.&lt;/p&gt;\n\n&lt;h2&gt;Ranges&lt;/h2&gt;\n\n&lt;p&gt;An array of type &lt;code&gt;T[n]&lt;/code&gt; has &lt;code&gt;n&lt;/code&gt; elements, indexed from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;; there is no element &lt;code&gt;n&lt;/code&gt;. And yet, to support half-open ranges (where the beginning is &lt;em&gt;inclusive&lt;/em&gt; and the end is &lt;em&gt;exclusive&lt;/em&gt;), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   +---+---+---+---+---+---+---+---+....\nx: |   |   |   |   |   |   |   |   |   .   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n   +---+---+---+---+---+---+---+---+....\n     ^                               ^\n     |                               |\n     |                               |\n     |                               |\nx+&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  |                          x+&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;  |     &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For example, if you want to sort an array, both of the following would work equally well:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(x + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, x + n);\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(&amp;amp;x[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], &amp;amp;x[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] + n);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that it is illegal to provide &lt;code&gt;&amp;amp;x[n]&lt;/code&gt; as the second argument since this is equivalent to &lt;code&gt;&amp;amp;*(x+n)&lt;/code&gt;, and the sub-expression &lt;code&gt;*(x+n)&lt;/code&gt; technically invokes &lt;a href=&quot;https://stackoverflow.com/questions/3144904/&quot;&gt;undefined behavior&lt;/a&gt; in C++ (but not in C99).&lt;/p&gt;\n\n&lt;p&gt;Also note that you could simply provide &lt;code&gt;x&lt;/code&gt; as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)&lt;/p&gt;\n    ","\n&lt;p&gt;Programmers often confuse multidimensional arrays with arrays of pointers.&lt;/p&gt;\n\n&lt;h1&gt;Multidimensional arrays&lt;/h1&gt;\n\n&lt;p&gt;Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as &quot;arrays of arrays&quot; or &quot;&lt;em&gt;true&lt;/em&gt; multidimensional arrays&quot;.&lt;/p&gt;\n\n&lt;h2&gt;Named multidimensional arrays&lt;/h2&gt;\n\n&lt;p&gt;When using named multidimensional arrays, &lt;em&gt;all&lt;/em&gt; dimensions must be known at compile time:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; H = &lt;span class=&quot;hljs-built_in&quot;&gt;read_int&lt;/span&gt;();\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; W = &lt;span class=&quot;hljs-built_in&quot;&gt;read_int&lt;/span&gt;();\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];   &lt;span class=&quot;hljs-comment&quot;&gt;// okay&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[H][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];   &lt;span class=&quot;hljs-comment&quot;&gt;// ISO C++ forbids variable length array&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][W];   &lt;span class=&quot;hljs-comment&quot;&gt;// ISO C++ forbids variable length array&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[H][W];   &lt;span class=&quot;hljs-comment&quot;&gt;// ISO C++ forbids variable length array&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is how a named multidimensional array looks like in memory:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;              +---+---+---+---+---+---+---+\nconnect_four: |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a &quot;flat&quot; sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, &lt;code&gt;connect_four[0][6]&lt;/code&gt; and &lt;code&gt;connect_four[1][0]&lt;/code&gt; are neighbors in memory. In fact, &lt;code&gt;connect_four[0][7]&lt;/code&gt; and &lt;code&gt;connect_four[1][0]&lt;/code&gt; denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = &amp;amp;connect_four[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* q = p + &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;some_int_sequence_algorithm&lt;/span&gt;(p, q);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Anonymous multidimensional arrays&lt;/h2&gt;\n\n&lt;p&gt;With anonymous multidimensional arrays, all dimensions &lt;em&gt;except the first&lt;/em&gt; must be known at compile time:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; (*p)[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];   &lt;span class=&quot;hljs-comment&quot;&gt;// okay&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; (*p)[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[H][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];   &lt;span class=&quot;hljs-comment&quot;&gt;// okay&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; (*p)[W] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][W];   &lt;span class=&quot;hljs-comment&quot;&gt;// ISO C++ forbids variable length array&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; (*p)[W] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[H][W];   &lt;span class=&quot;hljs-comment&quot;&gt;// ISO C++ forbids variable length array&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is how an anonymous multidimensional array looks like in memory:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;              +---+---+---+---+---+---+---+\n        +---&amp;gt; |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |\n      +-|-+\n   p: | | |\n      +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the array itself is still allocated as a single block in memory.&lt;/p&gt;\n\n&lt;h1&gt;Arrays of pointers&lt;/h1&gt;\n\n&lt;p&gt;You can overcome the restriction of fixed width by introducing another level of indirection.&lt;/p&gt;\n\n&lt;h2&gt;Named arrays of pointers&lt;/h2&gt;\n\n&lt;p&gt;Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* triangle[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; ++i)\n{\n    triangle[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; - i];\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; ++i)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] triangle[i];\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And here is how it looks like in memory:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\ntriangle: | | | | | | | | | | |\n          +---+---+---+---+---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.&lt;/p&gt;\n\n&lt;h2&gt;Anonymous arrays of pointers&lt;/h2&gt;\n\n&lt;p&gt;Here is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;hljs-built_in&quot;&gt;calculate_five&lt;/span&gt;();   &lt;span class=&quot;hljs-comment&quot;&gt;// or any other number&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;** p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*[n];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)\n{\n    p[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[n - i];\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p[i];\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p;   &lt;span class=&quot;hljs-comment&quot;&gt;// note the extra delete[] !&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And here is how it looks like in memory:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\n          | | | | | | | | | | |\n          +---+---+---+---+---+\n            ^\n            |\n            |\n          +-|-+\n       p: | | |\n          +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Conversions&lt;/h1&gt;\n\n&lt;p&gt;Array-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; array_of_arrays[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; (*pointer_to_array)[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;] = array_of_arrays;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* array_of_pointers[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;** pointer_to_pointer = array_of_pointers;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, there is no implicit conversion from &lt;code&gt;T[h][w]&lt;/code&gt; to &lt;code&gt;T**&lt;/code&gt;. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of &lt;code&gt;h&lt;/code&gt; pointers to &lt;code&gt;T&lt;/code&gt; (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;** p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;; ++i)\n{\n    p[i] = connect_four[i];\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; connect_four[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;** p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;; ++i)\n{\n    p[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;copy&lt;/span&gt;(connect_four[i], connect_four[i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], p[i]);\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;; ++i)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p[i];\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h1&gt;Assignment&lt;/h1&gt;\n\n&lt;p&gt;For no particular reason, arrays cannot be assigned to one another. Use &lt;code&gt;std::copy&lt;/code&gt; instead:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;};\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;copy&lt;/span&gt;(a + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, a + &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, b);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.\n&lt;code&gt;std::copy&lt;/code&gt; is usually specialized for primitive types to give maximum performance. It is unlikely that &lt;code&gt;std::memcpy&lt;/code&gt; performs better. If in doubt, measure.&lt;/p&gt;\n\n&lt;p&gt;Although you cannot assign arrays directly, you &lt;em&gt;can&lt;/em&gt; assign structs and classes which &lt;em&gt;contain&lt;/em&gt; array members. That is because &lt;a href=&quot;https://stackoverflow.com/questions/4164279/&quot;&gt;array members are copied memberwise&lt;/a&gt; by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.&lt;/p&gt;\n\n&lt;h1&gt;Parameter passing&lt;/h1&gt;\n\n&lt;p&gt;Arrays cannot be passed by value. You can either pass them by pointer or by reference.&lt;/p&gt;\n\n&lt;h2&gt;Pass by pointer&lt;/h2&gt;\n\n&lt;p&gt;Since arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called &quot;pass by pointer&quot;. Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;numeric&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;cstddef&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p, std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::&lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(p, p + n, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* q)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::&lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(p, q, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As a syntactic alternative, you can also declare parameters as &lt;code&gt;T p[]&lt;/code&gt;, and it means the exact same thing as &lt;code&gt;T* p&lt;/code&gt; &lt;strong&gt;in the context of parameter lists only&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; p[], std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::&lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(p, p + n, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can think of the compiler as rewriting &lt;code&gt;T p[]&lt;/code&gt; to &lt;code&gt;T *p&lt;/code&gt; &lt;strong&gt;in the context of parameter lists only&lt;/strong&gt;. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a &lt;em&gt;huge&lt;/em&gt; difference.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p, std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n)&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// error: redefinition of &apos;int sum(const int*, size_t)&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; p[], std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n)&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// error: redefinition of &apos;int sum(const int*, size_t)&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; p[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;], std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n)&lt;/span&gt;   &lt;span class=&quot;hljs-comment&quot;&gt;// the 8 has no meaning here&lt;/span&gt;\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Pass by reference&lt;/h2&gt;\n\n&lt;p&gt;Arrays can also be passed by reference:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (&amp;amp;a)[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::&lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(a + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, a + &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (&amp;amp;a)[n])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::&lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(a + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, a + n, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size &lt;code&gt;n&lt;/code&gt;, a different function is instantiated from the template. You can also write &lt;a href=&quot;https://stackoverflow.com/questions/4759078/&quot;&gt;quite useful&lt;/a&gt; function templates that abstract from both the element type and from the size.&lt;/p&gt;\n    ","\n&lt;h1&gt;5. Common pitfalls when using arrays.&lt;/h1&gt;\n\n&lt;h2&gt;5.1 Pitfall: Trusting type-unsafe linking.&lt;/h2&gt;\n\n&lt;p&gt;OK, youve been told, or have found out yourself, that globals (namespace\nscope variables that can be accessed outside the translation unit) are\nEvil. But did you know how truly Evil they are? Consider the\nprogram below, consisting of two files [main.cpp] and [numbers.cpp]:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// [main.cpp]&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* numbers;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;  i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;;  ++i )\n    {\n        cout &amp;lt;&amp;lt; (i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;? &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; numbers[i];\n    }\n    cout &amp;lt;&amp;lt; endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// [numbers.cpp]&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; numbers[&lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and\nVisual C++ 10.0.&lt;/p&gt;\n\n&lt;p&gt;Since the types don&apos;t match, the program crashes when you run it.&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/v7KJF.png&quot; alt=&quot;The Windows 7 crash dialog&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;In-the-formal explanation: the program has Undefined Behavior (UB), and instead\nof crashing it can therefore just hang, or perhaps do nothing, or it\ncan send threating e-mails to the presidents of the USA, Russia, India,\nChina and Switzerland, and make Nasal Daemons fly out of your nose.&lt;/p&gt;\n\n&lt;p&gt;In-practice explanation: in &lt;code&gt;main.cpp&lt;/code&gt; the array is treated as a pointer, placed\nat the same address as the array. For 32-bit executable this means that the first\n&lt;code&gt;int&lt;/code&gt; value in the array, is treated as a pointer. I.e., in &lt;code&gt;main.cpp&lt;/code&gt; the\n&lt;code&gt;numbers&lt;/code&gt; variable contains, or appears to contain, &lt;code&gt;(int*)1&lt;/code&gt;. This causes the\nprogram to access memory down at very bottom of the address space, which is\nconventionally reserved and trap-causing. Result: you get a crash.&lt;/p&gt;\n\n&lt;p&gt;The compilers are fully within their rights to not diagnose this error,\nbecause C++11 ยง3.5/10 says, about the requirement of compatible types\nfor the declarations,&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;[N3290 ยง3.5/10]&lt;/strong&gt;&lt;br&gt;\n  A violation of this rule on type identity does not require a diagnostic.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The same paragraph details the variation that is allowed:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt; declarations for an array object can specify array types that\n  differ by the presence or absence of a major array bound (8.3.4).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This allowed variation does not include declaring a name as an array in one\ntranslation unit, and as a pointer in another translation unit.    &lt;/p&gt;\n\n&lt;h2&gt;5.2 Pitfall: Doing premature optimization (&lt;code&gt;memset&lt;/code&gt; &amp;amp; friends).&lt;/h2&gt;\n\n&lt;p&gt;&lt;em&gt;Not written yet&lt;/em&gt;&lt;/p&gt;\n\n&lt;h2&gt;5.3 Pitfall: Using the C idiom to get number of elements.&lt;/h2&gt;\n\n&lt;p&gt;With deep C experience its natural to write &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; N_ITEMS( array )   (sizeof( array )/sizeof( array[0] ))&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since an &lt;code&gt;array&lt;/code&gt; decays to pointer to first element where needed, the\nexpression &lt;code&gt;sizeof(a)/sizeof(a[0])&lt;/code&gt; can also be written as\n&lt;code&gt;sizeof(a)/sizeof(*a)&lt;/code&gt;. It means the same, and no matter how its\nwritten it is the &lt;strong&gt;C idiom&lt;/strong&gt; for finding the number elements of array.&lt;/p&gt;\n\n&lt;p&gt;Main pitfall: the C idiom is not typesafe. For example, the code\n&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; N_ITEMS( array ) (sizeof( array )/sizeof( *array ))&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;] )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;   n = &lt;span class=&quot;hljs-built_in&quot;&gt;N_ITEMS&lt;/span&gt;( a );          &lt;span class=&quot;hljs-comment&quot;&gt;// Oops.&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d elements.\\n&quot;&lt;/span&gt;, n );\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;   moohaha[]   = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;};\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d elements, calling display...\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;N_ITEMS&lt;/span&gt;( moohaha ) );\n    &lt;span class=&quot;hljs-built_in&quot;&gt;display&lt;/span&gt;( moohaha );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;passes a pointer to &lt;code&gt;N_ITEMS&lt;/code&gt;, and therefore most likely produces a wrong\nresult. Compiled as a 32-bit executable in Windows 7 it produces &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;7 elements, calling display...&lt;br&gt;\n  1 elements.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;ol&gt;\n&lt;li&gt;The compiler rewrites &lt;code&gt;int const a[7]&lt;/code&gt; to just &lt;code&gt;int const a[]&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;The compiler rewrites &lt;code&gt;int const a[]&lt;/code&gt; to &lt;code&gt;int const* a&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;N_ITEMS&lt;/code&gt; is therefore invoked with a pointer.&lt;/li&gt;\n&lt;li&gt;For a 32-bit executable &lt;code&gt;sizeof(array)&lt;/code&gt; (size of a pointer) is then 4.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;sizeof(*array)&lt;/code&gt; is equivalent to &lt;code&gt;sizeof(int)&lt;/code&gt;, which for a 32-bit executable is also 4.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;In order to detect this error at run time you can do &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; N_ITEMS( array )       (                               \\\n    assert((                                                    \\\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;N_ITEMS requires an actual array as argument&quot;&lt;/span&gt;,        \\\n        typeid( array ) != typeid( &amp;amp;*array )                    \\\n        )),                                                     \\\n    sizeof( array )/sizeof( *array )                            \\\n    )&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;7 elements, calling display...&lt;br&gt;\n  Assertion failed: ( &quot;N_ITEMS requires an actual array as argument&quot;, typeid( a ) != typeid( &amp;amp;*a ) ), file runtime_detect\n  ion.cpp, line 16  &lt;/p&gt;\n  \n  &lt;p&gt;This application has requested the Runtime to terminate it in an unusual way.&lt;br&gt;\n  Please contact the application&apos;s support team for more information.  &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The runtime error detection is better than no detection, but it wastes a little\nprocessor time, and perhaps much more programmer time. Better with detection at\ncompile time! And if you&apos;re happy to not support arrays of local types with C++98,\nthen you can do that:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;ptrdiff_t&lt;/span&gt;   Size;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Type, Size n &amp;gt;\nSize &lt;span class=&quot;hljs-title&quot;&gt;n_items&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Type (&amp;amp;)[n] )&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n; }\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; N_ITEMS( array )       n_items( array )&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compiling this definition substituted into the first complete program, with g++,\nI got &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;M:\\count&amp;gt; g++ compile_time_detection.cpp&lt;br&gt;\n  compile_time_detection.cpp: In function &apos;void display(const int*)&apos;:&lt;br&gt;\n  compile_time_detection.cpp:14: error: no matching function for call to &apos;n_items(const int*&amp;amp;)&apos;  &lt;/p&gt;\n  \n  &lt;p&gt;M:\\count&amp;gt; _  &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;How it works: the array is passed &lt;em&gt;by reference&lt;/em&gt; to &lt;code&gt;n_items&lt;/code&gt;, and so it does\nnot decay to pointer to first element, and the function can just return the\nnumber of elements specified by the type.&lt;/p&gt;\n\n&lt;p&gt;With C++11 you can use this also for arrays of local type, and it&apos;s the type safe\n&lt;strong&gt;C++ idiom&lt;/strong&gt; for finding the number of elements of an array.&lt;/p&gt;\n\n&lt;h2&gt;5.4 C++11 &amp;amp; C++14 pitfall: Using a &lt;code&gt;constexpr&lt;/code&gt; array size function.&lt;/h2&gt;\n\n&lt;p&gt;With C++11 and later it&apos;s natural, but as you&apos;ll see dangerous!, to\nreplace the C++03 function&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;ptrdiff_t&lt;/span&gt;   Size;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Type, Size n &amp;gt;\nSize &lt;span class=&quot;hljs-title&quot;&gt;n_items&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Type (&amp;amp;)[n] )&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Size = &lt;span class=&quot;hljs-type&quot;&gt;ptrdiff_t&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Type, Size n &amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;n_items&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Type (&amp;amp;)[n] )&lt;/span&gt; -&amp;gt; Size &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;where the significant change is the use of &lt;code&gt;constexpr&lt;/code&gt;, which allows\nthis function to produce a &lt;strong&gt;compile time constant&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;For example, in contrast to the C++03 function, such a compile time constant\ncan be used to declare an array of the same size as another:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Example 1&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; x[] = {&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;};\n    &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; Size n = &lt;span class=&quot;hljs-built_in&quot;&gt;n_items&lt;/span&gt;( x );\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y[n] = {};\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Using y here.&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But consider this code using the &lt;code&gt;constexpr&lt;/code&gt; version:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Example 2&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Collection &amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Collection &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; c )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;hljs-built_in&quot;&gt;n_items&lt;/span&gt;( c );     &lt;span class=&quot;hljs-comment&quot;&gt;// Not in C++14!&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Use c here&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x[&lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;];\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;( x );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with\n&lt;code&gt;-pedantic-errors&lt;/code&gt;, and,\ntesting with the online compilers at &lt;a href=&quot;http://gcc.godbolt.org/&quot; rel=&quot;noreferrer&quot;&gt;gcc.godbolt.org/&lt;/a&gt;, also with clang 3.0\nand clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or\n3.7 (experimental). And important for the Windows platform, it does not compile\nwith Visual C++ 2015. The reason is a C++11/C++14 statement about use of\nreferences in &lt;code&gt;constexpr&lt;/code&gt; expressions:&lt;/p&gt;\n\nC++11 C++14 $5.19/2 nine&lt;sup&gt;&lt;i&gt;th&lt;/i&gt;&lt;/sup&gt; dash\n\n&lt;blockquote&gt;\n  &lt;p&gt;A &lt;em&gt;conditional-expression&lt;/em&gt; &lt;code&gt;e&lt;/code&gt; is a &lt;em&gt;core constant expression&lt;/em&gt; unless the evaluation\n  of &lt;code&gt;e&lt;/code&gt;, following the rules of the abstract machine (1.9), would evaluate one of the\n  following expressions:&lt;br&gt;\n  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;an &lt;em&gt;id-expression&lt;/em&gt; that refers to a variable or data member of reference type\n  unless the reference has a preceding initialization and either  \n  \n  &lt;ul&gt;\n  &lt;li&gt;it is initialized with a constant expression or  &lt;/li&gt;\n  &lt;li&gt;it is a non-static data member of an object whose lifetime began within\n  the evaluation of e;&lt;/li&gt;\n  &lt;/ul&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;One can always write the more verbose&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Example 3  --  limited&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Size = &lt;span class=&quot;hljs-type&quot;&gt;ptrdiff_t&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Collection &amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Collection &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; c )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; Size n = std::extent&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;( c ) &amp;gt;::value;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Use c here&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; but this fails when &lt;code&gt;Collection&lt;/code&gt; is not a raw array.&lt;/p&gt;\n\n&lt;p&gt;To deal with collections that can be non-arrays one needs the overloadability of an\n&lt;code&gt;n_items&lt;/code&gt; function, but also, for compile time use one needs a compile time\nrepresentation of the array size. And the classic C++03 solution, which works fine\nalso in C++11 and C++14, is to let the function report its result not as a value\nbut via its function result &lt;em&gt;type&lt;/em&gt;. For example like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Example 4 - OK (not ideal, but portable and safe)&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;array&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Size = &lt;span class=&quot;hljs-type&quot;&gt;ptrdiff_t&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; Size n &amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Size_carrier&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; sizer[n];\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Type, Size n &amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;static_n_items&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Type (&amp;amp;)[n] )&lt;/span&gt;\n    -&amp;gt; Size_carrier&amp;lt;n&amp;gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// No implementation, is used only at compile time.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Type&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; n &amp;gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// size_t for g++&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;static_n_items&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( std::array&amp;lt;Type, n&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; )&lt;/span&gt;\n    -&amp;gt; Size_carrier&amp;lt;n&amp;gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// No implementation, is used only at compile time.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; STATIC_N_ITEMS( c ) \\\n    static_cast&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Size&amp;gt;&lt;/span&gt;( sizeof( static_n_items( c ).sizer ) )&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Collection &amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( Collection &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; c )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; Size n = &lt;span class=&quot;hljs-built_in&quot;&gt;STATIC_N_ITEMS&lt;/span&gt;( c );\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Use c here&lt;/span&gt;\n    (&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;) c;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x[&lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;];\n    std::array&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, 43&amp;gt; y;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;( x );\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;( y );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;About the choice of return type for &lt;code&gt;static_n_items&lt;/code&gt;: this code doesn&apos;t use &lt;code&gt;std::integral_constant&lt;/code&gt;\nbecause with &lt;code&gt;std::integral_constant&lt;/code&gt; the result is represented\ndirectly as a &lt;code&gt;constexpr&lt;/code&gt; value, reintroducing the original problem. Instead\nof a &lt;code&gt;Size_carrier&lt;/code&gt; class one can let the function directly return a\nreference to an array. However, not everybody is familiar with that syntax.&lt;/p&gt;\n\n&lt;p&gt;About the naming: part of this solution to the &lt;code&gt;constexpr&lt;/code&gt;-invalid-due-to-reference\nproblem is to make the choice of compile time constant explicit.&lt;/p&gt;\n\n&lt;p&gt;Hopefully the oops-there-was-a-reference-involved-in-your-&lt;code&gt;constexpr&lt;/code&gt; issue will be fixed with\nC++17, but until then a macro like the &lt;code&gt;STATIC_N_ITEMS&lt;/code&gt; above yields portability,\ne.g. to the clang and Visual C++ compilers, retaining type safety.&lt;/p&gt;\n\n&lt;p&gt;Related: macros do not respect scopes, so to avoid name collisions it can be a\ngood idea to use a name prefix, e.g. &lt;code&gt;MYLIB_STATIC_N_ITEMS&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;h1&gt;Array creation and initialization&lt;/h1&gt;\n\n&lt;p&gt;As with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; &lt;a href=&quot;https://stackoverflow.com/questions/1887097/&quot;&gt;C++ does not support VLAs&lt;/a&gt;), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).&lt;/p&gt;\n\n&lt;h2&gt;Automatic arrays&lt;/h2&gt;\n\n&lt;p&gt;Automatic arrays (arrays living &quot;on the stack&quot;) are created each time the flow of control passes through the definition of a non-static local array variable:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; automatic_array[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Initialization is performed in ascending order. Note that the initial values depend on the element type &lt;code&gt;T&lt;/code&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;https://stackoverflow.com/questions/146589/&quot;&gt;POD&lt;/a&gt; (like &lt;code&gt;int&lt;/code&gt; in the above example), no initialization takes place.&lt;/li&gt;\n&lt;li&gt;Otherwise, the default-constructor of &lt;code&gt;T&lt;/code&gt; initializes all the elements.&lt;/li&gt;\n&lt;li&gt;If &lt;code&gt;T&lt;/code&gt; provides no accessible default-constructor, the program does not compile.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Alternatively, the initial values can be explicitly specified in the &lt;em&gt;array initializer&lt;/em&gt;, a comma-separated list surrounded by curly brackets:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; primes[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; primes[] = {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;};   &lt;span class=&quot;hljs-comment&quot;&gt;// size 8 is deduced&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It is also possible to specify the size and provide a shorter array initializer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; fibonacci[&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};   &lt;span class=&quot;hljs-comment&quot;&gt;// 47 trailing zeros are deduced&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In that case, the remaining elements are &lt;a href=&quot;https://stackoverflow.com/questions/1613383/&quot;&gt;zero-initialized&lt;/a&gt;. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to &lt;em&gt;initialize&lt;/em&gt; arrays; they cannot later be used in assignments.&lt;/p&gt;\n\n&lt;h2&gt;Static arrays&lt;/h2&gt;\n\n&lt;p&gt;Static arrays (arrays living &quot;in the data segment&quot;) are local array variables defined with the &lt;code&gt;static&lt;/code&gt; keyword and array variables at namespace scope (&quot;global variables&quot;):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; global_static_array[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; local_static_array[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Note that variables at namespace scope are implicitly static. Adding the &lt;code&gt;static&lt;/code&gt; keyword to their definition has a &lt;a href=&quot;https://stackoverflow.com/questions/3891325/&quot;&gt;completely different, deprecated meaning&lt;/a&gt;.)&lt;/p&gt;\n\n&lt;p&gt;Here is how static arrays behave differently from automatic arrays:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Static arrays without an array initializer are zero-initialized prior to any further potential initialization.&lt;/li&gt;\n&lt;li&gt;Static POD arrays are initialized &lt;em&gt;exactly once&lt;/em&gt;, and the initial values are &lt;em&gt;typically&lt;/em&gt; baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.&lt;/li&gt;\n&lt;li&gt;Static non-POD arrays are initialized the &lt;em&gt;first time&lt;/em&gt; the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)&lt;/p&gt;\n\n&lt;h2&gt;Array data members&lt;/h2&gt;\n\n&lt;p&gt;Array data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the &lt;a href=&quot;https://stackoverflow.com/questions/1711990/&quot;&gt;member initializer list&lt;/a&gt;, so initialization must be faked with assignments:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; primes[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Foo&lt;/span&gt;()\n    {\n        primes[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n        primes[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n        primes[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Alternatively, you can define an automatic array in the constructor body and copy the elements over:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; primes[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Foo&lt;/span&gt;()\n    {\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; local_array[] = {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;};\n        std::&lt;span class=&quot;hljs-built_in&quot;&gt;copy&lt;/span&gt;(local_array + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, local_array + &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, primes + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In C++0x, arrays &lt;em&gt;can&lt;/em&gt; be initialized in the member initializer list thanks to &lt;a href=&quot;http://www.youtube.com/watch?v=uEqknlxXJfg&quot; rel=&quot;noreferrer&quot;&gt;uniform initialization&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; primes[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Foo&lt;/span&gt;() : primes { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; }\n    {\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is the only solution that works with element types that have no default constructor.&lt;/p&gt;\n\n&lt;h2&gt;Dynamic arrays&lt;/h2&gt;\n\n&lt;p&gt;Dynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as &quot;anonymous arrays&quot; from now on.&lt;/p&gt;\n\n&lt;p&gt;In C, anonymous arrays are created via &lt;code&gt;malloc&lt;/code&gt; and friends. In C++, anonymous arrays are created using the &lt;code&gt;new T[size]&lt;/code&gt; syntax which returns a pointer to the first element of an anonymous array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; size = &lt;span class=&quot;hljs-built_in&quot;&gt;compute_size_at_runtime&lt;/span&gt;();\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[size];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The following ASCII art depicts the memory layout if the size is computed as 8 at runtime:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;             +---+---+---+---+---+---+---+---+\n(anonymous)  |   |   |   |   |   |   |   |   |\n             +---+---+---+---+---+---+---+---+\n               ^\n               |\n               |\n             +-|-+\n          p: | | |                               &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*\n             +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Obviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)&lt;/p&gt;\n\n&lt;p&gt;Note that there is &lt;em&gt;no&lt;/em&gt; array-to-pointer decay going on here. Although evaluating &lt;code&gt;new int[size]&lt;/code&gt; does in fact create an &lt;em&gt;array&lt;/em&gt; of integers, the result of the expression &lt;code&gt;new int[size]&lt;/code&gt; is &lt;em&gt;already&lt;/em&gt; a pointer to a single integer (the first element), &lt;em&gt;not&lt;/em&gt; an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)&lt;/p&gt;\n\n&lt;p&gt;Concerning default values for elements, anonymous arrays behave similar to automatic arrays.\nNormally, anonymous POD arrays are not initialized, but there is a &lt;a href=&quot;https://stackoverflow.com/questions/620137/&quot;&gt;special syntax&lt;/a&gt; that triggers value-initialization:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[some_computed_size]();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;] { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you are done using an anonymous array, you have to release it back to the system:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[] p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form &lt;code&gt;delete&lt;/code&gt; (or &lt;code&gt;free&lt;/code&gt;) instead of &lt;code&gt;delete[]&lt;/code&gt; to release the array is also &lt;a href=&quot;https://stackoverflow.com/questions/1612031/&quot;&gt;undefined behavior&lt;/a&gt;.&lt;/p&gt;\n    "],"id":264,"title":"How do I use arrays in C++?","content":"\n                \n&lt;p&gt;C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; since C++98 and &lt;a href=&quot;http://en.cppreference.com/w/cpp/container/array&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;std::array&amp;lt;T, n&amp;gt;&lt;/code&gt;&lt;/a&gt; since &lt;a href=&quot;https://en.wikipedia.org/wiki/C++11&quot; rel=&quot;noreferrer&quot;&gt;C++11&lt;/a&gt;), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.&lt;/p&gt;\n&lt;p&gt;This FAQ is split into five parts:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4810668/&quot;&gt;arrays on the type level and accessing elements&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4984228/&quot;&gt;array creation and initialization&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4810672/&quot;&gt;assignment and parameter passing&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4810676/&quot;&gt;multidimensional arrays and arrays of pointers&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c/7439261#7439261&quot;&gt;common pitfalls when using arrays&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.&lt;/p&gt;\n&lt;p&gt;In the following text, &quot;array&quot; means &quot;C array&quot;, not the class template &lt;code&gt;std::array&lt;/code&gt;. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of &lt;a href=&quot;https://stackoverflow.com/questions/712639/&quot;&gt;another FAQ&lt;/a&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow&apos;s C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;https://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;&lt;/p&gt;\n    ","slug":"how-do-i-use-arrays-in-c++-1657387456118","postType":"QUESTION","createdAt":"2022-07-09T17:24:16.000Z","updatedAt":"2022-07-09T17:24:16.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"How to find the 'sizeof' (a pointer pointing to an array)?","slug":"how-to-find-the-'sizeof'-(a-pointer-pointing-to-an-array)-1657387354284"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"Is there a JavaScript / jQuery DOM change listener?","slug":"is-there-a-javascript-jquery-dom-change-listener-1657387961200"},{"title":"How to randomize (shuffle) a JavaScript array?","slug":"how-to-randomize-(shuffle)-a-javascript-array-1657384790171"},{"title":"Query based on multiple where clauses in Firebase","slug":"query-based-on-multiple-where-clauses-in-firebase-1657387494547"},{"title":"Cleansing User Passwords","slug":"cleansing-user-passwords-1657387365583"},{"title":"How to check if element is visible after scrolling?","slug":"how-to-check-if-element-is-visible-after-scrolling-1657387987960"},{"title":"Resolve build errors due to circular dependency amongst classes","slug":"resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462"},{"title":"R cannot be resolved - Android error","slug":"r-cannot-be-resolved-android-error-1657388526258"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"What does this symbol mean in JavaScript?","slug":"what-does-this-symbol-mean-in-javascript-1657387632971"},{"title":"When should I wrap quotes around a shell variable?","slug":"when-should-i-wrap-quotes-around-a-shell-variable-1657384659265"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"},{"title":"What is DOM Event delegation?","slug":"what-is-dom-event-delegation-1657387625599"},{"title":"What does the 'static' keyword do in a class?","slug":"what-does-the-'static'-keyword-do-in-a-class-1657388554238"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"UTF-8 all the way through","slug":"utf-8-all-the-way-through-1657384323434"}]},"__N_SSG":true}