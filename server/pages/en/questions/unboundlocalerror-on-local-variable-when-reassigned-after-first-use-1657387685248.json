{"pageProps":{"data":{"answer":["\n&lt;p&gt;Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable &lt;code&gt;c&lt;/code&gt; before any value has been assigned to it.&lt;/p&gt;\n&lt;p&gt;If you want the variable &lt;code&gt;c&lt;/code&gt; to refer to the global &lt;code&gt;c = 3&lt;/code&gt; assigned before the function, put&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;as the first line of the function.&lt;/p&gt;\n&lt;p&gt;As for python 3, there is now&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;nonlocal&lt;/span&gt; c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;that you can use to refer to the nearest enclosing function scope that has a &lt;code&gt;c&lt;/code&gt; variable.&lt;/p&gt;\n    ","\n&lt;p&gt;Python is a little weird in that it keeps everything in a dictionary for the various scopes.  The original a,b,c are in the uppermost scope and so in that uppermost dictionary.  The function has its own dictionary.  When you reach the &lt;code&gt;print(a)&lt;/code&gt; and &lt;code&gt;print(b)&lt;/code&gt; statements, there&apos;s nothing by that name in the dictionary, so Python looks up the list and finds them in the global dictionary.&lt;/p&gt;\n\n&lt;p&gt;Now we get to &lt;code&gt;c+=1&lt;/code&gt;, which is, of course, equivalent to &lt;code&gt;c=c+1&lt;/code&gt;.  When Python scans that line, it says &quot;aha, there&apos;s a variable named c, I&apos;ll put it into my local scope dictionary.&quot;  Then when it goes looking for a value for c for the c on the right hand side of the assignment, it finds its &lt;em&gt;local variable named c&lt;/em&gt;, which has no value yet, and so throws the error.&lt;/p&gt;\n\n&lt;p&gt;The statement &lt;code&gt;global c&lt;/code&gt; mentioned above simply tells the parser that it uses the &lt;code&gt;c&lt;/code&gt; from the global scope and so doesn&apos;t need a new one.&lt;/p&gt;\n\n&lt;p&gt;The reason it says there&apos;s an issue on the line it does is because it is effectively looking for the names before it tries to generate code, and so in some sense doesn&apos;t think it&apos;s really doing that line yet.  I&apos;d argue that is a usability bug, but it&apos;s generally a good practice to just learn not to take a compiler&apos;s messages &lt;em&gt;too&lt;/em&gt; seriously.&lt;/p&gt;\n\n&lt;p&gt;If it&apos;s any comfort, I spent probably a day digging and experimenting with this same issue before I found something Guido had written about the dictionaries that Explained Everything.&lt;/p&gt;\n\n&lt;h3&gt;Update, see comments:&lt;/h3&gt;\n\n&lt;p&gt;It doesn&apos;t scan the code twice, but it does scan the code in two phases, lexing and parsing.&lt;/p&gt;\n\n&lt;p&gt;Consider how the parse of this line of code works.  The lexer reads the source text and breaks it into lexemes, the &quot;smallest components&quot; of the grammar.  So when it hits the line&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;c+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;it breaks it up into something like&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;SYMBOL(c) OPERATOR(+=) DIGIT(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The parser eventually wants to make this into a parse tree and execute it, but since it&apos;s an assignment, before it does, it looks for the name c in the local dictionary, doesn&apos;t see it, and inserts it in the dictionary, marking it as uninitialized. In a fully compiled language, it would just go into the symbol table and wait for the parse, but since it WON&apos;T have the luxury of a second pass, the lexer does a little extra work to make life easier later on.   Only, then it sees the OPERATOR, sees that the rules say &quot;if you have an operator += the left hand side must have been initialized&quot; and says &quot;whoops!&quot;&lt;/p&gt;\n\n&lt;p&gt;The point here is that it &lt;em&gt;hasn&apos;t really started the parse of the line yet&lt;/em&gt;.  This is all happening sort of preparatory to the actual parse, so the line counter hasn&apos;t advanced to the next line.  Thus when it signals the error, it still thinks its on the previous line.&lt;/p&gt;\n\n&lt;p&gt;As I say, you could argue it&apos;s a usability bug, but its actually a fairly common thing.  Some compilers are more honest about it and say &quot;error on or around line XXX&quot;, but this one doesn&apos;t.&lt;/p&gt;\n    ","\n&lt;p&gt;Taking a look at the disassembly may clarify what is happening:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;():\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; dis\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dis.dis(f)\n\n  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;           &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; LOAD_FAST                &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (a)\n              &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; PRINT_ITEM\n              &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; PRINT_NEWLINE\n\n  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; LOAD_GLOBAL              &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (b)\n              &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; PRINT_ITEM\n              &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; PRINT_NEWLINE\n\n  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;          &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; LOAD_CONST               &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n             &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; STORE_FAST               &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (a)\n             &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt; LOAD_CONST               &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;)\n             &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; RETURN_VALUE\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As you can see, the bytecode for accessing a is &lt;code&gt;LOAD_FAST&lt;/code&gt;, and for b, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;.  This is because the compiler has identified that a is assigned to within the function, and classified it as a local variable.  The access mechanism for locals is fundamentally different for globals - they are statically assigned an offset in the frame&apos;s variables table, meaning lookup is a quick index, rather than the more expensive dict lookup as for globals.  Because of this, Python is reading the &lt;code&gt;print a&lt;/code&gt; line as &quot;get the value of local variable &apos;a&apos; held in slot 0, and print it&quot;, and when it detects that this variable is still uninitialised, raises an exception.&lt;/p&gt;\n    ","\n&lt;p&gt;Python has rather interesting behavior when you try traditional global variable semantics.  I don&apos;t remember the details, but you can read the value of a variable declared in &apos;global&apos; scope just fine, but if you want to modify it, you have to use the &lt;code&gt;global&lt;/code&gt; keyword.  Try changing &lt;code&gt;test()&lt;/code&gt; to this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; c\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(b)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(c)    &lt;span class=&quot;hljs-comment&quot;&gt;# (A)&lt;/span&gt;\n    c+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;# (B)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also, the reason you are getting this error is because you can also declare a new variable inside that function with the same name as a &apos;global&apos; one, and it would be completely separate.  The interpreter thinks you are trying to make a new variable in this scope called &lt;code&gt;c&lt;/code&gt; and modify it all in one operation, which isn&apos;t allowed in Python because this new &lt;code&gt;c&lt;/code&gt; wasn&apos;t initialized.&lt;/p&gt;\n    ","\n&lt;p&gt;The best example that makes it clear is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;bar = &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; bar\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;:\n        bar = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;when calling &lt;code&gt;foo()&lt;/code&gt; , this also &lt;strong&gt;raises&lt;/strong&gt; &lt;code&gt;UnboundLocalError&lt;/code&gt; although we will never reach to line &lt;code&gt;bar=0&lt;/code&gt;, so logically local variable should never be created.&lt;/p&gt;\n\n&lt;p&gt;The mystery lies in &quot;&lt;strong&gt;Python is an Interpreted Language&lt;/strong&gt;&quot; and the declaration of the function &lt;code&gt;foo&lt;/code&gt; is interpreted as a single statement (i.e. a compound statement), it just interprets it dumbly and creates local and global scopes. So &lt;code&gt;bar&lt;/code&gt; is recognized in local scope before execution.&lt;/p&gt;\n\n&lt;p&gt;For &lt;strong&gt;more examples&lt;/strong&gt; like this Read this post: &lt;a href=&quot;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/&quot; rel=&quot;noreferrer&quot;&gt;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This post provides a Complete Description and Analyses of the Python Scoping of variables:&lt;/p&gt;\n    ","\n&lt;p&gt;Here are two links that may help&lt;/p&gt;\n\n&lt;p&gt;1: &lt;a href=&quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;2: &lt;a href=&quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;link one describes the error UnboundLocalError.  Link two can help with with re-writing your test function.  Based on link two, the original problem could be rewritten as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a, b, c = (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a, b, c)\n(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt; (a, b, c):\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (b)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (c)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    c += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a, b, c\n...\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a, b, c = test (a, b, c)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a, b ,c)\n(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is not a direct answer to your question, but it is closely related, as it&apos;s another gotcha caused by the relationship between augmented assignment and function scopes.&lt;/p&gt;\n\n&lt;p&gt;In most cases, you tend to think of augmented assignment (&lt;code&gt;a += b&lt;/code&gt;) as exactly equivalent to simple assignment (&lt;code&gt;a = a + b&lt;/code&gt;). It is possible to get into some trouble with this though, in one corner case. Let me explain:&lt;/p&gt;\n\n&lt;p&gt;The way Python&apos;s simple assignment works means that if &lt;code&gt;a&lt;/code&gt; is passed into a function (like &lt;code&gt;func(a)&lt;/code&gt;; note that Python is always pass-by-reference), then &lt;code&gt;a = a + b&lt;/code&gt; will not modify the &lt;code&gt;a&lt;/code&gt; that is passed in. Instead, it will just modify the local pointer to &lt;code&gt;a&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;But if you use &lt;code&gt;a += b&lt;/code&gt;, then it is sometimes implemented as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a = a + b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or sometimes (if the method exists) as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a.__iadd__(b)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the first case (as long as &lt;code&gt;a&lt;/code&gt; is not declared global), there are no side-effects outside local scope, as the assignment to &lt;code&gt;a&lt;/code&gt; is just a pointer update.&lt;/p&gt;\n\n&lt;p&gt;In the second case, &lt;code&gt;a&lt;/code&gt; will actually modify itself, so all references to &lt;code&gt;a&lt;/code&gt; will point to the modified version. This is demonstrated by the following code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;copy_on_write&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a&lt;/span&gt;):\n      a = a + a\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;inplace_add&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a&lt;/span&gt;):\n      a += a\na = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\ncopy_on_write(a)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a &lt;span class=&quot;hljs-comment&quot;&gt;# [1]&lt;/span&gt;\ninplace_add(a)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a &lt;span class=&quot;hljs-comment&quot;&gt;# [1, 1]&lt;/span&gt;\nb = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\ncopy_on_write(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b &lt;span class=&quot;hljs-comment&quot;&gt;# [1]&lt;/span&gt;\ninplace_add(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b &lt;span class=&quot;hljs-comment&quot;&gt;# 1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the trick is to avoid augmented assignment on function arguments (I try to only use it for local/loop variables). Use simple assignment, and you will be safe from ambiguous behaviour. &lt;/p&gt;\n    ","\n&lt;p&gt;The Python interpreter will read a function as a complete unit. I think of it as reading it in two passes, once to gather its closure (the local variables), then again to turn it into byte-code.&lt;/p&gt;\n\n&lt;p&gt;As I&apos;m sure you were already aware, any name used on the left of a &apos;=&apos; is implicitly a local variable. More than once I&apos;ve been caught out by changing a variable access to a += and it&apos;s suddenly a different variable.&lt;/p&gt;\n\n&lt;p&gt;I also wanted to point out it&apos;s not really anything to do with global scope specifically. You get the same behaviour with nested functions.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;c+=1&lt;/code&gt; assigns &lt;code&gt;c&lt;/code&gt;, python assumes assigned variables are local, but in this case it hasn&apos;t been declared locally.&lt;/p&gt;\n\n&lt;p&gt;Either use the &lt;code&gt;global&lt;/code&gt; or &lt;code&gt;nonlocal&lt;/code&gt; keywords. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;nonlocal&lt;/code&gt; works only in python 3, so if you&apos;re using python 2 and don&apos;t want to make your variable global, you can use a mutable object:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;my_variables = { &lt;span class=&quot;hljs-comment&quot;&gt;# a mutable object&lt;/span&gt;\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    my_variables[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;] +=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n\ntest()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The best way to reach class variable is directly accesing by class name&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Employee&lt;/span&gt;:\n    counter=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        Employee.counter+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can also get this message if you define a variable with the same name as a method.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;teams&lt;/span&gt;():\n    ...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;some_other_method&lt;/span&gt;():\n    teams = teams()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The solution, is to rename method &lt;code&gt;teams()&lt;/code&gt; to something else like &lt;code&gt;get_teams()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Since it is only used locally, the Python message is rather misleading!&lt;/p&gt;\n&lt;p&gt;You end up with something like this to get around it:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;teams&lt;/span&gt;():\n    ...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;some_other_method&lt;/span&gt;():\n    teams = get_teams()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This issue can also occur when the &lt;code&gt;del&lt;/code&gt; keyword is utilized on the variable down the line, after initialization, typically in a loop or a conditional block.&lt;/p&gt;\n    ","\n&lt;p&gt;The same problem bothers me. Using &lt;code&gt;nonlocal&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; can solve the problem.&lt;br&gt;\nHowever, attention is needed for the usage of &lt;code&gt;nonlocal&lt;/code&gt;, it works for nested functions. However, at the module level, it does not work. See &lt;a href=&quot;https://www.programiz.com/python-programming/global-local-nonlocal-variables#Nonlocal%20Variables&quot; rel=&quot;nofollow noreferrer&quot;&gt;examples&lt;/a&gt; here.&lt;/p&gt;\n    "],"id":339,"title":"UnboundLocalError on local variable when reassigned after first use","content":"\n                \n&lt;p&gt;The following code works as expected in both Python 2.5 and 3.0:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a, b, c = (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a, b, c)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(b)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(c)    &lt;span class=&quot;hljs-comment&quot;&gt;# (A)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;#c+=1       # (B)&lt;/span&gt;\ntest()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, when I uncomment line &lt;strong&gt;(B)&lt;/strong&gt;, I get an &lt;code&gt;UnboundLocalError: &apos;c&apos; not assigned&lt;/code&gt; at line &lt;strong&gt;(A)&lt;/strong&gt;. The values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are printed correctly. This has me completely baffled for two reasons:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Why is there a runtime error thrown at line &lt;strong&gt;(A)&lt;/strong&gt; because of a later statement on line &lt;strong&gt;(B)&lt;/strong&gt;?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Why are variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; printed as expected, while &lt;code&gt;c&lt;/code&gt; raises an error?&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The only explanation I can come up with is that a &lt;strong&gt;local&lt;/strong&gt; variable &lt;code&gt;c&lt;/code&gt; is created by the assignment &lt;code&gt;c+=1&lt;/code&gt;, which takes precedent over the &quot;global&quot; variable &lt;code&gt;c&lt;/code&gt; even before the local variable is created. Of course, it doesn&apos;t make sense for a variable to &quot;steal&quot; scope before it exists.&lt;/p&gt;\n\n&lt;p&gt;Could someone please explain this behavior?&lt;/p&gt;\n    ","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248","postType":"QUESTION","createdAt":"2022-07-09T17:28:05.000Z","updatedAt":"2022-07-09T17:28:05.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How can I combine two strings together in PHP?","slug":"how-can-i-combine-two-strings-together-in-php-1657388279401"},{"title":"What is a raw type and why shouldn't we use it?","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079"},{"title":"Object comparison in JavaScript [duplicate]","slug":"object-comparison-in-javascript-duplicate-1657387675463"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"How to convert string representation of list to a list","slug":"how-to-convert-string-representation-of-list-to-a-list-1657387384181"},{"title":"Retrieving the last record in each group - MySQL","slug":"retrieving-the-last-record-in-each-group-mysql-1657384887369"},{"title":"Flatten an irregular list of lists","slug":"flatten-an-irregular-list-of-lists-1657387315571"},{"title":"Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on","slug":"cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019"},{"title":"How to unnest (explode) a column in a pandas DataFrame, into multiple rows","slug":"how-to-unnest-(explode)-a-column-in-a-pandas-dataframe-into-multiple-rows-1657387806735"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"Retrieve only the queried element in an object array in MongoDB collection","slug":"retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457"},{"title":"GUI not working after rewriting to MVC","slug":"gui-not-working-after-rewriting-to-mvc-1657388388035"},{"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"},{"title":"Do DOM tree elements with IDs become global properties?","slug":"do-dom-tree-elements-with-ids-become-global-properties-1657387475110"},{"title":"How do I properly clean up Excel interop objects?","slug":"how-do-i-properly-clean-up-excel-interop-objects-1657388329706"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"How do I check if an array includes a value in JavaScript?","slug":"how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"}]},"__N_SSG":true}