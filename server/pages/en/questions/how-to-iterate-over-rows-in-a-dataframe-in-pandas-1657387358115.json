{"pageProps":{"data":{"answer":["\n&lt;p&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;DataFrame.iterrows&lt;/code&gt;&lt;/a&gt; is a generator which yields both the index and row (as a Series):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd\n\ndf = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;]})\ndf = df.reset_index()  &lt;span class=&quot;hljs-comment&quot;&gt;# make sure indexes pair with number of rows&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n&lt;h2&gt;How to iterate over rows in a DataFrame in Pandas?&lt;/h2&gt;\n&lt;/blockquote&gt;\n&lt;h1&gt;Answer: DON&apos;T&lt;sup&gt;*&lt;/sup&gt;!&lt;/h1&gt;\n&lt;p&gt;Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with &quot;&lt;code&gt;iter&lt;/code&gt;&quot; in its name for more than a few thousand rows or you will have to get used to a &lt;strong&gt;lot&lt;/strong&gt; of waiting.&lt;/p&gt;\n&lt;p&gt;Do you want to print a DataFrame? Use &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;code&gt;DataFrame.to_string()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Do you want to compute something? In that case, search for methods in this order (list modified from &lt;a href=&quot;https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues&quot;&gt;here&lt;/a&gt;):&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Vectorization&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cython&quot; rel=&quot;noreferrer&quot;&gt;Cython&lt;/a&gt; routines&lt;/li&gt;\n&lt;li&gt;List Comprehensions (vanilla &lt;code&gt;for&lt;/code&gt; loop)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;code&gt;DataFrame.apply()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;: i) &amp;nbsp;Reductions that can be performed in Cython, ii) Iteration in Python space&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;code&gt;DataFrame.itertuples()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iteritems.html#pandas.DataFrame.iteritems&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;code&gt;iteritems()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;code&gt;DataFrame.iterrows()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;iterrows&lt;/code&gt; and &lt;code&gt;itertuples&lt;/code&gt; (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Appeal to Authority&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration&quot; rel=&quot;noreferrer&quot;&gt;The documentation page&lt;/a&gt; on iteration has a huge red warning box that says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;sub&gt;* It&apos;s actually a little more complicated than &quot;don&apos;t&quot;. &lt;code&gt;df.iterrows()&lt;/code&gt; is the correct answer to this question, but &quot;vectorize your ops&quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you&apos;re not sure whether you need an iterative solution, you probably don&apos;t. PS: To know more about my rationale for writing this answer, skip to the very bottom.&lt;/sub&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Faster than Looping: &lt;a href=&quot;https://stackoverflow.com/questions/1422149/what-is-vectorization&quot;&gt;Vectorization&lt;/a&gt;, &lt;a href=&quot;https://cython.org&quot; rel=&quot;noreferrer&quot;&gt;Cython&lt;/a&gt;&lt;/h2&gt;\n&lt;p&gt;A good number of basic operations and computations are &quot;vectorised&quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#essential-basic-functionality&quot; rel=&quot;noreferrer&quot;&gt;Essential Basic Functionality&lt;/a&gt; to find a suitable vectorised method for your problem.&lt;/p&gt;\n&lt;p&gt;If none exists, feel free to write your own using custom &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#cython-writing-c-extensions-for-pandas&quot; rel=&quot;noreferrer&quot;&gt;Cython extensions&lt;/a&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Next Best Thing: &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions&quot; rel=&quot;noreferrer&quot;&gt;List Comprehensions&lt;/a&gt;&lt;sup&gt;*&lt;/sup&gt;&lt;/h2&gt;\n&lt;p&gt;List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you&apos;re trying to perform elementwise transformation on your code. There is a &lt;a href=&quot;https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care&quot;&gt;good amount of evidence&lt;/a&gt; to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.&lt;/p&gt;\n&lt;p&gt;The formula is simple,&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Iterating over one column - `f` is some function that processes your data&lt;/span&gt;\nresult = [f(x) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col&apos;&lt;/span&gt;]]\n&lt;span class=&quot;hljs-comment&quot;&gt;# Iterating over two columns, use `zip`&lt;/span&gt;\nresult = [f(x, y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x, y &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;], df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col2&apos;&lt;/span&gt;])]\n&lt;span class=&quot;hljs-comment&quot;&gt;# Iterating over multiple columns - same data type&lt;/span&gt;\nresult = [f(row[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], ..., row[n]) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df[[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;, ...,&lt;span class=&quot;hljs-string&quot;&gt;&apos;coln&apos;&lt;/span&gt;]].to_numpy()]\n&lt;span class=&quot;hljs-comment&quot;&gt;# Iterating over multiple columns - differing data type&lt;/span&gt;\nresult = [f(row[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], ..., row[n]) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;], ..., df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;coln&apos;&lt;/span&gt;])]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Caveats&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don&apos;t have NaNs, but this cannot always be guaranteed.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.&lt;/li&gt;\n&lt;li&gt;When dealing with mixed data types you should iterate over &lt;code&gt;zip(df[&apos;A&apos;], df[&apos;B&apos;], ...)&lt;/code&gt; instead of &lt;code&gt;df[[&apos;A&apos;, &apos;B&apos;]].to_numpy()&lt;/code&gt; as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, &lt;code&gt;to_numpy()&lt;/code&gt; will cast the entire array to string, which may not be what you want. Fortunately &lt;code&gt;zip&lt;/code&gt;ping your columns together is the most straightforward workaround to this.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;sub&gt;*Your mileage may vary for the reasons outlined in the &lt;strong&gt;Caveats&lt;/strong&gt; section above.&lt;/sub&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;An Obvious Example&lt;/h2&gt;\n&lt;p&gt;Let&apos;s demonstrate the difference with a simple example of adding two pandas columns &lt;code&gt;A + B&lt;/code&gt;. This is a vectorizable operaton, so it will be easy to contrast the performance of the methods discussed above.&lt;/p&gt;\n&lt;img src=&quot;https://i.stack.imgur.com/y44RJ.png&quot; width=&quot;600&quot;&gt;\n&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0&quot; rel=&quot;noreferrer&quot;&gt;Benchmarking code, for your reference&lt;/a&gt;. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you&apos;re doing. Stick to the API where you can (i.e., prefer &lt;code&gt;vec&lt;/code&gt; over &lt;code&gt;vec_numpy&lt;/code&gt;).&lt;/p&gt;\n&lt;p&gt;I should mention, however, that it isn&apos;t always this cut and dry. Sometimes the answer to &quot;what is the best method for an operation&quot; is &quot;it depends on your data&quot;. My advice is to test out different approaches on your data before settling on one.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;My Personal Opinion &lt;sup&gt;*&lt;/sup&gt;&lt;/h2&gt;\n&lt;p&gt;Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.&lt;/p&gt;\n&lt;p&gt;Here is my personal preference when selecting a method to use for a problem.&lt;/p&gt;\n&lt;p&gt;For the novice:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;em&gt;Vectorization&lt;/em&gt; (when possible)&lt;em&gt;; &lt;code&gt;apply()&lt;/code&gt;; List Comprehensions; &lt;code&gt;itertuples()&lt;/code&gt;/&lt;code&gt;iteritems()&lt;/code&gt;; &lt;code&gt;iterrows()&lt;/code&gt;; Cython&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;For the more experienced:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;em&gt;Vectorization&lt;/em&gt; (when possible)&lt;em&gt;; &lt;code&gt;apply()&lt;/code&gt;; List Comprehensions; Cython; &lt;code&gt;itertuples()&lt;/code&gt;/&lt;code&gt;iteritems()&lt;/code&gt;; &lt;code&gt;iterrows()&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.&lt;/p&gt;\n&lt;p&gt;I do tend to go on about how bad &lt;code&gt;apply&lt;/code&gt; is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it&apos;s doing. Additionally, there are quite a few use cases for &lt;code&gt;apply&lt;/code&gt; has explained in &lt;a href=&quot;https://stackoverflow.com/questions/54432583/when-should-i-not-want-to-use-pandas-apply-in-my-code&quot;&gt;this post of mine&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.&lt;/p&gt;\n&lt;p&gt;&lt;sub&gt;* As with any personal opinion, please take with heaps of salt!&lt;/sub&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Further Reading&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html&quot; rel=&quot;noreferrer&quot;&gt;10 Minutes to pandas&lt;/a&gt;, and &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html&quot; rel=&quot;noreferrer&quot;&gt;Essential Basic Functionality&lt;/a&gt; - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html&quot; rel=&quot;noreferrer&quot;&gt;Enhancing Performance&lt;/a&gt; - A primer from the documentation on enhancing standard Pandas operations&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care&quot;&gt;Are for-loops in pandas really bad? When should I care?&lt;/a&gt;&lt;/em&gt; - a detailed writeup by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/54432583/when-should-i-ever-want-to-use-pandas-apply-in-my-code&quot;&gt;When should I (not) want to use pandas apply() in my code?&lt;/a&gt;&lt;/em&gt; - &lt;code&gt;apply&lt;/code&gt; is slow (but not as slow as the &lt;code&gt;iter*&lt;/code&gt; family. There are, however, situations where one can (or should) consider &lt;code&gt;apply&lt;/code&gt; as a serious alternative, especially in some &lt;code&gt;GroupBy&lt;/code&gt; operations).&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;sub&gt;* Pandas string methods are &quot;vectorized&quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.&lt;/sub&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Why I Wrote this Answer&lt;/h2&gt;\n&lt;p&gt;A common trend I notice from new users is to ask questions of the form &quot;How can I iterate over my df to do X?&quot;. Showing code that calls &lt;code&gt;iterrows()&lt;/code&gt; while doing something inside a &lt;code&gt;for&lt;/code&gt; loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.&lt;/p&gt;\n&lt;p&gt;The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I&apos;m not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.&lt;/p&gt;\n    ","\n&lt;p&gt;First consider if you really need to &lt;em&gt;iterate&lt;/em&gt; over rows in a DataFrame. See &lt;a href=&quot;https://stackoverflow.com/a/55557758/3844376&quot;&gt;this answer&lt;/a&gt; for alternatives.&lt;/p&gt;\n&lt;p&gt;If you still need to iterate over rows, you can use methods below. Note some  &lt;strong&gt;important caveats&lt;/strong&gt; which are not mentioned in any of the other answers.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html&quot; rel=&quot;noreferrer&quot;&gt;DataFrame.iterrows()&lt;/a&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n      &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&quot;c1&quot;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&quot;c2&quot;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html&quot; rel=&quot;noreferrer&quot;&gt;DataFrame.itertuples()&lt;/a&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Pandas&apos;&lt;/span&gt;):\n      &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row.c1, row.c2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;itertuples()&lt;/code&gt; is supposed to be faster than &lt;code&gt;iterrows()&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;But be aware, according to the docs (pandas 0.24.2 at the moment):&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;iterrows: &lt;code&gt;dtype&lt;/code&gt; might not match from row to row&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Because iterrows returns a Series for each row, it &lt;strong&gt;does not preserve&lt;/strong&gt; dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;iterrows: Do not modify rows&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;You should &lt;strong&gt;never modify&lt;/strong&gt; something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Use &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html&quot; rel=&quot;noreferrer&quot;&gt;DataFrame.apply()&lt;/a&gt; instead:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;    new_df = df.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x: x * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, axis = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;itertuples:&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&amp;gt;255), regular tuples are returned.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;See &lt;a href=&quot;https://pandas.pydata.org/docs/user_guide/basics.html#iteration&quot; rel=&quot;noreferrer&quot;&gt;pandas docs on iteration&lt;/a&gt; for more details.&lt;/p&gt;\n    ","\n&lt;p&gt;You should use &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;df.iterrows()&lt;/code&gt;&lt;/a&gt;. Though iterating row-by-row is not especially efficient since &lt;code&gt;Series&lt;/code&gt; objects have to be created.&lt;/p&gt;\n    ","\n&lt;p&gt;While &lt;code&gt;iterrows()&lt;/code&gt; is a good option, sometimes &lt;code&gt;itertuples()&lt;/code&gt; can be much faster:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;df = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: randn(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;), &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: randn(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;),&lt;span class=&quot;hljs-string&quot;&gt;&apos;N&apos;&lt;/span&gt;: randint(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, (&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;)), &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;})\n\n%timeit [row.a * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; idx, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows()]\n&lt;span class=&quot;hljs-comment&quot;&gt;# =&amp;gt; 10 loops, best of 3: 50.3 ms per loop&lt;/span&gt;\n\n%timeit [row[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples()]\n&lt;span class=&quot;hljs-comment&quot;&gt;# =&amp;gt; 1000 loops, best of 3: 541 µs per loop&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can use the &lt;a href=&quot;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;df.iloc&lt;/code&gt;&lt;/a&gt; function as follows:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(df)):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(df.iloc[i][&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;], df.iloc[i][&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can also use &lt;code&gt;df.apply()&lt;/code&gt; to iterate over rows and access multiple columns for a function.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html&quot;&gt;docs: DataFrame.apply()&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;valuation_formula&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x, y&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x * y * &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;\n\ndf[&lt;span class=&quot;hljs-string&quot;&gt;&apos;price&apos;&lt;/span&gt;] = df.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; row: valuation_formula(row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt;]), axis=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h1&gt;How to iterate efficiently&lt;/h1&gt;\n\n&lt;p&gt;If you really have to iterate a Pandas dataframe, you will probably want to &lt;strong&gt;avoid using iterrows()&lt;/strong&gt;. There are different methods and the usual &lt;code&gt;iterrows()&lt;/code&gt; is far from being the best. &lt;strong&gt;itertuples() can be 100 times faster.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;In short:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;As a general rule, use &lt;code&gt;df.itertuples(name=None)&lt;/code&gt;. In particular, when you have a fixed number columns and less than 255 columns. &lt;em&gt;See point (3)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Otherwise, use &lt;code&gt;df.itertuples()&lt;/code&gt; except if your columns have special characters such as spaces or &apos;-&apos;. &lt;em&gt;See point (2)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;It is possible to use &lt;code&gt;itertuples()&lt;/code&gt; even if your dataframe has strange columns by using the last example. &lt;em&gt;See point (4)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Only use &lt;code&gt;iterrows()&lt;/code&gt; if you cannot the previous solutions. &lt;em&gt;See point (1)&lt;/em&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h1&gt;Different methods to iterate over rows in a Pandas dataframe:&lt;/h1&gt;\n\n&lt;p&gt;Generate a random dataframe with a million rows and 4 columns:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;    df = pd.DataFrame(np.random.randint(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, size=(&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)), columns=&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;ABCD&apos;&lt;/span&gt;))\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(df)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1) The usual &lt;code&gt;iterrows()&lt;/code&gt; is convenient, but damn slow:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;start_time = time.clock()\nresult = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n    result += &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;B&apos;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;])\n\ntotal_elapsed_time = &lt;span class=&quot;hljs-built_in&quot;&gt;round&lt;/span&gt;(time.clock() - start_time, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1. Iterrows done in {} seconds, result = {}&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(total_elapsed_time, result))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;2) The default &lt;code&gt;itertuples()&lt;/code&gt; is already much faster, but it doesn&apos;t work with column names such as &lt;code&gt;My Col-Name is very Strange&lt;/code&gt; (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;start_time = time.clock()\nresult = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;):\n    result += &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(row.B, row.C)\n\ntotal_elapsed_time = &lt;span class=&quot;hljs-built_in&quot;&gt;round&lt;/span&gt;(time.clock() - start_time, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;2. Named Itertuples done in {} seconds, result = {}&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(total_elapsed_time, result))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;3) The default &lt;code&gt;itertuples()&lt;/code&gt; using name=None is even faster but not really convenient as you have to define a variable per column.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;start_time = time.clock()\nresult = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(_, col1, col2, col3, col4) &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(name=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;):\n    result += &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(col2, col3)\n\ntotal_elapsed_time = &lt;span class=&quot;hljs-built_in&quot;&gt;round&lt;/span&gt;(time.clock() - start_time, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;3. Itertuples done in {} seconds, result = {}&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(total_elapsed_time, result))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;4) Finally, the named &lt;code&gt;itertuples()&lt;/code&gt; is slower than the previous point, but you do not have to define a variable per column and it works with column names such as &lt;code&gt;My Col-Name is very Strange&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;start_time = time.clock()\nresult = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;):\n    result += &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(row[df.columns.get_loc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;B&apos;&lt;/span&gt;)], row[df.columns.get_loc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;)])\n\ntotal_elapsed_time = &lt;span class=&quot;hljs-built_in&quot;&gt;round&lt;/span&gt;(time.clock() - start_time, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(total_elapsed_time, result))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;         A   B   C   D\n&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;41&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;63&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;54&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;34&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;39&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;94&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;82&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;97&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;88&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;79&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;54&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    ..  ..  ..  ..\n&lt;span class=&quot;hljs-number&quot;&gt;999995&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;999996&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;51&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;34&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;999997&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;39&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;61&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;999998&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;51&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;999999&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;51&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;53&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;47&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;\n\n[&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt; rows x &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; columns]\n\n&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt; Iterrows done &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;104.96&lt;/span&gt; seconds, result = &lt;span class=&quot;hljs-number&quot;&gt;66151519&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt; Named Itertuples done &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1.26&lt;/span&gt; seconds, result = &lt;span class=&quot;hljs-number&quot;&gt;66151519&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3.&lt;/span&gt; Itertuples done &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.94&lt;/span&gt; seconds, result = &lt;span class=&quot;hljs-number&quot;&gt;66151519&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;4.&lt;/span&gt; Polyvalent Itertuples working even &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; special characters &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the column name done &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2.94&lt;/span&gt; seconds, result = &lt;span class=&quot;hljs-number&quot;&gt;66151519&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d&quot; rel=&quot;noreferrer&quot;&gt;This article is a very interesting comparison between iterrows and itertuples&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I was looking for &lt;strong&gt;How to iterate on rows&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;and&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;columns&lt;/strong&gt; and ended here so:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j, column &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; row.iteritems():\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(column)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can write your own iterator that implements &lt;code&gt;namedtuple&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; namedtuple\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myiter&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d, cols=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; cols &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n        v = d.values.tolist()\n        cols = d.columns.values.tolist()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n        j = [d.columns.get_loc(c) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; cols]\n        v = d.values[:, j].tolist()\n\n    n = namedtuple(&lt;span class=&quot;hljs-string&quot;&gt;&apos;MyTuple&apos;&lt;/span&gt;, cols)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;iter&lt;/span&gt;(v):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; n(*line)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is directly comparable to &lt;code&gt;pd.DataFrame.itertuples&lt;/code&gt;.  I&apos;m aiming at performing the same task with more efficiency.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For the given dataframe with my function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(myiter(df))\n\n[MyTuple(c1=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;), MyTuple(c1=&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;), MyTuple(c1=&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;)]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or with &lt;code&gt;pd.DataFrame.itertuples&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;))\n\n[Pandas(c1=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;), Pandas(c1=&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;), Pandas(c1=&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;, c2=&lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;)]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;A comprehensive test&lt;/strong&gt;&lt;br&gt;\nWe test making all columns available and subsetting the columns.  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;iterfullA&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(myiter(d))\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;iterfullB&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(d.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;))\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;itersubA&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(myiter(d, [&lt;span class=&quot;hljs-string&quot;&gt;&apos;col3&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col4&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col5&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col6&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col7&apos;&lt;/span&gt;]))\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;itersubB&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(d[[&lt;span class=&quot;hljs-string&quot;&gt;&apos;col3&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col4&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col5&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col6&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col7&apos;&lt;/span&gt;]].itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;))\n\nres = pd.DataFrame(\n    index=[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;30000&lt;/span&gt;],\n    columns=&lt;span class=&quot;hljs-string&quot;&gt;&apos;iterfullA iterfullB itersubA itersubB&apos;&lt;/span&gt;.split(),\n    dtype=&lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;\n)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; res.index:\n    d = pd.DataFrame(np.random.randint(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, size=(i, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;))).add_prefix(&lt;span class=&quot;hljs-string&quot;&gt;&apos;col&apos;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; res.columns:\n        stmt = &lt;span class=&quot;hljs-string&quot;&gt;&apos;{}(d)&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(j)\n        setp = &lt;span class=&quot;hljs-string&quot;&gt;&apos;from __main__ import d, {}&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(j)\n        res.at[i, j] = timeit(stmt, setp, number=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)\n\nres.groupby(res.columns.&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;:-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], axis=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).plot(loglog=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rt88e.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rt88e.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/azbOF.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/azbOF.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;To loop all rows in a &lt;code&gt;dataframe&lt;/code&gt; you can use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(date_example.index)):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; date_example[&lt;span class=&quot;hljs-string&quot;&gt;&apos;Date&apos;&lt;/span&gt;].iloc[x]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ind &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.index:\n     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;][ind], df[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;][ind]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;We have multiple options to do the same, lots of folks have shared their answers.&lt;/p&gt;\n&lt;p&gt;I found below two methods easy and efficient to do :&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html&quot; rel=&quot;noreferrer&quot;&gt;DataFrame.iterrows()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html&quot; rel=&quot;noreferrer&quot;&gt;DataFrame.itertuples()&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd\n inp = [{&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;}, {&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;}, {&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;}]\n df = pd.DataFrame(inp)\n &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (df)\n\n &lt;span class=&quot;hljs-comment&quot;&gt;#With iterrows method &lt;/span&gt;\n\n &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&quot;c1&quot;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&quot;c2&quot;&lt;/span&gt;])\n\n &lt;span class=&quot;hljs-comment&quot;&gt;#With itertuples method&lt;/span&gt;\n\n &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Pandas&apos;&lt;/span&gt;):\n     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row.c1, row.c2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note: itertuples() is supposed to be faster than iterrows()&lt;/p&gt;\n    ","\n&lt;p&gt;Sometimes a useful pattern is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Borrowing @KutalmisB df example&lt;/span&gt;\ndf = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;col2&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;]}, index=[&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;])\n&lt;span class=&quot;hljs-comment&quot;&gt;# The to_dict call results in a list of dicts&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# where each row_dict is a dictionary with k:v pairs of columns:value for that row&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row_dict &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.to_dict(orient=&lt;span class=&quot;hljs-string&quot;&gt;&apos;records&apos;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row_dict)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which results in:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col2&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;}\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;col2&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: cs95 has updated &lt;a href=&quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758&quot;&gt;his answer&lt;/a&gt; to include plain numpy vectorization. You can simply refer to his answer.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758&quot;&gt;cs95 shows&lt;/a&gt; that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.&lt;/p&gt;\n&lt;p&gt;I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it&apos;s even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).&lt;/p&gt;\n&lt;p&gt;If you add the following functions to cs95&apos;s benchmark code, this becomes pretty evident:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;np_vectorization&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;df&lt;/span&gt;):\n    np_arr = df.to_numpy()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; pd.Series(np_arr[:,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] + np_arr[:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], index=df.index)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;just_np_vectorization&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;df&lt;/span&gt;):\n    np_arr = df.to_numpy()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; np_arr[:,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] + np_arr[:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/L0u4A.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/L0u4A.png&quot; alt=&quot;Enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In short&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Use vectorization if possible&lt;/li&gt;\n&lt;li&gt;If an operation can&apos;t be vectorized - use list comprehensions&lt;/li&gt;\n&lt;li&gt;If you need a single object representing the entire row - use itertuples&lt;/li&gt;\n&lt;li&gt;If the above is too slow - try &lt;em&gt;swifter.apply&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;If it&apos;s still too slow - try a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cython&quot; rel=&quot;noreferrer&quot;&gt;Cython&lt;/a&gt; routine&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Benchmark&lt;/h3&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ytaWK.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ytaWK.png&quot; alt=&quot;Benchmark of iteration over rows in a Pandas DataFrame&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;To loop all rows in a &lt;code&gt;dataframe&lt;/code&gt; and &lt;strong&gt;use&lt;/strong&gt; values of each row &lt;strong&gt;conveniently&lt;/strong&gt;, &lt;code&gt;namedtuples&lt;/code&gt; can be converted to &lt;code&gt;ndarray&lt;/code&gt;s. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;df = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;col1&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;col2&apos;&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;]}, index=[&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Iterating over the rows:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.itertuples(index=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Pandas&apos;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; np.asarray(row)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;results in:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;[ &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;]\n[ &lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Please note that if &lt;code&gt;index=True&lt;/code&gt;, &lt;strong&gt;the index is added as the first element of the tuple&lt;/strong&gt;, which may be undesirable for some applications.&lt;/p&gt;\n    ","\n&lt;p&gt;There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don&apos;t see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(df)):\n    row = df.iloc[[i]]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note the usage of double brackets. This returns a DataFrame with a single row.&lt;/p&gt;\n    ","\n&lt;p&gt;For both viewing and modifying values, I would use &lt;code&gt;iterrows()&lt;/code&gt;. In a for loop and by using tuple unpacking (see the example: &lt;code&gt;i, row&lt;/code&gt;), I use the &lt;code&gt;row&lt;/code&gt; for only viewing the value and use &lt;code&gt;i&lt;/code&gt; with the &lt;code&gt;loc&lt;/code&gt; method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n    df_column_A = df.loc[i, &lt;span class=&quot;hljs-string&quot;&gt;&apos;A&apos;&lt;/span&gt;]\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; df_column_A == &lt;span class=&quot;hljs-string&quot;&gt;&apos;Old_Value&apos;&lt;/span&gt;:\n        df_column_A = &lt;span class=&quot;hljs-string&quot;&gt;&apos;New_value&apos;&lt;/span&gt;  \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the &lt;code&gt;row&lt;/code&gt; in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like &lt;code&gt;row[&apos;A&apos;] = &apos;New_Value&apos;&lt;/code&gt;, it will not modify the DataFrame. However, you can use &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;loc&lt;/code&gt; and specify the DataFrame to do the work.&lt;/p&gt;\n    ","\n&lt;p&gt;There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;df = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;A&apos;&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;B&apos;&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]})\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(df)\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(df.shape[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]):\n    &lt;span class=&quot;hljs-comment&quot;&gt;# For printing the second column&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(df.iloc[i, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# For printing more than one columns&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(df.iloc[i, [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]])\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The easiest way, use the &lt;code&gt;apply&lt;/code&gt; function&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;print_row&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;row&lt;/span&gt;):\n   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;]\n\ndf.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; row: print_row(row), axis=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should &lt;em&gt;ever&lt;/em&gt; write loops in Pandas, and if so the best way to loop in those situations.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in &lt;em&gt;other&lt;/em&gt; rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.&lt;/strong&gt;  The looping code might even be faster, too.&lt;/p&gt;\n&lt;p&gt;I will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np\n\ndf = pd.DataFrame( { &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]  } )\n\n&lt;span class=&quot;hljs-comment&quot;&gt;#   x  y  desired_result&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#0  1  1               1&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#1  2  1               3&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#2  3  1               6&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#3  4  0               4&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#4  5  1               9&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#5  6  1              15&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is a good example where you could certainly write one line of Pandas to achieve this, although it&apos;s not especially readable, especially if you aren&apos;t fairly experienced with Pandas already:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;df.groupby( (df.y==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;).cumsum() )[&lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;].cumsum()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That&apos;s going to be fast enough for most situations, although you could also write faster code by avoiding the &lt;code&gt;groupby&lt;/code&gt;, but it will likely be even less readable.&lt;/p&gt;\n&lt;p&gt;Alternatively, what if we write this as a loop?  You could do something like the following with NumPy:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numba &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; nb\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@nb.jit(&lt;span class=&quot;hljs-params&quot;&gt;nopython=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;)  &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Optional&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;custom_sum&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x,y&lt;/span&gt;):\n    x_sum = x.copy()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(df)):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; y[i] &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: x_sum[i] = x_sum[i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] + x[i]\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x_sum\n\ndf[&lt;span class=&quot;hljs-string&quot;&gt;&apos;desired_result&apos;&lt;/span&gt;] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Admittedly, there&apos;s a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn&apos;t know anything about Pandas or NumPy:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; y[i] &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: x_sum[i] = x_sum[i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] + x[i]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And this code is actually &lt;em&gt;faster&lt;/em&gt; than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the &lt;em&gt;groupby&lt;/em&gt; approach.  Note that one key to the speed there is numba, which is optional.  Without the &quot;@nb.jit&quot; line, the looping code is actually about 10x slower than the &lt;em&gt;groupby&lt;/em&gt; approach.&lt;/p&gt;\n&lt;p&gt;Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;df.iterrows()&lt;/code&gt; returns &lt;code&gt;tuple(a, b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is the &lt;code&gt;row&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;You can also do NumPy indexing for even greater speed ups. It&apos;s not really iterating but works much better than iteration for certain applications.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;subset = row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]\n&lt;span class=&quot;hljs-built_in&quot;&gt;all&lt;/span&gt; = row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;][:]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;np.asarray(&lt;span class=&quot;hljs-built_in&quot;&gt;all&lt;/span&gt;)\nimgs[:] = cv2.resize(imgs[:], (&lt;span class=&quot;hljs-number&quot;&gt;224&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;224&lt;/span&gt;) ) &lt;span class=&quot;hljs-comment&quot;&gt;# Resize every image in an hdf5 file&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Although here are so many answers which recommend &lt;strong&gt;not&lt;/strong&gt; using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:&lt;/p&gt;\n&lt;h2&gt;Extend dataframe with data from API&lt;/h2&gt;\n&lt;p&gt;Let&apos;s say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example the user&apos;s &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;gender&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Both values have to be fetched from a backend API. I&apos;m assuming the API doesn&apos;t provide a &quot;batch&quot; endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.&lt;/p&gt;\n&lt;p&gt;The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We&apos;re talking about network roundtrip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.&lt;/p&gt;\n&lt;h2&gt;1 expensive network request for each row&lt;/h2&gt;\n&lt;p&gt;So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows&quot; rel=&quot;nofollow noreferrer&quot;&gt;DataFrame.iterrows&lt;/a&gt;:&lt;/p&gt;\n&lt;h2&gt;Example&lt;/h2&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; users_df.iterrows():\n  user_id = row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_id&apos;&lt;/span&gt;]\n  &lt;span class=&quot;hljs-comment&quot;&gt;# trigger expensive network request once for each row&lt;/span&gt;\n  response_dict = backend_api.get(&lt;span class=&quot;hljs-string&quot;&gt;f&apos;/api/user-data/&lt;span class=&quot;hljs-subst&quot;&gt;{user_id}&lt;/span&gt;&apos;&lt;/span&gt;)\n  &lt;span class=&quot;hljs-comment&quot;&gt;# extend dataframe with multiple data from response&lt;/span&gt;\n  users_df.at[index, &lt;span class=&quot;hljs-string&quot;&gt;&apos;age&apos;&lt;/span&gt;] = response_dict.get(&lt;span class=&quot;hljs-string&quot;&gt;&apos;age&apos;&lt;/span&gt;)\n  users_df.at[index, &lt;span class=&quot;hljs-string&quot;&gt;&apos;gender&apos;&lt;/span&gt;] = response_dict.get(&lt;span class=&quot;hljs-string&quot;&gt;&apos;gender&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This example uses iloc to isolate each digit in the data frame. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd\n\n a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n b = [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]\n\n mjr = pd.DataFrame({&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:a, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:b})\n\n size = mjr.shape\n\n &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(size[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]):\n     &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(size[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]):\n         &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(mjr.iloc[i, j])\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I &apos;stream&apos; my dataframe values one by one, I wrote the below, which comes in handy from time to time.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DataFrameReader&lt;/span&gt;:\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, df&lt;/span&gt;):\n    self._df = df\n    self._row = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n    self._columns = df.columns.tolist()\n    self.reset()\n    self.row_index = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__getattr__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, key&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.__getitem__(key)\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt;:\n    self._row = &lt;span class=&quot;hljs-built_in&quot;&gt;next&lt;/span&gt;(self._iterator, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;)\n    self.row_index += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._row &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;columns&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._columns\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;reset&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n    self._iterator = self._df.itertuples()\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;get_index&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._row[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;index&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._row[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;to_dict&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, columns: &lt;span class=&quot;hljs-type&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;] = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.row(columns=columns)\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;tolist&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, cols&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;]:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [self.__getitem__(c) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; cols]\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;row&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, columns: &lt;span class=&quot;hljs-type&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;] = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;Dict&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;]:\n    cols = &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(self._columns &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; columns &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; columns)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {c : self.__getitem__(c) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self._columns &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; cols}\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__getitem__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, key&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;:\n    &lt;span class=&quot;hljs-comment&quot;&gt;# the df index of the row is at index 0&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(key) &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;:\n            ix = [self._columns.index(key) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; key]\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n            ix = self._columns.index(key) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._row[ix]\n    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; BaseException &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; e:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__next__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;DataFrameReader&apos;&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.read():\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; StopIteration\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__iter__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;DataFrameReader&apos;&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which can be used:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; DataFrameReader(df):\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row.my_column_name)\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row.to_dict())\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;my_column_name&apos;&lt;/span&gt;])\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row.tolist())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.&lt;/p&gt;\n    ","\n&lt;p&gt;Along with the great answers in this post I am going to propose &lt;strong&gt;Divide and Conquer&lt;/strong&gt; approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of &lt;code&gt;splitting&lt;/code&gt; and &lt;code&gt;merging&lt;/code&gt; the pandas dataframe:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;PROS of Divide and Conquer:&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;You don&apos;t need to use vectorization or any other methods to cast the type of your dataframe into another type&lt;/li&gt;\n&lt;li&gt;You don&apos;t need to Cythonize your code which normally takes extra time from you&lt;/li&gt;\n&lt;li&gt;Both &lt;code&gt;iterrows()&lt;/code&gt; and &lt;code&gt;itertuples()&lt;/code&gt; in my case were having the same performance over entire dataframe&lt;/li&gt;\n&lt;li&gt;Depends on your choice of slicing &lt;code&gt;index&lt;/code&gt;, you will be able to exponentially quicken the iteration. The higher &lt;code&gt;index&lt;/code&gt;, the quicker your iteration process.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;CONS of Divide and Conquer:&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;You shouldn&apos;t have dependency over the iteration process to the same dataframe and different &lt;em&gt;slice&lt;/em&gt;. Meaning if you want to read or write from other &lt;em&gt;slice&lt;/em&gt;, it maybe difficult to do that.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;===================    Divide and Conquer Approach    =================&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Step 1: Splitting/Slicing&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a csv file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; I need to reiterate as other runtime analysis explained in the other solutions in this page, &quot;number of records&quot; has exponential proportion of &quot;runtime&quot; on search on the df. Based on the benchmark on my data here are the results:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;Number of records | Iteration per second\n========================================\n&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;           | &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; it/s\n&lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;           | &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; it/s\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;         | &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt; it/s\n&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;         | &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; it/s\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Step 2: Merging&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This is going to be an easy step, just merge all the written csv files into one dataframe and write it into a bigger csv file.&lt;/p&gt;\n&lt;p&gt;Here is the sample code:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Step 1 (Splitting/Slicing)&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd\ndf_all = pd.read_csv(&lt;span class=&quot;hljs-string&quot;&gt;&apos;C:/KtV.csv&apos;&lt;/span&gt;)\ndf_index = &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;\ndf_len = &lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(df)\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(df_len // df_index + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):\n    lower_bound = i * df_index \n    higher_bound = &lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(lower_bound + df_index, df_len)\n    &lt;span class=&quot;hljs-comment&quot;&gt;# splitting/slicing df (make sure to copy() otherwise it will be a view&lt;/span&gt;\n    df = df_all[lower_bound:higher_bound].copy()\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&apos;\n    write your iteration over the sliced df here\n    using iterrows() or intertuples() or ...\n    &apos;&apos;&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# writing into csv files&lt;/span&gt;\n    df.to_csv(&lt;span class=&quot;hljs-string&quot;&gt;&apos;C:/KtV_prep_&apos;&lt;/span&gt;+&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(i)+&lt;span class=&quot;hljs-string&quot;&gt;&apos;.csv&apos;&lt;/span&gt;)\n\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Step 2 (Merging)&lt;/span&gt;\nfilename=&lt;span class=&quot;hljs-string&quot;&gt;&apos;C:/KtV_prep_&apos;&lt;/span&gt;\ndf = (pd.read_csv(f) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; f &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [filename+&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(i)+&lt;span class=&quot;hljs-string&quot;&gt;&apos;.csv&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(ktv_len // ktv_index + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)])\ndf_prep_all = pd.concat(df)\ndf_prep_all.to_csv(&lt;span class=&quot;hljs-string&quot;&gt;&apos;C:/KtV_prep_all.csv&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas&quot;&gt;Efficient way of iteration over datafreame&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe&quot;&gt;Concatenate csv files into one Pandas Dataframe&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;As &lt;a href=&quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/16476974#16476974&quot;&gt;the accepted answer&lt;/a&gt; states, the fastest way to apply a function over rows is to use a &lt;strong&gt;vectorized function&lt;/strong&gt;, the so-called NumPy &lt;code&gt;ufuncs&lt;/code&gt; (universal functions).&lt;/p&gt;\n&lt;p&gt;But what should you do when the function you want to apply isn&apos;t already implemented in NumPy?&lt;/p&gt;\n&lt;p&gt;Well, using the &lt;code&gt;vectorize&lt;/code&gt; decorator from &lt;code&gt;numba&lt;/code&gt;, you can easily create ufuncs directly in Python like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; numba &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; vectorize, float64\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@vectorize(&lt;span class=&quot;hljs-params&quot;&gt;[float64(&lt;span class=&quot;hljs-params&quot;&gt;float64&lt;/span&gt;)]&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;):\n    &lt;span class=&quot;hljs-comment&quot;&gt;#x is your line, do something with it, and return a float&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The documentation for this function is here: &lt;em&gt;&lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/vectorize.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Creating NumPy universal functions&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Probably the most elegant solution (but certainly not the most efficient):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.values:\n    c2 = row[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row)\n    &lt;span class=&quot;hljs-comment&quot;&gt;# ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c1, c2 &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.values:\n    &lt;span class=&quot;hljs-comment&quot;&gt;# ...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the &lt;a href=&quot;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt; explicitly recommends to use &lt;code&gt;.to_numpy()&lt;/code&gt; instead&lt;/li&gt;\n&lt;li&gt;the produced NumPy array will have a dtype that fits all columns, in the worst case &lt;code&gt;object&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;there are &lt;a href=&quot;https://stackoverflow.com/a/55557758/4248897&quot;&gt;good reasons&lt;/a&gt; not to use a loop in the first place&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Still, I think this option should be included here, as a straight-forward solution to a (one should think) trivial problem.&lt;/p&gt;\n    "],"id":234,"title":"How to iterate over rows in a DataFrame in Pandas","content":"\n                \n&lt;p&gt;I have a pandas dataframe, &lt;code&gt;df&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;   c1   c2\n&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;110&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.rows:\n   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c1&apos;&lt;/span&gt;], row[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c2&apos;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;I found a &lt;a href=&quot;https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas&quot;&gt;similar question&lt;/a&gt; which suggests using either of these:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; date, row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.T.iteritems():\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; df.iterrows():\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But I do not understand what the &lt;code&gt;row&lt;/code&gt; object is and how I can work with it.&lt;/p&gt;\n    ","slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115","postType":"QUESTION","createdAt":"2022-07-09T17:22:38.000Z","updatedAt":"2022-07-09T17:22:38.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Is an array name a pointer?","slug":"is-an-array-name-a-pointer-1657387874827"},{"title":"C++ Singleton design pattern","slug":"c++-singleton-design-pattern-1657387830040"},{"title":"Add a property to a JavaScript object using a variable as the name?","slug":"add-a-property-to-a-javascript-object-using-a-variable-as-the-name-1657388425650"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"How can I find the time complexity of an algorithm?","slug":"how-can-i-find-the-time-complexity-of-an-algorithm-1657388486001"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"When can I use a forward declaration?","slug":"when-can-i-use-a-forward-declaration-1657388251827"},{"title":"AsyncTask Android example","slug":"asynctask-android-example-1657388127898"},{"title":"Open a URL in a new tab (and not a new window)","slug":"open-a-url-in-a-new-tab-(and-not-a-new-window)-1657387699598"},{"title":"How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version","slug":"how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422"},{"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606"},{"title":"What does this symbol mean in JavaScript?","slug":"what-does-this-symbol-mean-in-javascript-1657387632971"},{"title":"Ways to deal with #document under iframe","slug":"ways-to-deal-with-document-under-iframe-1657388403345"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"How to close/hide the Android soft keyboard programmatically?","slug":"how-to-closehide-the-android-soft-keyboard-programmatically-1657388217420"},{"title":"How can I sort arrays and data in PHP?","slug":"how-can-i-sort-arrays-and-data-in-php-1657384726665"},{"title":"The Definitive C++ Book Guide and List","slug":"the-definitive-c++-book-guide-and-list-1657384247395"},{"title":"How do I properly compare strings in C?","slug":"how-do-i-properly-compare-strings-in-c-1657387467202"},{"title":"Use a content script to access the page context variables and functions","slug":"use-a-content-script-to-access-the-page-context-variables-and-functions-1657384842444"}]},"__N_SSG":true}