<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="pointer-arithmetic,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216","name":"Questions"}}]}</script><title>With arrays, why is it the case that a[5] == 5[a]? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="As Joel points out in Stack Overflow podcast #34, in C Programming Language (aka: K &amp; R), there is mention of this property of arrays in C: a[5] == 5[a]

Joel says that it&#x27;s because of pointer arithmetic but I still don&#x27;t understand. Why does a[5] == 5[a]?
    "/><meta property="og:title" content="With arrays, why is it the case that a[5] == 5[a]? | Solution Checker"/><meta property="og:description" content="As Joel points out in Stack Overflow podcast #34, in C Programming Language (aka: K &amp; R), there is mention of this property of arrays in C: a[5] == 5[a]

Joel says that it&#x27;s because of pointer arithmetic but I still don&#x27;t understand. Why does a[5] == 5[a]?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"With arrays, why is it the case that a[5] == 5[a]?","text":"As Joel points out in Stack Overflow podcast #34, in C Programming Language (aka: K &amp; R), there is mention of this property of arrays in C: a[5] == 5[a]\n\nJoel says that it&apos;s because of pointer arithmetic but I still don&apos;t understand. Why does a[5] == 5[a]?\n    ","answerCount":19,"upVoteCount":500,"suggestedAnswer":[{"text":"The C standard defines the [] operator as follows:\n\na[b] == *(a + b)\n\nTherefore a[5] will evaluate to:\n\n*(a + 5)\n\n\nand 5[a] will evaluate to:\n\n*(5 + a)\n\n\na is a pointer to the first element of the array. a[5] is the value that&apos;s 5 elements further from a, which is the same as *(a + 5), and from elementary school math we know those are equal (addition is commutative).\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Because array access is defined in terms of pointers.  a[i] is defined to mean *(a + i), which is commutative.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I think something is being missed by the other answers.\n\nYes, p[i] is by definition equivalent to *(p+i), which (because addition is commutative) is equivalent to *(i+p), which (again, by the definition of the [] operator) is equivalent to i[p].\n\n(And in array[i], the array name is implicitly converted to a pointer to the array&apos;s first element.)\n\nBut the commutativity of addition is not all that obvious in this case.\n\nWhen both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: x + y == y + x.\n\nBut in this case we&apos;re talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)\n\nThe C standard&apos;s description of the + operator (N1570 6.5.6) says:\n\n\n  For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.\n\n\nIt could just as easily have said:\n\n\n  For addition, either both operands shall have arithmetic type, or the left\n  operand shall be a pointer to a complete object type and the right operand\n  shall have integer type.\n\n\nin which case both i + p and i[p] would be illegal.\n\nIn C++ terms, we really have two sets of overloaded + operators, which can be loosely described as:\n\npointer operator+(pointer p, integer i);\n\n\nand\n\npointer operator+(integer i, pointer p);\n\n\nof which only the first is really necessary.\n\nSo why is it this way?\n\nC++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 Users&apos; Reference to B), which got it from BCPL (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).\n\nSo the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C&apos;s ancestor languages.\n\nThose languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the unsigned keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn&apos;t have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn&apos;t up to the language to prevent it.\n\nAnd over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).\n\nChanging C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.\n\nSo now we have arr[3] and 3[arr] meaning exactly the same thing, though the latter form should never appear outside the IOCCC.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"And, of course\n\n (&quot;ABCD&quot;[2] == 2[&quot;ABCD&quot;]) &amp;&amp; (2[&quot;ABCD&quot;] == &apos;C&apos;) &amp;&amp; (&quot;ABCD&quot;[2] == &apos;C&apos;)\n\n\nThe main reason for this was that back in the 70&apos;s when C was designed, computers didn&apos;t have much memory (64KB was a lot), so the C compiler didn&apos;t do much syntax checking.  Hence &quot;X[Y]&quot; was rather blindly translated into &quot;*(X+Y)&quot;  \n\nThis also explains the &quot;+=&quot; and &quot;++&quot; syntaxes.  Everything in the form &quot;A = B + C&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn&apos;t bright enough to recognize it, so the developer had to (A += C).   Similarly, if C was 1, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn&apos;t recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"One thing no-one seems to have mentioned about Dinah&apos;s problem with sizeof:\n\nYou can only add an integer to a pointer, you can&apos;t add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"To answer the question literally. It is not always true that x == x\n\ndouble zero = 0.0;\ndouble a[] = { 0,0,0,0,0, zero/zero}; // NaN\ncout &lt;&lt; (a[5] == 5[a] ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;\n\n\nprints\n\nfalse\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !\nint a[] = { 2 , 3 , 3 , 2 , 4 };\nint s = sizeof a / sizeof *a;  //  s == 5\n\nfor(int i = 0 ; i &lt; s ; ++i) {  \n           \n    cout &lt;&lt; a[a[a[i]]] &lt;&lt; endl;\n    // ... is equivalent to ...\n    cout &lt;&lt; i[a][a][a] &lt;&lt; endl;  // but I prefer this one, it&apos;s easier to increase the level of indirection (without loop)\n    \n}\n\nOf course, I&apos;m quite sure that there is no use case for that in real code, but I found it interesting anyway :)\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Nice question/answers.\n\nJust want to point out that C pointers and arrays are not the same, although in this case the difference is not essential. \n\nConsider the following declarations:\n\nint a[10];\nint* p = a;\n\n\nIn a.out, the symbol a is at an address that&apos;s the beginning of the array, and symbol p is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. \n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"For pointers in C, we have\n\na[5] == *(a + 5)\n\n\nand also\n\n5[a] == *(5 + a)\n\n\nHence it is true that a[5] == 5[a].\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Not an answer, but just some food for thought.\nIf class is having overloaded index/subscript operator, the expression 0[x] will not work:\n\nclass Sub\n{\npublic:\n    int operator [](size_t nIndex)\n    {\n        return 0;\n    }   \n};\n\nint main()\n{\n    Sub s;\n    s[0];\n    0[s]; // ERROR \n}\n\n\nSince we dont have access to int class, this cannot be done:\n\nclass int\n{\n   int operator[](const Sub&amp;);\n};\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"It has very good explanation in A TUTORIAL ON POINTERS AND ARRAYS IN C\nby Ted Jensen.\n\nTed Jensen explained it as:\n\n\n  In fact, this is true, i.e wherever one writes a[i] it can be\n  replaced with *(a + i)  without any problems. In fact, the compiler\n  will create the same code in either case. Thus we see that pointer\n  arithmetic is the same thing as array indexing. Either syntax produces\n  the same result.\n  \n  This is NOT saying that pointers and arrays\n  are the same thing, they are not. We are only saying that to identify\n  a given element of an array we have the choice of two syntaxes, one\n  using array indexing and the other using pointer arithmetic, which\n  yield identical results.\n  \n  Now, looking at this last\n  expression, part of it.. (a + i), is a simple addition using the +\n  operator and the rules of C state that such an expression is\n  commutative. That is (a + i) is identical to (i + a). Thus we could\n  write *(i + a) just as easily as *(a + i).\n  But *(i + a) could have come from i[a] ! From all of this comes the curious\n  truth that if:\n\nchar a[20];\n\n  \n  writing\n\na[3] = &apos;x&apos;;\n\n  \n  is the same as writing\n\n3[a] = &apos;x&apos;;\n\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I know the question is answered, but I couldn&apos;t resist sharing this explanation.\n\nI remember Principles of Compiler design,\nLet&apos;s assume a is an int array and size of int is 2 bytes,\n&amp; Base address for a is 1000.\n\nHow a[5] will work -&gt;\n\nBase Address of your Array a + (5*size of(data type for array a))\ni.e. 1000 + (5*2) = 1010\n\n\nSo, \n\nSimilarly when the c code is broken down into 3-address code, \n5[a] will become -&gt;\n\nBase Address of your Array a + (size of(data type for array a)*5)\ni.e. 1000 + (2*5) = 1010 \n\n\nSo basically both the statements are pointing to the same location in memory and hence, a[5] = 5[a].\n\nThis explanation is also the reason why negative indexes in arrays work in C.\n\ni.e. if I access a[-5] it will give me\n\nBase Address of your Array a + (-5 * size of(data type for array a))\ni.e. 1000 + (-5*2) = 990\n\n\nIt will return me object at location 990.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"in c compiler \n\na[i]\ni[a]\n*(a+i)\n\n\nare different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"In C arrays, arr[3] and 3[arr] are the same, and their equivalent pointer notations are *(arr + 3) to *(3 + arr). But on the contrary [arr]3 or [3]arr is not correct and will result into syntax error, as (arr + 3)* and (3 + arr)* are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"A little bit of history now.  Among other languages, BCPL had a fairly major influence on C&apos;s early development.  If you declared an array in BCPL with something like:\n\nlet V = vec 10\n\n\nthat actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as\n\nlet J = V!5\n\n\nreally did have to do J = !(V + 5) (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus V!5 and 5!V were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)\n\nThe innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.\n\nNote that ! in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and sizeof became a thing.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Well, this is a feature that is only possible because of the language support.\n\nThe compiler interprets a[i] as *(a+i) and the expression 5[a] evaluates to *(5+a). Since addition is commutative it turns out that both are equal. Hence the expression evaluates to true.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"In C\n int a[]={10,20,30,40,50};\n int *p=a;\n printf(&quot;%d\\n&quot;,*p++);//output will be 10\n printf(&quot;%d\\n&quot;,*a++);//will give an error\n\nPointer p is a &quot;variable&quot;, array name a is a &quot;mnemonic&quot; or &quot;synonym&quot;,\nso p++ is valid but a++ is invalid.\na[2] is equals to 2[a] because the internal operation on both of this is &quot;Pointer Arithmetic&quot; internally calculated as *(a+2) equals *(2+a)\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Because C compiler always convert array notation in pointer notation.\na[5] = *(a + 5)  also 5[a] = *(5 + a) = *(a + 5)\nSo, both are equal.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Because it&apos;s useful to avoid confusing nesting.\nWould you rather read this:\narray[array[head].next].prev\n\nor this:\nhead[array].next[array].prev\n\nIncidentally, C++ has a similar commutative property for function calls. Rather than writing g(f(x)) as you must in C, you may use member functions to write x.f().g(). Replace f and g with lookup tables and you can write g[f[x]] (functional style) or (x[f])[g] (oop style). The latter gets really nice with structs containing indices: x[xs].y[ys].z[zs]. Using the more common notation that&apos;s zs[ys[xs[x].y].z].\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-260362324a06d105.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_buildManifest.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"><h1>With arrays, why is it the case that a[5] == 5[a]?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div><div class="question-content mt-5">
                
<p>As Joel points out in <a href="https://stackoverflow.blog/2008/12/18/podcast-34/">Stack Overflow podcast #34</a>, in <a href="https://rads.stackoverflow.com/amzn/click/com/0131103628" rel="noreferrer">C Programming Language</a> (aka: K &amp; R), there is mention of this property of arrays in C: <code>a[5] == 5[a]</code></p>

<p>Joel says that it's because of pointer arithmetic but I still don't understand. <strong>Why does <code>a[5] == 5[a]</code></strong>?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The C standard defines the <code>[]</code> operator as follows:</p>

<p><code>a[b] == *(a + b)</code></p>

<p>Therefore <code>a[5]</code> will evaluate to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*(a + <span class="hljs-number">5</span>)
</code></pre>

<p>and <code>5[a]</code> will evaluate to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*(<span class="hljs-number">5</span> + a)
</code></pre>

<p><code>a</code> is a pointer to the first element of the array. <code>a[5]</code> is the value that's 5 <strong>elements</strong> further from <code>a</code>, which is the same as <code>*(a + 5)</code>, and from elementary school math we know those are equal (addition is <a href="https://en.wikipedia.org/wiki/commutative" rel="noreferrer">commutative</a>).</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because array access is defined in terms of pointers.  <code>a[i]</code> is defined to mean <code>*(a + i)</code>, which is commutative.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think something is being missed by the other answers.</p>

<p>Yes, <code>p[i]</code> is by definition equivalent to <code>*(p+i)</code>, which (because addition is commutative) is equivalent to <code>*(i+p)</code>, which (again, by the definition of the <code>[]</code> operator) is equivalent to <code>i[p]</code>.</p>

<p>(And in <code>array[i]</code>, the array name is implicitly converted to a pointer to the array's first element.)</p>

<p>But the commutativity of addition is not all that obvious in this case.</p>

<p>When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: <code>x + y == y + x</code>.</p>

<p>But in this case we're talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)</p>

<p>The C standard's description of the <code>+</code> operator (<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">N1570</a> 6.5.6) says:</p>

<blockquote>
  <p>For addition, either both operands shall have arithmetic type, or one
  operand shall be a pointer to a complete object type and the other
  shall have integer type.</p>
</blockquote>

<p>It could just as easily have said:</p>

<blockquote>
  <p>For addition, either both operands shall have arithmetic type, or <em>the left</em>
  operand shall be a pointer to a complete object type and the <em>right operand</em>
  shall have integer type.</p>
</blockquote>

<p>in which case both <code>i + p</code> and <code>i[p]</code> would be illegal.</p>

<p>In C++ terms, we really have two sets of overloaded <code>+</code> operators, which can be loosely described as:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">pointer operator+(pointer p, integer i);
</code></pre>

<p>and</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">pointer operator+(integer i, pointer p);
</code></pre>

<p>of which only the first is really necessary.</p>

<p>So why is it this way?</p>

<p>C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 <a href="https://www.bell-labs.com/usr/dmr/www/kbman.html">Users' Reference to B</a>), which got it from <a href="https://www.bell-labs.com/usr/dmr/www/bcpl.html">BCPL</a> (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).</p>

<p>So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C's ancestor languages.</p>

<p>Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the <code>unsigned</code> keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn't have occurred to the designers of those languages. If a user wanted to add two "things", whether those "things" are integers, pointers, or something else, it wasn't up to the language to prevent it.</p>

<p>And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).</p>

<p>Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.</p>

<p>So now we have <code>arr[3]</code> and <code>3[arr]</code> meaning exactly the same thing, though the latter form should never appear outside the <a href="http://ioccc.org/">IOCCC</a>.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>And, of course</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> (<span class="hljs-string">"ABCD"</span>[<span class="hljs-number">2</span>] == <span class="hljs-number">2</span>[<span class="hljs-string">"ABCD"</span>]) &amp;&amp; (<span class="hljs-number">2</span>[<span class="hljs-string">"ABCD"</span>] == <span class="hljs-string">'C'</span>) &amp;&amp; (<span class="hljs-string">"ABCD"</span>[<span class="hljs-number">2</span>] == <span class="hljs-string">'C'</span>)
</code></pre>

<p>The main reason for this was that back in the 70's when C was designed, computers didn't have much memory (64KB was a lot), so the C compiler didn't do much syntax checking.  Hence "<code>X[Y]</code>" was rather blindly translated into "<code>*(X+Y)</code>"  </p>

<p>This also explains the "<code>+=</code>" and "<code>++</code>" syntaxes.  Everything in the form "<code>A = B + C</code>" had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn't bright enough to recognize it, so the developer had to (<code>A += C</code>).   Similarly, if <code>C</code> was <code>1</code>, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn't recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One thing no-one seems to have mentioned about Dinah's problem with <code>sizeof</code>:</p>

<p>You can only add an integer to a pointer, you can't add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To answer the question literally. It is not always true that <code>x == x</code></p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">double</span> zero = <span class="hljs-number">0.0</span>;
<span class="hljs-type">double</span> a[] = { <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, zero/zero}; <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">cout</span> &lt;&lt; (a[<span class="hljs-number">5</span>] == <span class="hljs-number">5</span>[a] ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
</code></pre>

<p>prints</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-literal">false</span>
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just find out this ugly syntax could be "useful", or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[] = { <span class="hljs-number">2</span> , <span class="hljs-number">3</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span> , <span class="hljs-number">4</span> };
<span class="hljs-type">int</span> s = <span class="hljs-keyword">sizeof</span> a / <span class="hljs-keyword">sizeof</span> *a;  <span class="hljs-comment">//  s == 5</span>

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s ; ++i) {  
           
    <span class="hljs-built_in">cout</span> &lt;&lt; a[a[a[i]]] &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">// ... is equivalent to ...</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; i[a][a][a] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// but I prefer this one, it's easier to increase the level of indirection (without loop)</span>
    
}
</code></pre>
<p>Of course, I'm quite sure that there is no use case for that in real code, but I found it interesting anyway :)</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Nice question/answers.</p>

<p>Just want to point out that C pointers and arrays are not the <em>same</em>, although in this case the difference is not essential. </p>

<p>Consider the following declarations:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];
<span class="hljs-type">int</span>* p = a;
</code></pre>

<p>In <code>a.out</code>, the symbol <code>a</code> is at an address that's the beginning of the array, and symbol <code>p</code> is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. </p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For pointers in C, we have</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">a[<span class="hljs-number">5</span>] == *(a + <span class="hljs-number">5</span>)
</code></pre>

<p>and also</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">5</span>[a] == *(<span class="hljs-number">5</span> + a)
</code></pre>

<p>Hence it is true that <code>a[5] == 5[a].</code></p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Not an answer, but just some food for thought.
If class is having overloaded index/subscript operator, the expression <code>0[x]</code> will not work:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span>
{</span>
public:
    <span class="hljs-type">int</span> operator [](<span class="hljs-type">size_t</span> nIndex)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }   
};

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    Sub s;
    s[<span class="hljs-number">0</span>];
    <span class="hljs-number">0</span>[s]; <span class="hljs-comment">// ERROR </span>
}
</code></pre>

<p>Since we dont have access to <strong>int</strong> class, this cannot be done:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">int</span>
{</span>
   <span class="hljs-type">int</span> operator[](<span class="hljs-type">const</span> Sub&amp;);
};
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It has very good explanation in <em>A TUTORIAL ON POINTERS AND ARRAYS IN C</em>
by Ted Jensen.</p>

<p>Ted Jensen explained it as:</p>

<blockquote>
  <p>In fact, this is true, i.e wherever one writes <code>a[i]</code> it can be
  replaced with <code>*(a + i)</code>  without any problems. In fact, the compiler
  will create the same code in either case. Thus we see that pointer
  arithmetic is the same thing as array indexing. Either syntax produces
  the same result.</p>
  
  <p>This is NOT saying that pointers and arrays
  are the same thing, they are not. We are only saying that to identify
  a given element of an array we have the choice of two syntaxes, one
  using array indexing and the other using pointer arithmetic, which
  yield identical results.</p>
  
  <p>Now, looking at this last
  expression, part of it.. <code>(a + i)</code>, is a simple addition using the +
  operator and the rules of C state that such an expression is
  commutative. That is (a + i) is identical to <code>(i + a)</code>. Thus we could
  write <code>*(i + a)</code> just as easily as <code>*(a + i)</code>.
  But <code>*(i + a)</code> could have come from <code>i[a]</code> ! From all of this comes the curious
  truth that if:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>];
</code></pre>
  
  <p>writing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">a[<span class="hljs-number">3</span>] = <span class="hljs-string">'x'</span>;
</code></pre>
  
  <p>is the same as writing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">3</span>[a] = <span class="hljs-string">'x'</span>;
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know the question is answered, but I couldn't resist sharing this explanation.</p>

<p>I remember Principles of Compiler design,
Let's assume <code>a</code> is an <code>int</code> array and size of <code>int</code> is 2 bytes,
&amp; Base address for <code>a</code> is 1000.</p>

<p>How <code>a[5]</code> will work -&gt;</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">Base Address of your Array a + (<span class="hljs-number">5</span>*size of(data type <span class="hljs-keyword">for</span> <span class="hljs-built_in">array</span> a))
i.e. <span class="hljs-number">1000</span> + (<span class="hljs-number">5</span>*<span class="hljs-number">2</span>) = <span class="hljs-number">1010</span>
</code></pre>

<p>So, </p>

<p>Similarly when the c code is broken down into 3-address code, 
<code>5[a]</code> will become -&gt;</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">Base Address of your Array a + (size of(data type <span class="hljs-keyword">for</span> <span class="hljs-built_in">array</span> a)*<span class="hljs-number">5</span>)
i.e. <span class="hljs-number">1000</span> + (<span class="hljs-number">2</span>*<span class="hljs-number">5</span>) = <span class="hljs-number">1010</span> 
</code></pre>

<p>So basically both the statements are pointing to the same location in memory and hence, <code>a[5] = 5[a]</code>.</p>

<p>This explanation is also the reason why negative indexes in arrays work in C.</p>

<p>i.e. if I access <code>a[-5]</code> it will give me</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">Base Address of your Array a + (<span class="hljs-number">-5</span> * size of(data type <span class="hljs-keyword">for</span> <span class="hljs-built_in">array</span> a))
i.e. <span class="hljs-number">1000</span> + (<span class="hljs-number">-5</span>*<span class="hljs-number">2</span>) = <span class="hljs-number">990</span>
</code></pre>

<p>It will return me object at location 990.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>in c compiler </p>

<pre class="lang-c s-code-block"><code class="hljs language-c">a[i]
i[a]
*(a+i)
</code></pre>

<p>are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C arrays, <code>arr[3]</code> and <code>3[arr]</code> are the same, and their equivalent pointer notations are <code>*(arr + 3)</code> to <code>*(3 + arr)</code>. But on the contrary <code>[arr]3</code> or <code>[3]arr</code> is not correct and will result into syntax error, as <code>(arr + 3)*</code> and <code>(3 + arr)*</code> are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A little bit of history now.  Among other languages, BCPL had a fairly major influence on C's early development.  If you declared an array in BCPL with something like:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">let V = vec <span class="hljs-number">10</span>
</code></pre>

<p>that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">let J = V!<span class="hljs-number">5</span>
</code></pre>

<p>really did have to do <code>J = !(V + 5)</code> (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus <code>V!5</code> and <code>5!V</code> were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)</p>

<p>The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.</p>

<p>Note that <code>!</code> in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of "pointer and integer" was made necessary in C when it gained data types, and <code>sizeof</code> became a thing.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, this is a feature that is only possible because of the language support.</p>

<p>The compiler interprets <code>a[i]</code> as <code>*(a+i)</code> and the expression <code>5[a]</code> evaluates to <code>*(5+a)</code>. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to <code>true</code>.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">int</span> a[]={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>};
 <span class="hljs-type">int</span> *p=a;
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,*p++);<span class="hljs-comment">//output will be 10</span>
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,*a++);<span class="hljs-comment">//will give an error</span>
</code></pre>
<p>Pointer <code>p</code> is a "variable", array name <code>a</code> is a "mnemonic" or "synonym",
so <code>p++</code> is valid but <code>a++</code> is invalid.</p>
<p><code>a[2]</code> is equals to <code>2[a]</code> because the internal operation on both of this is "Pointer Arithmetic" internally calculated as <code>*(a+2)</code> equals <code>*(2+a)</code></p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because C compiler always convert array notation in pointer notation.
<code>a[5] = *(a + 5)</code>  also <code>5[a] = *(5 + a) = *(a + 5)</code>
So, both are equal.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointer-arithmetic">pointer-arithmetic</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because it's useful to avoid confusing nesting.</p>
<p>Would you rather read this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">array</span>[<span class="hljs-built_in">array</span>[head].next].prev
</code></pre>
<p>or this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">head[<span class="hljs-built_in">array</span>].next[<span class="hljs-built_in">array</span>].prev
</code></pre>
<p>Incidentally, C++ has a similar commutative property for function calls. Rather than writing <code>g(f(x))</code> as you must in C, you may use member functions to write <code>x.f().g()</code>. Replace f and g with lookup tables and you can write <code>g[f[x]]</code> (functional style) or <code>(x[f])[g]</code> (oop style). The latter gets really nice with structs containing indices: <code>x[xs].y[ys].z[zs]</code>. Using the more common notation that's <code>zs[ys[xs[x].y].z]</code>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160">How do I merge two dictionaries in a single expression?</a><a href="/questions/dollar(document).ready-equivalent-without-jquery-1657388504115">$(document).ready equivalent without jQuery</a><a href="/questions/trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490">Trouble with UTF-8 characters; what I see is not what I stored</a><a href="/questions/how-to-choose-the-right-bean-scope-1657387596513">How to choose the right bean scope?</a><a href="/questions/what-are-copy-elision-and-return-value-optimization-1657385455976">What are copy elision and return value optimization?</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/parameterize-an-sql-in-clause-1657387536064">Parameterize an SQL IN clause</a><a href="/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747">SQL injection that gets around mysql_real_escape_string()</a><a href="/questions/how-to-generate-all-permutations-of-a-list-1657388537371">How to generate all permutations of a list</a><a href="/questions/why-not-use-tables-for-layout-in-html-closed-1657387752327">Why not use tables for layout in HTML? [closed]</a><a href="/questions/actual-meaning-of-&#x27;shelltrue&#x27;-in-subprocess-1657388470341">Actual meaning of &#x27;shell=True&#x27; in subprocess</a><a href="/questions/how-to-append-text-to-an-existing-file-in-java-1657388492377">How to append text to an existing file in Java?</a><a href="/questions/string.equals-versus-duplicate-1657387599972">String.equals versus == [duplicate]</a><a href="/questions/why-is-using-%22for...in%22-for-array-iteration-a-bad-idea-1657384653458">Why is using &quot;for...in&quot; for array iteration a bad idea?</a><a href="/questions/query-based-on-multiple-where-clauses-in-firebase-1657387494547">Query based on multiple where clauses in Firebase</a><a href="/questions/how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934">How to use java.net.URLConnection to fire and handle HTTP requests</a><a href="/questions/is-an-array-name-a-pointer-1657387874827">Is an array name a pointer?</a><a href="/questions/prefer-composition-over-inheritance-1657387399409">Prefer composition over inheritance?</a><a href="/questions/providing-white-space-in-a-swing-gui-1657384734588">Providing white space in a Swing GUI</a><a href="/questions/error-in-finding-last-used-cell-in-excel-with-vba-1657384584748">Error in finding last used cell in Excel with VBA</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The C standard defines the \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; operator as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a[b] == *(a + b)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore \u0026lt;code\u0026gt;a[5]\u0026lt;/code\u0026gt; will evaluate to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;code\u0026gt;5[a]\u0026lt;/code\u0026gt; will evaluate to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; + a)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a pointer to the first element of the array. \u0026lt;code\u0026gt;a[5]\u0026lt;/code\u0026gt; is the value that\u0026apos;s 5 \u0026lt;strong\u0026gt;elements\u0026lt;/strong\u0026gt; further from \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, which is the same as \u0026lt;code\u0026gt;*(a + 5)\u0026lt;/code\u0026gt;, and from elementary school math we know those are equal (addition is \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/commutative\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;commutative\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because array access is defined in terms of pointers.  \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; is defined to mean \u0026lt;code\u0026gt;*(a + i)\u0026lt;/code\u0026gt;, which is commutative.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think something is being missed by the other answers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, \u0026lt;code\u0026gt;p[i]\u0026lt;/code\u0026gt; is by definition equivalent to \u0026lt;code\u0026gt;*(p+i)\u0026lt;/code\u0026gt;, which (because addition is commutative) is equivalent to \u0026lt;code\u0026gt;*(i+p)\u0026lt;/code\u0026gt;, which (again, by the definition of the \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; operator) is equivalent to \u0026lt;code\u0026gt;i[p]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(And in \u0026lt;code\u0026gt;array[i]\u0026lt;/code\u0026gt;, the array name is implicitly converted to a pointer to the array\u0026apos;s first element.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But the commutativity of addition is not all that obvious in this case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: \u0026lt;code\u0026gt;x + y == y + x\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But in this case we\u0026apos;re talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C standard\u0026apos;s description of the \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; operator (\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\u0026quot;\u0026gt;N1570\u0026lt;/a\u0026gt; 6.5.6) says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It could just as easily have said:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;For addition, either both operands shall have arithmetic type, or \u0026lt;em\u0026gt;the left\u0026lt;/em\u0026gt;\n  operand shall be a pointer to a complete object type and the \u0026lt;em\u0026gt;right operand\u0026lt;/em\u0026gt;\n  shall have integer type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;in which case both \u0026lt;code\u0026gt;i + p\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;i[p]\u0026lt;/code\u0026gt; would be illegal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C++ terms, we really have two sets of overloaded \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; operators, which can be loosely described as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;pointer operator+(pointer p, integer i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;pointer operator+(integer i, pointer p);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;of which only the first is really necessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So why is it this way?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 \u0026lt;a href=\u0026quot;https://www.bell-labs.com/usr/dmr/www/kbman.html\u0026quot;\u0026gt;Users\u0026apos; Reference to B\u0026lt;/a\u0026gt;), which got it from \u0026lt;a href=\u0026quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html\u0026quot;\u0026gt;BCPL\u0026lt;/a\u0026gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C\u0026apos;s ancestor languages.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the \u0026lt;code\u0026gt;unsigned\u0026lt;/code\u0026gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn\u0026apos;t have occurred to the designers of those languages. If a user wanted to add two \u0026quot;things\u0026quot;, whether those \u0026quot;things\u0026quot; are integers, pointers, or something else, it wasn\u0026apos;t up to the language to prevent it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So now we have \u0026lt;code\u0026gt;arr[3]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;3[arr]\u0026lt;/code\u0026gt; meaning exactly the same thing, though the latter form should never appear outside the \u0026lt;a href=\u0026quot;http://ioccc.org/\u0026quot;\u0026gt;IOCCC\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;And, of course\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ABCD\u0026quot;\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ABCD\u0026quot;\u0026lt;/span\u0026gt;]) \u0026amp;amp;\u0026amp;amp; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ABCD\u0026quot;\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ABCD\u0026quot;\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The main reason for this was that back in the 70\u0026apos;s when C was designed, computers didn\u0026apos;t have much memory (64KB was a lot), so the C compiler didn\u0026apos;t do much syntax checking.  Hence \u0026quot;\u0026lt;code\u0026gt;X[Y]\u0026lt;/code\u0026gt;\u0026quot; was rather blindly translated into \u0026quot;\u0026lt;code\u0026gt;*(X+Y)\u0026lt;/code\u0026gt;\u0026quot;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This also explains the \u0026quot;\u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt;\u0026quot; and \u0026quot;\u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt;\u0026quot; syntaxes.  Everything in the form \u0026quot;\u0026lt;code\u0026gt;A = B + C\u0026lt;/code\u0026gt;\u0026quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn\u0026apos;t bright enough to recognize it, so the developer had to (\u0026lt;code\u0026gt;A += C\u0026lt;/code\u0026gt;).   Similarly, if \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; was \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn\u0026apos;t recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One thing no-one seems to have mentioned about Dinah\u0026apos;s problem with \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can only add an integer to a pointer, you can\u0026apos;t add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To answer the question literally. It is not always true that \u0026lt;code\u0026gt;x == x\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; zero = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a[] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, zero/zero}; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// NaN\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cout\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;[a] ? \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;true\u0026quot;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;false\u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;prints\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just find out this ugly syntax could be \u0026quot;useful\u0026quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; , \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; , \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; , \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; , \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; s = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; a / \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *a;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  s == 5\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ; i \u0026amp;lt; s ; ++i) {  \n           \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cout\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; a[a[a[i]]] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... is equivalent to ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cout\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; i[a][a][a] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but I prefer this one, it\u0026apos;s easier to increase the level of indirection (without loop)\u0026lt;/span\u0026gt;\n    \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Of course, I\u0026apos;m quite sure that there is no use case for that in real code, but I found it interesting anyway :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Nice question/answers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just want to point out that C pointers and arrays are not the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt;, although in this case the difference is not essential. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following declarations:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;a.out\u0026lt;/code\u0026gt;, the symbol \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is at an address that\u0026apos;s the beginning of the array, and symbol \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For pointers in C, we have\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] == *(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and also\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;[a] == *(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; + a)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Hence it is true that \u0026lt;code\u0026gt;a[5] == 5[a].\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Not an answer, but just some food for thought.\nIf class is having overloaded index/subscript operator, the expression \u0026lt;code\u0026gt;0[x]\u0026lt;/code\u0026gt; will not work:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Sub\u0026lt;/span\u0026gt;\n{\u0026lt;/span\u0026gt;\npublic:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; operator [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; nIndex)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    }   \n};\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    Sub s;\n    s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;[s]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ERROR \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since we dont have access to \u0026lt;strong\u0026gt;int\u0026lt;/strong\u0026gt; class, this cannot be done:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n{\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; operator[](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Sub\u0026amp;amp;);\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It has very good explanation in \u0026lt;em\u0026gt;A TUTORIAL ON POINTERS AND ARRAYS IN C\u0026lt;/em\u0026gt;\nby Ted Jensen.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Ted Jensen explained it as:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In fact, this is true, i.e wherever one writes \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; it can be\n  replaced with \u0026lt;code\u0026gt;*(a + i)\u0026lt;/code\u0026gt;  without any problems. In fact, the compiler\n  will create the same code in either case. Thus we see that pointer\n  arithmetic is the same thing as array indexing. Either syntax produces\n  the same result.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This is NOT saying that pointers and arrays\n  are the same thing, they are not. We are only saying that to identify\n  a given element of an array we have the choice of two syntaxes, one\n  using array indexing and the other using pointer arithmetic, which\n  yield identical results.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Now, looking at this last\n  expression, part of it.. \u0026lt;code\u0026gt;(a + i)\u0026lt;/code\u0026gt;, is a simple addition using the +\n  operator and the rules of C state that such an expression is\n  commutative. That is (a + i) is identical to \u0026lt;code\u0026gt;(i + a)\u0026lt;/code\u0026gt;. Thus we could\n  write \u0026lt;code\u0026gt;*(i + a)\u0026lt;/code\u0026gt; just as easily as \u0026lt;code\u0026gt;*(a + i)\u0026lt;/code\u0026gt;.\n  But \u0026lt;code\u0026gt;*(i + a)\u0026lt;/code\u0026gt; could have come from \u0026lt;code\u0026gt;i[a]\u0026lt;/code\u0026gt; ! From all of this comes the curious\n  truth that if:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;writing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;is the same as writing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;[a] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know the question is answered, but I couldn\u0026apos;t resist sharing this explanation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I remember Principles of Compiler design,\nLet\u0026apos;s assume \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; array and size of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; is 2 bytes,\n\u0026amp;amp; Base address for \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is 1000.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How \u0026lt;code\u0026gt;a[5]\u0026lt;/code\u0026gt; will work -\u0026amp;gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;Base Address of your Array a + (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;*size of(data type \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt; a))\ni.e. \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; + (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;*\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1010\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly when the c code is broken down into 3-address code, \n\u0026lt;code\u0026gt;5[a]\u0026lt;/code\u0026gt; will become -\u0026amp;gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;Base Address of your Array a + (size of(data type \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt; a)*\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\ni.e. \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; + (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;*\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1010\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So basically both the statements are pointing to the same location in memory and hence, \u0026lt;code\u0026gt;a[5] = 5[a]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This explanation is also the reason why negative indexes in arrays work in C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;i.e. if I access \u0026lt;code\u0026gt;a[-5]\u0026lt;/code\u0026gt; it will give me\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;Base Address of your Array a + (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-5\u0026lt;/span\u0026gt; * size of(data type \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt; a))\ni.e. \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; + (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-5\u0026lt;/span\u0026gt;*\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;990\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It will return me object at location 990.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;in c compiler \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;a[i]\ni[a]\n*(a+i)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C arrays, \u0026lt;code\u0026gt;arr[3]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;3[arr]\u0026lt;/code\u0026gt; are the same, and their equivalent pointer notations are \u0026lt;code\u0026gt;*(arr + 3)\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;*(3 + arr)\u0026lt;/code\u0026gt;. But on the contrary \u0026lt;code\u0026gt;[arr]3\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;[3]arr\u0026lt;/code\u0026gt; is not correct and will result into syntax error, as \u0026lt;code\u0026gt;(arr + 3)*\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;(3 + arr)*\u0026lt;/code\u0026gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A little bit of history now.  Among other languages, BCPL had a fairly major influence on C\u0026apos;s early development.  If you declared an array in BCPL with something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;let V = vec \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;let J = V!\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;really did have to do \u0026lt;code\u0026gt;J = !(V + 5)\u0026lt;/code\u0026gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus \u0026lt;code\u0026gt;V!5\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;5!V\u0026lt;/code\u0026gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of \u0026quot;pointer and integer\u0026quot; was made necessary in C when it gained data types, and \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; became a thing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, this is a feature that is only possible because of the language support.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler interprets \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;*(a+i)\u0026lt;/code\u0026gt; and the expression \u0026lt;code\u0026gt;5[a]\u0026lt;/code\u0026gt; evaluates to \u0026lt;code\u0026gt;*(5+a)\u0026lt;/code\u0026gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[]={\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;40\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;};\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p=a;\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;,*p++);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//output will be 10\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;,*a++);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//will give an error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Pointer \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; is a \u0026quot;variable\u0026quot;, array name \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a \u0026quot;mnemonic\u0026quot; or \u0026quot;synonym\u0026quot;,\nso \u0026lt;code\u0026gt;p++\u0026lt;/code\u0026gt; is valid but \u0026lt;code\u0026gt;a++\u0026lt;/code\u0026gt; is invalid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a[2]\u0026lt;/code\u0026gt; is equals to \u0026lt;code\u0026gt;2[a]\u0026lt;/code\u0026gt; because the internal operation on both of this is \u0026quot;Pointer Arithmetic\u0026quot; internally calculated as \u0026lt;code\u0026gt;*(a+2)\u0026lt;/code\u0026gt; equals \u0026lt;code\u0026gt;*(2+a)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because C compiler always convert array notation in pointer notation.\n\u0026lt;code\u0026gt;a[5] = *(a + 5)\u0026lt;/code\u0026gt;  also \u0026lt;code\u0026gt;5[a] = *(5 + a) = *(a + 5)\u0026lt;/code\u0026gt;\nSo, both are equal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because it\u0026apos;s useful to avoid confusing nesting.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Would you rather read this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[head].next].prev\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;head[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;].next[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;].prev\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Incidentally, C++ has a similar commutative property for function calls. Rather than writing \u0026lt;code\u0026gt;g(f(x))\u0026lt;/code\u0026gt; as you must in C, you may use member functions to write \u0026lt;code\u0026gt;x.f().g()\u0026lt;/code\u0026gt;. Replace f and g with lookup tables and you can write \u0026lt;code\u0026gt;g[f[x]]\u0026lt;/code\u0026gt; (functional style) or \u0026lt;code\u0026gt;(x[f])[g]\u0026lt;/code\u0026gt; (oop style). The latter gets really nice with structs containing indices: \u0026lt;code\u0026gt;x[xs].y[ys].z[zs]\u0026lt;/code\u0026gt;. Using the more common notation that\u0026apos;s \u0026lt;code\u0026gt;zs[ys[xs[x].y].z]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":429,"title":"With arrays, why is it the case that a[5] == 5[a]?","content":"\n                \n\u0026lt;p\u0026gt;As Joel points out in \u0026lt;a href=\u0026quot;https://stackoverflow.blog/2008/12/18/podcast-34/\u0026quot;\u0026gt;Stack Overflow podcast #34\u0026lt;/a\u0026gt;, in \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0131103628\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C Programming Language\u0026lt;/a\u0026gt; (aka: K \u0026amp;amp; R), there is mention of this property of arrays in C: \u0026lt;code\u0026gt;a[5] == 5[a]\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Joel says that it\u0026apos;s because of pointer arithmetic but I still don\u0026apos;t understand. \u0026lt;strong\u0026gt;Why does \u0026lt;code\u0026gt;a[5] == 5[a]\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;?\u0026lt;/p\u0026gt;\n    ","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216","postType":"QUESTION","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","tags":[{"id":2254,"name":"pointer-arithmetic","slug":"pointer-arithmetic","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","Questions_Tags":{"questionId":429,"tagId":2254}}],"relatedQuestions":[{"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216","tags":[{"name":"pointer-arithmetic","Questions_Tags":{"questionId":429,"tagId":2254}}]}]},"randomQuestions":[{"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"Trouble with UTF-8 characters; what I see is not what I stored","slug":"trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490"},{"title":"How to choose the right bean scope?","slug":"how-to-choose-the-right-bean-scope-1657387596513"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"Parameterize an SQL IN clause","slug":"parameterize-an-sql-in-clause-1657387536064"},{"title":"SQL injection that gets around mysql_real_escape_string()","slug":"sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"Why not use tables for layout in HTML? [closed]","slug":"why-not-use-tables-for-layout-in-html-closed-1657387752327"},{"title":"Actual meaning of 'shell=True' in subprocess","slug":"actual-meaning-of-'shelltrue'-in-subprocess-1657388470341"},{"title":"How to append text to an existing file in Java?","slug":"how-to-append-text-to-an-existing-file-in-java-1657388492377"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Why is using \"for...in\" for array iteration a bad idea?","slug":"why-is-using-\"for...in\"-for-array-iteration-a-bad-idea-1657384653458"},{"title":"Query based on multiple where clauses in Firebase","slug":"query-based-on-multiple-where-clauses-in-firebase-1657387494547"},{"title":"How to use java.net.URLConnection to fire and handle HTTP requests","slug":"how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934"},{"title":"Is an array name a pointer?","slug":"is-an-array-name-a-pointer-1657387874827"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"Providing white space in a Swing GUI","slug":"providing-white-space-in-a-swing-gui-1657384734588"},{"title":"Error in finding last used cell in Excel with VBA","slug":"error-in-finding-last-used-cell-in-excel-with-vba-1657384584748"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"},"buildId":"5tS3Jli5j89_wXapXajXn","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>