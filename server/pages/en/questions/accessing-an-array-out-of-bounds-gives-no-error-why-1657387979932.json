{"pageProps":{"data":{"answer":["\n&lt;p&gt;Welcome to every C/C++ programmer&apos;s bestest friend: &lt;strong&gt;Undefined Behavior&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;There is a lot that is not specified by the language standard, for a variety of reasons. This is one of them.&lt;/p&gt;\n\n&lt;p&gt;In general, whenever you encounter undefined behavior, &lt;em&gt;anything&lt;/em&gt; might happen. The application may crash, it may freeze, it may eject your CD-ROM drive or make demons come out of your nose. It may format your harddrive or email all your porn to your grandmother.&lt;/p&gt;\n\n&lt;p&gt;It may even, if you are really unlucky, &lt;em&gt;appear&lt;/em&gt; to work correctly.&lt;/p&gt;\n\n&lt;p&gt;The language simply says what should happen if you access the elements &lt;em&gt;within&lt;/em&gt; the bounds of an array. It is left undefined what happens if you go out of bounds. It might &lt;em&gt;seem&lt;/em&gt; to work today, on your compiler, but it is not legal C or C++, and there is no guarantee that it&apos;ll still work the next time you run the program. Or that it hasn&apos;t overwritten essential data even now, and you just haven&apos;t encountered the problems, that it &lt;em&gt;is&lt;/em&gt; going to cause  yet.&lt;/p&gt;\n\n&lt;p&gt;As for &lt;em&gt;why&lt;/em&gt; there is no bounds checking, there are a couple aspects to the answer:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;An array is a leftover from C. C arrays are about as primitive as you can get. Just a sequence of elements with contiguous addresses. There is no bounds checking because it is simply exposing raw memory. Implementing a robust bounds-checking mechanism would have been almost impossible in C.&lt;/li&gt;\n&lt;li&gt;In C++, bounds-checking is possible on class types. But an array is still the plain old C-compatible one. It is not a class. Further, C++ is also built on another rule which makes bounds-checking non-ideal. The C++ guiding principle is &quot;you don&apos;t pay for what you don&apos;t use&quot;. If your code is correct, you don&apos;t need bounds-checking, and you shouldn&apos;t be forced to pay for the overhead of runtime bounds-checking.&lt;/li&gt;\n&lt;li&gt;So C++ offers the &lt;code&gt;std::vector&lt;/code&gt; class template, which allows both. &lt;code&gt;operator[]&lt;/code&gt; is designed to be efficient. The language standard does not require that it performs bounds checking (although it does not forbid it either). A vector also has the &lt;code&gt;at()&lt;/code&gt; member function which &lt;em&gt;is guaranteed&lt;/em&gt; to perform bounds-checking. So in C++, you get the best of both worlds if you use a vector. You get array-like performance without bounds-checking, &lt;em&gt;and&lt;/em&gt; you get the ability to use bounds-checked access when you want it.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Using g++, you can add the command line option:  &lt;code&gt;-fstack-protector-all&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;On your example it resulted in the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;gt; g++ -o t -fstack-protector-all t.cc\n&amp;gt; ./t\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n/bin/bash: line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;15450&lt;/span&gt; Segmentation fault      ./t\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It doesn&apos;t really help you find or solve the problem, but at least the segfault will let you know that &lt;em&gt;something&lt;/em&gt; is wrong.&lt;/p&gt;\n    ","\n&lt;p&gt;g++ does not check for array bounds, and you may be overwriting something with 3,4 but nothing really important, if you try with higher numbers you&apos;ll get a crash.&lt;/p&gt;\n\n&lt;p&gt;You are just overwriting parts of the stack that are not used, you could continue till you reach the end of the allocated space for the stack and it&apos;d crash eventually&lt;/p&gt;\n\n&lt;p&gt;EDIT:\nYou have no way of dealing with that, maybe a static code analyzer could reveal those failures, but that&apos;s too simple, you may have similar(but more complex) failures undetected even for static analyzers&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s undefined behavior as far as I know. Run a larger program with that and it will crash somewhere along the way. Bounds checking is not a part of raw arrays (or even std::vector).&lt;/p&gt;\n&lt;p&gt;Use std::vector with &lt;code&gt;std::vector::iterator&lt;/code&gt;&apos;s instead so you don&apos;t have to worry about it.&lt;/p&gt;\n&lt;p&gt;Edit:&lt;/p&gt;\n&lt;p&gt;Just for fun, run this and see how long until you crash:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;; i++)\n   {\n       arr[i] = i;\n   }\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//will be lucky to ever reach this&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Edit2:&lt;/p&gt;\n&lt;p&gt;Don&apos;t run that.&lt;/p&gt;\n&lt;p&gt;Edit3:&lt;/p&gt;\n&lt;p&gt;OK, here is a quick lesson on arrays and their relationships with pointers:&lt;/p&gt;\n&lt;p&gt;When you use array indexing, you are really using a pointer in disguise (called a &quot;reference&quot;), that is automatically dereferenced. This is why instead of *(array+1), array[1] automatically returns the value at that index.&lt;/p&gt;\n&lt;p&gt;When you have a pointer to an array, like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ptr = arr;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then the &quot;array&quot; in the second declaration is really decaying to a pointer to the first array. This is equivalent behavior to this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ptr = &amp;amp;arr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;When you try to access beyond what you allocated, you are really just using a pointer to other memory (which C++ won&apos;t complain about). Taking my example program above, that is equivalent to this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ptr = arr;\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;; i++, ptr++)\n   {\n       *ptr++ = i;\n   }\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//will be lucky to ever reach this&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The compiler won&apos;t complain because in programming, you often have to communicate with other programs, especially the operating system. This is done with pointers quite a bit.&lt;/p&gt;\n    ","\n&lt;h2&gt;Hint&lt;/h2&gt;\n\n&lt;p&gt;If you want to have fast constraint size arrays with range error check, try using &lt;a href=&quot;http://www.boost.org/doc/libs/1_39_0/doc/html/array.html&quot; rel=&quot;noreferrer&quot;&gt;boost::array&lt;/a&gt;, (also &lt;a href=&quot;http://beans.seartipy.com/2006/12/10/getting-started-with-c-tr1-libraries/&quot; rel=&quot;noreferrer&quot;&gt;std::tr1::array&lt;/a&gt; from &lt;code&gt;&amp;lt;tr1/array&amp;gt;&lt;/code&gt; it will be standard container in next C++ specification). It&apos;s much faster then std::vector. It reserve memory on heap or inside class instance, just like int array[].&lt;br&gt;\nThis is simple sample code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;boost/array.hpp&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    boost::array&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,2&amp;gt; array;\n    array.&lt;span class=&quot;hljs-built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// checking index is inside range&lt;/span&gt;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// no error check, as fast as int array[2];&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;\n    {\n       &lt;span class=&quot;hljs-comment&quot;&gt;// index is inside range&lt;/span&gt;\n       std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;array.at(0) = &quot;&lt;/span&gt; &amp;lt;&amp;lt; array.&lt;span class=&quot;hljs-built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; std::endl;\n\n       &lt;span class=&quot;hljs-comment&quot;&gt;// index is outside range, throwing exception&lt;/span&gt;\n       std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;array.at(2) = &quot;&lt;/span&gt; &amp;lt;&amp;lt; array.&lt;span class=&quot;hljs-built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; std::endl; \n\n       &lt;span class=&quot;hljs-comment&quot;&gt;// never comes here&lt;/span&gt;\n       std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;array.at(1) = &quot;&lt;/span&gt; &amp;lt;&amp;lt; array.&lt;span class=&quot;hljs-built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; std::endl;  \n    }\n    &lt;span class=&quot;hljs-built_in&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::out_of_range&amp;amp; r)\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Something goes wrong: &quot;&lt;/span&gt; &amp;lt;&amp;lt; r.&lt;span class=&quot;hljs-built_in&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This program will print:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;array.&lt;span class=&quot;hljs-built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nSomething goes wrong: array&amp;lt;&amp;gt;: index out of range\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;C or C++ will not check the bounds of an array access.&lt;/p&gt;\n\n&lt;p&gt;You are allocating the array on the stack.  Indexing the array via &lt;code&gt;array[3]&lt;/code&gt; is equivalent to *&lt;code&gt;(array + 3)&lt;/code&gt;, where array is a pointer to &amp;amp;array[0].  This will result in undefined behavior.&lt;/p&gt;\n\n&lt;p&gt;One way to catch this &lt;strong&gt;sometimes&lt;/strong&gt; in C is to use a static checker, such as &lt;strong&gt;splint&lt;/strong&gt;.  If you run:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;splint +bounds array.c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;on,&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n\n    array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then you will get the warning:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;array.c: (in function main)\n  array.c:5:9: Likely out-of-bounds\n  store:\n      array[1]\n      Unable to resolve constraint:\n      requires 0 &amp;gt;= 1\n       needed to satisfy precondition:\n      requires maxSet(array @ array.c:5:9) &amp;gt;= 1   A memory write may\n  write to an address beyond the\n  allocated buffer.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Run this through &lt;a href=&quot;http://valgrind.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Valgrind&lt;/a&gt; and you might see an error.&lt;/p&gt;\n\n&lt;p&gt;As Falaina pointed out, valgrind does not detect many instances of stack corruption.  I just tried the sample under valgrind, and it does indeed report zero errors.  However, Valgrind can be instrumental in finding many other types of memory problems, it&apos;s just not particularly useful in this case unless you modify your bulid to include the --stack-check option.  If you build and run the sample as &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;g++ --stack-check -W -Wall errorRange.cpp -o errorRange\nvalgrind ./errorRange\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;valgrind &lt;strong&gt;will&lt;/strong&gt; report an error.&lt;/p&gt;\n    ","\n&lt;p&gt;You are certainly overwriting your stack, but the program is simple enough that effects of this go unnoticed.&lt;/p&gt;\n    ","\n&lt;p&gt;libstdc++, which is part of gcc, has a special &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;debug mode&lt;/a&gt; for error checking. It is enabled by  compiler flag &lt;code&gt;-D_GLIBCXX_DEBUG&lt;/code&gt;. Among other things it does bounds checking for &lt;code&gt;std::vector&lt;/code&gt; at the cost of performance. Here is &lt;a href=&quot;https://wandbox.org/permlink/XaTJtZdqier9zrI4&quot; rel=&quot;nofollow noreferrer&quot;&gt;online demo&lt;/a&gt; with recent version of gcc.&lt;/p&gt;\n\n&lt;p&gt;So actually you can do bounds checking with libstdc++ debug mode but you should do it only when testing because it costs notable performance compared to normal libstdc++ mode.&lt;/p&gt;\n    ","\n&lt;p&gt;Undefined behavior working in your favor.  Whatever memory you&apos;re clobbering apparently isn&apos;t holding anything important.  Note that C and C++ do not do bounds checking on arrays, so stuff like that isn&apos;t going to be caught at compile or run time.  &lt;/p&gt;\n    ","\n&lt;p&gt;When you write &apos;array[index]&apos; in C it translates it to machine instructions.&lt;/p&gt;\n\n&lt;p&gt;The translation is goes something like: &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&apos;get the address of array&apos;&lt;/li&gt;\n&lt;li&gt;&apos;get the size of the type of objects array is made up of&apos;&lt;/li&gt;\n&lt;li&gt;&apos;multiply the size of the type by index&apos;&lt;/li&gt;\n&lt;li&gt;&apos;add the result to the address of array&apos;&lt;/li&gt;\n&lt;li&gt;&apos;read what&apos;s at the resulting address&apos;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The result addresses something which may, or may not, be part of the array. In exchange for the blazing speed of machine instructions you lose the safety net of the computer checking things for you. If you&apos;re meticulous and careful it&apos;s not a problem. If you&apos;re sloppy or make a mistake you get burnt. Sometimes it might generate an invalid instruction that causes an exception, sometimes not.&lt;/p&gt;\n    ","\n&lt;p&gt;When you initialize the array with &lt;code&gt;int array[2]&lt;/code&gt;, space for 2 integers is allocated; but the identifier &lt;code&gt;array&lt;/code&gt; simply points to the beginning of that space. When you then access &lt;code&gt;array[3]&lt;/code&gt; and &lt;code&gt;array[4]&lt;/code&gt;, the compiler then simply increments that address to point to where those values would be, if the array was long enough; try accessing something like &lt;code&gt;array[42]&lt;/code&gt; without initializing it first, you&apos;ll end up getting whatever value happened to already be in memory at that location.&lt;/p&gt;\n\n&lt;p&gt;Edit:&lt;/p&gt;\n\n&lt;p&gt;More info on pointers/arrays: &lt;a href=&quot;http://home.netcom.com/~tjensen/ptr/pointers.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://home.netcom.com/~tjensen/ptr/pointers.htm&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;As I understand, local variables are allocated on stack, so going out of bounds on your own stack can only overwrite some other local variable, unless you go oob too much and exceed your stack size.\nSince you have no other variables declared in your function - it does not cause any side effects. Try declaring another variable/array right after your first one and see what will happen with it.&lt;/p&gt;\n    ","\n&lt;p&gt;A nice approach that i have seen often and I had been used actually is to inject some NULL type element (or a created one, like &lt;code&gt;uint THIS_IS_INFINITY = 82862863263;&lt;/code&gt;) at end of the array.&lt;/p&gt;\n\n&lt;p&gt;Then at the loop condition check, &lt;code&gt;TYPE *pagesWords&lt;/code&gt; is some kind of pointer array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; pagesWordsLength = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(pagesWords) / &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(pagesWords[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;realloc&lt;/span&gt; (pagesWords, &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(pagesWords[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]) * (pagesWordsLength + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n\npagesWords[pagesWordsLength] = MY_NULL;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (uint i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;; i++)\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (pagesWords[i] == MY_NULL)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This solution won&apos;t word if array is filled with &lt;code&gt;struct&lt;/code&gt; types.&lt;/p&gt;\n    ","\n&lt;p&gt;As mentioned now in the question using std::vector::at will solve the problem and make a bound check before accessing.&lt;/p&gt;\n\n&lt;p&gt;If you need a constant size array that is located on the stack as your first code use the C++11 new container std::array; as vector there is std::array::at function. In fact the function exists in all standard containers in which it have a meaning,i.e, where operator[] is defined :( deque, map, unordered_map) with the exception of std::bitset in which it is called std::bitset::test.&lt;/p&gt;\n    ","\n&lt;p&gt;If you change your program slightly:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; array[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n    INT NOTHING;\n    CHAR FOO[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;];\n    &lt;span class=&quot;hljs-built_in&quot;&gt;STRCPY&lt;/span&gt;(FOO, &lt;span class=&quot;hljs-string&quot;&gt;&quot;BAR&quot;&lt;/span&gt;);\n    array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; array[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; array[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n    COUT &amp;lt;&amp;lt; FOO &amp;lt;&amp;lt; ENDL;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Changes in capitals -- put those in lower case if you&apos;re going to try this.)&lt;/p&gt;\n\n&lt;p&gt;You will see that the variable &lt;strong&gt;foo&lt;/strong&gt; has been trashed.  Your code &lt;strong&gt;will&lt;/strong&gt; store values into the nonexistent array[3] and array[4], and be able to properly retrieve them, but the actual storage used will be from &lt;strong&gt;foo&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;So you can &quot;get away&quot; with exceeding the bounds of the array in your original example, but at the cost of causing damage elsewhere -- damage which may prove to be &lt;strong&gt;very&lt;/strong&gt; hard to diagnose.&lt;/p&gt;\n\n&lt;p&gt;As to why there is no automatic bounds checking -- a correctly written program does not need it.  Once that has been done, there is no reason to do run-time bounds checking and doing so would just slow down the program.  Best to get that all figured out during design and coding.&lt;/p&gt;\n\n&lt;p&gt;C++ is based on C, which was designed to be as close to assembly language as possible.&lt;/p&gt;\n    ","\n&lt;p&gt;when you declare int array[2]; you reserve 2 memory spaces of 4 bytes each(32bit program).\nif you type array[4] in your code it still corresponds to a valid call but only at run time will it throw an unhandled exception.  C++ uses manual memory management. This is actually a security flaw that was used for hacking programs&lt;/p&gt;\n\n&lt;p&gt;this can help understanding:&lt;/p&gt;\n\n&lt;p&gt;int * somepointer;   &lt;/p&gt;\n\n&lt;p&gt;somepointer[0]=somepointer[5];&lt;/p&gt;\n    ","\n&lt;p&gt;The behavior can depend on your system. Typically, you will have a margin for out of bounds, sometimes with value of 0 or garbage values. For the details you can check with memory allocation mechanism used in your OS. On top of that, if you use the programming language like c/c++, it will not check the bounds when you using some containers, like array. So, you will meet &quot;undefined event&quot; because you do not know what the OS did below the surface. But like the programming language Java, it will check the bound. If you step outside of the bound, you will get an exception.&lt;/p&gt;\n    "],"id":437,"title":"Accessing an array out of bounds gives no error, why?","content":"\n                \n&lt;p&gt;I am assigning values in a C++ program out of the bounds like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; array[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n    array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n    array[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; array[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; array[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The program prints &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;.  It should not be possible.  I am using g++ 4.3.3&lt;/p&gt;\n\n&lt;p&gt;Here is compile and run command&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -W -Wall errorRange.cpp -o errorRange\n$ ./errorRange\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Only when assigning &lt;code&gt;array[3000]=3000&lt;/code&gt; does it give me a segmentation fault.&lt;/p&gt;\n\n&lt;p&gt;If gcc doesn&apos;t check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?&lt;/p&gt;\n\n&lt;p&gt;I replaced the above code with&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;vint&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\nvint[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\nvint[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\nvint[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\nvint[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\ncout &amp;lt;&amp;lt; vint[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; endl;\ncout &amp;lt;&amp;lt; vint[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and this one also produces no error. &lt;/p&gt;\n    ","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932","postType":"QUESTION","createdAt":"2022-07-09T17:32:59.000Z","updatedAt":"2022-07-09T17:32:59.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Convert Rows to columns using 'Pivot' in SQL Server","slug":"convert-rows-to-columns-using-'pivot'-in-sql-server-1657388372528"},{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"How do I pass data between Activities in Android application?","slug":"how-do-i-pass-data-between-activities-in-android-application-1657384739839"},{"title":"Why do regex constructors need to be double escaped?","slug":"why-do-regex-constructors-need-to-be-double-escaped-1657388004942"},{"title":"How do I compose a rotation matrix with human readable angles from scratch?","slug":"how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch-1657387963457"},{"title":"Convert one date format into another in PHP","slug":"convert-one-date-format-into-another-in-php-1657384566234"},{"title":"Select first row in each GROUP BY group?","slug":"select-first-row-in-each-group-by-group-1657384809388"},{"title":"How to serve static files in Flask","slug":"how-to-serve-static-files-in-flask-1657387862496"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"CSS margin terror; Margin adds space outside parent element [duplicate]","slug":"css-margin-terror-margin-adds-space-outside-parent-element-duplicate-1657388142199"},{"title":"Using regular expressions to parse HTML: why not?","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"How can I make an AJAX call without jQuery?","slug":"how-can-i-make-an-ajax-call-without-jquery-1657388448955"},{"title":"What is the most efficient way to deep clone an object in JavaScript?","slug":"what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript-1657384601026"},{"title":"Tkinter: AttributeError: NoneType object has no attribute <attribute name>","slug":"tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410"},{"title":"What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?","slug":"what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on","slug":"cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"\"is\" operator behaves unexpectedly with integers","slug":"\"is\"-operator-behaves-unexpectedly-with-integers-1657387563823"}]},"__N_SSG":true}