<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the scope of variables in JavaScript? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?
    "/><meta property="og:title" content="What is the scope of variables in JavaScript? | Solutions Checker"/><meta property="og:description" content="What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the scope of variables in JavaScript?","text":"What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?\n    ","answerCount":27,"upVoteCount":500,"suggestedAnswer":[{"text":"TLDR\nJavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.\nThe four scopes are:\n\nGlobal - visible by everything\nFunction - visible within a function (and its sub-functions and blocks)\nBlock - visible within a block (and its sub-blocks)\nModule - visible within a module\n\nOutside of the special cases of global and module scope, variables are declared using var (function scope), let (block scope), and const (block scope). Most other forms of identifier declaration have block scope in strict mode.\nOverview\nScope is the region of the codebase over which an identifier is valid.\nA lexical environment is a mapping between identifier names and the values associated with them.\nScope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.\nThese linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.\nIdentifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.\nThere are three pertinent factors in deciding the scope of an identifier in JavaScript:\n\nHow an identifier was declared\nWhere an identifier was declared\nWhether you are in strict mode or non-strict mode\n\nSome of the ways identifiers can be declared:\n\nvar, let and const\nFunction parameters\nCatch block parameter\nFunction declarations\nNamed function expressions\nImplicitly defined properties on the global object (i.e., missing out var in non-strict mode)\nimport statements\neval\n\nSome of the locations identifiers can be declared:\n\nGlobal context\nFunction body\nOrdinary block\nThe top of a control structure (e.g., loop, if, while, etc.)\nControl structure body\nModules\n\nDeclaration Styles\nvar\nIdentifiers declared using var have function scope, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in eval functions.\nlet and const\nIdentifiers declared using let and const have block scope, apart from when they are declared directly in the global context, in which case they have global scope.\nNote: let, const and var are all hoisted. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared using let and const cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.\n\n\nfunction f() {\n    function g() {\n        console.log(x)\n    }\n    let x = 1\n    g()\n}\nf() // 1 because x is hoisted even though declared with `let`!\n Run code snippetHide resultsExpand snippet\n\n\nFunction parameter names\nFunction parameter names are scoped to the function body. Note that there is a slight complexity to this. Functions declared as default arguments close over the parameter list, and not the body of the function.\nFunction declarations\nFunction declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.\nNamed function expressions\nNamed function expressions are scoped to themselves (e.g., for the purpose of recursion).\nImplicitly defined properties on the global object\nIn non-strict mode, implicitly defined properties on the global object have global scope, because the global object sits at the top of the scope chain. In strict mode, these are not permitted.\neval\nIn eval strings, variables declared using var will be placed in the current scope, or, if eval is used indirectly, as properties on the global object.\nExamples\nThe following will throw a ReferenceError because the namesx, y, and z have no meaning outside of the function f.\n\n\nfunction f() {\n    var x = 1\n    let y = 1\n    const z = 1\n}\nconsole.log(typeof x) // undefined (because var has function scope!)\nconsole.log(typeof y) // undefined (because the body of the function is a block)\nconsole.log(typeof z) // undefined (because the body of the function is a block)\n Run code snippetHide resultsExpand snippet\n\n\nThe following will throw a ReferenceError for y and z, but not for x, because the visibility of x is not constrained by the block. Blocks that define the bodies of control structures like if, for, and while, behave similarly.\n\n\n{\n    var x = 1\n    let y = 1\n    const z = 1\n}\nconsole.log(x) // 1\nconsole.log(typeof y) // undefined because `y` has block scope\nconsole.log(typeof z) // undefined because `z` has block scope\n Run code snippetHide resultsExpand snippet\n\n\nIn the following, x is visible outside of the loop because var has function scope:\n\n\nfor(var x = 0; x &lt; 5; ++x) {}\nconsole.log(x) // 5 (note this is outside the loop!)\n Run code snippetHide resultsExpand snippet\n\n\n...because of this behavior, you need to be careful about closing over variables declared using var in loops. There is only one instance of variable x declared here, and it sits logically outside of the loop.\nThe following prints 5, five times, and then prints 5 a sixth time for the console.log outside the loop:\n\n\nfor(var x = 0; x &lt; 5; ++x) {\n    setTimeout(() =&gt; console.log(x)) // closes over the `x` which is logically positioned at the top of the enclosing scope, above the loop\n}\nconsole.log(x) // note: visible outside the loop\n Run code snippetHide resultsExpand snippet\n\n\nThe following prints undefined because x is block-scoped. The callbacks are run one by one asynchronously. New behavior for let variables means that each anonymous function closed over a different variable named x (unlike it would have done with var), and so integers 0 through 4 are printed.:\n\n\nfor(let x = 0; x &lt; 5; ++x) {\n    setTimeout(() =&gt; console.log(x)) // `let` declarations are re-declared on a per-iteration basis, so the closures capture different variables\n}\nconsole.log(typeof x) // undefined\n Run code snippetHide resultsExpand snippet\n\n\nThe following will NOT throw a ReferenceError because the visibility of x is not constrained by the block; it will, however, print undefined because the variable has not been initialised (because of the if statement).\n\n\nif(false) {\n    var x = 1\n}\nconsole.log(x) // here, `x` has been declared, but not initialised\n Run code snippetHide resultsExpand snippet\n\n\nA variable declared at the top of a for loop using let is scoped to the body of the loop:\n\n\nfor(let x = 0; x &lt; 10; ++x) {} \nconsole.log(typeof x) // undefined, because `x` is block-scoped\n Run code snippetHide resultsExpand snippet\n\n\nThe following will throw a ReferenceError because the visibility of x is constrained by the block:\n\n\nif(false) {\n    let x = 1\n}\nconsole.log(typeof x) // undefined, because `x` is block-scoped\n Run code snippetHide resultsExpand snippet\n\n\nVariables declared using var, let or const are all scoped to modules:\n// module1.js\n\nvar x = 0\nexport function f() {}\n\n//module2.js\n\nimport f from &apos;module1.js&apos;\n\nconsole.log(x) // throws ReferenceError\n\nThe following will declare a property on the global object because variables declared using var within the global context are added as properties to the global object:\n\n\nvar x = 1\nconsole.log(window.hasOwnProperty(&apos;x&apos;)) // true\n Run code snippetHide resultsExpand snippet\n\n\nlet and const in the global context do not add properties to the global object, but still have global scope:\n\n\nlet x = 1\nconsole.log(window.hasOwnProperty(&apos;x&apos;)) // false\n Run code snippetHide resultsExpand snippet\n\n\nFunction parameters can be considered to be declared in the function body:\n\n\nfunction f(x) {}\nconsole.log(typeof x) // undefined, because `x` is scoped to the function\n Run code snippetHide resultsExpand snippet\n\n\nCatch block parameters are scoped to the catch-block body:\n\n\ntry {} catch(e) {}\nconsole.log(typeof e) // undefined, because `e` is scoped to the catch block\n Run code snippetHide resultsExpand snippet\n\n\nNamed function expressions are scoped only to the expression itself:\n\n\n(function foo() { console.log(foo) })()\nconsole.log(typeof foo) // undefined, because `foo` is scoped to its own expression\n Run code snippetHide resultsExpand snippet\n\n\nIn non-strict mode, implicitly defined properties on the global object are globally scoped. In strict mode, you get an error.\n\n\nx = 1 // implicitly defined property on the global object (no &quot;var&quot;!)\n\nconsole.log(x) // 1\nconsole.log(window.hasOwnProperty(&apos;x&apos;)) // true\n Run code snippetHide resultsExpand snippet\n\n\nIn non-strict mode, function declarations have function scope. In strict mode, they have block scope.\n\n\n&apos;use strict&apos;\n{\n    function foo() {}\n}\nconsole.log(typeof foo) // undefined, because `foo` is block-scoped\n Run code snippetHide resultsExpand snippet\n\n\nHow it works under the hood\nScope is defined as the lexical region of code over which an identifier is valid.\nIn JavaScript, every function-object has a hidden [[Environment]] reference that is a reference to the lexical environment of the execution context (stack frame) within which it was created.\nWhen you invoke a function, the hidden [[Call]] method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the [[Environment]] value on the function-object, into an outer reference field on the lexical environment of the new execution context.\nNote that this link between the new execution context and the lexical environment of the function object is called a closure.\nThus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by searching up the chain for a matching identifier.\nFind out more.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It&apos;s always the position in the source that defines the scope.\n\nAn element in the scope chain is basically a Map with a pointer to its parent scope.\n\nWhen resolving a variable, javascript starts at the innermost scope and searches outwards.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.\n\n(I&apos;m sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across this page about what exactly this means at any time. Hopefully this more introductory link is enough to get you started though.)\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Old school JavaScript\nTraditionally, JavaScript really only has two types of scope :\n\nGlobal Scope : Variables are known throughout the application, from the start of the application (*)\nFunctional Scope : Variables are known within the function they are declared in, from the start of the function (*)\n\nI will not elaborate on this, since there are already many other answers explaining the difference.\n\nModern JavaScript\nThe most recent JavaScript specs now also allow a third scope :\n\nBlock Scope : Identifiers are &quot;known&quot; from the top of the scope they are declared within, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;\n\n\nHow do I create block scope variables?\nTraditionally, you create your variables like this :\nvar myVariable = &quot;Some text&quot;;\n\nBlock scope variables are created like this :\nlet myVariable = &quot;Some text&quot;;\n\n\nSo what is the difference between functional scope and block scope?\nTo understand the difference between functional scope and block scope, consider the following code :\n// i IS NOT known here\n// j IS NOT known here\n// k IS known here, but undefined\n// l IS NOT known here\n\nfunction loop(arr) {\n    // i IS known here, but undefined\n    // j IS NOT known here\n    // k IS known here, but has a value only the second time loop is called\n    // l IS NOT known here\n\n    for( var i = 0; i &lt; arr.length; i++ ) {\n        // i IS known here, and has a value\n        // j IS NOT known here\n        // k IS known here, but has a value only the second time loop is called\n        // l IS NOT known here\n    };\n\n    // i IS known here, and has a value\n    // j IS NOT known here\n    // k IS known here, but has a value only the second time loop is called\n    // l IS NOT known here\n\n    for( let j = 0; j &lt; arr.length; j++ ) {\n        // i IS known here, and has a value\n        // j IS known here, and has a value\n        // k IS known here, but has a value only the second time loop is called\n        // l IS NOT known here\n    };\n\n    // i IS known here, and has a value\n    // j IS NOT known here\n    // k IS known here, but has a value only the second time loop is called\n    // l IS NOT known here\n}\n\nloop([1,2,3,4]);\n\nfor( var k = 0; k &lt; arr.length; k++ ) {\n    // i IS NOT known here\n    // j IS NOT known here\n    // k IS known here, and has a value\n    // l IS NOT known here\n};\n\nfor( let l = 0; l &lt; arr.length; l++ ) {\n    // i IS NOT known here\n    // j IS NOT known here\n    // k IS known here, and has a value\n    // l IS known here, and has a value\n};\n\nloop([1,2,3,4]);\n\n// i IS NOT known here\n// j IS NOT known here\n// k IS known here, and has a value\n// l IS NOT known here\n\nHere, we can see that our variable j is only known in the first for loop, but not before and after. Yet, our variable i is known in the entire function.\nAlso, consider that block scoped variables are not known before they are declared because they are not hoisted. You&apos;re also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.\n\nIs it safe to use block scope variables today?\nWhether or not it is safe to use today, depends on your environment :\n\nIf you&apos;re writing server-side JavaScript code (Node.js), you can safely use the let statement.\n\nIf you&apos;re writing client-side JavaScript code and use a browser based transpiler (like Traceur or babel-standalone), you can safely use the let statement, however your code is likely to be anything but optimal with respect to performance.\n\nIf you&apos;re writing client-side JavaScript code and use a Node based transpiler (like the traceur shell script or Babel), you can safely use the let statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.\n\nIf you&apos;re writing client-side JavaScript code and don&apos;t use a transpiler, you need to consider browser support.\nThese are some browsers that don&apos;t support let at all :\n\nInternet explorer 10 and below\nFirefox 43 and below\nSafari 9 and below\nAndroid browser 4 and below\nOpera 27 and below\nChome 40 and below\nANY version of Opera Mini &amp; Blackberry Browser\n\n\n\n\n\nHow to keep track of browser support\nFor an up-to-date overview of which browsers support the let statement at the time of your reading this answer, see this Can I Use page.\n\n(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are hoisted. This means that declarations are always much to the top of the scope.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s an example:\n\n&lt;script&gt;\n\nvar globalVariable = 7; //==window.globalVariable\n\nfunction aGlobal( param ) { //==window.aGlobal(); \n                            //param is only accessible in this function\n  var scopedToFunction = {\n    //can&apos;t be accessed outside of this function\n\n    nested : 3 //accessible by: scopedToFunction.nested\n  };\n\n  anotherGlobal = {\n    //global because there&apos;s no `var`\n  }; \n\n}\n\n&lt;/script&gt;\n\n\nYou&apos;ll want to investigate closures, and how to use them to make private members.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.\n\nHere is a good article on the subject.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"In &quot;Javascript 1.7&quot; (Mozilla&apos;s extension to Javascript) one can also declare block-scope variables with let statement:\n\n var a = 4;\n let (a = 3) {\n   alert(a); // 3\n }\n alert(a);   // 4\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The idea of scoping in JavaScript when originally designed by Brendan Eich came from the HyperCard scripting language HyperTalk. \n\nIn this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.\n\nThis is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as Execution ContextsECMA. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.\n\nThe this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be window or a constructor function.\n\nThese execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution. \n\nSo that is the technical explanation. In practice, it is important to remember that in JavaScript\n\n\nScopes are technically &quot;Execution Contexts&quot;\nContexts form a stack of environments where variables are stored\nThe top of the stack takes precedence (the bottom being the global context)\nEach function creates an execution context (but not always a new this binding)\n\n\nApplying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six&apos;s immediately invoked function.\n\ni) The outer context. It has a variable environment of a = 1\n ii) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack\n iii) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.\n\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"1) There is a global scope, a function scope, and the with and catch scopes. There is no &apos;block&apos; level scope in general for variable&apos;s -- the with and the catch statements add names to their blocks.\n\n2) Scopes are nested by functions all the way to the global scope.\n\n3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.\n\nEDIT: ECMAAScript 6 (Harmony) is spec&apos;ed to support let, and I know chrome allows a &apos;harmony&apos; flag, so perhaps it does support it..\n\nLet would be a support for block level scoping, but you have to use the keyword to make it happen.\n\nEDIT: Based on Benjamin&apos;s pointing out of the with and catch statements in the comments, I&apos;ve edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that is a block scope. These variables are aliased to the properties of the objects passed into them.\n\n //chrome (v8)\n\n var a = { &apos;test1&apos;:&apos;test1val&apos; }\n test1   // error not defined\n with (a) { var test1 = &apos;replaced&apos; }\n test1   // undefined\n a       // a.test1 = &apos;replaced&apos;\n\n\nEDIT: Clarifying example:\n\ntest1 is scoped to the with block, but is aliased to a.test1.  &apos;Var test1&apos; creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is. \n\nYikes!  Be careful using &apos;with&apos; -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.\n\nTry the feature at:\n\n\nhttp://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope\n\n\nSee a demo at:\n\n\nhttp://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope&amp;s=http://prettydiff.com/lib/markup_beauty.js\n\n\nView the code at:\n\n\nhttp://prettydiff.com/lib/jspretty.js\nhttps://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js\n\n\nCurrently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Inline handlers\nA very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with\n&lt;button onclick=&quot;foo()&quot;&gt;&lt;/button&gt;\n\nThe scope of the variables that an on* attribute can reference must be either:\n\nglobal (working inline handlers almost always reference global variables)\na property of the document (eg, querySelector as a standalone variable will point to document.querySelector; rare)\na property of the element the handler is attached to (like above; rare)\n\nOtherwise, you&apos;ll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined inside window.onload or $(function() {, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:\nShow code snippet\n\nwindow.addEventListener(&apos;DOMContentLoaded&apos;, () =&gt; {\n  function foo() {\n    console.log(&apos;foo running&apos;);\n  }\n});\n&lt;button onclick=&quot;foo()&quot;&gt;click&lt;/button&gt;\n Run code snippetHide resultsExpand snippet\n\n\nProperties of the document and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked inside of two with blocks, one for the document, one for the element. The scope chain of variables inside these handlers is extremely unintuitive, and a working event handler will probably require a function to be global (and unnecessary global pollution should probably be avoided).\nSince the scope chain inside inline handlers is so weird, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it&apos;s probably easier to avoid them. Instead, attach event handlers using Javascript (like with addEventListener), rather than with HTML markup.\nShow code snippet\n\nfunction foo() {\n  console.log(&apos;foo running&apos;);\n}\ndocument.querySelector(&apos;.my-button&apos;).addEventListener(&apos;click&apos;, foo);\n&lt;button class=&quot;my-button&quot;&gt;click&lt;/button&gt;\n Run code snippetHide resultsExpand snippet\n\n\nModules (&lt;script type=&quot;module&quot;&gt;)\nOn a different note, unlike normal &lt;script&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;script&gt; tag is global, so you can reference it in other &lt;script&gt; tags, like this:\nShow code snippet\n\n&lt;script&gt;\nconst foo = &apos;foo&apos;;\n&lt;/script&gt;\n&lt;script&gt;\nconsole.log(foo);\n&lt;/script&gt;\n Run code snippetHide resultsExpand snippet\n\n\nBut the top level of an ES6 module is not global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly exported, or unless it&apos;s assigned to a property of the global object.\nShow code snippet\n\n&lt;script type=&quot;module&quot;&gt;\nconst foo = &apos;foo&apos;;\n&lt;/script&gt;\n&lt;script&gt;\n// Can&apos;t access foo here, because the other script is a module\nconsole.log(typeof foo);\n&lt;/script&gt;\n Run code snippetHide resultsExpand snippet\n\n\nThe top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;script&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"JavaScript have only two type of scope : \n\n\nGlobal Scope : Global is nothing but a window level scope.Here, variable present throughout the application.\nFunctional Scope : Variable declared within a function with var keyword has functional scope.\n\n\nWhenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.\n\n        a = &quot;global&quot;;\n         function outer(){ \n              b = &quot;local&quot;;\n              console.log(a+b); //&quot;globallocal&quot;\n         }\nouter();\n\n\nScope chain --&gt;  \n\n\nWindow level - a and outer function are at top level in scope chain.\nwhen outer function called a new variable scope object(and included in scope chain) added with variable b inside it.\n\n\nNow when a variable a required it first searches for nearest variable scope and if variable is not there than it move&apos;s to next object of variable scope chain.which is in this case is window level.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"run the code. hope this will give an idea about scoping \n\nName = &apos;global data&apos;;\ndocument.Name = &apos;current document data&apos;;\n(function(window,document){\nvar Name = &apos;local data&apos;;\nvar myObj = {\n    Name: &apos;object data&apos;,\n    f: function(){\n        alert(this.Name);\n    }\n};\n\nmyObj.newFun = function(){\n    alert(this.Name);\n}\n\nfunction testFun(){\n    alert(&quot;Window Scope : &quot; + window.Name + \n          &quot;\\nLocal Scope : &quot; + Name + \n          &quot;\\nObject Scope : &quot; + this.Name + \n          &quot;\\nCurrent document Scope : &quot; + document.Name\n         );\n}\n\n\ntestFun.call(myObj);\n})(window,document);\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Global Scope :\n\nGlobal variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.\n\n//global variable\nvar a = 2;\n\n//global function\nfunction b(){\n   console.log(a);  //access global variable\n}\n\n\nLocal Scope :\n\nIf you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.\n\nLocal variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error\n\nfunction b(){\n   var d = 21; //local variable\n   console.log(d);\n\n   function dog(){  console.log(a); }\n     dog(); //execute local function\n}\n\n console.log(d); //ReferenceError: dddddd is not defined    \n\n\n\n\nCheck this article for in-depth understanding of scope \n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it&apos;s compiling and executing the code.\n\nSo from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:\n\n\n\nQuoting from his ebook:\n\n\n  The building represents our programs nested scope ruleset. The first\n  floor of the building represents your currently executing scope,\n  wherever you are. The top level of the building is the global scope.\n  You resolve LHS and RHS references by looking on your current floor,\n  and if you dont find it, taking the elevator to the next floor,\n  looking there, then the next, and so on. Once you get to the top floor\n  (the global scope), you either find what youre looking for, or you\n  dont. But you have to stop regardless.\n\n\nOne thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.\n\nThis idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it&apos;s being looked up in a nested function.\nHere is a link that goes into all these details, Everything you wanted to know about javascript scope \n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"There are ALMOST only two types of JavaScript scopes:\n\n\nthe scope of each var declaration is associated with the most immediately enclosing function\nif there is no enclosing function for a var declaration, it is global scope\n\n\nSo, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:\n\nvar i = 10, v = 10;\nfor (var i = 0; i &lt; 5; i++) { var v = 5; }\nconsole.log(i, v);\n// output 5 5\n\n\nUsing functions instead:\n\nvar i = 10, v = 10;\n$.each([0, 1, 2, 3, 4], function(i) { var v = 5; });\nconsole.log(i,v);\n// output 10 10\n\n\nIn the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.\n\nThat&apos;s almost all you need to know in terms of JavaScript scoping, except:\n\n\ntry/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope\nwith-clause apparently is another exception, but using with-clause it highly discouraged (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with)\n\n\nSo you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:\n\n\nvar declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top\nmultiple var declarations within the same scope are combined\n\n\nSo this code:\n\nvar i = 1;\nfunction abc() {\n  i = 2;\n  var i = 3;\n}\nconsole.log(i);     // outputs 1\n\n\nis equivalent to:\n\nvar i = 1;\nfunction abc() {\n  var i;     // var declaration moved to the top of the scope\n  i = 2;\n  i = 3;     // the assignment stays where it is\n}\nconsole.log(i);\n\n\nThis may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Modern Js, ES6+, &apos;const&apos; and &apos;let&apos;\nYou should be using block scoping for every variable you create, just like most other major languages. var is obsolete. This makes your code safer and more maintainable.\nconst should be used for 95% of cases. It makes it so the variable reference can&apos;t change. Array, object, and DOM node properties can change and should likely be const.\nlet should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use let.\nBlock scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Try this curious example. In the example below if a were a numeric initialized at 0, you&apos;d see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.\n\nvar a = new Date();\nfunction f1(b)\n{\n    b.setDate(b.getDate()+1);\n    alert(b.getDate());\n}\nf1(a);\nalert(a.getDate());\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"There are only function scopes in JS. Not block scopes!\nYou can see what is hoisting too.\n\nvar global_variable = &quot;global_variable&quot;;\nvar hoisting_variable = &quot;global_hoist&quot;;\n\n// Global variables printed\nconsole.log(&quot;global_scope: - global_variable: &quot; + global_variable);\nconsole.log(&quot;global_scope: - hoisting_variable: &quot; + hoisting_variable);\n\nif (true) {\n    // The variable block will be global, on true condition.\n    var block = &quot;block&quot;;\n}\nconsole.log(&quot;global_scope: - block: &quot; + block);\n\nfunction local_function() {\n    var local_variable = &quot;local_variable&quot;;\n    console.log(&quot;local_scope: - local_variable: &quot; + local_variable);\n    console.log(&quot;local_scope: - global_variable: &quot; + global_variable);\n    console.log(&quot;local_scope: - block: &quot; + block);\n    // The hoisting_variable is undefined at the moment.\n    console.log(&quot;local_scope: - hoisting_variable: &quot; + hoisting_variable);\n\n    var hoisting_variable = &quot;local_hoist&quot;;\n    // The hoisting_variable is now set as a local one.\n    console.log(&quot;local_scope: - hoisting_variable: &quot; + hoisting_variable);\n}\n\nlocal_function();\n\n// No variable in a separate function is visible into the global scope.\nconsole.log(&quot;global_scope: - local_variable: &quot; + local_variable);\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword &apos;var&apos;, either within a function or outside, and block scope is indicated with the keyword &apos;let&apos;.\n\nFor those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS. \n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"In JavaScript there are two types of scope:\n\n\nLocal scope \nGlobal scope\n\n\nThe Below function has a local scope variable carName. And this variable is not accessible from outside of the function.\n\nfunction myFunction() {\n    var carName = &quot;Volvo&quot;;\n    alert(carName);\n    // code here can use carName\n}\n\n\nThe Below Class has a Global scope variable carName. And this variable is accessible from everywhere in the class.\n\nclass {\n\n    var carName = &quot; Volvo&quot;;\n\n    // code here can use carName\n\n    function myFunction() {\n        alert(carName);\n        // code here can use carName \n    }\n}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"I really like the accepted answer but I want to add this:\n\nScope collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code. \n\nScope is a set of rules for looking up variables by their identifier name.\n\n\nIf a variable cannot be found in the immediate scope, Engine consults the next outer containing scope, continuing until is found or until the outermost (a.k.a., global) scope has been reached. \nIs the set of rules that determines where and how a variable (identifier) can be looked up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. \nLHS references result from assignment operations. Scope-related assignments can occur either with the = operator or by passing arguments to (assign to) function parameters.\nThe JavaScript engine first compiles code before it executes, and in so doing, it splits up statements like var a = 2; into two separate steps: 1st. First, var a to declare it in that scope. This is performed at the beginning, before code execution. 2nd. Later, a = 2 to look up the variable (LHS reference) and assign to it if found.\nBoth LHS and RHS reference look-ups start at the currently executing scope, and if need be (that is, they dont find what theyre looking for there), they work their way up the nested scope, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or dont. Unfulfilled RHS references result in ReferenceError being thrown. Unfulfilled LHS references result in an automatic, implicitly created global of that name (if not in Strict Mode), or a ReferenceError (if in Strict Mode).\nscope consists of a series of bubbles that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author time.\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"ES5 and earlier:\nVariables in Javascript were initially (pre ES6) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by &apos;looking&apos; at the code.\nEvery variable declared with the var keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a scope chain. It works in the following manner:\n\nWhen a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside other functions which are in this scope).\nIf it cannot find the variable inside the function body it will climb up to the chain and look at the variable scope in the function in where the function was defined. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.\n\nExample:\n\n\n// global scope\nvar foo = &apos;global&apos;;\nvar bar = &apos;global&apos;;\nvar foobar = &apos;global&apos;;\n\nfunction outerFunc () {\n // outerFunc scope\n var foo = &apos;outerFunc&apos;;\n var foobar = &apos;outerFunc&apos;;\n innerFunc();\n \n function innerFunc(){\n // innerFunc scope\n  var foo = &apos;innerFunc&apos;;\n  console.log(foo);\n  console.log(bar);\n  console.log(foobar);\n  }\n}\n\nouterFunc();\n Run code snippetHide resultsExpand snippet\n\n\nWhat happens when we are trying to log the variables foo, bar, and foobar to the console is the following:\n\nWe try to log foo to the console, foo can be found inside the function innerFunc itself. Therefore, the value of foo is resolved to the string innerFunc.\nWe try to log bar to the console, bar cannot be found inside the function innerFunc itself. Therefore, we need to climb the scope chain. We first look in the outer function in which the function innerFunc was defined. This is the function outerFunc. In the scope of outerFunc we can find the variable bar, which holds the string &apos;outerFunc&apos;.\nfoobar cannot be found in innerFunc. . Therefore, we need to climb the scope chain to the innerFunc scope. It also cannot be found here, we climb another level to the global scope (i.e. the outermost scope). We find the variable foobar here which holds the string &apos;global&apos;. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a referenceError.\n\nES6 (ES 2015) and older:\nThe same concepts of lexically scope and scopechain still apply in ES6. However a new ways to declare variables were introduced. There are the following:\n\nlet: creates a block scoped variable\nconst: creates a block scoped variable which has to be initialized and cannot be reassigned\n\nThe biggest difference between var and let/const is that var is function scoped whereas let/const are block scoped. Here is an example to illustrate this:\n\n\nlet letVar = &apos;global&apos;;\nvar varVar = &apos;global&apos;;\n\nfunction foo () {\n  \n  if (true) {\n    // this variable declared with let is scoped to the if block, block scoped\n    let letVar = 5;\n    // this variable declared with let is scoped to the function block, function scoped\n    var varVar = 10;\n  }\n  \n  console.log(letVar);\n  console.log(varVar);\n}\n\n\nfoo();\n Run code snippetHide resultsExpand snippet\n\n\nIn the above example letVar logs the value global because variables declared with let are block scoped. They cease to exist outside their respective block, so the variable can&apos;t be accessed outside the if block.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"In EcmaScript5, there are mainly two scopes, local scope and global scope but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called block scope. \n\nExample of block scope is :-\n\nfor ( let i = 0; i &lt; 10; i++)\n{\n statement1...\nstatement2...// inside this scope we can access the value of i, if we want to access the value of i outside for loop it will give undefined.\n}\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.\n\nvar x = 10\nlet y = 10\nconst z = 10\n{\n  x = 20\n  let y = 20\n  const z = 20\n  {\n    x = 30\n    // x is in the global scope because of the &apos;var&apos; keyword\n    let y = 30\n    // y is in the local scope because of the &apos;let&apos; keyword\n    const z = 30\n    // z is in the local scope because of the &apos;const&apos; keyword\n    console.log(x) // 30\n    console.log(y) // 30\n    console.log(z) // 30\n  }\n  console.log(x) // 30\n  console.log(y) // 20\n  console.log(z) // 20\n}\n\nconsole.log(x) // 30\nconsole.log(y) // 10\nconsole.log(z) // 10\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"\n\n(function foo() { console.log(foo) })();\nconsole.log(typeof foo); // undefined, because `foo` is scoped to its own expression\n\n//but, like this\n(function foo() {\n    console.log(&apos;1:&apos;, foo) // function foo\n    foo = 100\n    console.log(&apos;2:&apos;, foo) // function foo, is not 100, why?\n})()\n Run code snippetHide resultsExpand snippet\n\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"There are two types of scopes in JavaScript. \n\n\nGlobal scope: variable which is announced in global scope can be used anywhere in the program very smoothly. For example: \n\nvar carName = &quot; BMW&quot;;\n\n// code here can use carName\n\nfunction myFunction() {\n     // code here can use carName \n}\n\nFunctional scope or Local scope: variable declared in this scope can be used in its own function only. For example:\n\n// code here can not use carName\nfunction myFunction() {\n   var carName = &quot;BMW&quot;;\n   // code here can use carName\n}\n\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291"><h1>What is the scope of variables in JavaScript?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/var">var</a></div></div><div class="question-content mt-5">
                
<p>What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>TLDR</h2>
<p>JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.</p>
<p>The four scopes are:</p>
<ol>
<li>Global - visible by everything</li>
<li>Function - visible within a function (and its sub-functions and blocks)</li>
<li>Block - visible within a block (and its sub-blocks)</li>
<li>Module - visible within a module</li>
</ol>
<p>Outside of the special cases of global and module scope, variables are declared using <code>var</code> (function scope), <code>let</code> (block scope), and <code>const</code> (block scope). Most other forms of identifier declaration have block scope in strict mode.</p>
<h2>Overview</h2>
<p>Scope is the region of the codebase over which an identifier is valid.</p>
<p>A lexical environment is a mapping between identifier names and the values associated with them.</p>
<p>Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.</p>
<p>These linked lexical environments form a scope "chain". Identifier resolution is the process of searching along this chain for a matching identifier.</p>
<p>Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot "see" into inner lexical environments.</p>
<p>There are three pertinent factors in deciding the <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)" rel="noreferrer">scope</a> of an <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords" rel="noreferrer">identifier</a> in JavaScript:</p>
<ol>
<li>How an identifier was declared</li>
<li>Where an identifier was declared</li>
<li>Whether you are in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noreferrer">strict mode</a> or <a href="https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode" rel="noreferrer">non-strict mode</a></li>
</ol>
<p>Some of the ways identifiers can be declared:</p>
<ol>
<li><code>var</code>, <code>let</code> and <code>const</code></li>
<li>Function parameters</li>
<li>Catch block parameter</li>
<li>Function declarations</li>
<li>Named function expressions</li>
<li>Implicitly defined properties on the global object (i.e., missing out <code>var</code> in non-strict mode)</li>
<li><code>import</code> statements</li>
<li><code>eval</code></li>
</ol>
<p>Some of the locations identifiers can be declared:</p>
<ol>
<li>Global context</li>
<li>Function body</li>
<li>Ordinary block</li>
<li>The top of a control structure (e.g., loop, if, while, etc.)</li>
<li>Control structure body</li>
<li>Modules</li>
</ol>
<h2>Declaration Styles</h2>
<h3>var</h3>
<p>Identifiers declared using <code>var</code> <strong>have function scope</strong>, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in <code>eval</code> functions.</p>
<h3>let and const</h3>
<p>Identifiers declared using <code>let</code> and <code>const</code> <strong>have block scope</strong>, apart from when they are declared directly in the global context, in which case they have global scope.</p>
<p>Note: <code>let</code>, <code>const</code> and <code>var</code> <a href="https://stackoverflow.com/a/31222689/38522">are all hoisted</a>. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared using <code>let</code> and <code>const</code> cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)
    }
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>
    <span class="hljs-title function_">g</span>()
}
<span class="hljs-title function_">f</span>() <span class="hljs-comment">// 1 because x is hoisted even though declared with `let`!</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Function parameter names</h3>
<p>Function parameter names are scoped to the function body. Note that there is a slight complexity to this. Functions declared as default arguments close over the <a href="https://stackoverflow.com/questions/61208843/where-are-arguments-positioned-in-the-lexical-environment/">parameter list</a>, and not the body of the function.</p>
<h3>Function declarations</h3>
<p>Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.</p>
<h3>Named function expressions</h3>
<p>Named function expressions are scoped to themselves (e.g., for the purpose of recursion).</p>
<h3>Implicitly defined properties on the global object</h3>
<p>In non-strict mode, implicitly defined properties on the global object have global scope, because the global object sits at the top of the scope chain. In strict mode, these are not permitted.</p>
<h3>eval</h3>
<p>In <code>eval</code> strings, variables declared using <code>var</code> will be placed in the current scope, or, if <code>eval</code> is used indirectly, as properties on the global object.</p>
<h2>Examples</h2>
<p>The following will throw a ReferenceError because the names<code>x</code>, <code>y</code>, and <code>z</code> have no meaning outside of the function <code>f</code>.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>
    <span class="hljs-keyword">const</span> z = <span class="hljs-number">1</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x) <span class="hljs-comment">// undefined (because var has function scope!)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> y) <span class="hljs-comment">// undefined (because the body of the function is a block)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> z) <span class="hljs-comment">// undefined (because the body of the function is a block)</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>The following will throw a ReferenceError for <code>y</code> and <code>z</code>, but not for <code>x</code>, because the visibility of <code>x</code> is not constrained by the block. Blocks that define the bodies of control structures like <code>if</code>, <code>for</code>, and <code>while</code>, behave similarly.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript">{
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>
    <span class="hljs-keyword">const</span> z = <span class="hljs-number">1</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> y) <span class="hljs-comment">// undefined because `y` has block scope</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> z) <span class="hljs-comment">// undefined because `z` has block scope</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif3" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In the following, <code>x</code> is visible outside of the loop because <code>var</code> has function scope:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">5</span>; ++x) {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 5 (note this is outside the loop!)</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif4" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>...because of this behavior, you need to be careful about closing over variables declared using <code>var</code> in loops. There is only one instance of variable <code>x</code> declared here, and it sits logically outside of the loop.</p>
<p>The following prints <code>5</code>, five times, and then prints <code>5</code> a sixth time for the <code>console.log</code> outside the loop:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">5</span>; ++x) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)) <span class="hljs-comment">// closes over the `x` which is logically positioned at the top of the enclosing scope, above the loop</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// note: visible outside the loop</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif5" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>The following prints <code>undefined</code> because <code>x</code> is block-scoped. The callbacks are run one by one asynchronously. New behavior for <code>let</code> variables means that each anonymous function closed over a different variable named <code>x</code> (unlike it would have done with <code>var</code>), and so integers <code>0</code> through <code>4</code> are printed.:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">5</span>; ++x) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)) <span class="hljs-comment">// `let` declarations are re-declared on a per-iteration basis, so the closures capture different variables</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x) <span class="hljs-comment">// undefined</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif6" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>The following will NOT throw a <code>ReferenceError</code> because the visibility of <code>x</code> is not constrained by the block; it will, however, print <code>undefined</code> because the variable has not been initialised (because of the <code>if</code> statement).</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// here, `x` has been declared, but not initialised</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif7" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>A variable declared at the top of a <code>for</code> loop using <code>let</code> is scoped to the body of the loop:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">10</span>; ++x) {} 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x) <span class="hljs-comment">// undefined, because `x` is block-scoped</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif8" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>The following will throw a <code>ReferenceError</code> because the visibility of <code>x</code> is constrained by the block:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x) <span class="hljs-comment">// undefined, because `x` is block-scoped</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif9" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Variables declared using <code>var</code>, <code>let</code> or <code>const</code> are all scoped to modules:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// module1.js</span>

<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {}

<span class="hljs-comment">//module2.js</span>

<span class="hljs-keyword">import</span> f <span class="hljs-keyword">from</span> <span class="hljs-string">'module1.js'</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// throws ReferenceError</span>
</code></pre>
<p>The following will declare a property on the global object because variables declared using <code>var</code> within the global context are added as properties to the global object:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// true</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif10" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p><code>let</code> and <code>const</code> in the global context do not add properties to the global object, but still have global scope:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// false</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif11" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Function parameters can be considered to be declared in the function body:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>) {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x) <span class="hljs-comment">// undefined, because `x` is scoped to the function</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif12" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Catch block parameters are scoped to the catch-block body:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">try</span> {} <span class="hljs-keyword">catch</span>(e) {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> e) <span class="hljs-comment">// undefined, because `e` is scoped to the catch block</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif13" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Named function expressions are scoped only to the expression itself:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo) })()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> foo) <span class="hljs-comment">// undefined, because `foo` is scoped to its own expression</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif14" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In non-strict mode, implicitly defined properties on the global object are globally scoped. In strict mode, you get an error.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript">x = <span class="hljs-number">1</span> <span class="hljs-comment">// implicitly defined property on the global object (no "var"!)</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// true</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif15" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In non-strict mode, function declarations have function scope. In strict mode, they have block scope.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-meta">'use strict'</span>
{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {}
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> foo) <span class="hljs-comment">// undefined, because `foo` is block-scoped</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif16" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h2>How it works under the hood</h2>
<p>Scope is defined as the <a href="https://stackoverflow.com/a/1047479/38522">lexical</a> region of code over which an identifier is valid.</p>
<p>In JavaScript, every function-object has a hidden <code>[[Environment]]</code> reference that is a reference to the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments" rel="noreferrer">lexical environment</a> of the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" rel="noreferrer">execution context</a> (stack frame) within which it was created.</p>
<p>When you invoke a function, the hidden <code>[[Call]]</code> method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the <code>[[Environment]]</code> value on the function-object, into an <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments" rel="noreferrer">outer reference</a> field on the lexical environment of the new execution context.</p>
<p>Note that this link between the new execution context and the lexical environment of the function object is called a <a href="https://stackoverflow.com/a/111114/38522">closure</a>.</p>
<p>Thus, in JavaScript, scope is implemented via lexical environments linked together in a "chain" by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference" rel="noreferrer">searching up the chain</a> for a matching identifier.</p>
<p>Find out <a href="https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures" rel="noreferrer">more</a>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It's always the position in the source that defines the scope.</p>

<p>An element in the scope chain is basically a Map with a pointer to its parent scope.</p>

<p>When resolving a variable, javascript starts at the innermost scope and searches outwards.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.</p>

<p>(I'm sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across <a href="http://www.digital-web.com/articles/scope_in_javascript/" rel="noreferrer">this page</a> about what exactly <code>this</code> means at any time. Hopefully <a href="http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4" rel="noreferrer">this more introductory link</a> is enough to get you started though.)</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Old school JavaScript</h1>
<p>Traditionally, JavaScript really only has two types of scope :</p>
<ol>
<li><strong>Global Scope</strong> : Variables are known throughout the application, from the start of the application <em>(*)</em></li>
<li><strong>Functional Scope</strong> : Variables are known within <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function" rel="noreferrer"><strong>the function</strong></a> they are declared in, from the start of the function <em>(*)</em></li>
</ol>
<p>I will not elaborate on this, since there are already many other answers explaining the difference.</p>
<hr>
<h1>Modern JavaScript</h1>
<p>The <a href="https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/" rel="noreferrer"><strong>most recent JavaScript specs</strong></a> now also allow a third scope :</p>
<ol start="3">
<li><strong>Block Scope</strong> : Identifiers are "known" <a href="https://stackoverflow.com/a/31222689/38522">from the top of the scope they are declared within</a>, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the "temporal dead zone."</li>
</ol>
<hr>
<h3>How do I create block scope variables?</h3>
<p>Traditionally, you create your variables like this :</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> myVariable = <span class="hljs-string">"Some text"</span>;
</code></pre>
<p>Block scope variables are created like this :</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> myVariable = <span class="hljs-string">"Some text"</span>;
</code></pre>
<hr>
<h3>So what is the difference between functional scope and block scope?</h3>
<p>To understand the difference between functional scope and block scope, consider the following code :</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// i IS NOT known here</span>
<span class="hljs-comment">// j IS NOT known here</span>
<span class="hljs-comment">// k IS known here, but undefined</span>
<span class="hljs-comment">// l IS NOT known here</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-comment">// i IS known here, but undefined</span>
    <span class="hljs-comment">// j IS NOT known here</span>
    <span class="hljs-comment">// k IS known here, but has a value only the second time loop is called</span>
    <span class="hljs-comment">// l IS NOT known here</span>

    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++ ) {
        <span class="hljs-comment">// i IS known here, and has a value</span>
        <span class="hljs-comment">// j IS NOT known here</span>
        <span class="hljs-comment">// k IS known here, but has a value only the second time loop is called</span>
        <span class="hljs-comment">// l IS NOT known here</span>
    };

    <span class="hljs-comment">// i IS known here, and has a value</span>
    <span class="hljs-comment">// j IS NOT known here</span>
    <span class="hljs-comment">// k IS known here, but has a value only the second time loop is called</span>
    <span class="hljs-comment">// l IS NOT known here</span>

    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j++ ) {
        <span class="hljs-comment">// i IS known here, and has a value</span>
        <span class="hljs-comment">// j IS known here, and has a value</span>
        <span class="hljs-comment">// k IS known here, but has a value only the second time loop is called</span>
        <span class="hljs-comment">// l IS NOT known here</span>
    };

    <span class="hljs-comment">// i IS known here, and has a value</span>
    <span class="hljs-comment">// j IS NOT known here</span>
    <span class="hljs-comment">// k IS known here, but has a value only the second time loop is called</span>
    <span class="hljs-comment">// l IS NOT known here</span>
}

<span class="hljs-title function_">loop</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; arr.<span class="hljs-property">length</span>; k++ ) {
    <span class="hljs-comment">// i IS NOT known here</span>
    <span class="hljs-comment">// j IS NOT known here</span>
    <span class="hljs-comment">// k IS known here, and has a value</span>
    <span class="hljs-comment">// l IS NOT known here</span>
};

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; l &lt; arr.<span class="hljs-property">length</span>; l++ ) {
    <span class="hljs-comment">// i IS NOT known here</span>
    <span class="hljs-comment">// j IS NOT known here</span>
    <span class="hljs-comment">// k IS known here, and has a value</span>
    <span class="hljs-comment">// l IS known here, and has a value</span>
};

<span class="hljs-title function_">loop</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

<span class="hljs-comment">// i IS NOT known here</span>
<span class="hljs-comment">// j IS NOT known here</span>
<span class="hljs-comment">// k IS known here, and has a value</span>
<span class="hljs-comment">// l IS NOT known here</span>
</code></pre>
<p>Here, we can see that our variable <code>j</code> is only known in the first for loop, but not before and after. Yet, our variable <code>i</code> is known in the entire function.</p>
<p>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</p>
<hr>
<h3>Is it safe to use block scope variables today?</h3>
<p>Whether or not it is safe to use today, depends on your environment :</p>
<ul>
<li><p>If you're writing server-side JavaScript code (<a href="https://nodejs.org/en/" rel="noreferrer"><strong>Node.js</strong></a>), you can safely use the <code>let</code> statement.</p>
</li>
<li><p>If you're writing client-side JavaScript code and use a browser based transpiler (like <a href="https://github.com/google/traceur-compiler" rel="noreferrer"><strong>Traceur</strong></a> or <a href="https://github.com/babel/babel-standalone" rel="noreferrer"><strong>babel-standalone</strong></a>), you can safely use the <code>let</code> statement, however your code is likely to be anything but optimal with respect to performance.</p>
</li>
<li><p>If you're writing client-side JavaScript code and use a Node based transpiler (like the <a href="https://github.com/google/traceur-compiler/wiki/Compiling-Offline" rel="noreferrer"><strong>traceur shell script</strong></a> or <a href="https://babeljs.io/" rel="noreferrer"><strong>Babel</strong></a>), you can safely use the <code>let</code> statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</p>
</li>
<li><p>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</p>
<p>These are some browsers that don't support <code>let</code> at all :</p>
<ul>
<li><strong>Internet explorer 10</strong> and below</li>
<li><strong>Firefox 43</strong> and below</li>
<li><strong>Safari 9</strong> and below</li>
<li><strong>Android browser 4</strong> and below</li>
<li><strong>Opera 27</strong> and below</li>
<li><strong>Chome 40</strong> and below</li>
<li>ANY version of <strong>Opera Mini</strong> &amp; <strong>Blackberry Browser</strong></li>
</ul>
</li>
</ul>
<p><a href="https://i.stack.imgur.com/J9kEC.png" rel="noreferrer"><img src="https://i.stack.imgur.com/J9kEC.png" alt="enter image description here"></a></p>
<hr>
<h3>How to keep track of browser support</h3>
<p>For an up-to-date overview of which browsers support the <code>let</code> statement at the time of your reading this answer, see <a href="http://caniuse.com/#search=let" rel="noreferrer"><strong>this <code>Can I Use</code> page</strong></a>.</p>
<hr>
<p><em>(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noreferrer"><strong>hoisted</strong></a>.</em> This means that declarations are always much to the top of the scope.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's an example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;script&gt;

<span class="hljs-keyword">var</span> globalVariable = <span class="hljs-number">7</span>; <span class="hljs-comment">//==window.globalVariable</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">aGlobal</span>(<span class="hljs-params"> param </span>) { <span class="hljs-comment">//==window.aGlobal(); </span>
                            <span class="hljs-comment">//param is only accessible in this function</span>
  <span class="hljs-keyword">var</span> scopedToFunction = {
    <span class="hljs-comment">//can't be accessed outside of this function</span>

    nested : <span class="hljs-number">3</span> <span class="hljs-comment">//accessible by: scopedToFunction.nested</span>
  };

  anotherGlobal = {
    <span class="hljs-comment">//global because there's no `var`</span>
  }; 

}

&lt;/script&gt;
</code></pre>

<p>You'll want to investigate closures, and how to use them to make <a href="http://www.crockford.com/javascript/private.html" rel="noreferrer">private members</a>.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.</p>

<p><a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting">Here is a good article on the subject.</a></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In "Javascript 1.7" (Mozilla's extension to Javascript) one can also declare block-scope variables with <a href="https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11" rel="noreferrer"><code>let</code> statement</a>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-keyword">var</span> a = <span class="hljs-number">4</span>;
 <span class="hljs-keyword">let</span> (a = <span class="hljs-number">3</span>) {
   <span class="hljs-title function_">alert</span>(a); <span class="hljs-comment">// 3</span>
 }
 <span class="hljs-title function_">alert</span>(a);   <span class="hljs-comment">// 4</span>
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The idea of scoping in JavaScript when originally designed by <a href="https://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> came from the <a href="https://en.wikipedia.org/wiki/HyperCard">HyperCard</a> scripting language <a href="https://en.wikipedia.org/wiki/HyperTalk">HyperTalk</a>. </p>

<p>In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.</p>

<p>This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as <strong><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-10.3">Execution Contexts<sup>ECMA</sup></a></strong>. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.</p>

<p>The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be <code>window</code> or a constructor function.</p>

<p>These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution. </p>

<p>So that is the technical explanation. In practice, it is important to remember that in JavaScript</p>

<ul>
<li>Scopes are technically "Execution Contexts"</li>
<li>Contexts form a stack of environments where variables are stored</li>
<li>The top of the stack takes precedence (the bottom being the global context)</li>
<li>Each function creates an execution context (but not always a new this binding)</li>
</ul>

<p>Applying this to one of the previous examples (5. "Closure") on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six's immediately invoked function.</p>

<p><em>i</em>) The outer context. It has a variable environment of a = 1<br>
 <em>ii</em>) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack<br>
 <em>iii</em>) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.</p>

<p><a href="https://i.stack.imgur.com/v45hL.png"><img src="https://i.stack.imgur.com/v45hL.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>1) There is a global scope, a function scope, and the with and catch scopes. There is no 'block' level scope in general for variable's -- the with and the catch statements add names to their blocks.</p>

<p>2) Scopes are nested by functions all the way to the global scope.</p>

<p>3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.</p>

<p>EDIT: ECMAAScript 6 (Harmony) is spec'ed to support let, and I know chrome allows a 'harmony' flag, so perhaps it does support it..</p>

<p>Let would be a support for block level scoping, but you have to use the keyword to make it happen.</p>

<p>EDIT: Based on Benjamin's pointing out of the with and catch statements in the comments, I've edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that <em>is</em> a block scope. These variables are aliased to the properties of the objects passed into them.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-comment">//chrome (v8)</span>

 <span class="hljs-keyword">var</span> a = { <span class="hljs-string">'test1'</span>:<span class="hljs-string">'test1val'</span> }
 test1   <span class="hljs-comment">// error not defined</span>
 <span class="hljs-keyword">with</span> (a) { <span class="hljs-keyword">var</span> test1 = <span class="hljs-string">'replaced'</span> }
 test1   <span class="hljs-comment">// undefined</span>
 a       <span class="hljs-comment">// a.test1 = 'replaced'</span>
</code></pre>

<p>EDIT: Clarifying example:</p>

<p>test1 is scoped to the with block, but is aliased to a.test1.  'Var test1' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is. </p>

<p>Yikes!  Be careful using 'with' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.</p>

<p>Try the feature at:</p>

<ul>
<li><a href="http://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope" rel="noreferrer">http://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope</a></li>
</ul>

<p>See a demo at:</p>

<ul>
<li><a href="http://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope&amp;s=http://prettydiff.com/lib/markup_beauty.js" rel="noreferrer">http://prettydiff.com/jspretty.xhtml?c=white&amp;jsscope&amp;s=http://prettydiff.com/lib/markup_beauty.js</a></li>
</ul>

<p>View the code at:</p>

<ul>
<li><a href="http://prettydiff.com/lib/jspretty.js" rel="noreferrer">http://prettydiff.com/lib/jspretty.js</a></li>
<li><a href="https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js" rel="noreferrer">https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js</a></li>
</ul>

<p>Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Inline handlers</h2>
<p>A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"foo()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>The scope of the variables that an <code>on*</code> attribute can reference <em>must</em> be either:</p>
<ul>
<li>global (working inline handlers almost always reference global variables)</li>
<li>a property of the document (eg, <code>querySelector</code> as a standalone variable will point to <code>document.querySelector</code>; rare)</li>
<li>a property of the element the handler is attached to (like above; rare)</li>
</ul>
<p>Otherwise, you'll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined <em>inside</em> <code>window.onload</code> or <code>$(function() {</code>, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:</p>
<p></p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false"><div class="snippet-display" style="vertical-align: center"><p><a class="snippet-show-link-chevron"><span class="expander-arrow-hide" style="vertical-align: middle;"></span></a><a class="snippet-show-link"><span class="show-hide" data-ishidden="true" style="vertical-align: middle">Show code snippet</span></a></p></div>
<div class="snippet-code snippet-currently-hidden" style="display: none;">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'DOMContentLoaded'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo running'</span>);
  }
});</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"foo()"</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif17" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Properties of the <code>document</code> and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked <a href="https://i.stack.imgur.com/dTDB0.png" rel="noreferrer"><em>inside</em> of two <code>with</code> blocks</a>, one for the <code>document</code>, one for the element. The scope chain of variables inside these handlers is <a href="https://stackoverflow.com/a/57048067">extremely unintuitive</a>, and a working event handler will <em>probably</em> require a function to be global (and unnecessary global pollution <a href="https://softwareengineering.stackexchange.com/q/148108">should probably be avoided</a>).</p>
<p>Since the scope chain inside inline handlers is <em>so weird</em>, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it's probably easier to avoid them. Instead, attach event handlers using Javascript (like with <code>addEventListener</code>), rather than with HTML markup.</p>
<p></p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false"><div class="snippet-display" style="vertical-align: center"><p><a class="snippet-show-link-chevron"><span class="expander-arrow-hide" style="vertical-align: middle;"></span></a><a class="snippet-show-link"><span class="show-hide" data-ishidden="true" style="vertical-align: middle">Show code snippet</span></a></p></div>
<div class="snippet-code snippet-currently-hidden" style="display: none;">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo running'</span>);
}
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.my-button'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, foo);</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-button"</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif18" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h2>Modules (<code>&lt;script type="module"&gt;</code>)</h2>
<p>On a different note, unlike normal <code>&lt;script&gt;</code> tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal <code>&lt;script&gt;</code> tag is global, so you can reference it in other <code>&lt;script&gt;</code> tags, like this:</p>
<p></p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false"><div class="snippet-display" style="vertical-align: center"><p><a class="snippet-show-link-chevron"><span class="expander-arrow-hide" style="vertical-align: middle;"></span></a><a class="snippet-show-link"><span class="show-hide" data-ishidden="true" style="vertical-align: middle">Show code snippet</span></a></p></div>
<div class="snippet-code snippet-currently-hidden" style="display: none;">
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">const</span> foo = <span class="hljs-string">'foo'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif19" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>But the top level of an ES6 module is <em>not</em> global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly <code>export</code>ed, or unless it's assigned to a property of the global object.</p>
<p></p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false"><div class="snippet-display" style="vertical-align: center"><p><a class="snippet-show-link-chevron"><span class="expander-arrow-hide" style="vertical-align: middle;"></span></a><a class="snippet-show-link"><span class="show-hide" data-ishidden="true" style="vertical-align: middle">Show code snippet</span></a></p></div>
<div class="snippet-code snippet-currently-hidden" style="display: none;">
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">const</span> foo = <span class="hljs-string">'foo'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-comment">// Can't access foo here, because the other script is a module</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> foo);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif20" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal <code>&lt;script&gt;</code>. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JavaScript have only two type of scope : </p>

<ol>
<li><strong>Global Scope</strong> : Global is nothing but a window level scope.Here, variable present throughout the application.</li>
<li><strong>Functional Scope</strong> : Variable declared within a function with <code>var</code> keyword has functional scope.</li>
</ol>

<p><em>Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.</em></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">        a = <span class="hljs-string">"global"</span>;
         <span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>){ 
              b = <span class="hljs-string">"local"</span>;
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a+b); <span class="hljs-comment">//"globallocal"</span>
         }
<span class="hljs-title function_">outer</span>();
</code></pre>

<p>Scope chain --&gt;  </p>

<ol>
<li>Window level - <code>a</code> and <code>outer</code> function are at top level in scope chain.</li>
<li>when outer function called a new <code>variable scope object</code>(and included in scope chain) added with variable <code>b</code> inside it.</li>
</ol>

<p>Now when a variable <code>a</code> required it first searches for nearest variable scope and if variable is not there than it move's to next object of variable scope chain.which is in this case is window level.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>run the code. hope this will give an idea about scoping </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Name</span> = <span class="hljs-string">'global data'</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">Name</span> = <span class="hljs-string">'current document data'</span>;
(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span>,<span class="hljs-variable language_">document</span></span>){
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Name</span> = <span class="hljs-string">'local data'</span>;
<span class="hljs-keyword">var</span> myObj = {
    <span class="hljs-title class_">Name</span>: <span class="hljs-string">'object data'</span>,
    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Name</span>);
    }
};

myObj.<span class="hljs-property">newFun</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Name</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">testFun</span>(<span class="hljs-params"></span>){
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Window Scope : "</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">Name</span> + 
          <span class="hljs-string">"\nLocal Scope : "</span> + <span class="hljs-title class_">Name</span> + 
          <span class="hljs-string">"\nObject Scope : "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">Name</span> + 
          <span class="hljs-string">"\nCurrent document Scope : "</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">Name</span>
         );
}


testFun.<span class="hljs-title function_">call</span>(myObj);
})(<span class="hljs-variable language_">window</span>,<span class="hljs-variable language_">document</span>);
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Global Scope :</h2>

<p>Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//global variable</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;

<span class="hljs-comment">//global function</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>){
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">//access global variable</span>
}
</code></pre>

<h2>Local Scope :</h2>

<p>If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.</p>

<p>Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>){
   <span class="hljs-keyword">var</span> d = <span class="hljs-number">21</span>; <span class="hljs-comment">//local variable</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);

   <span class="hljs-keyword">function</span> <span class="hljs-title function_">dog</span>(<span class="hljs-params"></span>){  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); }
     <span class="hljs-title function_">dog</span>(); <span class="hljs-comment">//execute local function</span>
}

 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">//ReferenceError: dddddd is not defined    </span>
</code></pre>

<hr>

<p><a href="http://www.thatjsdude.com/jsConcepts/concepts/scope.html" rel="noreferrer">Check this article for in-depth understanding of scope</a> </p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it's compiling and executing the code.</p>

<p>So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:</p>

<p><a href="https://i.stack.imgur.com/0kqpZ.png" rel="noreferrer"><img src="https://i.stack.imgur.com/0kqpZ.png" alt="image"></a></p>

<p>Quoting from his ebook:</p>

<blockquote>
  <p>The building represents our programs nested scope ruleset. The first
  floor of the building represents your currently executing scope,
  wherever you are. The top level of the building is the global scope.
  You resolve LHS and RHS references by looking on your current floor,
  and if you dont find it, taking the elevator to the next floor,
  looking there, then the next, and so on. Once you get to the top floor
  (the global scope), you either find what youre looking for, or you
  dont. But you have to stop regardless.</p>
</blockquote>

<p>One thing of note that is worth mentioning, "Scope look-up stops once it finds the first match".</p>

<p>This idea of "scope levels" explains why "this" can be changed with a newly created scope, if it's being looked up in a nested function.
Here is a link that goes into all these details, <a href="https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/" rel="noreferrer">Everything you wanted to know about javascript scope</a> </p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are ALMOST only two types of JavaScript scopes:</p>

<ul>
<li>the scope of each var declaration is associated with the most immediately enclosing function</li>
<li>if there is no enclosing function for a var declaration, it is global scope</li>
</ul>

<p>So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>, v = <span class="hljs-number">10</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) { <span class="hljs-keyword">var</span> v = <span class="hljs-number">5</span>; }
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, v);
<span class="hljs-comment">// output 5 5</span>
</code></pre>

<p>Using functions instead:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>, v = <span class="hljs-number">10</span>;
$.<span class="hljs-title function_">each</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) { <span class="hljs-keyword">var</span> v = <span class="hljs-number">5</span>; });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i,v);
<span class="hljs-comment">// output 10 10</span>
</code></pre>

<p>In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.</p>

<p>That's almost all you need to know in terms of JavaScript scoping, except:</p>

<ul>
<li>try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope</li>
<li>with-clause apparently is another exception, but using with-clause it highly discouraged (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with</a>)</li>
</ul>

<p>So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:</p>

<ul>
<li>var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top</li>
<li>multiple var declarations within the same scope are combined</li>
</ul>

<p>So this code:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params"></span>) {
  i = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">3</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);     <span class="hljs-comment">// outputs 1</span>
</code></pre>

<p>is equivalent to:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> i;     <span class="hljs-comment">// var declaration moved to the top of the scope</span>
  i = <span class="hljs-number">2</span>;
  i = <span class="hljs-number">3</span>;     <span class="hljs-comment">// the assignment stays where it is</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
</code></pre>

<p>This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Modern Js, ES6+, '<code>const</code>' and '<code>let</code>'</h1>
<p>You should be using block scoping for every variable you create, just like most other major languages. <code>var</code> is <em>obsolete</em>. This makes your code safer and more maintainable.</p>
<p><code>const</code> should be used for <strong>95% of cases</strong>. It makes it so the variable <em>reference</em> can't change. Array, object, and DOM node properties can change and should likely be <code>const</code>.</p>
<p><code>let</code> should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use <code>let</code>.</p>
<p>Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Try this curious example. In the example below if a were a numeric initialized at 0, you'd see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">b</span>)
{
    b.<span class="hljs-title function_">setDate</span>(b.<span class="hljs-title function_">getDate</span>()+<span class="hljs-number">1</span>);
    <span class="hljs-title function_">alert</span>(b.<span class="hljs-title function_">getDate</span>());
}
<span class="hljs-title function_">f1</span>(a);
<span class="hljs-title function_">alert</span>(a.<span class="hljs-title function_">getDate</span>());
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are only function scopes in JS. Not block scopes!
You can see what is hoisting too.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> global_variable = <span class="hljs-string">"global_variable"</span>;
<span class="hljs-keyword">var</span> hoisting_variable = <span class="hljs-string">"global_hoist"</span>;

<span class="hljs-comment">// Global variables printed</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"global_scope: - global_variable: "</span> + global_variable);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"global_scope: - hoisting_variable: "</span> + hoisting_variable);

<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// The variable block will be global, on true condition.</span>
    <span class="hljs-keyword">var</span> block = <span class="hljs-string">"block"</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"global_scope: - block: "</span> + block);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">local_function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> local_variable = <span class="hljs-string">"local_variable"</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"local_scope: - local_variable: "</span> + local_variable);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"local_scope: - global_variable: "</span> + global_variable);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"local_scope: - block: "</span> + block);
    <span class="hljs-comment">// The hoisting_variable is undefined at the moment.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"local_scope: - hoisting_variable: "</span> + hoisting_variable);

    <span class="hljs-keyword">var</span> hoisting_variable = <span class="hljs-string">"local_hoist"</span>;
    <span class="hljs-comment">// The hoisting_variable is now set as a local one.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"local_scope: - hoisting_variable: "</span> + hoisting_variable);
}

<span class="hljs-title function_">local_function</span>();

<span class="hljs-comment">// No variable in a separate function is visible into the global scope.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"global_scope: - local_variable: "</span> + local_variable);
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword 'var', either within a function or outside, and block scope is indicated with the keyword 'let'.</p>

<p>For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS. </p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let</a></p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In JavaScript there are two types of scope:</p>

<ul>
<li>Local scope </li>
<li>Global scope</li>
</ul>

<p>The Below function has a local scope variable <code>carName</code>. And this variable is not accessible from outside of the function.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> carName = <span class="hljs-string">"Volvo"</span>;
    <span class="hljs-title function_">alert</span>(carName);
    <span class="hljs-comment">// code here can use carName</span>
}
</code></pre>

<p>The Below Class has a Global scope variable <code>carName</code>. And this variable is accessible from everywhere in the class.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">class</span> {

    <span class="hljs-keyword">var</span> carName = <span class="hljs-string">" Volvo"</span>;

    <span class="hljs-comment">// code here can use carName</span>

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">alert</span>(carName);
        <span class="hljs-comment">// code here can use carName </span>
    }
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I really like the accepted answer but I want to add this:</p>

<p><strong>Scope collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.</strong> </p>

<p>Scope is a set of rules for looking up variables by their identifier name.</p>

<ul>
<li>If a variable cannot be found in the immediate scope, Engine consults the next outer containing scope, continuing until is found or until the outermost (a.k.a., global) scope has been reached. </li>
<li>Is the set of rules that determines where and how a variable (identifier) can be looked up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. </li>
<li>LHS references result from assignment operations. Scope-related assignments can occur either with the = operator or by passing arguments to (assign to) function parameters.</li>
<li>The JavaScript engine first compiles code before it executes, and in so doing, it splits up statements like var a = 2; into two separate steps: 1st. First, var a to declare it in that scope. This is performed at the beginning, before code execution. 2nd. Later, a = 2 to look up the variable (LHS reference) and assign to it if found.</li>
<li>Both LHS and RHS reference look-ups start at the currently executing scope, and if need be (that is, they dont find what theyre looking for there), they work their way up the nested scope, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or dont. Unfulfilled RHS references result in ReferenceError being thrown. Unfulfilled LHS references result in an automatic, implicitly created global of that name (if not in Strict Mode), or a ReferenceError (if in Strict Mode).</li>
<li>scope consists of a series of bubbles that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author time.</li>
</ul>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><code>ES5</code> and earlier:</h2>
<p>Variables in Javascript were initially (pre <code>ES6</code>) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by 'looking' at the code.</p>
<p>Every variable declared with the <code>var</code> keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a <strong>scope chain</strong>. It works in the following manner:</p>
<ol>
<li>When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside <strong>other</strong> <strong>functions</strong> which are in this scope).</li>
<li>If it cannot find the variable inside the function body it <strong>will climb up to the chain</strong> and look at the variable scope in the function in <strong>where the function was defined</strong>. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.</li>
</ol>
<h2>Example:</h2>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// global scope</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">'global'</span>;
<span class="hljs-keyword">var</span> bar = <span class="hljs-string">'global'</span>;
<span class="hljs-keyword">var</span> foobar = <span class="hljs-string">'global'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunc</span> () {
 <span class="hljs-comment">// outerFunc scope</span>
 <span class="hljs-keyword">var</span> foo = <span class="hljs-string">'outerFunc'</span>;
 <span class="hljs-keyword">var</span> foobar = <span class="hljs-string">'outerFunc'</span>;
 <span class="hljs-title function_">innerFunc</span>();
 
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunc</span>(<span class="hljs-params"></span>){
 <span class="hljs-comment">// innerFunc scope</span>
  <span class="hljs-keyword">var</span> foo = <span class="hljs-string">'innerFunc'</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foobar);
  }
}

<span class="hljs-title function_">outerFunc</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif21" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>What happens when we are trying to log the variables <code>foo</code>, <code>bar</code>, and <code>foobar</code> to the console is the following:</p>
<ol>
<li>We try to log foo to the console, foo can be found inside the function <code>innerFunc</code> itself. Therefore, the value of foo is resolved to the string <code>innerFunc</code>.</li>
<li>We try to log bar to the console, bar cannot be found inside the function <code>innerFunc</code> itself. Therefore, we need to <strong>climb the scope chain</strong>. We first look in the outer function in which the function <code>innerFunc</code> was defined. This is the function <code>outerFunc</code>. In the scope of <code>outerFunc</code> we can find the variable bar, which holds the string 'outerFunc'.</li>
<li>foobar cannot be found in innerFunc. . Therefore, we need to <strong>climb the scope chain</strong> to the innerFunc scope. It also cannot be found here, we climb another level to the <strong>global scope</strong> (i.e. the outermost scope). We find the variable foobar here which holds the string 'global'. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a <strong>referenceError</strong>.</li>
</ol>
<h2><code>ES6</code> (ES 2015) and older:</h2>
<p>The same concepts of lexically scope and scopechain still apply in <code>ES6</code>. However a new ways to declare variables were introduced. There are the following:</p>
<ul>
<li><code>let</code>: creates a block scoped variable</li>
<li><code>const</code>: creates a block scoped variable which has to be initialized and cannot be reassigned</li>
</ul>
<p>The biggest difference between <code>var</code> and <code>let</code>/<code>const</code> is that <code>var</code> is function scoped whereas <code>let</code>/<code>const</code> are block scoped. Here is an example to illustrate this:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> letVar = <span class="hljs-string">'global'</span>;
<span class="hljs-keyword">var</span> varVar = <span class="hljs-string">'global'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> () {
  
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// this variable declared with let is scoped to the if block, block scoped</span>
    <span class="hljs-keyword">let</span> letVar = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// this variable declared with let is scoped to the function block, function scoped</span>
    <span class="hljs-keyword">var</span> varVar = <span class="hljs-number">10</span>;
  }
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(letVar);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(varVar);
}


<span class="hljs-title function_">foo</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif22" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In the above example letVar logs the value global because variables declared with <code>let</code> are block scoped. They cease to exist outside their respective block, so the variable can't be accessed outside the if block.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In EcmaScript5, there are mainly two scopes, <strong>local scope</strong> and <strong>global scope</strong> but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called <strong>block scope</strong>. </p>

<p>Example of block scope is :-</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
{
 statement1...
statement2...<span class="hljs-comment">// inside this scope we can access the value of i, if we want to access the value of i outside for loop it will give undefined.</span>
}
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>
<span class="hljs-keyword">let</span> y = <span class="hljs-number">10</span>
<span class="hljs-keyword">const</span> z = <span class="hljs-number">10</span>
{
  x = <span class="hljs-number">20</span>
  <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>
  <span class="hljs-keyword">const</span> z = <span class="hljs-number">20</span>
  {
    x = <span class="hljs-number">30</span>
    <span class="hljs-comment">// x is in the global scope because of the 'var' keyword</span>
    <span class="hljs-keyword">let</span> y = <span class="hljs-number">30</span>
    <span class="hljs-comment">// y is in the local scope because of the 'let' keyword</span>
    <span class="hljs-keyword">const</span> z = <span class="hljs-number">30</span>
    <span class="hljs-comment">// z is in the local scope because of the 'const' keyword</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 30</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y) <span class="hljs-comment">// 30</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z) <span class="hljs-comment">// 30</span>
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 30</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y) <span class="hljs-comment">// 20</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z) <span class="hljs-comment">// 20</span>
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">// 30</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y) <span class="hljs-comment">// 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z) <span class="hljs-comment">// 10</span>
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo) })();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> foo); <span class="hljs-comment">// undefined, because `foo` is scoped to its own expression</span>

<span class="hljs-comment">//but, like this</span>
(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1:'</span>, foo) <span class="hljs-comment">// function foo</span>
    foo = <span class="hljs-number">100</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2:'</span>, foo) <span class="hljs-comment">// function foo, is not 100, why?</span>
})()</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif23" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/var">var</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are two types of scopes in JavaScript. </p>

<ol>
<li><p><strong>Global scope</strong>: variable which is announced in global scope can be used anywhere in the program very smoothly. For example: </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> carName = <span class="hljs-string">" BMW"</span>;

<span class="hljs-comment">// code here can use carName</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) {
     <span class="hljs-comment">// code here can use carName </span>
}
</code></pre></li>
<li><p><strong>Functional scope or Local scope</strong>: variable declared in this scope can be used in its own function only. For example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// code here can not use carName</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">var</span> carName = <span class="hljs-string">"BMW"</span>;
   <span class="hljs-comment">// code here can use carName</span>
}
</code></pre></li>
</ol>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/get-the-data-received-in-a-flask-request-1657387804432">Get the data received in a Flask request</a><a href="/questions/retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457">Retrieve only the queried element in an object array in MongoDB collection</a><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392">Big O, how do you calculate/approximate it?</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/google-maps-js-api-v3-simple-multiple-marker-example-1657388073335">Google Maps JS API v3 - Simple Multiple Marker Example</a><a href="/questions/is-java-%22pass-by-reference%22-or-%22pass-by-value%22-1657384319828">Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;?</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/why-is-settimeout(fn-0)-sometimes-useful-1657388379869">Why is setTimeout(fn, 0) sometimes useful?</a><a href="/questions/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212">What is the explicit promise construction antipattern and how do I avoid it?</a><a href="/questions/deep-cloning-objects-1657387930865">Deep cloning objects</a><a href="/questions/sorting-an-array-of-objects-by-property-values-1657387447490">Sorting an array of objects by property values</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a><a href="/questions/numbering-rows-within-groups-in-a-data-frame-1657388556436">Numbering rows within groups in a data frame</a><a href="/questions/is-there-a-difference-between-%22%22-and-%22is%22-1657387902231">Is there a difference between &quot;==&quot; and &quot;is&quot;?</a><a href="/questions/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch-1657387963457">How do I compose a rotation matrix with human readable angles from scratch?</a><a href="/questions/how-to-deal-with-floating-point-number-precision-in-javascript-1657387293762">How to deal with floating point number precision in JavaScript?</a><a href="/questions/commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519">commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated</a><a href="/questions/how-do-i-return-the-response-from-an-observablehttpasync-call-in-angular-1657387335024">How do I return the response from an Observable/http/async call in angular?</a><a href="/questions/self-references-in-object-literals-initializers-1657384835356">Self-references in object literals / initializers</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;TLDR\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The four scopes are:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Global - visible by everything\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function - visible within a function (and its sub-functions and blocks)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Block - visible within a block (and its sub-blocks)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Module - visible within a module\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Outside of the special cases of global and module scope, variables are declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; (function scope), \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; (block scope), and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Overview\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Scope is the region of the codebase over which an identifier is valid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A lexical environment is a mapping between identifier names and the values associated with them.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;These linked lexical environments form a scope \u0026quot;chain\u0026quot;. Identifier resolution is the process of searching along this chain for a matching identifier.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot \u0026quot;see\u0026quot; into inner lexical environments.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are three pertinent factors in deciding the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Scope_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scope\u0026lt;/a\u0026gt; of an \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;identifier\u0026lt;/a\u0026gt; in JavaScript:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;How an identifier was declared\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Where an identifier was declared\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Whether you are in \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;strict mode\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;non-strict mode\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Some of the ways identifiers can be declared:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function parameters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Catch block parameter\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function declarations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Named function expressions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Implicitly defined properties on the global object (i.e., missing out \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; in non-strict mode)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; statements\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;eval\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Some of the locations identifiers can be declared:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Global context\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function body\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Ordinary block\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The top of a control structure (e.g., loop, if, while, etc.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Control structure body\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Modules\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;h2\u0026gt;Declaration Styles\u0026lt;/h2\u0026gt;\n\u0026lt;h3\u0026gt;var\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Identifiers declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;have function scope\u0026lt;/strong\u0026gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in \u0026lt;code\u0026gt;eval\u0026lt;/code\u0026gt; functions.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;let and const\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Identifiers declared using \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;have block scope\u0026lt;/strong\u0026gt;, apart from when they are declared directly in the global context, in which case they have global scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note: \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/31222689/38522\u0026quot;\u0026gt;are all hoisted\u0026lt;/a\u0026gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared using \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x)\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;()\n}\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1 because x is hoisted even though declared with `let`!\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Function parameter names\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Function parameter names are scoped to the function body. Note that there is a slight complexity to this. Functions declared as default arguments close over the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/61208843/where-are-arguments-positioned-in-the-lexical-environment/\u0026quot;\u0026gt;parameter list\u0026lt;/a\u0026gt;, and not the body of the function.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Function declarations\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Named function expressions\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Named function expressions are scoped to themselves (e.g., for the purpose of recursion).\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Implicitly defined properties on the global object\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In non-strict mode, implicitly defined properties on the global object have global scope, because the global object sits at the top of the scope chain. In strict mode, these are not permitted.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;eval\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;eval\u0026lt;/code\u0026gt; strings, variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; will be placed in the current scope, or, if \u0026lt;code\u0026gt;eval\u0026lt;/code\u0026gt; is used indirectly, as properties on the global object.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Examples\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The following will throw a ReferenceError because the names\u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt; have no meaning outside of the function \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; z = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined (because var has function scope!)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined (because the body of the function is a block)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; z) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined (because the body of the function is a block)\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following will throw a ReferenceError for \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;, but not for \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, because the visibility of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is not constrained by the block. Blocks that define the bodies of control structures like \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;while\u0026lt;/code\u0026gt;, behave similarly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; z = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined because `y` has block scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; z) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined because `z` has block scope\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif3\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the following, \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is visible outside of the loop because \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; has function scope:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; x \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; ++x) {}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5 (note this is outside the loop!)\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif4\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;...because of this behavior, you need to be careful about closing over variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; in loops. There is only one instance of variable \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; declared here, and it sits logically outside of the loop.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following prints \u0026lt;code\u0026gt;5\u0026lt;/code\u0026gt;, five times, and then prints \u0026lt;code\u0026gt;5\u0026lt;/code\u0026gt; a sixth time for the \u0026lt;code\u0026gt;console.log\u0026lt;/code\u0026gt; outside the loop:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; x \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; ++x) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// closes over the `x` which is logically positioned at the top of the enclosing scope, above the loop\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note: visible outside the loop\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif5\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following prints \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt; because \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; variables means that each anonymous function closed over a different variable named \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; (unlike it would have done with \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;), and so integers \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; through \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt; are printed.:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; x \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; ++x) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `let` declarations are re-declared on a per-iteration basis, so the closures capture different variables\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif6\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following will NOT throw a \u0026lt;code\u0026gt;ReferenceError\u0026lt;/code\u0026gt; because the visibility of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is not constrained by the block; it will, however, print \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt; because the variable has not been initialised (because of the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// here, `x` has been declared, but not initialised\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif7\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A variable declared at the top of a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop using \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; is scoped to the body of the loop:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; x \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; ++x) {} \n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `x` is block-scoped\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif8\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following will throw a \u0026lt;code\u0026gt;ReferenceError\u0026lt;/code\u0026gt; because the visibility of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is constrained by the block:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `x` is block-scoped\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif9\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; are all scoped to modules:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// module1.js\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;export\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//module2.js\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; f \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;module1.js\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// throws ReferenceError\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The following will declare a property on the global object because variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; within the global context are added as properties to the global object:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasOwnProperty\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif10\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; in the global context do not add properties to the global object, but still have global scope:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasOwnProperty\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif11\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Function parameters can be considered to be declared in the function body:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `x` is scoped to the function\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif12\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Catch block parameters are scoped to the catch-block body:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt; {} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(e) {}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; e) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `e` is scoped to the catch block\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif13\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Named function expressions are scoped only to the expression itself:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo) })()\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; foo) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `foo` is scoped to its own expression\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif14\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In non-strict mode, implicitly defined properties on the global object are globally scoped. In strict mode, you get an error.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implicitly defined property on the global object (no \u0026quot;var\u0026quot;!)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasOwnProperty\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif15\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In non-strict mode, function declarations have function scope. In strict mode, they have block scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026apos;use strict\u0026apos;\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; foo) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `foo` is block-scoped\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif16\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;How it works under the hood\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Scope is defined as the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1047479/38522\u0026quot;\u0026gt;lexical\u0026lt;/a\u0026gt; region of code over which an identifier is valid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In JavaScript, every function-object has a hidden \u0026lt;code\u0026gt;[[Environment]]\u0026lt;/code\u0026gt; reference that is a reference to the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;lexical environment\u0026lt;/a\u0026gt; of the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;execution context\u0026lt;/a\u0026gt; (stack frame) within which it was created.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you invoke a function, the hidden \u0026lt;code\u0026gt;[[Call]]\u0026lt;/code\u0026gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the \u0026lt;code\u0026gt;[[Environment]]\u0026lt;/code\u0026gt; value on the function-object, into an \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;outer reference\u0026lt;/a\u0026gt; field on the lexical environment of the new execution context.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that this link between the new execution context and the lexical environment of the function object is called a \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/111114/38522\u0026quot;\u0026gt;closure\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Thus, in JavaScript, scope is implemented via lexical environments linked together in a \u0026quot;chain\u0026quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;searching up the chain\u0026lt;/a\u0026gt; for a matching identifier.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Find out \u0026lt;a href=\u0026quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;more\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It\u0026apos;s always the position in the source that defines the scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An element in the scope chain is basically a Map with a pointer to its parent scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When resolving a variable, javascript starts at the innermost scope and searches outwards.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(I\u0026apos;m sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across \u0026lt;a href=\u0026quot;http://www.digital-web.com/articles/scope_in_javascript/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this page\u0026lt;/a\u0026gt; about what exactly \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; means at any time. Hopefully \u0026lt;a href=\u0026quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this more introductory link\u0026lt;/a\u0026gt; is enough to get you started though.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Old school JavaScript\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Traditionally, JavaScript really only has two types of scope :\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Global Scope\u0026lt;/strong\u0026gt; : Variables are known throughout the application, from the start of the application \u0026lt;em\u0026gt;(*)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Functional Scope\u0026lt;/strong\u0026gt; : Variables are known within \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;the function\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; they are declared in, from the start of the function \u0026lt;em\u0026gt;(*)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;I will not elaborate on this, since there are already many other answers explaining the difference.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;Modern JavaScript\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;most recent JavaScript specs\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; now also allow a third scope :\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Block Scope\u0026lt;/strong\u0026gt; : Identifiers are \u0026quot;known\u0026quot; \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/31222689/38522\u0026quot;\u0026gt;from the top of the scope they are declared within\u0026lt;/a\u0026gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the \u0026quot;temporal dead zone.\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;How do I create block scope variables?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Traditionally, you create your variables like this :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myVariable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Some text\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Block scope variables are created like this :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; myVariable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Some text\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;So what is the difference between functional scope and block scope?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;To understand the difference between functional scope and block scope, consider the following code :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS NOT known here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but undefined\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;arr\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS known here, but undefined\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but has a value only the second time loop is called\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; arr.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; i++ ) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS known here, and has a value\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but has a value only the second time loop is called\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS known here, and has a value\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but has a value only the second time loop is called\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; arr.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; j++ ) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS known here, and has a value\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS known here, and has a value\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but has a value only the second time loop is called\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS known here, and has a value\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, but has a value only the second time loop is called\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; k = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k \u0026amp;lt; arr.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; k++ ) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, and has a value\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; l = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; l \u0026amp;lt; arr.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; l++ ) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, and has a value\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS known here, and has a value\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i IS NOT known here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j IS NOT known here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// k IS known here, and has a value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// l IS NOT known here\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here, we can see that our variable \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt; is only known in the first for loop, but not before and after. Yet, our variable \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is known in the entire function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You\u0026apos;re also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Is it safe to use block scope variables today?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Whether or not it is safe to use today, depends on your environment :\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you\u0026apos;re writing server-side JavaScript code (\u0026lt;a href=\u0026quot;https://nodejs.org/en/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Node.js\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;), you can safely use the \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; statement.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you\u0026apos;re writing client-side JavaScript code and use a browser based transpiler (like \u0026lt;a href=\u0026quot;https://github.com/google/traceur-compiler\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Traceur\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://github.com/babel/babel-standalone\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;babel-standalone\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;), you can safely use the \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; statement, however your code is likely to be anything but optimal with respect to performance.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you\u0026apos;re writing client-side JavaScript code and use a Node based transpiler (like the \u0026lt;a href=\u0026quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;traceur shell script\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://babeljs.io/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Babel\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;), you can safely use the \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you\u0026apos;re writing client-side JavaScript code and don\u0026apos;t use a transpiler, you need to consider browser support.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;These are some browsers that don\u0026apos;t support \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; at all :\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Internet explorer 10\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Firefox 43\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Safari 9\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Android browser 4\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Opera 27\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Chome 40\u0026lt;/strong\u0026gt; and below\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ANY version of \u0026lt;strong\u0026gt;Opera Mini\u0026lt;/strong\u0026gt; \u0026amp;amp; \u0026lt;strong\u0026gt;Blackberry Browser\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/J9kEC.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/J9kEC.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;How to keep track of browser support\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;For an up-to-date overview of which browsers support the \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; statement at the time of your reading this answer, see \u0026lt;a href=\u0026quot;http://caniuse.com/#search=let\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;this \u0026lt;code\u0026gt;Can I Use\u0026lt;/code\u0026gt; page\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;hoisted\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/em\u0026gt; This means that declarations are always much to the top of the scope.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s an example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;script\u0026amp;gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; globalVariable = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//==window.globalVariable\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;aGlobal\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; param \u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//==window.aGlobal(); \u0026lt;/span\u0026gt;\n                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//param is only accessible in this function\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; scopedToFunction = {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//can\u0026apos;t be accessed outside of this function\u0026lt;/span\u0026gt;\n\n    nested : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//accessible by: scopedToFunction.nested\u0026lt;/span\u0026gt;\n  };\n\n  anotherGlobal = {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//global because there\u0026apos;s no `var`\u0026lt;/span\u0026gt;\n  }; \n\n}\n\n\u0026amp;lt;/script\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll want to investigate closures, and how to use them to make \u0026lt;a href=\u0026quot;http://www.crockford.com/javascript/private.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;private members\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting\u0026quot;\u0026gt;Here is a good article on the subject.\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In \u0026quot;Javascript 1.7\u0026quot; (Mozilla\u0026apos;s extension to Javascript) one can also declare block-scope variables with \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; statement\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; (a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) {\n   \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n }\n \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The idea of scoping in JavaScript when originally designed by \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Brendan_Eich\u0026quot;\u0026gt;Brendan Eich\u0026lt;/a\u0026gt; came from the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/HyperCard\u0026quot;\u0026gt;HyperCard\u0026lt;/a\u0026gt; scripting language \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/HyperTalk\u0026quot;\u0026gt;HyperTalk\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3\u0026quot;\u0026gt;Execution Contexts\u0026lt;sup\u0026gt;ECMA\u0026lt;/sup\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be \u0026lt;code\u0026gt;window\u0026lt;/code\u0026gt; or a constructor function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So that is the technical explanation. In practice, it is important to remember that in JavaScript\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Scopes are technically \u0026quot;Execution Contexts\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Contexts form a stack of environments where variables are stored\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The top of the stack takes precedence (the bottom being the global context)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Each function creates an execution context (but not always a new this binding)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Applying this to one of the previous examples (5. \u0026quot;Closure\u0026quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six\u0026apos;s immediately invoked function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;i\u0026lt;/em\u0026gt;) The outer context. It has a variable environment of a = 1\u0026lt;br\u0026gt;\n \u0026lt;em\u0026gt;ii\u0026lt;/em\u0026gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack\u0026lt;br\u0026gt;\n \u0026lt;em\u0026gt;iii\u0026lt;/em\u0026gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/v45hL.png\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/v45hL.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;1) There is a global scope, a function scope, and the with and catch scopes. There is no \u0026apos;block\u0026apos; level scope in general for variable\u0026apos;s -- the with and the catch statements add names to their blocks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2) Scopes are nested by functions all the way to the global scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT: ECMAAScript 6 (Harmony) is spec\u0026apos;ed to support let, and I know chrome allows a \u0026apos;harmony\u0026apos; flag, so perhaps it does support it..\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let would be a support for block level scoping, but you have to use the keyword to make it happen.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT: Based on Benjamin\u0026apos;s pointing out of the with and catch statements in the comments, I\u0026apos;ve edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; a block scope. These variables are aliased to the properties of the objects passed into them.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//chrome (v8)\u0026lt;/span\u0026gt;\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test1val\u0026apos;\u0026lt;/span\u0026gt; }\n test1   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error not defined\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; (a) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; test1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;replaced\u0026apos;\u0026lt;/span\u0026gt; }\n test1   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined\u0026lt;/span\u0026gt;\n a       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a.test1 = \u0026apos;replaced\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT: Clarifying example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;test1 is scoped to the with block, but is aliased to a.test1.  \u0026apos;Var test1\u0026apos; creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yikes!  Be careful using \u0026apos;with\u0026apos; -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Try the feature at:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://prettydiff.com/jspretty.xhtml?c=white\u0026amp;amp;jsscope\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://prettydiff.com/jspretty.xhtml?c=white\u0026amp;amp;jsscope\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See a demo at:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://prettydiff.com/jspretty.xhtml?c=white\u0026amp;amp;jsscope\u0026amp;amp;s=http://prettydiff.com/lib/markup_beauty.js\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://prettydiff.com/jspretty.xhtml?c=white\u0026amp;amp;jsscope\u0026amp;amp;s=http://prettydiff.com/lib/markup_beauty.js\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;View the code at:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://prettydiff.com/lib/jspretty.js\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://prettydiff.com/lib/jspretty.js\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Inline handlers\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;onclick\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The scope of the variables that an \u0026lt;code\u0026gt;on*\u0026lt;/code\u0026gt; attribute can reference \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; be either:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;global (working inline handlers almost always reference global variables)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a property of the document (eg, \u0026lt;code\u0026gt;querySelector\u0026lt;/code\u0026gt; as a standalone variable will point to \u0026lt;code\u0026gt;document.querySelector\u0026lt;/code\u0026gt;; rare)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a property of the element the handler is attached to (like above; rare)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Otherwise, you\u0026apos;ll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined \u0026lt;em\u0026gt;inside\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;window.onload\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;$(function() {\u0026lt;/code\u0026gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;true\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-display\u0026quot; style=\u0026quot;vertical-align: center\u0026quot;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link-chevron\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;expander-arrow-hide\u0026quot; style=\u0026quot;vertical-align: middle;\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;show-hide\u0026quot; data-ishidden=\u0026quot;true\u0026quot; style=\u0026quot;vertical-align: middle\u0026quot;\u0026gt;Show code snippet\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code snippet-currently-hidden\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addEventListener\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;DOMContentLoaded\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo running\u0026apos;\u0026lt;/span\u0026gt;);\n  }\n});\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;onclick\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;click\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif17\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Properties of the \u0026lt;code\u0026gt;document\u0026lt;/code\u0026gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked \u0026lt;a href=\u0026quot;https://i.stack.imgur.com/dTDB0.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;inside\u0026lt;/em\u0026gt; of two \u0026lt;code\u0026gt;with\u0026lt;/code\u0026gt; blocks\u0026lt;/a\u0026gt;, one for the \u0026lt;code\u0026gt;document\u0026lt;/code\u0026gt;, one for the element. The scope chain of variables inside these handlers is \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/57048067\u0026quot;\u0026gt;extremely unintuitive\u0026lt;/a\u0026gt;, and a working event handler will \u0026lt;em\u0026gt;probably\u0026lt;/em\u0026gt; require a function to be global (and unnecessary global pollution \u0026lt;a href=\u0026quot;https://softwareengineering.stackexchange.com/q/148108\u0026quot;\u0026gt;should probably be avoided\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since the scope chain inside inline handlers is \u0026lt;em\u0026gt;so weird\u0026lt;/em\u0026gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it\u0026apos;s probably easier to avoid them. Instead, attach event handlers using Javascript (like with \u0026lt;code\u0026gt;addEventListener\u0026lt;/code\u0026gt;), rather than with HTML markup.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;true\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-display\u0026quot; style=\u0026quot;vertical-align: center\u0026quot;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link-chevron\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;expander-arrow-hide\u0026quot; style=\u0026quot;vertical-align: middle;\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;show-hide\u0026quot; data-ishidden=\u0026quot;true\u0026quot; style=\u0026quot;vertical-align: middle\u0026quot;\u0026gt;Show code snippet\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code snippet-currently-hidden\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo running\u0026apos;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;querySelector\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.my-button\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addEventListener\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;click\u0026apos;\u0026lt;/span\u0026gt;, foo);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;my-button\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;click\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif18\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Modules (\u0026lt;code\u0026gt;\u0026amp;lt;script type=\u0026quot;module\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt;)\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;On a different note, unlike normal \u0026lt;code\u0026gt;\u0026amp;lt;script\u0026amp;gt;\u0026lt;/code\u0026gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal \u0026lt;code\u0026gt;\u0026amp;lt;script\u0026amp;gt;\u0026lt;/code\u0026gt; tag is global, so you can reference it in other \u0026lt;code\u0026gt;\u0026amp;lt;script\u0026amp;gt;\u0026lt;/code\u0026gt; tags, like this:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;true\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-display\u0026quot; style=\u0026quot;vertical-align: center\u0026quot;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link-chevron\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;expander-arrow-hide\u0026quot; style=\u0026quot;vertical-align: middle;\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;show-hide\u0026quot; data-ishidden=\u0026quot;true\u0026quot; style=\u0026quot;vertical-align: middle\u0026quot;\u0026gt;Show code snippet\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code snippet-currently-hidden\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-javascript\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-javascript\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo);\n\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif19\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But the top level of an ES6 module is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly \u0026lt;code\u0026gt;export\u0026lt;/code\u0026gt;ed, or unless it\u0026apos;s assigned to a property of the global object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;true\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-display\u0026quot; style=\u0026quot;vertical-align: center\u0026quot;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link-chevron\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;expander-arrow-hide\u0026quot; style=\u0026quot;vertical-align: middle;\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;show-hide\u0026quot; data-ishidden=\u0026quot;true\u0026quot; style=\u0026quot;vertical-align: middle\u0026quot;\u0026gt;Show code snippet\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code snippet-currently-hidden\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;module\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-javascript\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-javascript\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Can\u0026apos;t access foo here, because the other script is a module\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; foo);\n\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif20\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal \u0026lt;code\u0026gt;\u0026amp;lt;script\u0026amp;gt;\u0026lt;/code\u0026gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JavaScript have only two type of scope : \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Global Scope\u0026lt;/strong\u0026gt; : Global is nothing but a window level scope.Here, variable present throughout the application.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Functional Scope\u0026lt;/strong\u0026gt; : Variable declared within a function with \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; keyword has functional scope.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;        a = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global\u0026quot;\u0026lt;/span\u0026gt;;\n         \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){ \n              b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local\u0026quot;\u0026lt;/span\u0026gt;;\n              \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a+b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026quot;globallocal\u0026quot;\u0026lt;/span\u0026gt;\n         }\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Scope chain --\u0026amp;gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Window level - \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;outer\u0026lt;/code\u0026gt; function are at top level in scope chain.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when outer function called a new \u0026lt;code\u0026gt;variable scope object\u0026lt;/code\u0026gt;(and included in scope chain) added with variable \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; inside it.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Now when a variable \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; required it first searches for nearest variable scope and if variable is not there than it move\u0026apos;s to next object of variable scope chain.which is in this case is window level.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;run the code. hope this will give an idea about scoping \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global data\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;current document data\u0026apos;\u0026lt;/span\u0026gt;;\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;){\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;local data\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myObj = {\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;object data\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt;);\n    }\n};\n\nmyObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;newFun\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;testFun\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Window Scope : \u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; + \n          \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nLocal Scope : \u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; + \n          \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nObject Scope : \u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt; + \n          \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nCurrent document Scope : \u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Name\u0026lt;/span\u0026gt;\n         );\n}\n\n\ntestFun.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(myObj);\n})(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Global Scope :\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//global variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//global function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n   \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//access global variable\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Local Scope :\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;21\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//local variable\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(d);\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a); }\n     \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//execute local function\u0026lt;/span\u0026gt;\n}\n\n \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(d); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ReferenceError: dddddd is not defined    \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.thatjsdude.com/jsConcepts/concepts/scope.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Check this article for in-depth understanding of scope\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it\u0026apos;s compiling and executing the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/0kqpZ.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/0kqpZ.png\u0026quot; alt=\u0026quot;image\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quoting from his ebook:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The building represents our programs nested scope ruleset. The first\n  floor of the building represents your currently executing scope,\n  wherever you are. The top level of the building is the global scope.\n  You resolve LHS and RHS references by looking on your current floor,\n  and if you dont find it, taking the elevator to the next floor,\n  looking there, then the next, and so on. Once you get to the top floor\n  (the global scope), you either find what youre looking for, or you\n  dont. But you have to stop regardless.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;One thing of note that is worth mentioning, \u0026quot;Scope look-up stops once it finds the first match\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This idea of \u0026quot;scope levels\u0026quot; explains why \u0026quot;this\u0026quot; can be changed with a newly created scope, if it\u0026apos;s being looked up in a nested function.\nHere is a link that goes into all these details, \u0026lt;a href=\u0026quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Everything you wanted to know about javascript scope\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are ALMOST only two types of JavaScript scopes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the scope of each var declaration is associated with the most immediately enclosing function\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if there is no enclosing function for a var declaration, it is global scope\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; i++) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; }\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(i, v);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// output 5 5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using functions instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n$.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;each\u0026lt;/span\u0026gt;([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; });\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(i,v);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// output 10 10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s almost all you need to know in terms of JavaScript scoping, except:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with-clause apparently is another exception, but using with-clause it highly discouraged (\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with\u0026lt;/a\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;multiple var declarations within the same scope are combined\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So this code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;abc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(i);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// outputs 1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is equivalent to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;abc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// var declaration moved to the top of the scope\u0026lt;/span\u0026gt;\n  i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n  i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the assignment stays where it is\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Modern Js, ES6+, \u0026apos;\u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;\u0026apos; and \u0026apos;\u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;\u0026apos;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;You should be using block scoping for every variable you create, just like most other major languages. \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;obsolete\u0026lt;/em\u0026gt;. This makes your code safer and more maintainable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; should be used for \u0026lt;strong\u0026gt;95% of cases\u0026lt;/strong\u0026gt;. It makes it so the variable \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; can\u0026apos;t change. Array, object, and DOM node properties can change and should likely be \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try this curious example. In the example below if a were a numeric initialized at 0, you\u0026apos;d see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Date\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;)\n{\n    b.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setDate\u0026lt;/span\u0026gt;(b.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDate\u0026lt;/span\u0026gt;()+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(b.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDate\u0026lt;/span\u0026gt;());\n}\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;(a);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDate\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are only function scopes in JS. Not block scopes!\nYou can see what is hoisting too.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; global_variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_variable\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; hoisting_variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_hoist\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Global variables printed\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_scope: - global_variable: \u0026quot;\u0026lt;/span\u0026gt; + global_variable);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_scope: - hoisting_variable: \u0026quot;\u0026lt;/span\u0026gt; + hoisting_variable);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The variable block will be global, on true condition.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; block = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;block\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_scope: - block: \u0026quot;\u0026lt;/span\u0026gt; + block);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;local_function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; local_variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_variable\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_scope: - local_variable: \u0026quot;\u0026lt;/span\u0026gt; + local_variable);\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_scope: - global_variable: \u0026quot;\u0026lt;/span\u0026gt; + global_variable);\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_scope: - block: \u0026quot;\u0026lt;/span\u0026gt; + block);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The hoisting_variable is undefined at the moment.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_scope: - hoisting_variable: \u0026quot;\u0026lt;/span\u0026gt; + hoisting_variable);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; hoisting_variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_hoist\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The hoisting_variable is now set as a local one.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local_scope: - hoisting_variable: \u0026quot;\u0026lt;/span\u0026gt; + hoisting_variable);\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;local_function\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No variable in a separate function is visible into the global scope.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global_scope: - local_variable: \u0026quot;\u0026lt;/span\u0026gt; + local_variable);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword \u0026apos;var\u0026apos;, either within a function or outside, and block scope is indicated with the keyword \u0026apos;let\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In JavaScript there are two types of scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Local scope \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Global scope\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The Below function has a local scope variable \u0026lt;code\u0026gt;carName\u0026lt;/code\u0026gt;. And this variable is not accessible from outside of the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; carName = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Volvo\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(carName);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The Below Class has a Global scope variable \u0026lt;code\u0026gt;carName\u0026lt;/code\u0026gt;. And this variable is accessible from everywhere in the class.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; carName = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Volvo\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(carName);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName \u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I really like the accepted answer but I want to add this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Scope collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Scope is a set of rules for looking up variables by their identifier name.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If a variable cannot be found in the immediate scope, Engine consults the next outer containing scope, continuing until is found or until the outermost (a.k.a., global) scope has been reached. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Is the set of rules that determines where and how a variable (identifier) can be looked up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;LHS references result from assignment operations. Scope-related assignments can occur either with the = operator or by passing arguments to (assign to) function parameters.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The JavaScript engine first compiles code before it executes, and in so doing, it splits up statements like var a = 2; into two separate steps: 1st. First, var a to declare it in that scope. This is performed at the beginning, before code execution. 2nd. Later, a = 2 to look up the variable (LHS reference) and assign to it if found.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Both LHS and RHS reference look-ups start at the currently executing scope, and if need be (that is, they dont find what theyre looking for there), they work their way up the nested scope, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or dont. Unfulfilled RHS references result in ReferenceError being thrown. Unfulfilled LHS references result in an automatic, implicitly created global of that name (if not in Strict Mode), or a ReferenceError (if in Strict Mode).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;scope consists of a series of bubbles that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author time.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;ES5\u0026lt;/code\u0026gt; and earlier:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Variables in Javascript were initially (pre \u0026lt;code\u0026gt;ES6\u0026lt;/code\u0026gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by \u0026apos;looking\u0026apos; at the code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Every variable declared with the \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a \u0026lt;strong\u0026gt;scope chain\u0026lt;/strong\u0026gt;. It works in the following manner:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside \u0026lt;strong\u0026gt;other\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;functions\u0026lt;/strong\u0026gt; which are in this scope).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it cannot find the variable inside the function body it \u0026lt;strong\u0026gt;will climb up to the chain\u0026lt;/strong\u0026gt; and look at the variable scope in the function in \u0026lt;strong\u0026gt;where the function was defined\u0026lt;/strong\u0026gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;h2\u0026gt;Example:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// global scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; bar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foobar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunc\u0026lt;/span\u0026gt; () {\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// outerFunc scope\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;outerFunc\u0026apos;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foobar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;outerFunc\u0026apos;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunc\u0026lt;/span\u0026gt;();\n \n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// innerFunc scope\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;innerFunc\u0026apos;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo);\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(bar);\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foobar);\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunc\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif21\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What happens when we are trying to log the variables \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;foobar\u0026lt;/code\u0026gt; to the console is the following:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;We try to log foo to the console, foo can be found inside the function \u0026lt;code\u0026gt;innerFunc\u0026lt;/code\u0026gt; itself. Therefore, the value of foo is resolved to the string \u0026lt;code\u0026gt;innerFunc\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;We try to log bar to the console, bar cannot be found inside the function \u0026lt;code\u0026gt;innerFunc\u0026lt;/code\u0026gt; itself. Therefore, we need to \u0026lt;strong\u0026gt;climb the scope chain\u0026lt;/strong\u0026gt;. We first look in the outer function in which the function \u0026lt;code\u0026gt;innerFunc\u0026lt;/code\u0026gt; was defined. This is the function \u0026lt;code\u0026gt;outerFunc\u0026lt;/code\u0026gt;. In the scope of \u0026lt;code\u0026gt;outerFunc\u0026lt;/code\u0026gt; we can find the variable bar, which holds the string \u0026apos;outerFunc\u0026apos;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;foobar cannot be found in innerFunc. . Therefore, we need to \u0026lt;strong\u0026gt;climb the scope chain\u0026lt;/strong\u0026gt; to the innerFunc scope. It also cannot be found here, we climb another level to the \u0026lt;strong\u0026gt;global scope\u0026lt;/strong\u0026gt; (i.e. the outermost scope). We find the variable foobar here which holds the string \u0026apos;global\u0026apos;. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a \u0026lt;strong\u0026gt;referenceError\u0026lt;/strong\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;ES6\u0026lt;/code\u0026gt; (ES 2015) and older:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The same concepts of lexically scope and scopechain still apply in \u0026lt;code\u0026gt;ES6\u0026lt;/code\u0026gt;. However a new ways to declare variables were introduced. There are the following:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;: creates a block scoped variable\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;: creates a block scoped variable which has to be initialized and cannot be reassigned\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The biggest difference between \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; is that \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; is function scoped whereas \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; are block scoped. Here is an example to illustrate this:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; letVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; varVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;global\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; () {\n  \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this variable declared with let is scoped to the if block, block scoped\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; letVar = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this variable declared with let is scoped to the function block, function scoped\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; varVar = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n  }\n  \n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(letVar);\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(varVar);\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif22\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the above example letVar logs the value global because variables declared with \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; are block scoped. They cease to exist outside their respective block, so the variable can\u0026apos;t be accessed outside the if block.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In EcmaScript5, there are mainly two scopes, \u0026lt;strong\u0026gt;local scope\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;global scope\u0026lt;/strong\u0026gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called \u0026lt;strong\u0026gt;block scope\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example of block scope is :-\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; i++)\n{\n statement1...\nstatement2...\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// inside this scope we can access the value of i, if we want to access the value of i outside for loop it will give undefined.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; z = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n{\n  x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; z = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\n  {\n    x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x is in the global scope because of the \u0026apos;var\u0026apos; keyword\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// y is in the local scope because of the \u0026apos;let\u0026apos; keyword\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; z = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// z is in the local scope because of the \u0026apos;const\u0026apos; keyword\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 30\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 30\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(z) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 30\u0026lt;/span\u0026gt;\n  }\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 30\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 20\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(z) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 20\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 30\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 10\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(z) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo) })();\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; foo); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined, because `foo` is scoped to its own expression\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//but, like this\u0026lt;/span\u0026gt;\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1:\u0026apos;\u0026lt;/span\u0026gt;, foo) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function foo\u0026lt;/span\u0026gt;\n    foo = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2:\u0026apos;\u0026lt;/span\u0026gt;, foo) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function foo, is not 100, why?\u0026lt;/span\u0026gt;\n})()\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif23\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are two types of scopes in JavaScript. \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Global scope\u0026lt;/strong\u0026gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; carName = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; BMW\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Functional scope or Local scope\u0026lt;/strong\u0026gt;: variable declared in this scope can be used in its own function only. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can not use carName\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; carName = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;BMW\u0026quot;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code here can use carName\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    "],"id":64,"title":"What is the scope of variables in JavaScript?","content":"\n                \n\u0026lt;p\u0026gt;What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291","postType":"QUESTION","createdAt":"2022-07-09T16:34:24.000Z","updatedAt":"2022-07-09T16:34:24.000Z","tags":[{"id":236,"name":"var","slug":"var","createdAt":"2022-07-09T16:34:24.000Z","updatedAt":"2022-07-09T16:34:24.000Z","Questions_Tags":{"questionId":64,"tagId":236}}],"relatedQuestions":[{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291","tags":[{"name":"var","Questions_Tags":{"questionId":64,"tagId":236}}]}]},"randomQuestions":[{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"Retrieve only the queried element in an object array in MongoDB collection","slug":"retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":"Google Maps JS API v3 - Simple Multiple Marker Example","slug":"google-maps-js-api-v3-simple-multiple-marker-example-1657388073335"},{"title":"Is Java \"pass-by-reference\" or \"pass-by-value\"?","slug":"is-java-\"pass-by-reference\"-or-\"pass-by-value\"-1657384319828"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"Why is setTimeout(fn, 0) sometimes useful?","slug":"why-is-settimeout(fn-0)-sometimes-useful-1657388379869"},{"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"},{"title":"Deep cloning objects","slug":"deep-cloning-objects-1657387930865"},{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"Is there a difference between \"==\" and \"is\"?","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231"},{"title":"How do I compose a rotation matrix with human readable angles from scratch?","slug":"how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch-1657387963457"},{"title":"How to deal with floating point number precision in JavaScript?","slug":"how-to-deal-with-floating-point-number-precision-in-javascript-1657387293762"},{"title":"commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated","slug":"commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519"},{"title":"How do I return the response from an Observable/http/async call in angular?","slug":"how-do-i-return-the-response-from-an-observablehttpasync-call-in-angular-1657387335024"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>