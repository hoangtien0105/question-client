{"pageProps":{"data":{"answer":["\n&lt;p&gt;There is no enlightened answer, it&apos;s just because it&apos;s not defined as valid syntax by the C++ language...  So it is so, by definition of the language.&lt;/p&gt;\n\n&lt;p&gt;If you do have an expression within then it is valid.  For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt; ((&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));&lt;span class=&quot;hljs-comment&quot;&gt;//compiles&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Even simpler put: because &lt;code&gt;(x)&lt;/code&gt; is a valid C++ expression, while &lt;code&gt;()&lt;/code&gt; is not. &lt;/p&gt;\n\n&lt;p&gt;To learn more about how languages are defined, and how compilers work, you should learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Formal_language_theory&quot; rel=&quot;noreferrer&quot;&gt;Formal language theory&lt;/a&gt; or more specifically &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot; rel=&quot;noreferrer&quot;&gt;Context Free Grammars (CFG)&lt;/a&gt; and related material like finite state machines.  If you are interested in that though the wikipedia pages won&apos;t be enough, you&apos;ll have to get a book.&lt;/p&gt;\n    ","\n&lt;p&gt;The final solution to this issue is to move to the C+11 uniform initialization syntax if you can.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;A a{};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#uniform-init&quot;&gt;http://www.stroustrup.com/C++11FAQ.html#uniform-init&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;h1&gt;C function declarators&lt;/h1&gt;\n\n&lt;p&gt;First of all, there is C. In C, &lt;code&gt;A a()&lt;/code&gt; is function declaration. For example, &lt;code&gt;putchar&lt;/code&gt; has the following declaration. Normally, such declarations are stored in header files, however nothing stops you from writing them manually, if you know how the declaration of function looks like. The argument names are optional in declarations, so I omitted it in this example.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;putchar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This allows you to write the code like this.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C also allows you to define functions that take functions as arguments, with nice readable syntax that looks like a function call (well, it&apos;s readable, as long you won&apos;t return a pointer to function).&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eighty_four&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;84&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output_result&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; callback())&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Returned: %d\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;callback&lt;/span&gt;());\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;output_result&lt;/span&gt;(eighty_four);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As I mentioned, C allows omitting argument names in header files, therefore the &lt;code&gt;output_result&lt;/code&gt; would look like this in header file.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output_result&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;())&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;One argument in constructor&lt;/h1&gt;\n\n&lt;p&gt;Don&apos;t you recognize that one? Well, let me remind you.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(B())&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Yep, it&apos;s exactly the same function declaration. &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;output_result&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;You can easily notice a conflict of C with new features of C++. To be exact, constructors being class name and parenthesis, and alternate declaration syntax with &lt;code&gt;()&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;. By design, C++ tries to be compatible with C code, and therefore it has to deal with this case - even if practically nobody cares. Therefore, old C features have priority over new C++ features. The grammar of declarations tries to match the name as function, before reverting to the new syntax with &lt;code&gt;()&lt;/code&gt; if it fails.&lt;/p&gt;\n\n&lt;p&gt;If one of those features wouldn&apos;t exist, or had a different syntax (like &lt;code&gt;{}&lt;/code&gt; in C++11), this issue would never have happened for syntax with one argument.&lt;/p&gt;\n\n&lt;p&gt;Now you may ask why &lt;code&gt;A a((B()))&lt;/code&gt; works. Well, let&apos;s declare &lt;code&gt;output_result&lt;/code&gt; with useless parentheses.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output_result&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;()))&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It won&apos;t work. The grammar requires the variable to not be in parentheses.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;lt;stdin&amp;gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;: error: expected declaration specifiers &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; ... before ( token\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, C++ expects standard expression here. In C++, you can write the following code.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And the following code.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value = ((((&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;()))));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C++ expects expression inside inside parentheses to be... well... expression, as opposed to the type C expects. Parentheses don&apos;t mean anything here. However, by inserting useless parentheses, the C function declaration is not matched, and the new syntax can be matched properly (which simply expects an expression, such as &lt;code&gt;2 + 2&lt;/code&gt;).&lt;/p&gt;\n\n&lt;h1&gt;More arguments in constructor&lt;/h1&gt;\n\n&lt;p&gt;Surely one argument is nice, but what about two? It&apos;s not that constructors may have just one argument. One of built-in classes which takes two arguments is &lt;code&gt;std::string&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;hundred_dots&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is all well and fine (technically, it would have most vexing parse if it would be written as &lt;code&gt;std::string wat(int(), char())&lt;/code&gt;, but let&apos;s be honest - who would write that? But let&apos;s assume this code has a vexing problem. You would assume that you have to put everything in parentheses.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;hundred_dots&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;((&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Not quite so.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;lt;stdin&amp;gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;36&lt;/span&gt;: error: invalid conversion from &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; to &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* [-fpermissive]\nIn file included from /usr/include/c++/&lt;span class=&quot;hljs-number&quot;&gt;4.8&lt;/span&gt;/string:&lt;span class=&quot;hljs-number&quot;&gt;53&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,\n                 from &amp;lt;stdin&amp;gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n/usr/include/c++/&lt;span class=&quot;hljs-number&quot;&gt;4.8&lt;/span&gt;/bits/basic_string.tcc:&lt;span class=&quot;hljs-number&quot;&gt;212&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;: error:   initializing argument &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; of std::basic_string&amp;lt;_CharT, _Traits, _Alloc&amp;gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;basic_string&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; _CharT*, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; _Alloc&amp;amp;) [with _CharT = &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;; _Traits = std::char_traits&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;&amp;gt;; _Alloc = std::allocator&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;&amp;gt;] [-fpermissive]\n     basic_string&amp;lt;_CharT, _Traits, _Alloc&amp;gt;::\n     ^\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;m not sure why g++ tries to convert &lt;code&gt;char&lt;/code&gt; to &lt;code&gt;const char *&lt;/code&gt;. Either way, the constructor was called with just one value of type &lt;code&gt;char&lt;/code&gt;. There is no overload which has one argument of type &lt;code&gt;char&lt;/code&gt;, therefore the compiler is confused. You may ask - why the argument is of type char?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Yes, &lt;code&gt;,&lt;/code&gt; here is a comma operator. The comma operator takes two arguments, and gives the right-side argument. It isn&apos;t really useful, but it&apos;s something to be known for my explanation.&lt;/p&gt;\n\n&lt;p&gt;Instead, to solve the most vexing parse, the following code is needed.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;hundred_dots&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;((&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;), (&lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The arguments are in parentheses, not the entire expression. In fact, just one of expressions needs to be in parentheses, as it&apos;s enough to break from the C grammar slightly to use the C++ feature. Things brings us to the point of zero arguments.&lt;/p&gt;\n\n&lt;h1&gt;Zero arguments in constructor&lt;/h1&gt;\n\n&lt;p&gt;You may have noticed the &lt;code&gt;eighty_four&lt;/code&gt; function in my explanation.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eighty_four&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Yes, this is also affected by the most vexing parse. It&apos;s a valid definition, and one you most likely have seen if you created header files (and you should). Adding parentheses doesn&apos;t fix it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eighty_four&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(())&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Why is that so? Well, &lt;code&gt;()&lt;/code&gt; is not an expression. In C++, you have to put an expression between parentheses. You cannot write &lt;code&gt;auto value = ()&lt;/code&gt; in C++, because &lt;code&gt;()&lt;/code&gt; doesn&apos;t mean anything (and even if did, like empty tuple (see Python), it would be one argument, not zero). Practically that means you cannot use shorthand syntax without using C++11&apos;s &lt;code&gt;{}&lt;/code&gt; syntax, as there are no expressions to put in parenthesis, and C grammar for function declarations will always apply.&lt;/p&gt;\n    ","\n&lt;p&gt;You could instead&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(())&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;use&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;A a=&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The innermost parens in your example would be an expression, and in C++ the grammar defines an &lt;code&gt;expression&lt;/code&gt; to be an &lt;code&gt;assignment-expression&lt;/code&gt; or another &lt;code&gt;expression&lt;/code&gt; followed by a comma and another &lt;code&gt;assignment-expression&lt;/code&gt; (Appendix A.4 - Grammar summary/Expressions).&lt;/p&gt;\n\n&lt;p&gt;The grammar further defines an &lt;code&gt;assignment-expression&lt;/code&gt; as one of several other types of expression, none of which can be nothing (or only whitespace).&lt;/p&gt;\n\n&lt;p&gt;So the reason you can&apos;t have &lt;code&gt;A a(())&lt;/code&gt; is simply because the grammar doesn&apos;t allow it.  However, I can&apos;t answer why the people who created C++ didn&apos;t allow this particular use of empty parens as some sort of special-case - I&apos;d guess that they&apos;d rather not put in such a special case if there was a reasonable alternative.&lt;/p&gt;\n    "],"id":579,"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","content":"\n                \n&lt;p&gt;Among the many things Stack Overflow has taught me is what is known as the &quot;most vexing parse&quot;, which is classically demonstrated with a line such as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(B())&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//declares a function&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;While this, for most, intuitively appears to be the declaration of an object &lt;code&gt;a&lt;/code&gt; of type &lt;code&gt;A&lt;/code&gt;, taking a temporary &lt;code&gt;B&lt;/code&gt; object as a constructor parameter, it&apos;s actually a declaration of a function &lt;code&gt;a&lt;/code&gt; returning an &lt;code&gt;A&lt;/code&gt;, taking a pointer to a function which returns &lt;code&gt;B&lt;/code&gt; and itself takes no parameters. Similarly the line&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//declares a function&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;also falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the &lt;code&gt;B()&lt;/code&gt;, as the compiler will then interpret it as the declaration of an object&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;((B()))&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//declares an object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, in the second case, doing the same leads to a compile error&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(())&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//compile error&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;My question is, why? Yes I&apos;m very well aware that the correct &apos;workaround&apos; is to change it to &lt;code&gt;A a;&lt;/code&gt;, but I&apos;m curious to know what it is that the extra &lt;code&gt;()&lt;/code&gt; does for the compiler in the first example which then doesn&apos;t work when reapplying it in the second example. Is the &lt;code&gt;A a((B()));&lt;/code&gt; workaround a specific exception written into the standard?&lt;/p&gt;\n    ","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057","postType":"QUESTION","createdAt":"2022-07-09T17:41:14.000Z","updatedAt":"2022-07-09T17:41:14.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Sort a Map<Key, Value> by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"Test for existence of nested JavaScript object key","slug":"test-for-existence-of-nested-javascript-object-key-1657387935411"},{"title":"Make a div fill the height of the remaining screen space","slug":"make-a-div-fill-the-height-of-the-remaining-screen-space-1657387482387"},{"title":"What does this symbol mean in JavaScript?","slug":"what-does-this-symbol-mean-in-javascript-1657387632971"},{"title":"Reshaping multiple sets of measurement columns (wide format) into single columns (long format)","slug":"reshaping-multiple-sets-of-measurement-columns-(wide-format)-into-single-columns-(long-format)-1657388016983"},{"title":"Is there a difference between \"==\" and \"is\"?","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"What is __init__.py for?","slug":"what-is-__init__.py-for-1657388415243"},{"title":"How can I sanitize user input with PHP?","slug":"how-can-i-sanitize-user-input-with-php-1657387892329"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"What is a NullReferenceException, and how do I fix it?","slug":"what-is-a-nullreferenceexception-and-how-do-i-fix-it-1657384234873"},{"title":"input() error - NameError: name '...' is not defined","slug":"input()-error-nameerror:-name-'...'-is-not-defined-1657388497243"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"How does the Windows Command Interpreter (CMD.EXE) parse scripts?","slug":"how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560"},{"title":"Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference","slug":"why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchronous-code-reference-1657384288966"},{"title":"Find object by id in an array of JavaScript objects","slug":"find-object-by-id-in-an-array-of-javascript-objects-1657387572087"},{"title":"Get all unique values in a JavaScript array (remove duplicates)","slug":"get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296"},{"title":"Why are global variables evil? [closed]","slug":"why-are-global-variables-evil-closed-1657388260006"}]},"__N_SSG":true}