<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="iostream,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","name":"Questions"}}]}</script><title>Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I just found a comment in this answer saying that using iostream::eof in a loop condition is &quot;almost certainly wrong&quot;. I generally use something like while(cin&gt;&gt;n) - which I guess implicitly checks for EOF.

Why is checking for eof explicitly using while (!cin.eof()) wrong?  

How is it different from using scanf(&quot;...&quot;,...)!=EOF in C (which I often use with no problems)?
    "/><meta property="og:title" content="Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong? | Solution Checker"/><meta property="og:description" content="I just found a comment in this answer saying that using iostream::eof in a loop condition is &quot;almost certainly wrong&quot;. I generally use something like while(cin&gt;&gt;n) - which I guess implicitly checks for EOF.

Why is checking for eof explicitly using while (!cin.eof()) wrong?  

How is it different from using scanf(&quot;...&quot;,...)!=EOF in C (which I often use with no problems)?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","text":"I just found a comment in this answer saying that using iostream::eof in a loop condition is &quot;almost certainly wrong&quot;. I generally use something like while(cin&gt;&gt;n) - which I guess implicitly checks for EOF.\n\nWhy is checking for eof explicitly using while (!cin.eof()) wrong?  \n\nHow is it different from using scanf(&quot;...&quot;,...)!=EOF in C (which I often use with no problems)?\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"Because iostream::eof will only return true after reading the end of the stream. It does not indicate, that the next read will be the end of the stream.\n\nConsider this (and assume then next read will be at the end of the stream):\n\nwhile(!inStream.eof()){\n  int data;\n  // yay, not end of stream yet, now read ...\n  inStream &gt;&gt; data;\n  // oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\n  // do stuff with (now uninitialized) data\n}\n\n\nAgainst this:\n\nint data;\nwhile(inStream &gt;&gt; data){\n  // when we land here, we can be sure that the read was successful.\n  // if it wasn&apos;t, the returned stream from operator&gt;&gt; would be converted to false\n  // and the loop wouldn&apos;t even be entered\n  // do stuff with correctly initialized data (hopefully)\n}\n\n\nAnd on your second question: Because\n\nif(scanf(&quot;...&quot;,...)!=EOF)\n\n\nis the same as\n\nif(!(inStream &gt;&gt; data).eof())\n\n\nand not the same as\n\nif(!inStream.eof())\n    inFile &gt;&gt; data\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Bottom-line top:  With proper handling of white-space, the following is how eof can be used (and even, be more reliable than fail() for error checking):\n\nwhile( !(in&gt;&gt;std::ws).eof() ) {  \n   int data;\n   in &gt;&gt; data;\n   if ( in.fail() ) /* handle with break or throw */; \n   // now use data\n}    \n\n\n(Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.)\n\n\n\nThe main argument against using eof() seems to be missing an important subtlety about the role of white space. My proposition is that, checking eof() explicitly is not only not &quot;always wrong&quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the always correct solution (although, not necessarily the tersest).\n\nTo summarize what is being suggested as the &quot;proper&quot; termination and read order is the following:\n\nint data;\nwhile(in &gt;&gt; data) {  /* ... */ }\n\n// which is equivalent to \nwhile( !(in &gt;&gt; data).fail() )  {  /* ... */ }\n\n\nThe failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \n\n\n1 2 3 4 5&lt;eof&gt;\n1 2 a 3 4 5&lt;eof&gt; \na&lt;eof&gt;\n\n\nwhile(in&gt;&gt;data) terminates with a set failbit for all three input. In the first and third, eofbit is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\n\nWhereas, take the following: \n\nwhile( !in.eof() ) \n{  \n   int data;\n   in &gt;&gt; data;\n   if ( in.fail() ) /* handle with break or throw */; \n   // now use data\n}    \n\n\nHere, in.fail() verifies that as long as there is something to read, it is the correct one. It&apos;s purpose is not a mere while-loop terminator. \n\nSo far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against eof() as terminator?\n\nWe don&apos;t need to surrender our error handling; just eat up the white-space:\n\nwhile( !in.eof() ) \n{  \n   int data;\n   in &gt;&gt; data &gt;&gt; ws; // eat whitespace with std::ws\n   if ( in.fail() ) /* handle with break or throw */; \n   // now use data\n}\n\n\nstd::ws skips any potential (zero or more) trailing space in the stream while setting the eofbit, and not the failbit.  So, in.fail() works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\n\nwhile( !(in&gt;&gt;ws).eof() ) \n{  \n   int data;\n   in &gt;&gt; data; \n   if ( in.fail() ) /* handle with break or throw */; \n   /* this will never fire if the eof is reached cleanly */\n   // now use data\n}\n\n\nSummary: A properly constructed while(!eof) is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, while(!fail) is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Because if programmers don&apos;t write while(stream &gt;&gt; n), they possibly write this:\n\nwhile(!stream.eof())\n{\n    stream &gt;&gt; n;\n    //some work on n;\n}\n\n\nHere the problem is, you cannot do some work on n without first checking if the stream read was successful, because if it was unsuccessful, your some work on n would produce undesired result.\n\nThe whole point is that, eofbit, badbit, or failbit are set after an attempt is made to read from the stream. So if stream &gt;&gt; n fails, then eofbit, badbit, or failbit is set immediately, so its more idiomatic if you write while (stream &gt;&gt; n), because the returned object stream converts to false if there was some failure in reading from the stream and consequently the loop stops. And it converts to true if the read was successful and the loop continues.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"The other answers have explained why the logic is wrong in while (!stream.eof()) and how to fix it. I want to focus on something different:\n\n\n  why is checking for eof explicitly using iostream::eof wrong?\n\n\nIn general terms, checking for eof only is wrong because stream extraction (&gt;&gt;) can fail without hitting the end of the file. If you have e.g. int n; cin &gt;&gt; n; and the stream contains hello, then h is not a valid digit, so extraction will fail without reaching the end of the input.\n\nThis issue, combined with the general logic error of checking the stream state before attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\n\n\nIf the stream is empty, the loop will run once. &gt;&gt; will fail (there is no input to be read) and all variables that were supposed to be set (by stream &gt;&gt; x) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\n\n(If your standard library conforms to C++11, things are a bit different now: A failed &gt;&gt; now sets numeric variables to 0 instead of leaving them uninitialized (except for chars).)\nIf the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all &gt;&gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as &quot;the last line is printed twice&quot; or &quot;the last input record is processed twice&quot;.\n\n(This should manifest a bit differently since C++11 (see above): Now you get a &quot;phantom record&quot; of zeroes instead of a repeated last line.)\nIf the stream contains malformed data but you only check for .eof, you end up with an infinite loop. &gt;&gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\n\n\n\n\nTo recap: The solution is to test the success of the &gt;&gt; operation itself, not to use a separate .eof() method: while (stream &gt;&gt; n &gt;&gt; m) { ... }, just as in C you test the success of the scanf call itself: while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { ... }.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The important thing to remember is that, inFile.eof() doesnt become True until after an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\nwhile (!inFile.eof()){\n    inFile &gt;&gt; x;\n        process(x);\n}\n\nThe way to make this loop correct, is to combine reading and checking into a single operation, like so\nwhile (inFile &gt;&gt; x) \n    process(x); \n\nBy convention, operator&gt;&gt; returns the stream we read from, and a Boolean test on a stream returns False when the stream fails (such as reaching end of file).\nSo this gives us the correct sequence :\n\nread\ntest whether the read succeeds\nif and only if the test succeeds, process what weve read\n\nIf you happen to encounter some other problem that prevents you from reading from the file correctly, you will not be able to reach eof() as such. For example, lets look at something like this\nint x; \nwhile (!inFile.eof()) { \n    inFile &gt;&gt; x; \n    process(x);\n} \n    \n\nLet us trace through the working of the above code, with an example\n\nAssume the contents of the file are &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;a&apos;, &apos;b&apos;.\nThe loop will read the 1, 2, and 3 correctly.\nThen itll get to a.\nWhen it tries to extract a as an int, itll fail.\nThe stream is now in a failed state, until or unless we clear the stream, all attempts at reading from it will fail.\nBut, when we test for eof(), itll return False, because were not at the end of the file, because theres still a waiting to be read.\nThe loop will keep trying to read from the file, and fail every time, so it never reaches the end of the file.\nSo, the loop above will run forever.\n\nBut, if we use a loop like this, we will get the required output.\nwhile (inFile &gt;&gt; x)\n    process(x);\n\nIn this case, the stream will convert to False not only in case of end of file, but also in case of a failed conversion, such as the a that we cant read as an integer.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"><h1>Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/iostream">iostream</a></div></div><div class="question-content mt-5">
                
<p>I just found a comment in <a href="https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649">this</a> answer saying that using <code>iostream::eof</code> in a loop condition is "almost certainly wrong". I generally use something like <code>while(cin&gt;&gt;n)</code> - which I guess implicitly checks for EOF.</p>

<p>Why is checking for eof explicitly using <code>while (!cin.eof())</code> wrong?  </p>

<p>How is it different from using <code>scanf("...",...)!=EOF</code> in C (which I often use with no problems)?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because <code>iostream::eof</code> will only return <code>true</code> <em>after</em> reading the end of the stream. It does <em>not</em> indicate, that the next read will be the end of the stream.</p>

<p>Consider this (and assume then next read will be at the end of the stream):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!inStream.<span class="hljs-built_in">eof</span>()){
  <span class="hljs-type">int</span> data;
  <span class="hljs-comment">// yay, not end of stream yet, now read ...</span>
  inStream &gt;&gt; data;
  <span class="hljs-comment">// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)</span>
  <span class="hljs-comment">// do stuff with (now uninitialized) data</span>
}
</code></pre>

<p>Against this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(inStream &gt;&gt; data){
  <span class="hljs-comment">// when we land here, we can be sure that the read was successful.</span>
  <span class="hljs-comment">// if it wasn't, the returned stream from operator&gt;&gt; would be converted to false</span>
  <span class="hljs-comment">// and the loop wouldn't even be entered</span>
  <span class="hljs-comment">// do stuff with correctly initialized data (hopefully)</span>
}
</code></pre>

<p>And on your second question: Because</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"..."</span>,...)!=EOF)
</code></pre>

<p>is the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!(inStream &gt;&gt; data).<span class="hljs-built_in">eof</span>())
</code></pre>

<p>and <strong>not</strong> the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!inStream.<span class="hljs-built_in">eof</span>())
    inFile &gt;&gt; data
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Bottom-line top:</strong>  With proper handling of white-space, the following is how <code>eof</code> can be used (and even, be more reliable than <code>fail()</code> for error checking):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;std::ws).<span class="hljs-built_in">eof</span>() ) {  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>(<em>Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.</em>)</p>

<hr>

<p>The main argument against using <code>eof()</code> seems to be missing an important subtlety about the role of white space. My proposition is that, checking <code>eof()</code> explicitly is not only not "<em>always wrong</em>" -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the <em>always correct</em> solution (although, not necessarily the tersest).</p>

<p>To summarize what is being suggested as the "proper" termination and read order is the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(in &gt;&gt; data) {  <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// which is equivalent to </span>
<span class="hljs-keyword">while</span>( !(in &gt;&gt; data).<span class="hljs-built_in">fail</span>() )  {  <span class="hljs-comment">/* ... */</span> }
</code></pre>

<p>The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: </p>

<ul>
<li><code>1 2 3 4 5&lt;eof&gt;</code></li>
<li><code>1 2 a 3 4 5&lt;eof&gt;</code> </li>
<li><code>a&lt;eof&gt;</code></li>
</ul>

<p><code>while(in&gt;&gt;data)</code> terminates with a set <code>failbit</code> for <em>all</em> three input. In the first and third, <code>eofbit</code> is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).</p>

<p>Whereas, take the following: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>Here, <code>in.fail()</code> verifies that as long as there is something to read, it is the correct one. It's purpose is not a mere while-loop terminator. </p>

<p>So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against <code>eof()</code> as terminator?</p>

<p>We don't need to surrender our error handling; just eat up the white-space:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data &gt;&gt; ws; <span class="hljs-comment">// eat whitespace with std::ws</span>
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><code>std::ws</code> skips any potential (zero or more) trailing space in the stream while setting the <code>eofbit</code>, and <strong>not the <code>failbit</code></strong>.  So, <code>in.fail()</code> works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;ws).<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data; 
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">/* this will never fire if the eof is reached cleanly */</span>
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><strong>Summary:</strong> A properly constructed <code>while(!eof)</code> is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, <code>while(!fail)</code> is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. </p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because if programmers don't write <code>while(stream &gt;&gt; n)</code>, they possibly write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!stream.<span class="hljs-built_in">eof</span>())
{
    stream &gt;&gt; n;
    <span class="hljs-comment">//some work on n;</span>
}
</code></pre>

<p>Here the problem is, you cannot do <code>some work on n</code> without first checking if the stream read was successful, because if it was unsuccessful, your <code>some work on n</code> would produce undesired result.</p>

<p>The whole point is that, <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> are set <strong>after an attempt is made to read from the stream.</strong> So if <code>stream &gt;&gt; n</code> fails, then <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> is set immediately, so its more idiomatic if you write <code>while (stream &gt;&gt; n)</code>, because the returned object <code>stream</code> converts to <code>false</code> if there was some failure in reading from the stream and consequently the loop stops. And it converts to <code>true</code> if the read was successful and the loop continues.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The other answers have explained why the logic is wrong in <code>while (!stream.eof())</code> and how to fix it. I want to focus on something different:</p>

<blockquote>
  <p>why is checking for eof explicitly using <code>iostream::eof</code> wrong?</p>
</blockquote>

<p>In general terms, checking for <code>eof</code> <em>only</em> is wrong because stream extraction (<code>&gt;&gt;</code>) can fail without hitting the end of the file. If you have e.g. <code>int n; cin &gt;&gt; n;</code> and the stream contains <code>hello</code>, then <code>h</code> is not a valid digit, so extraction will fail without reaching the end of the input.</p>

<p>This issue, combined with the general logic error of checking the stream state <em>before</em> attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:</p>

<ul>
<li><p>If the stream is empty, the loop will run once. <code>&gt;&gt;</code> will fail (there is no input to be read) and all variables that were supposed to be set (by <code>stream &gt;&gt; x</code>) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).</p>

<p>(If your standard library conforms to C++11, things are a bit different now: A failed <code>&gt;&gt;</code> now sets numeric variables to <code>0</code> instead of leaving them uninitialized (except for <code>char</code>s).)</p></li>
<li><p>If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all <code>&gt;&gt;</code> operations fail, variables are likely to keep their value from the previous iteration. This can manifest as "the last line is printed twice" or "the last input record is processed twice".</p>

<p>(This should manifest a bit differently since C++11 (see above): Now you get a "phantom record" of zeroes instead of a repeated last line.)</p></li>
<li><p>If the stream contains malformed data but you only check for <code>.eof</code>, you end up with an infinite loop. <code>&gt;&gt;</code> will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.</p></li>
</ul>

<hr>

<p>To recap: The solution is to test the success of the <code>&gt;&gt;</code> operation itself, not to use a separate <code>.eof()</code> method: <code>while (stream &gt;&gt; n &gt;&gt; m) { ... }</code>, just as in C you test the success of the <code>scanf</code> call itself: <code>while (scanf("%d%d", &amp;n, &amp;m) == 2) { ... }</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The important thing to remember is that, <code>inFile.eof()</code> doesnt become <code>True</code> until <em><strong>after</strong></em> an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()){
    inFile &gt;&gt; x;
        <span class="hljs-built_in">process</span>(x);
}
</code></pre>
<p>The way to make this loop correct, is to combine reading and checking into a single operation, like so</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)&nbsp;
    <span class="hljs-built_in">process</span>(x);&nbsp;
</code></pre>
<p>By convention, <code>operator&gt;&gt;</code> returns the stream we read from, and a Boolean test on a stream returns <code>False</code> when the stream fails (such as reaching end of file).</p>
<p><strong>So this gives us the correct sequence :</strong></p>
<ul>
<li>read</li>
<li>test whether the read succeeds</li>
<li>if and only if the test succeeds, process what weve read</li>
</ul>
<p>If you happen to encounter some <em>other</em> problem that prevents you from reading from the file correctly, you will not be able to reach <code>eof()</code> as such. For example, lets look at something like this</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x;&nbsp;
<span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()) {&nbsp;
    inFile &gt;&gt; x;&nbsp;
    <span class="hljs-built_in">process</span>(x);
}&nbsp;
    
</code></pre>
<p>Let us trace through the working of the above code, with an example</p>
<ul>
<li>Assume the contents of the file are <code>'1', '2', '3', 'a', 'b'</code>.</li>
<li>The loop will read the 1, 2, and 3 correctly.</li>
<li>Then itll get to <code>a</code>.</li>
<li>When it tries to extract <code>a</code> as an int, itll fail.</li>
<li>The stream is now in a failed state, until or unless we <code>clear</code> the stream, all attempts at reading from it will fail.</li>
<li>But, when we test for eof(), itll return <code>False</code>, because were not at the end of the file, because theres still <code>a</code> waiting to be read.</li>
<li>The loop will keep trying to read from the file, and fail every time, so it <strong>never</strong> reaches the end of the file.</li>
<li>So, the loop above will run forever.</li>
</ul>
<p>But, if we use a loop like this, we will get the required output.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)
    <span class="hljs-built_in">process</span>(x);
</code></pre>
<p>In this case, the stream will convert to <code>False</code> not only in case of end of file, but also in case of a failed conversion, such as the <code>a</code> that we cant read as an integer.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386">How do I access previous promise results in a .then() chain?</a><a href="/questions/reference-what-does-this-regex-mean-1657384291445">Reference - What does this regex mean?</a><a href="/questions/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554">Why does the order in which libraries are linked sometimes cause errors in GCC?</a><a href="/questions/how-to-get-the-difference-between-two-arrays-in-javascript-1657388463384">How to get the difference between two arrays in JavaScript?</a><a href="/questions/how-to-make-good-reproducible-pandas-examples-1657384310402">How to make good reproducible pandas examples</a><a href="/questions/use-dynamic-variable-names-in-javascript-1657388468075">Use dynamic variable names in JavaScript</a><a href="/questions/how-can-i-validate-an-email-address-using-a-regular-expression-1657384549233">How can I validate an email address using a regular expression?</a><a href="/questions/copy-array-by-value-1657387649531">Copy array by value</a><a href="/questions/how-do-i-correctly-clone-a-javascript-object-1657387325850">How do I correctly clone a JavaScript object?</a><a href="/questions/what-is-array-to-pointer-decay-1657384709608">What is array to pointer decay?</a><a href="/questions/using-asyncawait-with-a-foreach-loop-1657384512667">Using async/await with a forEach loop</a><a href="/questions/is-java-%22pass-by-reference%22-or-%22pass-by-value%22-1657384319828">Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;?</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/%22notice:-undefined-variable%22-%22notice:-undefined-index%22-%22warning:-undefined-array-key%22-and-%22notice:-undefined-offset%22-using-php-1657384250748">&quot;Notice: Undefined variable&quot;, &quot;Notice: Undefined index&quot;, &quot;Warning: Undefined array key&quot;, and &quot;Notice: Undefined offset&quot; using PHP</a><a href="/questions/how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922">How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result</a><a href="/questions/find-object-by-id-in-an-array-of-javascript-objects-1657387572087">Find object by id in an array of JavaScript objects</a><a href="/questions/deserialize-json-into-c-dynamic-object-1657388568720">Deserialize JSON into C# dynamic object?</a><a href="/questions/why-are-mutable-structs-%22evil%22-1657388508974">Why are mutable structs “evil”?</a><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392">Big O, how do you calculate/approximate it?</a><a href="/questions/how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057">How to use SharedPreferences in Android to store, fetch and edit values [closed]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; will only return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; reading the end of the stream. It does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; indicate, that the next read will be the end of the stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this (and assume then next read will be at the end of the stream):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, not end of stream yet, now read ...\u0026lt;/span\u0026gt;\n  inStream \u0026amp;gt;\u0026amp;gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with (now uninitialized) data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Against this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(inStream \u0026amp;gt;\u0026amp;gt; data){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when we land here, we can be sure that the read was successful.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if it wasn\u0026apos;t, the returned stream from operator\u0026amp;gt;\u0026amp;gt; would be converted to false\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the loop wouldn\u0026apos;t even be entered\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with correctly initialized data (hopefully)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And on your second question: Because\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;...\u0026quot;\u0026lt;/span\u0026gt;,...)!=EOF)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!(inStream \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n    inFile \u0026amp;gt;\u0026amp;gt; data\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bottom-line top:\u0026lt;/strong\u0026gt;  With proper handling of white-space, the following is how \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; can be used (and even, be more reliable than \u0026lt;code\u0026gt;fail()\u0026lt;/code\u0026gt; for error checking):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;std::ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) {  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(\u0026lt;em\u0026gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The main argument against using \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; explicitly is not only not \u0026quot;\u0026lt;em\u0026gt;always wrong\u0026lt;/em\u0026gt;\u0026quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the \u0026lt;em\u0026gt;always correct\u0026lt;/em\u0026gt; solution (although, not necessarily the tersest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize what is being suggested as the \u0026quot;proper\u0026quot; termination and read order is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in \u0026amp;gt;\u0026amp;gt; data) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is equivalent to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() )  {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 a 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(in\u0026amp;gt;\u0026amp;gt;data)\u0026lt;/code\u0026gt; terminates with a set \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; for \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; three input. In the first and third, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas, take the following: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; verifies that as long as there is something to read, it is the correct one. It\u0026apos;s purpose is not a mere while-loop terminator. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as terminator?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We don\u0026apos;t need to surrender our error handling; just eat up the white-space:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data \u0026amp;gt;\u0026amp;gt; ws; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// eat whitespace with std::ws\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; skips any potential (zero or more) trailing space in the stream while setting the \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, and \u0026lt;strong\u0026gt;not the \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.  So, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data; \n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* this will never fire if the eof is reached cleanly */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary:\u0026lt;/strong\u0026gt; A properly constructed \u0026lt;code\u0026gt;while(!eof)\u0026lt;/code\u0026gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, \u0026lt;code\u0026gt;while(!fail)\u0026lt;/code\u0026gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because if programmers don\u0026apos;t write \u0026lt;code\u0026gt;while(stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, they possibly write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!stream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n{\n    stream \u0026amp;gt;\u0026amp;gt; n;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some work on n;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the problem is, you cannot do \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; without first checking if the stream read was successful, because if it was unsuccessful, your \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; would produce undesired result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole point is that, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set \u0026lt;strong\u0026gt;after an attempt is made to read from the stream.\u0026lt;/strong\u0026gt; So if \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; n\u0026lt;/code\u0026gt; fails, then \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set immediately, so its more idiomatic if you write \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, because the returned object \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; converts to \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the read was successful and the loop continues.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The other answers have explained why the logic is wrong in \u0026lt;code\u0026gt;while (!stream.eof())\u0026lt;/code\u0026gt; and how to fix it. I want to focus on something different:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;why is checking for eof explicitly using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In general terms, checking for \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; is wrong because stream extraction (\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;) can fail without hitting the end of the file. If you have e.g. \u0026lt;code\u0026gt;int n; cin \u0026amp;gt;\u0026amp;gt; n;\u0026lt;/code\u0026gt; and the stream contains \u0026lt;code\u0026gt;hello\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; is not a valid digit, so extraction will fail without reaching the end of the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue, combined with the general logic error of checking the stream state \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is empty, the loop will run once. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail (there is no input to be read) and all variables that were supposed to be set (by \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; x\u0026lt;/code\u0026gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If your standard library conforms to C++11, things are a bit different now: A failed \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; now sets numeric variables to \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; instead of leaving them uninitialized (except for \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s).)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as \u0026quot;the last line is printed twice\u0026quot; or \u0026quot;the last input record is processed twice\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(This should manifest a bit differently since C++11 (see above): Now you get a \u0026quot;phantom record\u0026quot; of zeroes instead of a repeated last line.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream contains malformed data but you only check for \u0026lt;code\u0026gt;.eof\u0026lt;/code\u0026gt;, you end up with an infinite loop. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To recap: The solution is to test the success of the \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operation itself, not to use a separate \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; method: \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; m) { ... }\u0026lt;/code\u0026gt;, just as in C you test the success of the \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; call itself: \u0026lt;code\u0026gt;while (scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;amp;n, \u0026amp;amp;m) == 2) { ... }\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The important thing to remember is that, \u0026lt;code\u0026gt;inFile.eof()\u0026lt;/code\u0026gt; doesnt become \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; until \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n    inFile \u0026amp;gt;\u0026amp;gt; x;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\u0026amp;nbsp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By convention, \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returns the stream we read from, and a Boolean test on a stream returns \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; when the stream fails (such as reaching end of file).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So this gives us the correct sequence :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;read\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;test whether the read succeeds\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if and only if the test succeeds, process what weve read\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;If you happen to encounter some \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; problem that prevents you from reading from the file correctly, you will not be able to reach \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as such. For example, lets look at something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\u0026amp;nbsp;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\u0026amp;nbsp;\n    inFile \u0026amp;gt;\u0026amp;gt; x;\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\u0026amp;nbsp;\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Let us trace through the working of the above code, with an example\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assume the contents of the file are \u0026lt;code\u0026gt;\u0026apos;1\u0026apos;, \u0026apos;2\u0026apos;, \u0026apos;3\u0026apos;, \u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will read the 1, 2, and 3 correctly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then itll get to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it tries to extract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; as an int, itll fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The stream is now in a failed state, until or unless we \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; the stream, all attempts at reading from it will fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But, when we test for eof(), itll return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;, because were not at the end of the file, because theres still \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; waiting to be read.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will keep trying to read from the file, and fail every time, so it \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; reaches the end of the file.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, the loop above will run forever.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;But, if we use a loop like this, we will get the required output.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, the stream will convert to \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; not only in case of end of file, but also in case of a failed conversion, such as the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that we cant read as an integer.\u0026lt;/p\u0026gt;\n    "],"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","content":"\n                \n\u0026lt;p\u0026gt;I just found a comment in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; answer saying that using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; in a loop condition is \u0026quot;almost certainly wrong\u0026quot;. I generally use something like \u0026lt;code\u0026gt;while(cin\u0026amp;gt;\u0026amp;gt;n)\u0026lt;/code\u0026gt; - which I guess implicitly checks for EOF.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why is checking for eof explicitly using \u0026lt;code\u0026gt;while (!cin.eof())\u0026lt;/code\u0026gt; wrong?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How is it different from using \u0026lt;code\u0026gt;scanf(\u0026quot;...\u0026quot;,...)!=EOF\u0026lt;/code\u0026gt; in C (which I often use with no problems)?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}],"relatedQuestions":[{"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","tags":[{"name":"iostream","Questions_Tags":{"questionId":35,"tagId":122}}]}]},"randomQuestions":[{"title":"How do I access previous promise results in a .then() chain?","slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"},{"title":"Reference - What does this regex mean?","slug":"reference-what-does-this-regex-mean-1657384291445"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"How to get the difference between two arrays in JavaScript?","slug":"how-to-get-the-difference-between-two-arrays-in-javascript-1657388463384"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"Use dynamic variable names in JavaScript","slug":"use-dynamic-variable-names-in-javascript-1657388468075"},{"title":"How can I validate an email address using a regular expression?","slug":"how-can-i-validate-an-email-address-using-a-regular-expression-1657384549233"},{"title":"Copy array by value","slug":"copy-array-by-value-1657387649531"},{"title":"How do I correctly clone a JavaScript object?","slug":"how-do-i-correctly-clone-a-javascript-object-1657387325850"},{"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608"},{"title":"Using async/await with a forEach loop","slug":"using-asyncawait-with-a-foreach-loop-1657384512667"},{"title":"Is Java \"pass-by-reference\" or \"pass-by-value\"?","slug":"is-java-\"pass-by-reference\"-or-\"pass-by-value\"-1657384319828"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"\"Notice: Undefined variable\", \"Notice: Undefined index\", \"Warning: Undefined array key\", and \"Notice: Undefined offset\" using PHP","slug":"\"notice:-undefined-variable\"-\"notice:-undefined-index\"-\"warning:-undefined-array-key\"-and-\"notice:-undefined-offset\"-using-php-1657384250748"},{"title":"How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result","slug":"how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922"},{"title":"Find object by id in an array of JavaScript objects","slug":"find-object-by-id-in-an-array-of-javascript-objects-1657387572087"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"Why are mutable structs “evil”?","slug":"why-are-mutable-structs-\"evil\"-1657388508974"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"How to use SharedPreferences in Android to store, fetch and edit values [closed]","slug":"how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>