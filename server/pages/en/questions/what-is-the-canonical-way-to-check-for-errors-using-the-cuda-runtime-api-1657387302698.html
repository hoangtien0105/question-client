<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the canonical way to check for errors using the CUDA runtime API? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Looking through the answers and comments on CUDA questions, and in the CUDA tag wiki, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like cudaGetLastError, cudaPeekAtLastError, and cudaGetErrorString, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?
    "/><meta property="og:title" content="What is the canonical way to check for errors using the CUDA runtime API? | Solutions Checker"/><meta property="og:description" content="Looking through the answers and comments on CUDA questions, and in the CUDA tag wiki, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like cudaGetLastError, cudaPeekAtLastError, and cudaGetErrorString, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the canonical way to check for errors using the CUDA runtime API?","text":"Looking through the answers and comments on CUDA questions, and in the CUDA tag wiki, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like cudaGetLastError, cudaPeekAtLastError, and cudaGetErrorString, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?\n    ","answerCount":4,"upVoteCount":500,"suggestedAnswer":[{"text":"Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:\n\n#define gpuErrchk(ans) { gpuAssert((ans), __FILE__, __LINE__); }\ninline void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true)\n{\n   if (code != cudaSuccess) \n   {\n      fprintf(stderr,&quot;GPUassert: %s %s %d\\n&quot;, cudaGetErrorString(code), file, line);\n      if (abort) exit(code);\n   }\n}\n\n\nYou can then wrap each API call with the gpuErrchk macro, which will process the return status of the API call it wraps, for example:\n\ngpuErrchk( cudaMalloc(&amp;a_d, size*sizeof(int)) );\n\n\nIf there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to stderr and the application will exit. You could conceivably modify gpuAssert to raise an exception rather than call exit() in a more sophisticated application if it were required.\n\nA second related question is how to check for errors in kernel launches, which can&apos;t be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:\n\nkernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(a);\ngpuErrchk( cudaPeekAtLastError() );\ngpuErrchk( cudaDeviceSynchronize() );\n\n\nwill firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:\n\nkernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(a_d);\ngpuErrchk( cudaPeekAtLastError() );\ngpuErrchk( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );\n\n\nin which case the cudaMemcpy call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. \n\nNote that when using CUDA Dynamic Parallelism, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:\n\n#include &lt;assert.h&gt;\n#define cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }\n__device__ void cdpAssert(cudaError_t code, const char *file, int line, bool abort=true)\n{\n   if (code != cudaSuccess)\n   {\n      printf(&quot;GPU kernel assert: %s %s %d\\n&quot;, cudaGetErrorString(code), file, line);\n      if (abort) assert(0);\n   }\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"talonmies&apos; answer above is a fine way to abort an application in an assert-style manner.\n\nOccasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.\n\nHere&apos;s a reasonably terse way to do that by throwing a C++ exception derived from std::runtime_error using thrust::system_error:\n\n#include &lt;thrust/system_error.h&gt;\n#include &lt;thrust/system/cuda/error.h&gt;\n#include &lt;sstream&gt;\n\nvoid throw_on_cuda_error(cudaError_t code, const char *file, int line)\n{\n  if(code != cudaSuccess)\n  {\n    std::stringstream ss;\n    ss &lt;&lt; file &lt;&lt; &quot;(&quot; &lt;&lt; line &lt;&lt; &quot;)&quot;;\n    std::string file_and_line;\n    ss &gt;&gt; file_and_line;\n    throw thrust::system_error(code, thrust::cuda_category(), file_and_line);\n  }\n}\n\n\nThis will incorporate the filename, line number, and an English language description of the cudaError_t into the thrown exception&apos;s .what() member:\n\n#include &lt;iostream&gt;\n\nint main()\n{\n  try\n  {\n    // do something crazy\n    throw_on_cuda_error(cudaSetDevice(-1), __FILE__, __LINE__);\n  }\n  catch(thrust::system_error &amp;e)\n  {\n    std::cerr &lt;&lt; &quot;CUDA error after cudaSetDevice: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n\n    // oops, recover\n    cudaSetDevice(0);\n  }\n\n  return 0;\n}\n\n\nThe output:\n\n$ nvcc exception.cu -run\nCUDA error after cudaSetDevice: exception.cu(23): invalid device ordinal\n\n\nA client of some_function can distinguish CUDA errors from other kinds of errors if desired:\n\ntry\n{\n  // call some_function which may throw something\n  some_function();\n}\ncatch(thrust::system_error &amp;e)\n{\n  std::cerr &lt;&lt; &quot;CUDA error during some_function: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n}\ncatch(std::bad_alloc &amp;e)\n{\n  std::cerr &lt;&lt; &quot;Bad memory allocation during some_function: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n}\ncatch(std::runtime_error &amp;e)\n{\n  std::cerr &lt;&lt; &quot;Runtime error during some_function: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n}\ncatch(...)\n{\n  std::cerr &lt;&lt; &quot;Some other kind of error during some_function&quot; &lt;&lt; std::endl;\n\n  // no idea what to do, so just rethrow the exception\n  throw;\n}\n\n\nBecause thrust::system_error is a std::runtime_error, we can alternatively handle it in the same manner of a broad class of errors if we don&apos;t require the precision of the previous example:\n\ntry\n{\n  // call some_function which may throw something\n  some_function();\n}\ncatch(std::runtime_error &amp;e)\n{\n  std::cerr &lt;&lt; &quot;Runtime error during some_function: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The C++-canonical way: Don&apos;t check for errors...use the C++ bindings which throw exceptions.\nI used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared&apos;s answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.\nSo I&apos;ve approached this in a different and more fundamental way. For a sample of the result, here&apos;s part of the CUDA vectorAdd sample - with complete error checking of every runtime API call:\n// (... prepare host-side buffers here ...)\n\nauto current_device = cuda::device::current::get();\nauto d_A = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);\nauto d_B = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);\nauto d_C = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);\n\ncuda::memory::copy(d_A.get(), h_A.get(), size);\ncuda::memory::copy(d_B.get(), h_B.get(), size);\n\nauto launch_config = cuda::launch_config_builder()\n    .overall_size(numElements)\n    .block_size(256)\n    .build();\n\ncuda::launch(vectorAdd, launch_config,\n    d_A.get(), d_B.get(), d_C.get(), numElements\n);    \ncuda::memory::copy(h_C.get(), d_C.get(), size);\n\n// (... verify results here...)\n\nAgain - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error after launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a cuda::outstanding_error::ensure_none() command).\nThe code above uses my\nThin Modern-C++ wrappers for the CUDA Runtime API library (Github)\nNote that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.\nA few links to how CUDA errors are automagically checked with these wrappers:\n\nA test program throwing and catching a bunch of exceptions\nDocumentation for the error-related functionality\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"The solution discussed here worked well for me. This solution uses built-in cuda functions and is very simple to implement.\n\nThe relevant code is copied below:\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n__global__ void foo(int *ptr)\n{\n  *ptr = 7;\n}\n\nint main(void)\n{\n  foo&lt;&lt;&lt;1,1&gt;&gt;&gt;(0);\n\n  // make the host block until the device is finished with foo\n  cudaDeviceSynchronize();\n\n  // check for error\n  cudaError_t error = cudaGetLastError();\n  if(error != cudaSuccess)\n  {\n    // print the CUDA error message and exit\n    printf(&quot;CUDA error: %s\\n&quot;, cudaGetErrorString(error));\n    exit(-1);\n  }\n\n  return 0;\n}\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"><h1>What is the canonical way to check for errors using the CUDA runtime API?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/error-checking">error-checking</a></div></div><div class="question-content mt-5">
                
<p>Looking through the answers and comments on CUDA questions, and in the <a href="https://stackoverflow.com/tags/cuda/info">CUDA tag wiki</a>, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like <code>cudaGetLastError</code>, <code>cudaPeekAtLastError</code>, and <code>cudaGetErrorString</code>, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/error-checking">error-checking</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">gpuErrchk</span>(ans) { <span class="hljs-built_in">gpuAssert</span>((ans), __FILE__, __LINE__); }
inline void <span class="hljs-built_in">gpuAssert</span>(cudaError_t code, const char *file, int line, bool abort=true)
{
   if (code != cudaSuccess) 
   {
      <span class="hljs-built_in">fprintf</span>(stderr,"GPUassert: %s %s %d\n", cudaGetErrorString(code), file, line);
      if (abort) <span class="hljs-built_in">exit</span>(code);
   }
}
</code></pre>

<p>You can then wrap each API call with the <code>gpuErrchk</code> macro, which will process the return status of the API call it wraps, for example:</p>

<pre class="default s-code-block"><code class="hljs language-lisp">gpuErrchk( <span class="hljs-name">cudaMalloc</span>(<span class="hljs-name">&amp;a_d</span>, size*sizeof(<span class="hljs-name">int</span>)) )<span class="hljs-comment">;</span>
</code></pre>

<p>If there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to <code>stderr</code> and the application will exit. You could conceivably modify <code>gpuAssert</code> to raise an exception rather than call <code>exit()</code> in a more sophisticated application if it were required.</p>

<p>A second related question is how to check for errors in kernel launches, which can't be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss">kernel&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(a);
<span class="hljs-built_in">gpuErrchk</span>( cudaPeekAtLastError() );
<span class="hljs-built_in">gpuErrchk</span>( cudaDeviceSynchronize() );
</code></pre>

<p>will firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss">kernel&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(a_d);
<span class="hljs-built_in">gpuErrchk</span>( cudaPeekAtLastError() );
<span class="hljs-built_in">gpuErrchk</span>( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );
</code></pre>

<p>in which case the <code>cudaMemcpy</code> call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. </p>

<p>Note that when using <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism" rel="noreferrer">CUDA Dynamic Parallelism</a>, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }</span>
<span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">cdpAssert</span><span class="hljs-params">(cudaError_t code, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line, <span class="hljs-type">bool</span> abort=<span class="hljs-literal">true</span>)</span>
</span>{
   <span class="hljs-keyword">if</span> (code != cudaSuccess)
   {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"GPU kernel assert: %s %s %d\n"</span>, <span class="hljs-built_in">cudaGetErrorString</span>(code), file, line);
      <span class="hljs-keyword">if</span> (abort) <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);
   }
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/error-checking">error-checking</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>talonmies' answer above is a fine way to abort an application in an <code>assert</code>-style manner.</p>

<p>Occasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.</p>

<p>Here's a reasonably terse way to do that by throwing a C++ exception derived from <code>std::runtime_error</code> using <code>thrust::system_error</code>:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrust/system_error.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrust/system/cuda/error.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">throw_on_cuda_error</span><span class="hljs-params">(cudaError_t code, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line)</span>
</span>{
  <span class="hljs-keyword">if</span>(code != cudaSuccess)
  {
    std::stringstream ss;
    ss &lt;&lt; file &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">")"</span>;
    std::string file_and_line;
    ss &gt;&gt; file_and_line;
    <span class="hljs-keyword">throw</span> thrust::<span class="hljs-built_in">system_error</span>(code, thrust::<span class="hljs-built_in">cuda_category</span>(), file_and_line);
  }
}
</code></pre>

<p>This will incorporate the filename, line number, and an English language description of the <code>cudaError_t</code> into the thrown exception's <code>.what()</code> member:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-comment">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>()
{
  <span class="hljs-keyword">try</span>
  {
    <span class="hljs-comment">// do something crazy</span>
    <span class="hljs-title function_ invoke__">throw_on_cuda_error</span>(<span class="hljs-title function_ invoke__">cudaSetDevice</span>(-<span class="hljs-number">1</span>), <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);
  }
  <span class="hljs-keyword">catch</span>(thrust::<span class="hljs-variable constant_">system_error</span> &amp;e)
  {
    std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"CUDA error after cudaSetDevice: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;

    <span class="hljs-comment">// oops, recover</span>
    <span class="hljs-title function_ invoke__">cudaSetDevice</span>(<span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The output:</p>

<pre class="default s-code-block"><code class="hljs language-ocaml">$ nvcc <span class="hljs-keyword">exception</span>.cu -run
<span class="hljs-type">CUDA</span> error after cudaSetDevice: <span class="hljs-keyword">exception</span>.cu(<span class="hljs-number">23</span>): invalid device ordinal
</code></pre>

<p>A client of <code>some_function</code> can distinguish CUDA errors from other kinds of errors if desired:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">try</span>
{
  <span class="hljs-comment">// call some_function which may throw something</span>
  <span class="hljs-title function_ invoke__">some_function</span>();
}
<span class="hljs-keyword">catch</span>(thrust::<span class="hljs-variable constant_">system_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"CUDA error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">bad_alloc</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Bad memory allocation during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">runtime_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Runtime error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(...)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Some other kind of error during some_function"</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;

  <span class="hljs-comment">// no idea what to do, so just rethrow the exception</span>
  <span class="hljs-keyword">throw</span>;
}
</code></pre>

<p>Because <code>thrust::system_error</code> is a <code>std::runtime_error</code>, we can alternatively handle it in the same manner of a broad class of errors if we don't require the precision of the previous example:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">try</span>
{
  <span class="hljs-comment">// call some_function which may throw something</span>
  <span class="hljs-title function_ invoke__">some_function</span>();
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">runtime_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Runtime error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/error-checking">error-checking</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>The C++-canonical way: Don't check for errors...use the C++ bindings which throw exceptions.</h3>
<p>I used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared's answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.</p>
<p>So I've approached this in a different and more fundamental way. For a sample of the result, here's part of the CUDA <code>vectorAdd</code> sample - with <em>complete</em> error checking of every runtime API call:</p>
<pre class="default s-code-block"><code class="hljs language-rust"><span class="hljs-comment">// (... prepare host-side buffers here ...)</span>

auto current_device = cuda::device::current::<span class="hljs-title function_ invoke__">get</span>();
auto d_A = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);
auto d_B = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);
auto d_C = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);

cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(d_A.<span class="hljs-title function_ invoke__">get</span>(), h_A.<span class="hljs-title function_ invoke__">get</span>(), size);
cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(d_B.<span class="hljs-title function_ invoke__">get</span>(), h_B.<span class="hljs-title function_ invoke__">get</span>(), size);

auto launch_config = cuda::<span class="hljs-title function_ invoke__">launch_config_builder</span>()
    .<span class="hljs-title function_ invoke__">overall_size</span>(numElements)
    .<span class="hljs-title function_ invoke__">block_size</span>(<span class="hljs-number">256</span>)
    .<span class="hljs-title function_ invoke__">build</span>();

cuda::<span class="hljs-title function_ invoke__">launch</span>(vectorAdd, launch_config,
    d_A.<span class="hljs-title function_ invoke__">get</span>(), d_B.<span class="hljs-title function_ invoke__">get</span>(), d_C.<span class="hljs-title function_ invoke__">get</span>(), numElements
);    
cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(h_C.<span class="hljs-title function_ invoke__">get</span>(), d_C.<span class="hljs-title function_ invoke__">get</span>(), size);

<span class="hljs-comment">// (... verify results here...)</span>
</code></pre>
<p>Again - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error <em>after</em> launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a <code>cuda::outstanding_error::ensure_none()</code> command).</p>
<p>The code above uses my</p>
<p><a href="https://github.com/eyalroz/cuda-api-wrappers" rel="nofollow noreferrer"><strong>Thin Modern-C++ wrappers for the CUDA Runtime API library</strong></a> (Github)</p>
<p>Note that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.</p>
<p>A few links to how CUDA errors are automagically checked with these wrappers:</p>
<ul>
<li><a href="https://github.com/eyalroz/cuda-api-wrappers/blob/master/examples/by_runtime_api_module/error_handling.cu" rel="nofollow noreferrer">A test program throwing and catching a bunch of exceptions</a></li>
<li><a href="https://codedocs.xyz/eyalroz/cuda-api-wrappers/error_8hpp.html" rel="nofollow noreferrer">Documentation for the error-related functionality</a></li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/error-checking">error-checking</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The solution discussed <a href="https://code.google.com/p/stanford-cs193g-sp2010/wiki/TutorialWhenSomethingGoesWrong" rel="noreferrer">here</a> worked well for me. This solution uses built-in cuda functions and is very simple to implement.</p>

<p>The relevant code is copied below:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span>
</span>{
  *ptr = <span class="hljs-number">7</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
  foo&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// make the host block until the device is finished with foo</span>
  <span class="hljs-built_in">cudaDeviceSynchronize</span>();

  <span class="hljs-comment">// check for error</span>
  cudaError_t error = <span class="hljs-built_in">cudaGetLastError</span>();
  <span class="hljs-keyword">if</span>(error != cudaSuccess)
  {
    <span class="hljs-comment">// print the CUDA error message and exit</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"CUDA error: %s\n"</span>, <span class="hljs-built_in">cudaGetErrorString</span>(error));
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/sorting-an-array-of-objects-by-property-values-1657387447490">Sorting an array of objects by property values</a><a href="/questions/why-are-these-numbers-not-equal-1657384729559">Why are these numbers not equal?</a><a href="/questions/why-is-settimeout(fn-0)-sometimes-useful-1657388379869">Why is setTimeout(fn, 0) sometimes useful?</a><a href="/questions/what-is-event-bubbling-and-capturing-1657388059203">What is event bubbling and capturing?</a><a href="/questions/example-images-for-code-and-mark-up-qandas-closed-1657387690222">Example images for code and mark-up Q&amp;As [closed]</a><a href="/questions/safely-turning-a-json-string-into-an-object-1657388194824">Safely turning a JSON string into an object</a><a href="/questions/select-first-row-in-each-group-by-group-1657384809388">Select first row in each GROUP BY group?</a><a href="/questions/how-do-i-vertically-center-text-with-css-duplicate-1657387645821">How do I vertically center text with CSS? [duplicate]</a><a href="/questions/how-do-i-profile-c++-code-running-on-linux-1657384754272">How do I profile C++ code running on Linux?</a><a href="/questions/how-to-use-php&#x27;s-password_hash-to-hash-and-verify-passwords-1657387808784">How to use PHP&#x27;s password_hash to hash and verify passwords</a><a href="/questions/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474">What is an efficient way to implement a singleton pattern in Java? [closed]</a><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a><a href="/questions/trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490">Trouble with UTF-8 characters; what I see is not what I stored</a><a href="/questions/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java-1657388359877">Why do I need to override the equals and hashCode methods in Java?</a><a href="/questions/use-a-content-script-to-access-the-page-context-variables-and-functions-1657384842444">Use a content script to access the page context variables and functions</a><a href="/questions/what-should-main()-return-in-c-and-c++-1657384745630">What should main() return in C and C++?</a><a href="/questions/how-can-i-sanitize-user-input-with-php-1657387892329">How can I sanitize user input with PHP?</a><a href="/questions/what-does-enctype&#x27;multipartform-data&#x27;-mean-1657388229352">What does enctype=&#x27;multipart/form-data&#x27; mean?</a><a href="/questions/what-is-the-%22n+1-selects-problem%22-in-orm-(object-relational-mapping)-1657388055597">What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)?</a><a href="/questions/aggregate-summarize-multiple-variables-per-group-(e.g.-sum-mean)-1657387764061">Aggregate / summarize multiple variables per group (e.g. sum, mean)</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-id\u0026quot;\u0026gt;#define\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;(ans) { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuAssert\u0026lt;/span\u0026gt;((ans), __FILE__, __LINE__); }\ninline void \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuAssert\u0026lt;/span\u0026gt;(cudaError_t code, const char *file, int line, bool abort=true)\n{\n   if (code != cudaSuccess) \n   {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(stderr,\u0026quot;GPUassert: %s %s %d\\n\u0026quot;, cudaGetErrorString(code), file, line);\n      if (abort) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(code);\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can then wrap each API call with the \u0026lt;code\u0026gt;gpuErrchk\u0026lt;/code\u0026gt; macro, which will process the return status of the API call it wraps, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt;gpuErrchk( \u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cudaMalloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;\u0026amp;amp;a_d\u0026lt;/span\u0026gt;, size*sizeof(\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)) )\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to \u0026lt;code\u0026gt;stderr\u0026lt;/code\u0026gt; and the application will exit. You could conceivably modify \u0026lt;code\u0026gt;gpuAssert\u0026lt;/code\u0026gt; to raise an exception rather than call \u0026lt;code\u0026gt;exit()\u0026lt;/code\u0026gt; in a more sophisticated application if it were required.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A second related question is how to check for errors in kernel launches, which can\u0026apos;t be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;kernel\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(a);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaPeekAtLastError() );\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaDeviceSynchronize() );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;kernel\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(a_d);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaPeekAtLastError() );\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in which case the \u0026lt;code\u0026gt;cudaMemcpy\u0026lt;/code\u0026gt; call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that when using \u0026lt;a href=\u0026quot;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CUDA Dynamic Parallelism\u0026lt;/a\u0026gt;, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;__device__ \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cdpAssert\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cudaError_t code, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *file, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; line, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; abort=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (code != cudaSuccess)\n   {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;GPU kernel assert: %s %s %d\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetErrorString\u0026lt;/span\u0026gt;(code), file, line);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (abort) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;talonmies\u0026apos; answer above is a fine way to abort an application in an \u0026lt;code\u0026gt;assert\u0026lt;/code\u0026gt;-style manner.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Occasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a reasonably terse way to do that by throwing a C++ exception derived from \u0026lt;code\u0026gt;std::runtime_error\u0026lt;/code\u0026gt; using \u0026lt;code\u0026gt;thrust::system_error\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;thrust/system_error.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;thrust/system/cuda/error.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw_on_cuda_error\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cudaError_t code, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *file, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(code != cudaSuccess)\n  {\n    std::stringstream ss;\n    ss \u0026amp;lt;\u0026amp;lt; file \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; line \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\u0026quot;\u0026lt;/span\u0026gt;;\n    std::string file_and_line;\n    ss \u0026amp;gt;\u0026amp;gt; file_and_line;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; thrust::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt;(code, thrust::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cuda_category\u0026lt;/span\u0026gt;(), file_and_line);\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will incorporate the filename, line number, and an English language description of the \u0026lt;code\u0026gt;cudaError_t\u0026lt;/code\u0026gt; into the thrown exception\u0026apos;s \u0026lt;code\u0026gt;.what()\u0026lt;/code\u0026gt; member:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#include \u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do something crazy\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;throw_on_cuda_error\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cudaSetDevice\u0026lt;/span\u0026gt;(-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;__FILE__\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;__LINE__\u0026lt;/span\u0026gt;);\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(thrust::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n  {\n    std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error after cudaSetDevice: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oops, recover\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cudaSetDevice\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-ocaml\u0026quot;\u0026gt;$ nvcc \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exception\u0026lt;/span\u0026gt;.cu -run\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CUDA\u0026lt;/span\u0026gt; error after cudaSetDevice: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exception\u0026lt;/span\u0026gt;.cu(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;): invalid device ordinal\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A client of \u0026lt;code\u0026gt;some_function\u0026lt;/code\u0026gt; can distinguish CUDA errors from other kinds of errors if desired:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call some_function which may throw something\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(thrust::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;bad_alloc\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Bad memory allocation during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Runtime error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(...)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Some other kind of error during some_function\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no idea what to do, so just rethrow the exception\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;thrust::system_error\u0026lt;/code\u0026gt; is a \u0026lt;code\u0026gt;std::runtime_error\u0026lt;/code\u0026gt;, we can alternatively handle it in the same manner of a broad class of errors if we don\u0026apos;t require the precision of the previous example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call some_function which may throw something\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Runtime error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;The C++-canonical way: Don\u0026apos;t check for errors...use the C++ bindings which throw exceptions.\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;I used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared\u0026apos;s answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So I\u0026apos;ve approached this in a different and more fundamental way. For a sample of the result, here\u0026apos;s part of the CUDA \u0026lt;code\u0026gt;vectorAdd\u0026lt;/code\u0026gt; sample - with \u0026lt;em\u0026gt;complete\u0026lt;/em\u0026gt; error checking of every runtime API call:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (... prepare host-side buffers here ...)\u0026lt;/span\u0026gt;\n\nauto current_device = cuda::device::current::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\nauto d_A = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\nauto d_B = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\nauto d_C = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\n\ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(d_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), h_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(d_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), h_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\n\nauto launch_config = cuda::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;launch_config_builder\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;overall_size\u0026lt;/span\u0026gt;(numElements)\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;block_size\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;)\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;build\u0026lt;/span\u0026gt;();\n\ncuda::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;launch\u0026lt;/span\u0026gt;(vectorAdd, launch_config,\n    d_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), numElements\n);    \ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(h_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (... verify results here...)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a \u0026lt;code\u0026gt;cuda::outstanding_error::ensure_none()\u0026lt;/code\u0026gt; command).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code above uses my\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/eyalroz/cuda-api-wrappers\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Thin Modern-C++ wrappers for the CUDA Runtime API library\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; (Github)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A few links to how CUDA errors are automagically checked with these wrappers:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/eyalroz/cuda-api-wrappers/blob/master/examples/by_runtime_api_module/error_handling.cu\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;A test program throwing and catching a bunch of exceptions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://codedocs.xyz/eyalroz/cuda-api-wrappers/error_8hpp.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Documentation for the error-related functionality\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The solution discussed \u0026lt;a href=\u0026quot;https://code.google.com/p/stanford-cs193g-sp2010/wiki/TutorialWhenSomethingGoesWrong\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; worked well for me. This solution uses built-in cuda functions and is very simple to implement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The relevant code is copied below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;__global__ \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ptr)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  *ptr = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  foo\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make the host block until the device is finished with foo\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaDeviceSynchronize\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// check for error\u0026lt;/span\u0026gt;\n  cudaError_t error = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetLastError\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(error != cudaSuccess)\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// print the CUDA error message and exit\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error: %s\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetErrorString\u0026lt;/span\u0026gt;(error));\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":217,"title":"What is the canonical way to check for errors using the CUDA runtime API?","content":"\n                \n\u0026lt;p\u0026gt;Looking through the answers and comments on CUDA questions, and in the \u0026lt;a href=\u0026quot;https://stackoverflow.com/tags/cuda/info\u0026quot;\u0026gt;CUDA tag wiki\u0026lt;/a\u0026gt;, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like \u0026lt;code\u0026gt;cudaGetLastError\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;cudaPeekAtLastError\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;cudaGetErrorString\u0026lt;/code\u0026gt;, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698","postType":"QUESTION","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","tags":[{"id":1496,"name":"cuda","slug":"cuda","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","Questions_Tags":{"questionId":217,"tagId":1496}},{"id":1497,"name":"error-checking","slug":"error-checking","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","Questions_Tags":{"questionId":217,"tagId":1497}}],"relatedQuestions":[{"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698","tags":[{"name":"cuda","Questions_Tags":{"questionId":217,"tagId":1496}},{"name":"error-checking","Questions_Tags":{"questionId":217,"tagId":1497}}]}]},"randomQuestions":[{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"Why is setTimeout(fn, 0) sometimes useful?","slug":"why-is-settimeout(fn-0)-sometimes-useful-1657388379869"},{"title":"What is event bubbling and capturing?","slug":"what-is-event-bubbling-and-capturing-1657388059203"},{"title":"Example images for code and mark-up Q\u0026As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"Select first row in each GROUP BY group?","slug":"select-first-row-in-each-group-by-group-1657384809388"},{"title":"How do I vertically center text with CSS? [duplicate]","slug":"how-do-i-vertically-center-text-with-css-duplicate-1657387645821"},{"title":"How do I profile C++ code running on Linux?","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272"},{"title":"How to use PHP's password_hash to hash and verify passwords","slug":"how-to-use-php's-password_hash-to-hash-and-verify-passwords-1657387808784"},{"title":"What is an efficient way to implement a singleton pattern in Java? [closed]","slug":"what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},{"title":"Trouble with UTF-8 characters; what I see is not what I stored","slug":"trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490"},{"title":"Why do I need to override the equals and hashCode methods in Java?","slug":"why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java-1657388359877"},{"title":"Use a content script to access the page context variables and functions","slug":"use-a-content-script-to-access-the-page-context-variables-and-functions-1657384842444"},{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630"},{"title":"How can I sanitize user input with PHP?","slug":"how-can-i-sanitize-user-input-with-php-1657387892329"},{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597"},{"title":"Aggregate / summarize multiple variables per group (e.g. sum, mean)","slug":"aggregate-summarize-multiple-variables-per-group-(e.g.-sum-mean)-1657387764061"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>