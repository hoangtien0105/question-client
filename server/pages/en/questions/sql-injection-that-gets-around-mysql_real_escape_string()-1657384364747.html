<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747","name":"Questions"}}]}</script><title>SQL injection that gets around mysql_real_escape_string() | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Is there an SQL injection possibility even when using mysql_real_escape_string() function?

Consider this sample situation. SQL is constructed in PHP like this:

$login = mysql_real_escape_string(GetFromPost(&#x27;login&#x27;));
$password = mysql_real_escape_string(GetFromPost(&#x27;password&#x27;));

$sql = &quot;SELECT * FROM table WHERE login=&#x27;$login&#x27; AND password=&#x27;$password&#x27;&quot;;


I have heard numerous people say to me that code like that is still dangerous and possible to hack even with mysql_real_escape_string() function used. But I cannot think of any possible exploit?

Classic injections like this:

aaa&#x27; OR 1=1 --


do not work.

Do you know of any possible injection that would get through the PHP code above?
    "/><meta property="og:title" content="SQL injection that gets around mysql_real_escape_string() | Solution Checker"/><meta property="og:description" content="Is there an SQL injection possibility even when using mysql_real_escape_string() function?

Consider this sample situation. SQL is constructed in PHP like this:

$login = mysql_real_escape_string(GetFromPost(&#x27;login&#x27;));
$password = mysql_real_escape_string(GetFromPost(&#x27;password&#x27;));

$sql = &quot;SELECT * FROM table WHERE login=&#x27;$login&#x27; AND password=&#x27;$password&#x27;&quot;;


I have heard numerous people say to me that code like that is still dangerous and possible to hack even with mysql_real_escape_string() function used. But I cannot think of any possible exploit?

Classic injections like this:

aaa&#x27; OR 1=1 --


do not work.

Do you know of any possible injection that would get through the PHP code above?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"SQL injection that gets around mysql_real_escape_string()","text":"Is there an SQL injection possibility even when using mysql_real_escape_string() function?\n\nConsider this sample situation. SQL is constructed in PHP like this:\n\n$login = mysql_real_escape_string(GetFromPost(&apos;login&apos;));\n$password = mysql_real_escape_string(GetFromPost(&apos;password&apos;));\n\n$sql = &quot;SELECT * FROM table WHERE login=&apos;$login&apos; AND password=&apos;$password&apos;&quot;;\n\n\nI have heard numerous people say to me that code like that is still dangerous and possible to hack even with mysql_real_escape_string() function used. But I cannot think of any possible exploit?\n\nClassic injections like this:\n\naaa&apos; OR 1=1 --\n\n\ndo not work.\n\nDo you know of any possible injection that would get through the PHP code above?\n    ","answerCount":4,"upVoteCount":500,"suggestedAnswer":[{"text":"The short answer is yes, yes there is a way to get around mysql_real_escape_string().\n#For Very OBSCURE EDGE CASES!!!\nThe long answer isn&apos;t so easy. It&apos;s based off an attack demonstrated here.\nThe Attack\nSo, let&apos;s start off by showing the attack...\nmysql_query(&apos;SET NAMES gbk&apos;);\n$var = mysql_real_escape_string(&quot;\\xbf\\x27 OR 1=1 /*&quot;);\nmysql_query(&quot;SELECT * FROM test WHERE name = &apos;$var&apos; LIMIT 1&quot;);\n\nIn certain circumstances, that will return more than 1 row. Let&apos;s dissect what&apos;s going on here:\n\nSelecting a Character Set\nmysql_query(&apos;SET NAMES gbk&apos;);\n\nFor this attack to work, we need the encoding that the server&apos;s expecting on the connection both to encode &apos; as in ASCII i.e. 0x27 and to have some character whose final byte is an ASCII \\ i.e. 0x5c.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: big5, cp932, gb2312, gbk and sjis.  We&apos;ll select gbk here.\nNow, it&apos;s very important to note the use of SET NAMES here. This sets the character set ON THE SERVER. If we used the call to the C API function mysql_set_charset(), we&apos;d be fine (on MySQL releases since 2006). But more on why in a minute...\n\nThe Payload\nThe payload we&apos;re going to use for this injection starts with the byte sequence 0xbf27.  In gbk, that&apos;s an invalid multibyte character; in latin1, it&apos;s the string Â¿&apos;.  Note that in latin1 and gbk, 0x27 on its own is a literal &apos; character.\nWe have chosen this payload because, if we called addslashes() on it, we&apos;d insert an ASCII \\ i.e. 0x5c, before the &apos; character. So we&apos;d wind up with 0xbf5c27, which in gbk is a two character sequence: 0xbf5c followed by 0x27. Or in other words, a valid character followed by an unescaped &apos;. But we&apos;re not using addslashes(). So on to the next step...\n\nmysql_real_escape_string()\nThe C API call to mysql_real_escape_string() differs from addslashes() in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we&apos;re still using latin1 for the connection, because we never told it otherwise. We did tell the server we&apos;re using gbk, but the client still thinks it&apos;s latin1.\nTherefore the call to mysql_real_escape_string() inserts the backslash, and we have a free hanging &apos; character in our &quot;escaped&quot; content! In fact, if we were to look at $var in the gbk character set, we&apos;d see:\n&apos; OR 1=1 /*\nWhich is exactly what the attack requires.\n\nThe Query\nThis part is just a formality, but here&apos;s the rendered query:\nSELECT * FROM test WHERE name = &apos;&apos; OR 1=1 /*&apos; LIMIT 1\n\n\n\nCongratulations, you just successfully attacked a program using mysql_real_escape_string()...\nThe Bad\nIt gets worse. PDO defaults to emulating prepared statements with MySQL. That means that on the client side, it basically does a sprintf through mysql_real_escape_string() (in the C library), which means the following will result in a successful injection:\n$pdo-&gt;query(&apos;SET NAMES gbk&apos;);\n$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$stmt-&gt;execute(array(&quot;\\xbf\\x27 OR 1=1 /*&quot;));\n\nNow, it&apos;s worth noting that you can prevent this by disabling emulated prepared statements:\n$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n\nThis will usually result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently fallback to emulating statements that MySQL can&apos;t prepare natively: those that it can are listed in the manual, but beware to select the appropriate server version).\nThe Ugly\nI said at the very beginning that we could have prevented all of this if we had used mysql_set_charset(&apos;gbk&apos;) instead of SET NAMES gbk. And that&apos;s true provided you are using a MySQL release since 2006.\nIf you&apos;re using an earlier MySQL release, then a bug in mysql_real_escape_string() meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes even if the client had been correctly informed of the connection encoding and so this attack would still succeed.  The bug was fixed in MySQL 4.1.20, 5.0.22 and 5.1.11.\nBut the worst part is that PDO didn&apos;t expose the C API for mysql_set_charset() until 5.3.6, so in prior versions it cannot prevent this attack for every possible command!\nIt&apos;s now exposed as a DSN parameter.\nThe Saving Grace\nAs we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  utf8mb4 is not vulnerable and yet can support every Unicode character: so you could elect to use that insteadbut it has only been available since MySQL 5.5.3.  An alternative is utf8, which is also not vulnerable and can support the whole of the Unicode Basic Multilingual Plane.\nAlternatively, you can enable the NO_BACKSLASH_ESCAPES SQL mode, which (amongst other things) alters the operation of mysql_real_escape_string().  With this mode enabled, 0x27 will be replaced with 0x2727 rather than 0x5c27 and thus the escaping process cannot create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. 0xbf27 is still 0xbf27 etc.)so the server will still reject the string as invalid.  However, see @eggyal&apos;s answer for a different vulnerability that can arise from using this SQL mode.\nSafe Examples\nThe following examples are safe:\nmysql_query(&apos;SET NAMES utf8&apos;);\n$var = mysql_real_escape_string(&quot;\\xbf\\x27 OR 1=1 /*&quot;);\nmysql_query(&quot;SELECT * FROM test WHERE name = &apos;$var&apos; LIMIT 1&quot;);\n\nBecause the server&apos;s expecting utf8...\nmysql_set_charset(&apos;gbk&apos;);\n$var = mysql_real_escape_string(&quot;\\xbf\\x27 OR 1=1 /*&quot;);\nmysql_query(&quot;SELECT * FROM test WHERE name = &apos;$var&apos; LIMIT 1&quot;);\n\nBecause we&apos;ve properly set the character set so the client and the server match.\n$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n$pdo-&gt;query(&apos;SET NAMES gbk&apos;);\n$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$stmt-&gt;execute(array(&quot;\\xbf\\x27 OR 1=1 /*&quot;));\n\nBecause we&apos;ve turned off emulated prepared statements.\n$pdo = new PDO(&apos;mysql:host=localhost;dbname=testdb;charset=gbk&apos;, $user, $password);\n$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$stmt-&gt;execute(array(&quot;\\xbf\\x27 OR 1=1 /*&quot;));\n\nBecause we&apos;ve set the character set properly.\n$mysqli-&gt;query(&apos;SET NAMES gbk&apos;);\n$stmt = $mysqli-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$param = &quot;\\xbf\\x27 OR 1=1 /*&quot;;\n$stmt-&gt;bind_param(&apos;s&apos;, $param);\n$stmt-&gt;execute();\n\nBecause MySQLi does true prepared statements all the time.\nWrapping Up\nIf you:\n\nUse Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) AND mysql_set_charset() / $mysqli-&gt;set_charset() / PDO&apos;s DSN charset parameter (in PHP  5.3.6)\n\nOR\n\nDon&apos;t use a vulnerable character set for connection encoding (you only use utf8 / latin1 / ascii / etc)\n\nYou&apos;re 100% safe.\nOtherwise, you&apos;re vulnerable even though you&apos;re using mysql_real_escape_string()...\n    ","url":"https://solutionschecker.com/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747#solution1","@type":"Answer","upvoteCount":0},{"text":"Consider the following query:\n\n$iId = mysql_real_escape_string(&quot;1 OR 1=1&quot;);    \n$sSql = &quot;SELECT * FROM table WHERE id = $iId&quot;;\n\n\nmysql_real_escape_string() will not protect you against this.\nThe fact that you use single quotes (&apos; &apos;) around your variables inside your query is what protects you against this. The following is also an option:\n\n$iId = (int)&quot;1 OR 1=1&quot;;\n$sSql = &quot;SELECT * FROM table WHERE id = $iId&quot;;\n\n    ","url":"https://solutionschecker.com/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747#solution2","@type":"Answer","upvoteCount":0},{"text":"\n  TL;DR\n  \n  mysql_real_escape_string() will provide no protection whatsoever (and could furthermore munge your data) if:\n  \n  \n  MySQL&apos;s NO_BACKSLASH_ESCAPES SQL mode is enabled (which it might be, unless you explicitly select another SQL mode every time you connect); and\n  your SQL string literals are quoted using double-quote &quot; characters.\n  \n  \n  This was filed as bug #72458 and has been fixed in MySQL v5.7.6 (see the section headed &quot;The Saving Grace&quot;, below).\n\n\nThis is another, (perhaps less?) obscure EDGE CASE!!!\n\nIn homage to @ircmaxell&apos;s excellent answer (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:\n\nThe Attack\n\nStarting off with a demonstration...\n\nmysql_query(&apos;SET SQL_MODE=&quot;NO_BACKSLASH_ESCAPES&quot;&apos;); // could already be set\n$var = mysql_real_escape_string(&apos;&quot; OR 1=1 -- &apos;);\nmysql_query(&apos;SELECT * FROM test WHERE name = &quot;&apos;.$var.&apos;&quot; LIMIT 1&apos;);\n\n\nThis will return all records from the test table.  A dissection:\n\n\nSelecting an SQL Mode\n\nmysql_query(&apos;SET SQL_MODE=&quot;NO_BACKSLASH_ESCAPES&quot;&apos;);\n\n\nAs documented under String Literals:\n\n\n  There are several ways to include quote characters within a string:\n  \n  \n  A &apos; inside a string quoted with &apos; may be written as &apos;&apos;.\n  A &quot; inside a string quoted with &quot; may be written as &quot;&quot;.\n  Precede the quote character by an escape character (\\).\n  A &apos; inside a string quoted with &quot; needs no special treatment and need not be doubled or escaped. In the same way, &quot; inside a string quoted with &apos; needs no special treatment.\n  \n\n\nIf the server&apos;s SQL mode includes NO_BACKSLASH_ESCAPES, then the third of these optionswhich is the usual approach adopted by mysql_real_escape_string()is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one&apos;s data.\nThe Payload\n\n&quot; OR 1=1 -- \n\n\nThe payload initiates this injection quite literally with the &quot; character.  No particular encoding.  No special characters.  No weird bytes.\nmysql_real_escape_string()\n\n$var = mysql_real_escape_string(&apos;&quot; OR 1=1 -- &apos;);\n\n\nFortunately, mysql_real_escape_string() does check the SQL mode and adjust its behaviour accordingly.  See libmysql.c:\n\nulong STDCALL\nmysql_real_escape_string(MYSQL *mysql, char *to,const char *from,\n             ulong length)\n{\n  if (mysql-&gt;server_status &amp; SERVER_STATUS_NO_BACKSLASH_ESCAPES)\n    return escape_quotes_for_mysql(mysql-&gt;charset, to, 0, from, length);\n  return escape_string_for_mysql(mysql-&gt;charset, to, 0, from, length);\n}\n\n\nThus a different underlying function, escape_quotes_for_mysql(), is invoked if the NO_BACKSLASH_ESCAPES SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.\n\nHowever, this function arbitrarily assumes that the string will be quoted using the single-quote &apos; character.  See charset.c:\n\n/*\n  Escape apostrophes by doubling them up\n\n// [ deletia 839-845 ]\n\n  DESCRIPTION\n    This escapes the contents of a string by doubling up any apostrophes that\n    it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in\n    effect on the server.\n\n// [ deletia 852-858 ]\n*/\n\nsize_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,\n                               char *to, size_t to_length,\n                               const char *from, size_t length)\n{\n// [ deletia 865-892 ]\n\n    if (*from == &apos;\\&apos;&apos;)\n    {\n      if (to + 2 &gt; to_end)\n      {\n        overflow= TRUE;\n        break;\n      }\n      *to++= &apos;\\&apos;&apos;;\n      *to++= &apos;\\&apos;&apos;;\n    }\n\n\nSo, it leaves double-quote &quot; characters untouched (and doubles all single-quote &apos; characters) irrespective of the actual character that is used to quote the literal!  In our case $var remains exactly the same as the argument that was provided to mysql_real_escape_string()it&apos;s as though no escaping has taken place at all.\nThe Query\n\nmysql_query(&apos;SELECT * FROM test WHERE name = &quot;&apos;.$var.&apos;&quot; LIMIT 1&apos;);\n\n\nSomething of a formality, the rendered query is:\n\nSELECT * FROM test WHERE name = &quot;&quot; OR 1=1 -- &quot; LIMIT 1\n\n\n\nAs my learned friend put it: congratulations, you just successfully attacked a program using mysql_real_escape_string()...\n\nThe Bad\n\nmysql_set_charset() cannot help, as this has nothing to do with character sets; nor can mysqli::real_escape_string(), since that&apos;s just a different wrapper around this same function.\n\nThe problem, if not already obvious, is that the call to mysql_real_escape_string() cannot know with which character the literal will be quoted, as that&apos;s left to the developer to decide at a later time.  So, in NO_BACKSLASH_ESCAPES mode, there is literally no way that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).\n\nThe Ugly\n\nIt gets worse.  NO_BACKSLASH_ESCAPES may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the SQL-92 specification, namely the &lt;quote symbol&gt; ::= &lt;quote&gt;&lt;quote&gt; grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly recommended as a workaround to the (long since fixed) bug that ircmaxell&apos;s post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like addslashes().\n\nAlso, the SQL mode of a new connection is set by the server according to its configuration (which a SUPER user can change at any time); thus, to be certain of the server&apos;s behaviour, you must always explicitly specify your desired mode after connecting.\n\nThe Saving Grace\n\nSo long as you always explicitly set the SQL mode not to include NO_BACKSLASH_ESCAPES, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively escape_quotes_for_mysql() will not be used, or its assumption about which quote characters require repeating will be correct.\n\nFor this reason, I recommend that anyone using NO_BACKSLASH_ESCAPES also enables ANSI_QUOTES mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be usedit merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).\n\nIn PDO, both its equivalent function PDO::quote() and its prepared statement emulator call upon mysql_handle_quoter()which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.\n\nAs of MySQL v5.7.6, this bug has been fixed.  See change log:\n\n\n  Functionality Added or Changed\n  \n  \n  Incompatible Change: A new C API function, mysql_real_escape_string_quote(), has been implemented as a replacement for mysql_real_escape_string() because the latter function can fail to properly encode characters when the NO_BACKSLASH_ESCAPES SQL mode is enabled. In this case, mysql_real_escape_string() cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. mysql_real_escape_string_quote() takes an extra argument for specifying the quoting context. For usage details, see mysql_real_escape_string_quote().\n  \n  \n    Â Note\n    \n    Applications should be modified to use mysql_real_escape_string_quote(), instead of mysql_real_escape_string(), which now fails and produces an CR_INSECURE_API_ERR error if NO_BACKSLASH_ESCAPES is enabled.\n  \n  \n  References: See also Bug #19211994.\n  \n\n\nSafe Examples\n\nTaken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):\n\nmysql_set_charset($charset);\nmysql_query(&quot;SET SQL_MODE=&apos;&apos;&quot;);\n$var = mysql_real_escape_string(&apos;&quot; OR 1=1 /*&apos;);\nmysql_query(&apos;SELECT * FROM test WHERE name = &quot;&apos;.$var.&apos;&quot; LIMIT 1&apos;);\n\n\n...because we&apos;ve explicitly selected an SQL mode that doesn&apos;t include NO_BACKSLASH_ESCAPES.\n\nmysql_set_charset($charset);\n$var = mysql_real_escape_string(&quot;&apos; OR 1=1 /*&quot;);\nmysql_query(&quot;SELECT * FROM test WHERE name = &apos;$var&apos; LIMIT 1&quot;);\n\n\n...because we&apos;re quoting our string literal with single-quotes.\n\n$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$stmt-&gt;execute([&quot;&apos; OR 1=1 /*&quot;]);\n\n\n...because PDO prepared statements are immune from this vulnerability (and ircmaxell&apos;s too, provided either that you&apos;re using PHP5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).\n\n$var  = $pdo-&gt;quote(&quot;&apos; OR 1=1 /*&quot;);\n$stmt = $pdo-&gt;query(&quot;SELECT * FROM test WHERE name = $var LIMIT 1&quot;);\n\n\n...because PDO&apos;s quote() function not only escapes the literal, but also quotes it (in single-quote &apos; characters); note that to avoid ircmaxell&apos;s bug in this case, you must be using PHP5.3.6 and have correctly set the character set in the DSN.\n\n$stmt = $mysqli-&gt;prepare(&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;);\n$param = &quot;&apos; OR 1=1 /*&quot;;\n$stmt-&gt;bind_param(&apos;s&apos;, $param);\n$stmt-&gt;execute();\n\n\n...because MySQLi prepared statements are safe.\n\nWrapping Up\n\nThus, if you:\n\n\nuse native prepared statements\n\n\nOR\n\n\nuse MySQL v5.7.6 or later\n\n\nOR\n\n\nin addition to employing one of the solutions in ircmaxell&apos;s summary, use at least one of:\n\n\nPDO;\nsingle-quoted string literals; or\nan explicitly set SQL mode that does not include NO_BACKSLASH_ESCAPES\n\n\n\n...then you should be completely safe (vulnerabilities outside the scope of string escaping aside).\n    ","url":"https://solutionschecker.com/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747#solution3","@type":"Answer","upvoteCount":0},{"text":"Well, there&apos;s nothing really that can pass through that, other than % wildcard. It could be dangerous if you were using LIKE statement as attacker could put just % as login if you don&apos;t filter that out, and would have to just bruteforce a password of any of your users.\nPeople often suggest using prepared statements to make it 100% safe, as data can&apos;t interfere with the query itself that way.\nBut for such simple queries it probably would be more efficient to do something like $login = preg_replace(&apos;/[^a-zA-Z0-9_]/&apos;, &apos;&apos;, $login);\n    ","url":"https://solutionschecker.com/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747#solution4","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747"><h1>SQL injection that gets around mysql_real_escape_string()</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Is there an SQL injection possibility even when using <code>mysql_real_escape_string()</code> function?</p>

<p>Consider this sample situation. SQL is constructed in PHP like this:</p>

<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-variable">$login</span> = mysql_real_escape_string(GetFromPost(<span class="hljs-string">'login'</span>));
<span class="hljs-variable">$password</span> = mysql_real_escape_string(GetFromPost(<span class="hljs-string">'password'</span>));

<span class="hljs-variable">$sql</span> = <span class="hljs-string">"SELECT * FROM table WHERE login='<span class="hljs-variable">$login</span>' AND password='<span class="hljs-variable">$password</span>'"</span>;
</code></pre>

<p>I have heard numerous people say to me that code like that is still dangerous and possible to hack even with <code>mysql_real_escape_string()</code> function used. But I cannot think of any possible exploit?</p>

<p>Classic injections like this:</p>

<pre class="default s-code-block"><code class="hljs language-haskell"><span class="hljs-title">aaa'</span> <span class="hljs-type">OR</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-comment">--</span>
</code></pre>

<p>do not work.</p>

<p>Do you know of any possible injection that would get through the PHP code above?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The short answer is <strong>yes, yes there is a way to get around <code>mysql_real_escape_string()</code></strong>.
#For Very OBSCURE EDGE CASES!!!</p>
<p>The long answer isn't so easy. It's based off an attack <a href="http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string" rel="noreferrer">demonstrated here</a>.</p>
<h1>The Attack</h1>
<p>So, let's start off by showing the attack...</p>
<pre class="default s-code-block"><code class="hljs language-bash">mysql_query(<span class="hljs-string">'SET NAMES gbk'</span>);
<span class="hljs-variable">$var</span> = mysql_real_escape_string(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>);
mysql_query(<span class="hljs-string">"SELECT * FROM test WHERE name = '<span class="hljs-variable">$var</span>' LIMIT 1"</span>);
</code></pre>
<p>In certain circumstances, that will return more than 1 row. Let's dissect what's going on here:</p>
<ol>
<li><p><strong>Selecting a Character Set</strong></p>
<pre class="default s-code-block"><code class="hljs language-scss"><span class="hljs-built_in">mysql_query</span>('SET NAMES gbk');
</code></pre>
<p>For this attack to work, we need the encoding that the server's expecting on the connection both to encode <code>'</code> as in ASCII i.e. <code>0x27</code> <em>and</em> to have some character whose final byte is an ASCII <code>\</code> i.e. <code>0x5c</code>.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: <code>big5</code>, <code>cp932</code>, <code>gb2312</code>, <code>gbk</code> and <code>sjis</code>.  We'll select <code>gbk</code> here.</p>
<p>Now, it's very important to note the use of <code>SET NAMES</code> here. This sets the character set <strong>ON THE SERVER</strong>. If we used the call to the C API function <code>mysql_set_charset()</code>, we'd be fine (on MySQL releases since 2006). But more on why in a minute...</p>
</li>
<li><p><strong>The Payload</strong></p>
<p>The payload we're going to use for this injection starts with the byte sequence <code>0xbf27</code>.  In <code>gbk</code>, that's an invalid multibyte character; in <code>latin1</code>, it's the string <code>Â¿'</code>.  Note that in <code>latin1</code> <strong>and</strong> <code>gbk</code>, <code>0x27</code> on its own is a literal <code>'</code> character.</p>
<p>We have chosen this payload because, if we called <code>addslashes()</code> on it, we'd insert an ASCII <code>\</code> i.e. <code>0x5c</code>, before the <code>'</code> character. So we'd wind up with <code>0xbf5c27</code>, which in <code>gbk</code> is a two character sequence: <code>0xbf5c</code> followed by <code>0x27</code>. Or in other words, a <em>valid</em> character followed by an unescaped <code>'</code>. But we're not using <code>addslashes()</code>. So on to the next step...</p>
</li>
<li><p><strong>mysql_real_escape_string()</strong></p>
<p>The C API call to <code>mysql_real_escape_string()</code> differs from <code>addslashes()</code> in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we're still using <code>latin1</code> for the connection, because we never told it otherwise. We did tell the <em>server</em> we're using <code>gbk</code>, but the <em>client</em> still thinks it's <code>latin1</code>.</p>
<p>Therefore the call to <code>mysql_real_escape_string()</code> inserts the backslash, and we have a free hanging <code>'</code> character in our "escaped" content! In fact, if we were to look at <code>$var</code> in the <code>gbk</code> character set, we'd see:</p>
<pre>' OR 1=1 /*</pre>
<p>Which is <a href="https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;oq=%E7%B8%97%27%20OR&amp;aqs=chrome..69i57&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8" rel="noreferrer">exactly what</a> the attack requires.</p>
</li>
<li><p><strong>The Query</strong></p>
<p>This part is just a formality, but here's the rendered query:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">''</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-comment">/*' LIMIT 1
</span></code></pre>
</li>
</ol>
<p>Congratulations, you just successfully attacked a program using <code>mysql_real_escape_string()</code>...</p>
<h1>The Bad</h1>
<p>It gets worse. <code>PDO</code> defaults to <em>emulating</em> prepared statements with MySQL. That means that on the client side, it basically does a sprintf through <code>mysql_real_escape_string()</code> (in the C library), which means the following will result in a successful injection:</p>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">'SET NAMES gbk'</span>);
<span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>));
</code></pre>
<p>Now, it's worth noting that you can prevent this by disabling emulated prepared statements:</p>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">setAttribute</span>(PDO::<span class="hljs-variable constant_">ATTR_EMULATE_PREPARES</span>, <span class="hljs-literal">false</span>);
</code></pre>
<p>This will <em>usually</em> result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently <a href="https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210" rel="noreferrer">fallback</a> to emulating statements that MySQL can't prepare natively: those that it can are <a href="https://dev.mysql.com/doc/en/sql-prepared-statements.html#prepared-statements-permitted" rel="noreferrer">listed</a> in the manual, but beware to select the appropriate server version).</p>
<h1>The Ugly</h1>
<p>I said at the very beginning that we could have prevented all of this if we had used <code>mysql_set_charset('gbk')</code> instead of <code>SET NAMES gbk</code>. And that's true provided you are using a MySQL release since 2006.</p>
<p>If you're using an earlier MySQL release, then a <a href="http://bugs.mysql.com/bug.php?id=8378" rel="noreferrer">bug</a> in <code>mysql_real_escape_string()</code> meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes <em>even if the client had been correctly informed of the connection encoding</em> and so this attack would still succeed.  The bug was fixed in MySQL <a href="http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html" rel="noreferrer">4.1.20</a>, <a href="http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html" rel="noreferrer">5.0.22</a> and <a href="http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html" rel="noreferrer">5.1.11</a>.</p>
<p>But the worst part is that <code>PDO</code> didn't expose the C API for <code>mysql_set_charset()</code> until 5.3.6, so in prior versions it <strong>cannot</strong> prevent this attack for every possible command!
It's now exposed as a <a href="http://www.php.net/manual/en/ref.pdo-mysql.connection.php" rel="noreferrer">DSN parameter</a>.</p>
<h1>The Saving Grace</h1>
<p>As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html" rel="noreferrer"><code>utf8mb4</code></a> is <em>not vulnerable</em> and yet can support <em>every</em> Unicode character: so you could elect to use that insteadbut it has only been available since MySQL 5.5.3.  An alternative is <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8.html" rel="noreferrer"><code>utf8</code></a>, which is also <em>not vulnerable</em> and can support the whole of the Unicode <a href="http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" rel="noreferrer">Basic Multilingual Plane</a>.</p>
<p>Alternatively, you can enable the <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode, which (amongst other things) alters the operation of <code>mysql_real_escape_string()</code>.  With this mode enabled, <code>0x27</code> will be replaced with <code>0x2727</code> rather than <code>0x5c27</code> and thus the escaping process <em>cannot</em> create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. <code>0xbf27</code> is still <code>0xbf27</code> etc.)so the server will still reject the string as invalid.  However, see <a href="https://stackoverflow.com/a/23277864/623041">@eggyal's answer</a> for a different vulnerability that can arise from using this SQL mode.</p>
<h1>Safe Examples</h1>
<p>The following examples are safe:</p>
<pre class="default s-code-block"><code class="hljs language-bash">mysql_query(<span class="hljs-string">'SET NAMES utf8'</span>);
<span class="hljs-variable">$var</span> = mysql_real_escape_string(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>);
mysql_query(<span class="hljs-string">"SELECT * FROM test WHERE name = '<span class="hljs-variable">$var</span>' LIMIT 1"</span>);
</code></pre>
<p>Because the server's expecting <code>utf8</code>...</p>
<pre class="default s-code-block"><code class="hljs language-bash">mysql_set_charset(<span class="hljs-string">'gbk'</span>);
<span class="hljs-variable">$var</span> = mysql_real_escape_string(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>);
mysql_query(<span class="hljs-string">"SELECT * FROM test WHERE name = '<span class="hljs-variable">$var</span>' LIMIT 1"</span>);
</code></pre>
<p>Because we've properly set the character set so the client and the server match.</p>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">setAttribute</span>(PDO::<span class="hljs-variable constant_">ATTR_EMULATE_PREPARES</span>, <span class="hljs-literal">false</span>);
<span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">'SET NAMES gbk'</span>);
<span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>));
</code></pre>
<p>Because we've turned off emulated prepared statements.</p>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$pdo</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">PDO</span>(<span class="hljs-string">'mysql:host=localhost;dbname=testdb;charset=gbk'</span>, <span class="hljs-variable">$user</span>, <span class="hljs-variable">$password</span>);
<span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>));
</code></pre>
<p>Because we've set the character set properly.</p>
<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-variable">$mysqli</span>-&gt;query(<span class="hljs-string">'SET NAMES gbk'</span>);
<span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$mysqli</span>-&gt;prepare(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$param</span> = <span class="hljs-string">"\xbf\x27 OR 1=1 /*"</span>;
<span class="hljs-variable">$stmt</span>-&gt;bind_param(<span class="hljs-string">'s'</span>, <span class="hljs-variable">$param</span>);
<span class="hljs-variable">$stmt</span>-&gt;execute();
</code></pre>
<p>Because MySQLi does true prepared statements all the time.</p>
<h1>Wrapping Up</h1>
<p>If you:</p>
<ul>
<li>Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) <strong>AND</strong> <code>mysql_set_charset()</code> / <code>$mysqli-&gt;set_charset()</code> / PDO's DSN charset parameter (in PHP  5.3.6)</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Don't use a vulnerable character set for connection encoding (you only use <code>utf8</code> / <code>latin1</code> / <code>ascii</code> / etc)</li>
</ul>
<p>You're 100% safe.</p>
<p>Otherwise, you're vulnerable <strong>even though you're using <code>mysql_real_escape_string()</code></strong>...</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider the following query:</p>

<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-variable">$iId</span> = mysql_real_escape_string(<span class="hljs-string">"1 OR 1=1"</span>);    
<span class="hljs-variable">$sSql</span> = <span class="hljs-string">"SELECT * FROM table WHERE id = <span class="hljs-variable">$iId</span>"</span>;
</code></pre>

<p><code>mysql_real_escape_string()</code> will not protect you against this.
<strong>The fact that you use single quotes (<code>' '</code>) around your variables inside your query is what protects you against this.</strong> The following is also an option:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$iId</span> = (<span class="hljs-keyword">int</span>)<span class="hljs-string">"1 OR 1=1"</span>;
<span class="hljs-variable">$sSql</span> = <span class="hljs-string">"SELECT * FROM table WHERE id = <span class="hljs-subst">$iId</span>"</span>;
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">


<blockquote>
  <h1>TL;DR</h1>
  
  <p><code>mysql_real_escape_string()</code> will <strong>provide no protection whatsoever</strong> (and could furthermore munge your data) if:</p>
  
  <ul>
  <li><p>MySQL's <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode is enabled (which it <em>might</em> be, unless you <em>explicitly</em> select another SQL mode <em>every time you connect</em>); and</p></li>
  <li><p>your SQL string literals are quoted using double-quote <code>"</code> characters.</p></li>
  </ul>
  
  <p>This was filed as <a href="http://bugs.mysql.com/bug.php?id=72458" rel="noreferrer">bug #72458</a> and has been fixed in MySQL v5.7.6 (see the section headed "<strong>The Saving Grace</strong>", below).</p>
</blockquote>

<h1>This is another, (perhaps less?) obscure EDGE CASE!!!</h1>

<p>In homage to <a href="https://stackoverflow.com/a/12118602">@ircmaxell's excellent answer</a> (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:</p>

<h2>The Attack</h2>

<p>Starting off with a demonstration...</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">'SET SQL_MODE="NO_BACKSLASH_ESCAPES"'</span>); <span class="hljs-comment">// could already be set</span>
<span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">mysql_real_escape_string</span>(<span class="hljs-string">'" OR 1=1 -- '</span>);
<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = "'</span>.<span class="hljs-variable">$var</span>.<span class="hljs-string">'" LIMIT 1'</span>);
</code></pre>

<p>This will return all records from the <code>test</code> table.  A dissection:</p>

<ol>
<li><p><strong>Selecting an SQL Mode</strong></p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">'SET SQL_MODE="NO_BACKSLASH_ESCAPES"'</span>);
</code></pre>

<p>As documented under <a href="http://dev.mysql.com/doc/en/string-literals.html" rel="noreferrer">String Literals</a>:</p>

<blockquote>
  <p>There are several ways to include quote characters within a string:</p>
  
  <ul>
  <li><p>A <code>'</code> inside a string quoted with <code>'</code> may be written as <code>''</code>.</p></li>
  <li><p>A <code>"</code> inside a string quoted with <code>"</code> may be written as <code>""</code>.</p></li>
  <li><p>Precede the quote character by an escape character (<code>\</code>).</p></li>
  <li><p>A <code>'</code> inside a string quoted with <code>"</code> needs no special treatment and need not be doubled or escaped. In the same way, <code>"</code> inside a string quoted with <code>'</code> needs no special treatment.</p></li>
  </ul>
</blockquote>

<p>If the server's SQL mode includes <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a>, then the third of these optionswhich is the usual approach adopted by <code>mysql_real_escape_string()</code>is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one's data.</p></li>
<li><p><strong>The Payload</strong></p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-string">" OR 1=1 -- 
</span></code></pre>

<p>The payload initiates this injection quite literally with the <code>"</code> character.  No particular encoding.  No special characters.  No weird bytes.</p></li>
<li><p><strong>mysql_real_escape_string()</strong></p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">mysql_real_escape_string</span>(<span class="hljs-string">'" OR 1=1 -- '</span>);
</code></pre>

<p>Fortunately, <code>mysql_real_escape_string()</code> does check the SQL mode and adjust its behaviour accordingly.  See <a href="http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267" rel="noreferrer"><code>libmysql.c</code></a>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">ulong STDCALL
<span class="hljs-title function_">mysql_real_escape_string</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-type">char</span> *to,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *from,
             ulong length)</span>
{
  <span class="hljs-keyword">if</span> (mysql-&gt;server_status &amp; SERVER_STATUS_NO_BACKSLASH_ESCAPES)
    <span class="hljs-keyword">return</span> escape_quotes_for_mysql(mysql-&gt;charset, to, <span class="hljs-number">0</span>, from, length);
  <span class="hljs-keyword">return</span> escape_string_for_mysql(mysql-&gt;charset, to, <span class="hljs-number">0</span>, from, length);
}
</code></pre>

<p>Thus a different underlying function, <code>escape_quotes_for_mysql()</code>, is invoked if the <code>NO_BACKSLASH_ESCAPES</code> SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.</p>

<p>However, this function arbitrarily <em>assumes</em> that the string will be quoted using the single-quote <code>'</code> character.  See <a href="http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836" rel="noreferrer"><code>charset.c</code></a>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/*
  Escape apostrophes by doubling them up

// [ deletia 839-845 ]

  DESCRIPTION
    This escapes the contents of a string by doubling up any apostrophes that
    it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in
    effect on the server.

// [ deletia 852-858 ]
*/</span>

<span class="hljs-type">size_t</span> <span class="hljs-title function_">escape_quotes_for_mysql</span><span class="hljs-params">(CHARSET_INFO *charset_info,
                               <span class="hljs-type">char</span> *to, <span class="hljs-type">size_t</span> to_length,
                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *from, <span class="hljs-type">size_t</span> length)</span>
{
<span class="hljs-comment">// [ deletia 865-892 ]</span>

    <span class="hljs-keyword">if</span> (*from == <span class="hljs-string">'\''</span>)
    {
      <span class="hljs-keyword">if</span> (to + <span class="hljs-number">2</span> &gt; to_end)
      {
        overflow= TRUE;
        <span class="hljs-keyword">break</span>;
      }
      *to++= <span class="hljs-string">'\''</span>;
      *to++= <span class="hljs-string">'\''</span>;
    }
</code></pre>

<p>So, it leaves double-quote <code>"</code> characters untouched (and doubles all single-quote <code>'</code> characters) <em>irrespective of the actual character that is used to quote the literal</em>!  In our case <code>$var</code> remains exactly the same as the argument that was provided to <code>mysql_real_escape_string()</code>it's as though no escaping has taken place <em>at all</em>.</p></li>
<li><p><strong>The Query</strong></p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = "'</span>.<span class="hljs-variable">$var</span>.<span class="hljs-string">'" LIMIT 1'</span>);
</code></pre>

<p>Something of a formality, the rendered query is:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> "" <span class="hljs-keyword">OR</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-comment">-- " LIMIT 1</span>
</code></pre></li>
</ol>

<p>As my learned friend put it: congratulations, you just successfully attacked a program using <code>mysql_real_escape_string()</code>...</p>

<h2>The Bad</h2>

<p><a href="http://www.php.net/manual/en/function.mysql-set-charset.php" rel="noreferrer"><code>mysql_set_charset()</code></a> cannot help, as this has nothing to do with character sets; nor can <a href="http://www.php.net/manual/en/mysqli.real-escape-string.php" rel="noreferrer"><code>mysqli::real_escape_string()</code></a>, since that's just a different wrapper around this same function.</p>

<p>The problem, if not already obvious, is that the call to <code>mysql_real_escape_string()</code> <strong>cannot know</strong> with which character the literal will be quoted, as that's left to the developer to decide at a later time.  So, in <code>NO_BACKSLASH_ESCAPES</code> mode, there is literally <em>no way</em> that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).</p>

<h2>The Ugly</h2>

<p>It gets worse.  <code>NO_BACKSLASH_ESCAPES</code> may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" rel="noreferrer">SQL-92 specification</a>, namely the <code>&lt;quote symbol&gt; ::= &lt;quote&gt;&lt;quote&gt;</code> grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly <a href="http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html" rel="noreferrer">recommended as a workaround</a> to the (long since fixed) <a href="http://bugs.mysql.com/bug.php?id=8378" rel="noreferrer">bug</a> that ircmaxell's post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like <a href="http://www.php.net/manual/en/function.addslashes.php" rel="noreferrer"><code>addslashes()</code></a>.</p>

<p>Also, the <a href="http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting" rel="noreferrer">SQL mode of a new connection</a> is set by the server according to its configuration (which a <code>SUPER</code> user can change at any time); thus, to be certain of the server's behaviour, you must <em>always</em> explicitly specify your desired mode after connecting.</p>

<h2>The Saving Grace</h2>

<p>So long as you always <em>explicitly</em> set the SQL mode not to include <code>NO_BACKSLASH_ESCAPES</code>, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively <code>escape_quotes_for_mysql()</code> will not be used, or its assumption about which quote characters require repeating will be correct.</p>

<p>For this reason, I recommend that anyone using <code>NO_BACKSLASH_ESCAPES</code> also enables <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes" rel="noreferrer"><code>ANSI_QUOTES</code></a> mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be usedit merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).</p>

<p>In PDO, both its equivalent function <a href="http://www.php.net/manual/en/pdo.quote.php" rel="noreferrer"><code>PDO::quote()</code></a> and its prepared statement emulator call upon <a href="https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302" rel="noreferrer"><code>mysql_handle_quoter()</code></a>which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.</p>

<p>As of MySQL v5.7.6, this bug has been fixed.  See <a href="http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html" rel="noreferrer">change log</a>:</p>

<blockquote>
  <h3>Functionality Added or Changed</h3>
  
  <ul>
  <li><p><strong><em>Incompatible Change:</em></strong> A new C API function, <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html" rel="noreferrer"><code>mysql_real_escape_string_quote()</code></a>, has been implemented as a replacement for <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html" rel="noreferrer"><code>mysql_real_escape_string()</code></a> because the latter function can fail to properly encode characters when the <a href="http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode is enabled. In this case, <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html" rel="noreferrer"><code>mysql_real_escape_string()</code></a> cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html" rel="noreferrer"><code>mysql_real_escape_string_quote()</code></a> takes an extra argument for specifying the quoting context. For usage details, see <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html" rel="noreferrer">mysql_real_escape_string_quote()</a>.</p>
  
  <blockquote>
    <h3>&nbsp;Note</h3>
    
    <p>Applications should be modified to use <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html" rel="noreferrer"><code>mysql_real_escape_string_quote()</code></a>, instead of <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html" rel="noreferrer"><code>mysql_real_escape_string()</code></a>, which now fails and produces an <a href="http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err" rel="noreferrer"><code>CR_INSECURE_API_ERR</code></a> error if <a href="http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a> is enabled.</p>
  </blockquote>
  
  <p>References: See also Bug #19211994.</p></li>
  </ul>
</blockquote>

<h2>Safe Examples</h2>

<p>Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-title function_ invoke__">mysql_set_charset</span>(<span class="hljs-variable">$charset</span>);
<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">"SET SQL_MODE=''"</span>);
<span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">mysql_real_escape_string</span>(<span class="hljs-string">'" OR 1=1 /*'</span>);
<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = "'</span>.<span class="hljs-variable">$var</span>.<span class="hljs-string">'" LIMIT 1'</span>);
</code></pre>

<p>...because we've explicitly selected an SQL mode that doesn't include <code>NO_BACKSLASH_ESCAPES</code>.</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-title function_ invoke__">mysql_set_charset</span>(<span class="hljs-variable">$charset</span>);
<span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">mysql_real_escape_string</span>(<span class="hljs-string">"' OR 1=1 /*"</span>);
<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">"SELECT * FROM test WHERE name = '<span class="hljs-subst">$var</span>' LIMIT 1"</span>);
</code></pre>

<p>...because we're quoting our string literal with single-quotes.</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>([<span class="hljs-string">"' OR 1=1 /*"</span>]);
</code></pre>

<p>...because PDO prepared statements are immune from this vulnerability (and ircmaxell's too, provided either that you're using PHP5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$var</span>  = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">quote</span>(<span class="hljs-string">"' OR 1=1 /*"</span>);
<span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM test WHERE name = <span class="hljs-subst">$var</span> LIMIT 1"</span>);
</code></pre>

<p>...because PDO's <code>quote()</code> function not only escapes the literal, but also quotes it (in single-quote <code>'</code> characters); note that to avoid ircmaxell's bug in this case, you <em>must</em> be using PHP5.3.6 <em>and</em> have correctly set the character set in the DSN.</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">'SELECT * FROM test WHERE name = ? LIMIT 1'</span>);
<span class="hljs-variable">$param</span> = <span class="hljs-string">"' OR 1=1 /*"</span>;
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">bind_param</span>(<span class="hljs-string">'s'</span>, <span class="hljs-variable">$param</span>);
<span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>();
</code></pre>

<p>...because MySQLi prepared statements are safe.</p>

<h2>Wrapping Up</h2>

<p>Thus, if you:</p>

<ul>
<li>use native prepared statements</li>
</ul>

<p><strong>OR</strong></p>

<ul>
<li>use MySQL v5.7.6 or later</li>
</ul>

<p><strong>OR</strong></p>

<ul>
<li><p>in <em>addition</em> to employing one of the solutions in ircmaxell's summary, use at least one of:</p>

<ul>
<li>PDO;</li>
<li>single-quoted string literals; or</li>
<li>an explicitly set SQL mode that does not include <code>NO_BACKSLASH_ESCAPES</code></li>
</ul></li>
</ul>

<p>...then you <em>should</em> be completely safe (vulnerabilities outside the scope of string escaping aside).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, there's nothing really that can pass through that, other than <code>%</code> wildcard. It could be dangerous if you were using <code>LIKE</code> statement as attacker could put just <code>%</code> as login if you don't filter that out, and would have to just bruteforce a password of any of your users.
People often suggest using prepared statements to make it 100% safe, as data can't interfere with the query itself that way.
But for such simple queries it probably would be more efficient to do something like <code>$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);</code></p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-not-use-double-or-float-to-represent-currency-1657387417964">Why not use Double or Float to represent currency?</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909">How do I set a variable to the output of a command in Bash?</a><a href="/questions/what-is-selenium-and-what-is-webdriver-1657385470372">What Is Selenium And What Is WebDriver?</a><a href="/questions/dynamic-tabs-with-user-click-chosen-components-1657388465232">Dynamic tabs with user-click chosen components</a><a href="/questions/in-css-flexbox-why-are-there-no-%22justify-items%22-and-%22justify-self%22-properties-1657384782711">In CSS Flexbox, why are there no &quot;justify-items&quot; and &quot;justify-self&quot; properties?</a><a href="/questions/sort-array-of-objects-by-string-property-value-1657384860090">Sort array of objects by string property value</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248">UnboundLocalError on local variable when reassigned after first use</a><a href="/questions/scanf()-leaves-the-newline-character-in-the-buffer-1657384699202">scanf() leaves the newline character in the buffer</a><a href="/questions/open-a-url-in-a-new-tab-(and-not-a-new-window)-1657387699598">Open a URL in a new tab (and not a new window)</a><a href="/questions/how-to-extract-and-access-data-from-json-with-php-1657384483259">How to extract and access data from JSON with PHP?</a><a href="/questions/what-are-metaclasses-in-python-1657387811608">What are metaclasses in Python?</a><a href="/questions/what-is-the-difference-between-include-lessfilenamegreater-and-include-%22filename%22-1657388489547">What is the difference between #include &lt;filename&gt; and #include &quot;filename&quot;?</a><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a><a href="/questions/error-in-finding-last-used-cell-in-excel-with-vba-1657384584748">Error in finding last used cell in Excel with VBA</a><a href="/questions/what-is-pecs-(producer-extends-consumer-super)-1657384828870">What is PECS (Producer Extends Consumer Super)?</a><a href="/questions/sorting-object-property-by-values-1657388367300">Sorting object property by values</a><a href="/questions/is-there-a-regexp.escape-function-in-javascript-1657387606651">Is there a RegExp.escape function in JavaScript?</a><a href="/questions/commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519">commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The short answer is \u0026lt;strong\u0026gt;yes, yes there is a way to get around \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.\n#For Very OBSCURE EDGE CASES!!!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The long answer isn\u0026apos;t so easy. It\u0026apos;s based off an attack \u0026lt;a href=\u0026quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;demonstrated here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The Attack\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;So, let\u0026apos;s start off by showing the attack...\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;mysql_query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET NAMES gbk\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = mysql_real_escape_string(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;);\nmysql_query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM test WHERE name = \u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;\u0026apos; LIMIT 1\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In certain circumstances, that will return more than 1 row. Let\u0026apos;s dissect what\u0026apos;s going on here:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Selecting a Character Set\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026apos;SET NAMES gbk\u0026apos;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For this attack to work, we need the encoding that the server\u0026apos;s expecting on the connection both to encode \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; as in ASCII i.e. \u0026lt;code\u0026gt;0x27\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; to have some character whose final byte is an ASCII \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt; i.e. \u0026lt;code\u0026gt;0x5c\u0026lt;/code\u0026gt;.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: \u0026lt;code\u0026gt;big5\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;cp932\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gb2312\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;sjis\u0026lt;/code\u0026gt;.  We\u0026apos;ll select \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt; here.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, it\u0026apos;s very important to note the use of \u0026lt;code\u0026gt;SET NAMES\u0026lt;/code\u0026gt; here. This sets the character set \u0026lt;strong\u0026gt;ON THE SERVER\u0026lt;/strong\u0026gt;. If we used the call to the C API function \u0026lt;code\u0026gt;mysql_set_charset()\u0026lt;/code\u0026gt;, we\u0026apos;d be fine (on MySQL releases since 2006). But more on why in a minute...\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The Payload\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The payload we\u0026apos;re going to use for this injection starts with the byte sequence \u0026lt;code\u0026gt;0xbf27\u0026lt;/code\u0026gt;.  In \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt;, that\u0026apos;s an invalid multibyte character; in \u0026lt;code\u0026gt;latin1\u0026lt;/code\u0026gt;, it\u0026apos;s the string \u0026lt;code\u0026gt;Â¿\u0026apos;\u0026lt;/code\u0026gt;.  Note that in \u0026lt;code\u0026gt;latin1\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;and\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;0x27\u0026lt;/code\u0026gt; on its own is a literal \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; character.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We have chosen this payload because, if we called \u0026lt;code\u0026gt;addslashes()\u0026lt;/code\u0026gt; on it, we\u0026apos;d insert an ASCII \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt; i.e. \u0026lt;code\u0026gt;0x5c\u0026lt;/code\u0026gt;, before the \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; character. So we\u0026apos;d wind up with \u0026lt;code\u0026gt;0xbf5c27\u0026lt;/code\u0026gt;, which in \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt; is a two character sequence: \u0026lt;code\u0026gt;0xbf5c\u0026lt;/code\u0026gt; followed by \u0026lt;code\u0026gt;0x27\u0026lt;/code\u0026gt;. Or in other words, a \u0026lt;em\u0026gt;valid\u0026lt;/em\u0026gt; character followed by an unescaped \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt;. But we\u0026apos;re not using \u0026lt;code\u0026gt;addslashes()\u0026lt;/code\u0026gt;. So on to the next step...\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;mysql_real_escape_string()\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The C API call to \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; differs from \u0026lt;code\u0026gt;addslashes()\u0026lt;/code\u0026gt; in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we\u0026apos;re still using \u0026lt;code\u0026gt;latin1\u0026lt;/code\u0026gt; for the connection, because we never told it otherwise. We did tell the \u0026lt;em\u0026gt;server\u0026lt;/em\u0026gt; we\u0026apos;re using \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt;, but the \u0026lt;em\u0026gt;client\u0026lt;/em\u0026gt; still thinks it\u0026apos;s \u0026lt;code\u0026gt;latin1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Therefore the call to \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; inserts the backslash, and we have a free hanging \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; character in our \u0026quot;escaped\u0026quot; content! In fact, if we were to look at \u0026lt;code\u0026gt;$var\u0026lt;/code\u0026gt; in the \u0026lt;code\u0026gt;gbk\u0026lt;/code\u0026gt; character set, we\u0026apos;d see:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026apos; OR 1=1 /*\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Which is \u0026lt;a href=\u0026quot;https://www.google.com/search?q=%E7%B8%97%27%20OR\u0026amp;amp;oq=%E7%B8%97%27%20OR\u0026amp;amp;aqs=chrome..69i57\u0026amp;amp;sourceid=chrome\u0026amp;amp;es_sm=122\u0026amp;amp;ie=UTF-8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;exactly what\u0026lt;/a\u0026gt; the attack requires.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The Query\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This part is just a formality, but here\u0026apos;s the rendered query:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; test \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OR\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\u0026apos; LIMIT 1\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Congratulations, you just successfully attacked a program using \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;...\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The Bad\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;It gets worse. \u0026lt;code\u0026gt;PDO\u0026lt;/code\u0026gt; defaults to \u0026lt;em\u0026gt;emulating\u0026lt;/em\u0026gt; prepared statements with MySQL. That means that on the client side, it basically does a sprintf through \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; (in the C library), which means the following will result in a successful injection:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET NAMES gbk\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;execute\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, it\u0026apos;s worth noting that you can prevent this by disabling emulated prepared statements:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;setAttribute\u0026lt;/span\u0026gt;(PDO::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;ATTR_EMULATE_PREPARES\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will \u0026lt;em\u0026gt;usually\u0026lt;/em\u0026gt; result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently \u0026lt;a href=\u0026quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;fallback\u0026lt;/a\u0026gt; to emulating statements that MySQL can\u0026apos;t prepare natively: those that it can are \u0026lt;a href=\u0026quot;https://dev.mysql.com/doc/en/sql-prepared-statements.html#prepared-statements-permitted\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;listed\u0026lt;/a\u0026gt; in the manual, but beware to select the appropriate server version).\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The Ugly\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;I said at the very beginning that we could have prevented all of this if we had used \u0026lt;code\u0026gt;mysql_set_charset(\u0026apos;gbk\u0026apos;)\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;SET NAMES gbk\u0026lt;/code\u0026gt;. And that\u0026apos;s true provided you are using a MySQL release since 2006.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you\u0026apos;re using an earlier MySQL release, then a \u0026lt;a href=\u0026quot;http://bugs.mysql.com/bug.php?id=8378\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;bug\u0026lt;/a\u0026gt; in \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes \u0026lt;em\u0026gt;even if the client had been correctly informed of the connection encoding\u0026lt;/em\u0026gt; and so this attack would still succeed.  The bug was fixed in MySQL \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;4.1.20\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;5.0.22\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;5.1.11\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But the worst part is that \u0026lt;code\u0026gt;PDO\u0026lt;/code\u0026gt; didn\u0026apos;t expose the C API for \u0026lt;code\u0026gt;mysql_set_charset()\u0026lt;/code\u0026gt; until 5.3.6, so in prior versions it \u0026lt;strong\u0026gt;cannot\u0026lt;/strong\u0026gt; prevent this attack for every possible command!\nIt\u0026apos;s now exposed as a \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DSN parameter\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The Saving Grace\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;utf8mb4\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is \u0026lt;em\u0026gt;not vulnerable\u0026lt;/em\u0026gt; and yet can support \u0026lt;em\u0026gt;every\u0026lt;/em\u0026gt; Unicode character: so you could elect to use that insteadbut it has only been available since MySQL 5.5.3.  An alternative is \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;utf8\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which is also \u0026lt;em\u0026gt;not vulnerable\u0026lt;/em\u0026gt; and can support the whole of the Unicode \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Basic Multilingual Plane\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, you can enable the \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; SQL mode, which (amongst other things) alters the operation of \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;.  With this mode enabled, \u0026lt;code\u0026gt;0x27\u0026lt;/code\u0026gt; will be replaced with \u0026lt;code\u0026gt;0x2727\u0026lt;/code\u0026gt; rather than \u0026lt;code\u0026gt;0x5c27\u0026lt;/code\u0026gt; and thus the escaping process \u0026lt;em\u0026gt;cannot\u0026lt;/em\u0026gt; create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. \u0026lt;code\u0026gt;0xbf27\u0026lt;/code\u0026gt; is still \u0026lt;code\u0026gt;0xbf27\u0026lt;/code\u0026gt; etc.)so the server will still reject the string as invalid.  However, see \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/23277864/623041\u0026quot;\u0026gt;@eggyal\u0026apos;s answer\u0026lt;/a\u0026gt; for a different vulnerability that can arise from using this SQL mode.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Safe Examples\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;The following examples are safe:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;mysql_query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET NAMES utf8\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = mysql_real_escape_string(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;);\nmysql_query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM test WHERE name = \u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;\u0026apos; LIMIT 1\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because the server\u0026apos;s expecting \u0026lt;code\u0026gt;utf8\u0026lt;/code\u0026gt;...\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;mysql_set_charset(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;gbk\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = mysql_real_escape_string(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;);\nmysql_query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM test WHERE name = \u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;\u0026apos; LIMIT 1\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because we\u0026apos;ve properly set the character set so the client and the server match.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;setAttribute\u0026lt;/span\u0026gt;(PDO::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;ATTR_EMULATE_PREPARES\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET NAMES gbk\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;execute\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because we\u0026apos;ve turned off emulated prepared statements.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;PDO\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;mysql:host=localhost;dbname=testdb;charset=gbk\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$user\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;execute\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because we\u0026apos;ve set the character set properly.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$mysqli\u0026lt;/span\u0026gt;-\u0026amp;gt;query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET NAMES gbk\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$mysqli\u0026lt;/span\u0026gt;-\u0026amp;gt;prepare(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$param\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xbf\\x27 OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;bind_param(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$param\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;execute();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because MySQLi does true prepared statements all the time.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Wrapping Up\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;If you:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) \u0026lt;strong\u0026gt;AND\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;mysql_set_charset()\u0026lt;/code\u0026gt; / \u0026lt;code\u0026gt;$mysqli-\u0026amp;gt;set_charset()\u0026lt;/code\u0026gt; / PDO\u0026apos;s DSN charset parameter (in PHP  5.3.6)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t use a vulnerable character set for connection encoding (you only use \u0026lt;code\u0026gt;utf8\u0026lt;/code\u0026gt; / \u0026lt;code\u0026gt;latin1\u0026lt;/code\u0026gt; / \u0026lt;code\u0026gt;ascii\u0026lt;/code\u0026gt; / etc)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;You\u0026apos;re 100% safe.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Otherwise, you\u0026apos;re vulnerable \u0026lt;strong\u0026gt;even though you\u0026apos;re using \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider the following query:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$iId\u0026lt;/span\u0026gt; = mysql_real_escape_string(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1 OR 1=1\u0026quot;\u0026lt;/span\u0026gt;);    \n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sSql\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM table WHERE id = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$iId\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; will not protect you against this.\n\u0026lt;strong\u0026gt;The fact that you use single quotes (\u0026lt;code\u0026gt;\u0026apos; \u0026apos;\u0026lt;/code\u0026gt;) around your variables inside your query is what protects you against this.\u0026lt;/strong\u0026gt; The following is also an option:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$iId\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1 OR 1=1\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sSql\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM table WHERE id = \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;$iId\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h1\u0026gt;TL;DR\u0026lt;/h1\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; will \u0026lt;strong\u0026gt;provide no protection whatsoever\u0026lt;/strong\u0026gt; (and could furthermore munge your data) if:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;MySQL\u0026apos;s \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; SQL mode is enabled (which it \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; be, unless you \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt; select another SQL mode \u0026lt;em\u0026gt;every time you connect\u0026lt;/em\u0026gt;); and\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;your SQL string literals are quoted using double-quote \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; characters.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;This was filed as \u0026lt;a href=\u0026quot;http://bugs.mysql.com/bug.php?id=72458\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;bug #72458\u0026lt;/a\u0026gt; and has been fixed in MySQL v5.7.6 (see the section headed \u0026quot;\u0026lt;strong\u0026gt;The Saving Grace\u0026lt;/strong\u0026gt;\u0026quot;, below).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h1\u0026gt;This is another, (perhaps less?) obscure EDGE CASE!!!\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;In homage to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/12118602\u0026quot;\u0026gt;@ircmaxell\u0026apos;s excellent answer\u0026lt;/a\u0026gt; (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The Attack\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Starting off with a demonstration...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET SQL_MODE=\u0026quot;NO_BACKSLASH_ESCAPES\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// could already be set\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_real_escape_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; OR 1=1 -- \u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = \u0026quot;\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will return all records from the \u0026lt;code\u0026gt;test\u0026lt;/code\u0026gt; table.  A dissection:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Selecting an SQL Mode\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SET SQL_MODE=\u0026quot;NO_BACKSLASH_ESCAPES\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As documented under \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/string-literals.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;String Literals\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;There are several ways to include quote characters within a string:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; inside a string quoted with \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; may be written as \u0026lt;code\u0026gt;\u0026apos;\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; inside a string quoted with \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; may be written as \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Precede the quote character by an escape character (\u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; inside a string quoted with \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; needs no special treatment and need not be doubled or escaped. In the same way, \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; inside a string quoted with \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; needs no special treatment.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;If the server\u0026apos;s SQL mode includes \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, then the third of these optionswhich is the usual approach adopted by \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one\u0026apos;s data.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The Payload\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; OR 1=1 -- \n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The payload initiates this injection quite literally with the \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; character.  No particular encoding.  No special characters.  No weird bytes.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;mysql_real_escape_string()\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_real_escape_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; OR 1=1 -- \u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Fortunately, \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; does check the SQL mode and adjust its behaviour accordingly.  See \u0026lt;a href=\u0026quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;libmysql.c\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ulong STDCALL\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;mysql_real_escape_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(MYSQL *mysql, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *to,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *from,\n             ulong length)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (mysql-\u0026amp;gt;server_status \u0026amp;amp; SERVER_STATUS_NO_BACKSLASH_ESCAPES)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; escape_quotes_for_mysql(mysql-\u0026amp;gt;charset, to, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, from, length);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; escape_string_for_mysql(mysql-\u0026amp;gt;charset, to, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, from, length);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thus a different underlying function, \u0026lt;code\u0026gt;escape_quotes_for_mysql()\u0026lt;/code\u0026gt;, is invoked if the \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt; SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, this function arbitrarily \u0026lt;em\u0026gt;assumes\u0026lt;/em\u0026gt; that the string will be quoted using the single-quote \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; character.  See \u0026lt;a href=\u0026quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;charset.c\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n  Escape apostrophes by doubling them up\n\n// [ deletia 839-845 ]\n\n  DESCRIPTION\n    This escapes the contents of a string by doubling up any apostrophes that\n    it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in\n    effect on the server.\n\n// [ deletia 852-858 ]\n*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;escape_quotes_for_mysql\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(CHARSET_INFO *charset_info,\n                               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *to, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; to_length,\n                               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *from, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; length)\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [ deletia 865-892 ]\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*from == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;)\n    {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (to + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026amp;gt; to_end)\n      {\n        overflow= TRUE;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n      }\n      *to++= \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;;\n      *to++= \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, it leaves double-quote \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; characters untouched (and doubles all single-quote \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; characters) \u0026lt;em\u0026gt;irrespective of the actual character that is used to quote the literal\u0026lt;/em\u0026gt;!  In our case \u0026lt;code\u0026gt;$var\u0026lt;/code\u0026gt; remains exactly the same as the argument that was provided to \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;it\u0026apos;s as though no escaping has taken place \u0026lt;em\u0026gt;at all\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The Query\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = \u0026quot;\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Something of a formality, the rendered query is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; test \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026quot;\u0026quot; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OR\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026quot; LIMIT 1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;As my learned friend put it: congratulations, you just successfully attacked a program using \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;...\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The Bad\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.php.net/manual/en/function.mysql-set-charset.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_set_charset()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; cannot help, as this has nothing to do with character sets; nor can \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/mysqli.real-escape-string.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysqli::real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, since that\u0026apos;s just a different wrapper around this same function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem, if not already obvious, is that the call to \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;cannot know\u0026lt;/strong\u0026gt; with which character the literal will be quoted, as that\u0026apos;s left to the developer to decide at a later time.  So, in \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt; mode, there is literally \u0026lt;em\u0026gt;no way\u0026lt;/em\u0026gt; that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The Ugly\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;It gets worse.  \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt; may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the \u0026lt;a href=\u0026quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SQL-92 specification\u0026lt;/a\u0026gt;, namely the \u0026lt;code\u0026gt;\u0026amp;lt;quote symbol\u0026amp;gt; ::= \u0026amp;lt;quote\u0026amp;gt;\u0026amp;lt;quote\u0026amp;gt;\u0026lt;/code\u0026gt; grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;recommended as a workaround\u0026lt;/a\u0026gt; to the (long since fixed) \u0026lt;a href=\u0026quot;http://bugs.mysql.com/bug.php?id=8378\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;bug\u0026lt;/a\u0026gt; that ircmaxell\u0026apos;s post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/function.addslashes.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;addslashes()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, the \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SQL mode of a new connection\u0026lt;/a\u0026gt; is set by the server according to its configuration (which a \u0026lt;code\u0026gt;SUPER\u0026lt;/code\u0026gt; user can change at any time); thus, to be certain of the server\u0026apos;s behaviour, you must \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; explicitly specify your desired mode after connecting.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The Saving Grace\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;So long as you always \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt; set the SQL mode not to include \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively \u0026lt;code\u0026gt;escape_quotes_for_mysql()\u0026lt;/code\u0026gt; will not be used, or its assumption about which quote characters require repeating will be correct.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For this reason, I recommend that anyone using \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt; also enables \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ANSI_QUOTES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be usedit merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In PDO, both its equivalent function \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/pdo.quote.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;PDO::quote()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and its prepared statement emulator call upon \u0026lt;a href=\u0026quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_handle_quoter()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As of MySQL v5.7.6, this bug has been fixed.  See \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;change log\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;Functionality Added or Changed\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Incompatible Change:\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; A new C API function, \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string_quote()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, has been implemented as a replacement for \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; because the latter function can fail to properly encode characters when the \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; SQL mode is enabled. In this case, \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string_quote()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; takes an extra argument for specifying the quoting context. For usage details, see \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;mysql_real_escape_string_quote()\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;blockquote\u0026gt;\n    \u0026lt;h3\u0026gt;\u0026amp;nbsp;Note\u0026lt;/h3\u0026gt;\n    \n    \u0026lt;p\u0026gt;Applications should be modified to use \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string_quote()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, instead of \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which now fails and produces an \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;CR_INSECURE_API_ERR\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; error if \u0026lt;a href=\u0026quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is enabled.\u0026lt;/p\u0026gt;\n  \u0026lt;/blockquote\u0026gt;\n  \n  \u0026lt;p\u0026gt;References: See also Bug #19211994.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Safe Examples\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_set_charset\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$charset\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SET SQL_MODE=\u0026apos;\u0026apos;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_real_escape_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; OR 1=1 /*\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = \u0026quot;\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...because we\u0026apos;ve explicitly selected an SQL mode that doesn\u0026apos;t include \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_set_charset\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$charset\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_real_escape_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mysql_query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM test WHERE name = \u0026apos;\u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;\u0026apos; LIMIT 1\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...because we\u0026apos;re quoting our string literal with single-quotes.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;execute\u0026lt;/span\u0026gt;([\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...because PDO prepared statements are immune from this vulnerability (and ircmaxell\u0026apos;s too, provided either that you\u0026apos;re using PHP5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt;  = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;quote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pdo\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM test WHERE name = \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;$var\u0026lt;/span\u0026gt; LIMIT 1\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...because PDO\u0026apos;s \u0026lt;code\u0026gt;quote()\u0026lt;/code\u0026gt; function not only escapes the literal, but also quotes it (in single-quote \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt; characters); note that to avoid ircmaxell\u0026apos;s bug in this case, you \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; be using PHP5.3.6 \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; have correctly set the character set in the DSN.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$mysqli\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SELECT * FROM test WHERE name = ? LIMIT 1\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$param\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; OR 1=1 /*\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;bind_param\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$param\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$stmt\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;execute\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...because MySQLi prepared statements are safe.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Wrapping Up\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Thus, if you:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;use native prepared statements\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;use MySQL v5.7.6 or later\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;in \u0026lt;em\u0026gt;addition\u0026lt;/em\u0026gt; to employing one of the solutions in ircmaxell\u0026apos;s summary, use at least one of:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;PDO;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;single-quoted string literals; or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;an explicitly set SQL mode that does not include \u0026lt;code\u0026gt;NO_BACKSLASH_ESCAPES\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;...then you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; be completely safe (vulnerabilities outside the scope of string escaping aside).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, there\u0026apos;s nothing really that can pass through that, other than \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; wildcard. It could be dangerous if you were using \u0026lt;code\u0026gt;LIKE\u0026lt;/code\u0026gt; statement as attacker could put just \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; as login if you don\u0026apos;t filter that out, and would have to just bruteforce a password of any of your users.\nPeople often suggest using prepared statements to make it 100% safe, as data can\u0026apos;t interfere with the query itself that way.\nBut for such simple queries it probably would be more efficient to do something like \u0026lt;code\u0026gt;$login = preg_replace(\u0026apos;/[^a-zA-Z0-9_]/\u0026apos;, \u0026apos;\u0026apos;, $login);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":38,"title":"SQL injection that gets around mysql_real_escape_string()","content":"\n                \n\u0026lt;p\u0026gt;Is there an SQL injection possibility even when using \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; function?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this sample situation. SQL is constructed in PHP like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$login\u0026lt;/span\u0026gt; = mysql_real_escape_string(GetFromPost(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;login\u0026apos;\u0026lt;/span\u0026gt;));\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt; = mysql_real_escape_string(GetFromPost(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;password\u0026apos;\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sql\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SELECT * FROM table WHERE login=\u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$login\u0026lt;/span\u0026gt;\u0026apos; AND password=\u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;\u0026apos;\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I have heard numerous people say to me that code like that is still dangerous and possible to hack even with \u0026lt;code\u0026gt;mysql_real_escape_string()\u0026lt;/code\u0026gt; function used. But I cannot think of any possible exploit?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Classic injections like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-haskell\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;aaa\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;OR\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;do not work.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Do you know of any possible injection that would get through the PHP code above?\u0026lt;/p\u0026gt;\n    ","slug":"sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747","postType":"QUESTION","createdAt":"2022-07-09T16:32:44.000Z","updatedAt":"2022-07-09T16:32:44.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why not use Double or Float to represent currency?","slug":"why-not-use-double-or-float-to-represent-currency-1657387417964"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"How do I set a variable to the output of a command in Bash?","slug":"how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909"},{"title":"What Is Selenium And What Is WebDriver?","slug":"what-is-selenium-and-what-is-webdriver-1657385470372"},{"title":"Dynamic tabs with user-click chosen components","slug":"dynamic-tabs-with-user-click-chosen-components-1657388465232"},{"title":"In CSS Flexbox, why are there no \"justify-items\" and \"justify-self\" properties?","slug":"in-css-flexbox-why-are-there-no-\"justify-items\"-and-\"justify-self\"-properties-1657384782711"},{"title":"Sort array of objects by string property value","slug":"sort-array-of-objects-by-string-property-value-1657384860090"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"UnboundLocalError on local variable when reassigned after first use","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},{"title":"scanf() leaves the newline character in the buffer","slug":"scanf()-leaves-the-newline-character-in-the-buffer-1657384699202"},{"title":"Open a URL in a new tab (and not a new window)","slug":"open-a-url-in-a-new-tab-(and-not-a-new-window)-1657387699598"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"What is the difference between #include \u003cfilename\u003e and #include \"filename\"?","slug":"what-is-the-difference-between-include-lessfilenamegreater-and-include-\"filename\"-1657388489547"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"Error in finding last used cell in Excel with VBA","slug":"error-in-finding-last-used-cell-in-excel-with-vba-1657384584748"},{"title":"What is PECS (Producer Extends Consumer Super)?","slug":"what-is-pecs-(producer-extends-consumer-super)-1657384828870"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"Is there a RegExp.escape function in JavaScript?","slug":"is-there-a-regexp.escape-function-in-javascript-1657387606651"},{"title":"commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated","slug":"commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>