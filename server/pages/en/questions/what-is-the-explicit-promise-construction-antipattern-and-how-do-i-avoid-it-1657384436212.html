<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="promise,bluebird,q,es6-promise,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212","name":"Questions"}}]}</script><title>What is the explicit promise construction antipattern and how do I avoid it? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I was writing code that does something that looks like:

function getStuffDone(param) {           | function getStuffDone(param) {
    var d = Q.defer(); /* or $q.defer */ |     return new Promise(function(resolve, reject) {
    // or = new $.Deferred() etc.        |     // using a promise constructor
    myPromiseFn(param+1)                 |         myPromiseFn(param+1)
    .then(function(val) { /* or .done */ |         .then(function(val) {
        d.resolve(val);                  |             resolve(val);
    }).catch(function(err) { /* .fail */ |         }).catch(function(err) {
        d.reject(err);                   |             reject(err);
    });                                  |         });
    return d.promise; /* or promise() */ |     });
}                                        | }


Someone told me this is called the &quot;deferred antipattern&quot; or the &quot;Promise constructor antipattern&quot; respectively, what&#x27;s bad about this code and why is this called an antipattern?
    "/><meta property="og:title" content="What is the explicit promise construction antipattern and how do I avoid it? | Solution Checker"/><meta property="og:description" content="I was writing code that does something that looks like:

function getStuffDone(param) {           | function getStuffDone(param) {
    var d = Q.defer(); /* or $q.defer */ |     return new Promise(function(resolve, reject) {
    // or = new $.Deferred() etc.        |     // using a promise constructor
    myPromiseFn(param+1)                 |         myPromiseFn(param+1)
    .then(function(val) { /* or .done */ |         .then(function(val) {
        d.resolve(val);                  |             resolve(val);
    }).catch(function(err) { /* .fail */ |         }).catch(function(err) {
        d.reject(err);                   |             reject(err);
    });                                  |         });
    return d.promise; /* or promise() */ |     });
}                                        | }


Someone told me this is called the &quot;deferred antipattern&quot; or the &quot;Promise constructor antipattern&quot; respectively, what&#x27;s bad about this code and why is this called an antipattern?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the explicit promise construction antipattern and how do I avoid it?","text":"I was writing code that does something that looks like:\n\nfunction getStuffDone(param) {           | function getStuffDone(param) {\n    var d = Q.defer(); /* or $q.defer */ |     return new Promise(function(resolve, reject) {\n    // or = new $.Deferred() etc.        |     // using a promise constructor\n    myPromiseFn(param+1)                 |         myPromiseFn(param+1)\n    .then(function(val) { /* or .done */ |         .then(function(val) {\n        d.resolve(val);                  |             resolve(val);\n    }).catch(function(err) { /* .fail */ |         }).catch(function(err) {\n        d.reject(err);                   |             reject(err);\n    });                                  |         });\n    return d.promise; /* or promise() */ |     });\n}                                        | }\n\n\nSomeone told me this is called the &quot;deferred antipattern&quot; or the &quot;Promise constructor antipattern&quot; respectively, what&apos;s bad about this code and why is this called an antipattern?\n    ","answerCount":3,"upVoteCount":500,"suggestedAnswer":[{"text":"The deferred antipattern (now explicit-construction anti-pattern) coined by Esailija is a common anti-pattern people who are new to promises make, I&apos;ve made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.\n\nPromises can chain with .then and you can return promises directly. Your code in getStuffDone can be rewritten as:\n\nfunction getStuffDone(param){\n    return myPromiseFn(param+1); // much nicer, right?\n}\n\n\nPromises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.\n\nYou should only use deferred objects when you are converting an API to promises and can&apos;t do it automatically, or when you&apos;re writing aggregation functions that are easier expressed this way. \n\nQuoting Esailija:\n\n\n  This is the most common anti-pattern. It is easy to fall into this when you don&apos;t really understand promises and think of them as glorified event emitters or callback utility. Let&apos;s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"What&apos;s wrong with it?\n\n\n  But the pattern works!\n\n\nLucky you. Unfortunately, it probably doesn&apos;t, as you likely forgot some edge case. In more than half of the occurrences I&apos;ve seen, the author has forgotten to take care of the error handler:\n\nreturn new Promise(function(resolve) {\n    getOtherPromise().then(function(result) {\n        resolve(result.property.example);\n    });\n})\n\n\nIf the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.\n\nThe same thing happens in the case that your callback code causes an error - e.g. when result doesn&apos;t have a property and an exception is thrown. That would go unhandled and leave the new promise unresolved. \n\nIn contrast, using .then() does automatically take care of both these scenarios, and rejects the new promise when an error happens:\n\n return getOtherPromise().then(function(result) {\n     return result.property.example;\n })\n\n\nThe deferred antipattern is not only cumbersome, but also error-prone. Using .then() for chaining is much safer.\n\n\n  But I&apos;ve handled everything!\n\n\nReally? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won&apos;t want to rewrite your code for that.\n\nThe libraries&apos; methods (then) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.\n\nHow do I avoid it?\n\nSo whenever you find yourself manually creating a Promise or Deferred and already existing promises are involved, check the library API first. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but promises are more than callbacks: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don&apos;t want to deal with.\n\nIf you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Now 7 years later there is a simpler answer to this question:\nHow do I avoid the explicit constructor antipattern?\nUse async functions, then await every Promise!\nInstead of manually constructing nested Promise chains such as this one:\nfunction promised() {\n  return new Promise(function(resolve) {\n    getOtherPromise().then(function(result) {\n      getAnotherPromise(result).then(function(result2) {\n        resolve(result2);\n      });\n    });\n  });\n}\n\njust turn your function async and use the await keyword to stop execution of the function until the Promise resolves:\nasync function promised() {\n   const result =  await getOtherPromise();\n   const result2 = await getAnotherPromise(result);\n   return result2;\n}\n\nThis has various benefits:\n\nCalling the async function always returns a Promise, which resolves with the returned value and rejects if an error get&apos;s thrown inside the async function\nIf an awaited Promise rejects, the error get&apos;s thrown inside the async function, so you can just try { ... } catch(error) { ... } it like the synchronous errors.\nYou can await inside loops and if branches, making most of the Promise chain logic trivial\nAlthough async functions behave mostly like chains of Promises, they are way easier to read (and easier to reason about)\n\nHow can I await a callback?\nIf the callback only calls back once, and the API you are calling does not provide a Promise already (most of them do!) this is the only reason to use a Promise constructor:\n // Create a wrapper around the &quot;old&quot; function taking a callback, passing the &apos;resolve&apos; function as callback\n const delay = time =&gt; new Promise((resolve, reject) =&gt;\n   setTimeout(resolve, time)\n ); \n\n await delay(1000);\n\nIf await stops execution, does calling an async function return the result directly?\nNo. If you call an async function, a Promise gets always returned. You can then await that Promise too inside an async function. You cannot wait for the result inside of a synchronous function (you would have to call .then and attach a callback).\nConceptually, synchronous functions always run to completion in one job, while async functions run synchronously till they reach an await, then they continue in another job.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"><h1>What is the explicit promise construction antipattern and how do I avoid it?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/promise">promise</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/bluebird">bluebird</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/q">q</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/es6-promise">es6-promise</a></div></div><div class="question-content mt-5">
                
<p>I was writing code that does something that looks like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getStuffDone</span>(<span class="hljs-params">param</span>) {           | <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStuffDone</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">var</span> d = Q.<span class="hljs-title function_">defer</span>(); <span class="hljs-comment">/* or $q.defer */</span> |     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-comment">// or = new $.Deferred() etc.        |     // using a promise constructor</span>
    <span class="hljs-title function_">myPromiseFn</span>(param+<span class="hljs-number">1</span>)                 |         <span class="hljs-title function_">myPromiseFn</span>(param+<span class="hljs-number">1</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) { <span class="hljs-comment">/* or .done */</span> |         .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
        d.<span class="hljs-title function_">resolve</span>(val);                  |             <span class="hljs-title function_">resolve</span>(val);
    }).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) { <span class="hljs-comment">/* .fail */</span> |         }).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) {
        d.<span class="hljs-title function_">reject</span>(err);                   |             <span class="hljs-title function_">reject</span>(err);
    });                                  |         });
    <span class="hljs-keyword">return</span> d.<span class="hljs-property">promise</span>; <span class="hljs-comment">/* or promise() */</span> |     });
}                                        | }
</code></pre>

<p>Someone told me this is called the "<strong>deferred antipattern</strong>" or the "<strong><code>Promise</code> constructor antipattern</strong>" respectively, what's bad about this code and why is this called an <a href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noreferrer">antipattern</a>?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/promise">promise</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/bluebird">bluebird</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/q">q</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/es6-promise">es6-promise</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" rel="noreferrer">deferred antipattern (now explicit-construction anti-pattern)</a> coined by <a href="https://stackoverflow.com/users/995876/esailija">Esailija</a> is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</p>

<p>Promises can chain with <code>.then</code> and you can return promises directly. Your code in <code>getStuffDone</code> can be rewritten as:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getStuffDone</span>(<span class="hljs-params">param</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">myPromiseFn</span>(param+<span class="hljs-number">1</span>); <span class="hljs-comment">// much nicer, right?</span>
}
</code></pre>

<p>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</p>

<p>You should only use deferred objects when you are <a href="https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises">converting an API to promises</a> and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way. </p>

<p>Quoting Esailija:</p>

<blockquote>
  <p>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</p>
</blockquote>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/promise">promise</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/bluebird">bluebird</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/q">q</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/es6-promise">es6-promise</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>What's wrong with it?</h1>

<blockquote>
  <p>But the pattern works!</p>
</blockquote>

<p>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) {
    <span class="hljs-title function_">getOtherPromise</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
        <span class="hljs-title function_">resolve</span>(result.<span class="hljs-property">property</span>.<span class="hljs-property">example</span>);
    });
})
</code></pre>

<p>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</p>

<p>The same thing happens in the case that your callback code causes an error - e.g. when <code>result</code> doesn't have a <code>property</code> and an exception is thrown. That would go unhandled and leave the new promise unresolved. </p>

<p>In contrast, using <code>.then()</code> does automatically take care of both these scenarios, and rejects the new promise when an error happens:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-keyword">return</span> <span class="hljs-title function_">getOtherPromise</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
     <span class="hljs-keyword">return</span> result.<span class="hljs-property">property</span>.<span class="hljs-property">example</span>;
 })
</code></pre>

<p>The deferred antipattern is not only cumbersome, but also <strong>error-prone</strong>. Using <code>.then()</code> for chaining is much safer.</p>

<blockquote>
  <p>But I've handled everything!</p>
</blockquote>

<p>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</p>

<p>The libraries' methods (<code>then</code>) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</p>

<h1>How do I avoid it?</h1>

<p>So whenever you find yourself manually creating a <code>Promise</code> or <code>Deferred</code> and already existing promises are involved, <strong>check the library API first</strong>. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but <a href="https://stackoverflow.com/a/22562045/1048572">promises are <em>more</em> than callbacks</a>: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</p>

<p>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/promise">promise</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/bluebird">bluebird</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/q">q</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/es6-promise">es6-promise</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Now 7 years later there is a simpler answer to this question:</p>
<p><strong>How do I avoid the explicit constructor antipattern?</strong></p>
<p>Use <code>async function</code>s, then <code>await</code> every Promise!</p>
<p>Instead of manually constructing nested Promise chains such as this one:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promised</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) {
    <span class="hljs-title function_">getOtherPromise</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
      <span class="hljs-title function_">getAnotherPromise</span>(result).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result2</span>) {
        <span class="hljs-title function_">resolve</span>(result2);
      });
    });
  });
}
</code></pre>
<p>just turn your function <code>async</code> and use the <code>await</code> keyword to <em>stop execution of the function</em> until the Promise resolves:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">promised</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">const</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOtherPromise</span>();
   <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAnotherPromise</span>(result);
   <span class="hljs-keyword">return</span> result2;
}
</code></pre>
<p>This has various benefits:</p>
<ul>
<li>Calling the <code>async</code> function always returns a Promise, which resolves with the returned value and rejects if an error get's thrown inside the async function</li>
<li>If an <code>await</code>ed Promise rejects, the error get's thrown inside the async function, so you can just <code>try { ... } catch(error) { ... }</code> it like the synchronous errors.</li>
<li>You can <code>await</code> inside loops and if branches, making most of the Promise chain logic trivial</li>
<li>Although async functions behave mostly like chains of Promises, they are way easier to read (and easier to reason about)</li>
</ul>
<p><strong>How can I <code>await</code> a callback?</strong></p>
<p>If the callback only calls back once, and the API you are calling does not provide a Promise already (most of them do!) this is the <em>only reason</em> to use a Promise constructor:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-comment">// Create a wrapper around the "old" function taking a callback, passing the 'resolve' function as callback</span>
 <span class="hljs-keyword">const</span> <span class="hljs-title function_">delay</span> = time =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>
   <span class="hljs-built_in">setTimeout</span>(resolve, time)
 ); 

 <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);
</code></pre>
<p><strong>If <code>await</code> stops execution, does calling an <code>async function</code> return the result directly?</strong></p>
<p>No. If you call an async function, a Promise gets always returned. You can then <code>await</code> that Promise too inside an async function. You cannot wait for the result inside of a synchronous function (you would have to call <code>.then</code> and attach a callback).</p>
<p>Conceptually, synchronous <code>function</code>s always run to completion in one job, while <code>async function</code>s run synchronously till they reach an <code>await</code>, then they continue in another job.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248">UnboundLocalError on local variable when reassigned after first use</a><a href="/questions/how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725">How do I write a correct micro-benchmark in Java?</a><a href="/questions/convert-columns-into-rows-with-pandas-1657388374964">Convert columns into rows with Pandas</a><a href="/questions/how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553">How do I pass variables and data from PHP to JavaScript?</a><a href="/questions/how-should-a-model-be-structured-in-mvc-closed-1657388394807">How should a model be structured in MVC? [closed]</a><a href="/questions/selenium-%22selenium.common.exceptions.nosuchelementexception%22-when-using-chrome-1657388136699">Selenium &quot;selenium.common.exceptions.NoSuchElementException&quot; when using Chrome</a><a href="/questions/prototypical-inheritance-writing-up-duplicate-1657385478064">Prototypical inheritance - writing up [duplicate]</a><a href="/questions/what-is-__init__.py-for-1657388415243">What is __init__.py for?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/providing-white-space-in-a-swing-gui-1657384734588">Providing white space in a Swing GUI</a><a href="/questions/servlet-returns-%22http-status-404-the-requested-resource-(servlet)-is-not-available%22-1657384850661">Servlet returns &quot;HTTP Status 404 The requested resource (/servlet) is not available&quot;</a><a href="/questions/jquery-dollar-is-not-defined-1657388385731">JQuery - $ is not defined</a><a href="/questions/parsing-a-string-to-a-date-in-javascript-1657387782497">Parsing a string to a date in JavaScript</a><a href="/questions/what-are-copy-elision-and-return-value-optimization-1657385455976">What are copy elision and return value optimization?</a><a href="/questions/what-is-the-difference-between-client-side-and-server-side-programming-1657384372926">What is the difference between client-side and server-side programming?</a><a href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773">Is storing a delimited list in a database column really that bad?</a><a href="/questions/what-does-it-mean-to-%22program-to-an-interface%22-1657384671665">What does it mean to &quot;program to an interface&quot;?</a><a href="/questions/re.findall-behaves-weird-1657388408049">re.findall behaves weird</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;deferred antipattern (now explicit-construction anti-pattern)\u0026lt;/a\u0026gt; coined by \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/995876/esailija\u0026quot;\u0026gt;Esailija\u0026lt;/a\u0026gt; is a common anti-pattern people who are new to promises make, I\u0026apos;ve made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Promises can chain with \u0026lt;code\u0026gt;.then\u0026lt;/code\u0026gt; and you can return promises directly. Your code in \u0026lt;code\u0026gt;getStuffDone\u0026lt;/code\u0026gt; can be rewritten as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getStuffDone\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myPromiseFn\u0026lt;/span\u0026gt;(param+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// much nicer, right?\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You should only use deferred objects when you are \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises\u0026quot;\u0026gt;converting an API to promises\u0026lt;/a\u0026gt; and can\u0026apos;t do it automatically, or when you\u0026apos;re writing aggregation functions that are easier expressed this way. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quoting Esailija:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This is the most common anti-pattern. It is easy to fall into this when you don\u0026apos;t really understand promises and think of them as glorified event emitters or callback utility. Let\u0026apos;s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;What\u0026apos;s wrong with it?\u0026lt;/h1\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;But the pattern works!\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Lucky you. Unfortunately, it probably doesn\u0026apos;t, as you likely forgot some edge case. In more than half of the occurrences I\u0026apos;ve seen, the author has forgotten to take care of the error handler:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOtherPromise\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;(result.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;example\u0026lt;/span\u0026gt;);\n    });\n})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The same thing happens in the case that your callback code causes an error - e.g. when \u0026lt;code\u0026gt;result\u0026lt;/code\u0026gt; doesn\u0026apos;t have a \u0026lt;code\u0026gt;property\u0026lt;/code\u0026gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In contrast, using \u0026lt;code\u0026gt;.then()\u0026lt;/code\u0026gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOtherPromise\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;) {\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;example\u0026lt;/span\u0026gt;;\n })\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The deferred antipattern is not only cumbersome, but also \u0026lt;strong\u0026gt;error-prone\u0026lt;/strong\u0026gt;. Using \u0026lt;code\u0026gt;.then()\u0026lt;/code\u0026gt; for chaining is much safer.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;But I\u0026apos;ve handled everything!\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won\u0026apos;t want to rewrite your code for that.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The libraries\u0026apos; methods (\u0026lt;code\u0026gt;then\u0026lt;/code\u0026gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;How do I avoid it?\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;So whenever you find yourself manually creating a \u0026lt;code\u0026gt;Promise\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;Deferred\u0026lt;/code\u0026gt; and already existing promises are involved, \u0026lt;strong\u0026gt;check the library API first\u0026lt;/strong\u0026gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/22562045/1048572\u0026quot;\u0026gt;promises are \u0026lt;em\u0026gt;more\u0026lt;/em\u0026gt; than callbacks\u0026lt;/a\u0026gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don\u0026apos;t want to deal with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Now 7 years later there is a simpler answer to this question:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How do I avoid the explicit constructor antipattern?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;async function\u0026lt;/code\u0026gt;s, then \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; every Promise!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Instead of manually constructing nested Promise chains such as this one:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promised\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOtherPromise\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAnotherPromise\u0026lt;/span\u0026gt;(result).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;result2\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;(result2);\n      });\n    });\n  });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;just turn your function \u0026lt;code\u0026gt;async\u0026lt;/code\u0026gt; and use the \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; keyword to \u0026lt;em\u0026gt;stop execution of the function\u0026lt;/em\u0026gt; until the Promise resolves:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;async\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promised\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; result =  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOtherPromise\u0026lt;/span\u0026gt;();\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; result2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAnotherPromise\u0026lt;/span\u0026gt;(result);\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result2;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This has various benefits:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Calling the \u0026lt;code\u0026gt;async\u0026lt;/code\u0026gt; function always returns a Promise, which resolves with the returned value and rejects if an error get\u0026apos;s thrown inside the async function\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt;ed Promise rejects, the error get\u0026apos;s thrown inside the async function, so you can just \u0026lt;code\u0026gt;try { ... } catch(error) { ... }\u0026lt;/code\u0026gt; it like the synchronous errors.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You can \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; inside loops and if branches, making most of the Promise chain logic trivial\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Although async functions behave mostly like chains of Promises, they are way easier to read (and easier to reason about)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How can I \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; a callback?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If the callback only calls back once, and the API you are calling does not provide a Promise already (most of them do!) this is the \u0026lt;em\u0026gt;only reason\u0026lt;/em\u0026gt; to use a Promise constructor:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create a wrapper around the \u0026quot;old\u0026quot; function taking a callback, passing the \u0026apos;resolve\u0026apos; function as callback\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;delay\u0026lt;/span\u0026gt; = time =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(resolve, time)\n ); \n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;delay\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;If \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; stops execution, does calling an \u0026lt;code\u0026gt;async function\u0026lt;/code\u0026gt; return the result directly?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;No. If you call an async function, a Promise gets always returned. You can then \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt; that Promise too inside an async function. You cannot wait for the result inside of a synchronous function (you would have to call \u0026lt;code\u0026gt;.then\u0026lt;/code\u0026gt; and attach a callback).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Conceptually, synchronous \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt;s always run to completion in one job, while \u0026lt;code\u0026gt;async function\u0026lt;/code\u0026gt;s run synchronously till they reach an \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt;, then they continue in another job.\u0026lt;/p\u0026gt;\n    "],"id":57,"title":"What is the explicit promise construction antipattern and how do I avoid it?","content":"\n                \n\u0026lt;p\u0026gt;I was writing code that does something that looks like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getStuffDone\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param\u0026lt;/span\u0026gt;) {           | \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getStuffDone\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = Q.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;defer\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* or $q.defer */\u0026lt;/span\u0026gt; |     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or = new $.Deferred() etc.        |     // using a promise constructor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myPromiseFn\u0026lt;/span\u0026gt;(param+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)                 |         \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myPromiseFn\u0026lt;/span\u0026gt;(param+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* or .done */\u0026lt;/span\u0026gt; |         .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;) {\n        d.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;(val);                  |             \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;(val);\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;err\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* .fail */\u0026lt;/span\u0026gt; |         }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;err\u0026lt;/span\u0026gt;) {\n        d.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt;(err);                   |             \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt;(err);\n    });                                  |         });\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;promise\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* or promise() */\u0026lt;/span\u0026gt; |     });\n}                                        | }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Someone told me this is called the \u0026quot;\u0026lt;strong\u0026gt;deferred antipattern\u0026lt;/strong\u0026gt;\u0026quot; or the \u0026quot;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;Promise\u0026lt;/code\u0026gt; constructor antipattern\u0026lt;/strong\u0026gt;\u0026quot; respectively, what\u0026apos;s bad about this code and why is this called an \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Anti-pattern\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;antipattern\u0026lt;/a\u0026gt;?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212","postType":"QUESTION","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","tags":[{"id":204,"name":"promise","slug":"promise","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","Questions_Tags":{"questionId":57,"tagId":204}},{"id":205,"name":"bluebird","slug":"bluebird","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","Questions_Tags":{"questionId":57,"tagId":205}},{"id":206,"name":"q","slug":"q","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","Questions_Tags":{"questionId":57,"tagId":206}},{"id":207,"name":"es6-promise","slug":"es6-promise","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","Questions_Tags":{"questionId":57,"tagId":207}}],"relatedQuestions":[{"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212","tags":[{"name":"promise","Questions_Tags":{"questionId":57,"tagId":204}},{"name":"bluebird","Questions_Tags":{"questionId":57,"tagId":205}},{"name":"q","Questions_Tags":{"questionId":57,"tagId":206}},{"name":"es6-promise","Questions_Tags":{"questionId":57,"tagId":207}}]}]},"randomQuestions":[{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"UnboundLocalError on local variable when reassigned after first use","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},{"title":"How do I write a correct micro-benchmark in Java?","slug":"how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725"},{"title":"Convert columns into rows with Pandas","slug":"convert-columns-into-rows-with-pandas-1657388374964"},{"title":"How do I pass variables and data from PHP to JavaScript?","slug":"how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553"},{"title":"How should a model be structured in MVC? [closed]","slug":"how-should-a-model-be-structured-in-mvc-closed-1657388394807"},{"title":"Selenium \"selenium.common.exceptions.NoSuchElementException\" when using Chrome","slug":"selenium-\"selenium.common.exceptions.nosuchelementexception\"-when-using-chrome-1657388136699"},{"title":"Prototypical inheritance - writing up [duplicate]","slug":"prototypical-inheritance-writing-up-duplicate-1657385478064"},{"title":"What is __init__.py for?","slug":"what-is-__init__.py-for-1657388415243"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"Providing white space in a Swing GUI","slug":"providing-white-space-in-a-swing-gui-1657384734588"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"Parsing a string to a date in JavaScript","slug":"parsing-a-string-to-a-date-in-javascript-1657387782497"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},{"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665"},{"title":"re.findall behaves weird","slug":"re.findall-behaves-weird-1657388408049"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>