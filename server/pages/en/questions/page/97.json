{"pageProps":{"data":{"count":610,"rows":[{"id":130,"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975","postType":"QUESTION","createdAt":"2022-07-09T16:38:32.000Z","updatedAt":"2022-07-09T16:38:32.000Z","tags":[{"id":475,"name":"variable-length-array","slug":"variable-length-array","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":475}},{"id":476,"name":"variable-length","slug":"variable-length","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":476}}]},{"id":129,"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608","postType":"QUESTION","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","tags":[{"id":471,"name":"pointers","slug":"pointers","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","Questions_Tags":{"questionId":129,"tagId":471}}]},{"id":128,"title":"Why is my Spring @Autowired field null?","slug":"why-is-my-spring-@autowired-field-null-1657384705291","postType":"QUESTION","createdAt":"2022-07-09T16:38:25.000Z","updatedAt":"2022-07-09T16:38:25.000Z","tags":[{"id":463,"name":"spring","slug":"spring","createdAt":"2022-07-09T16:38:25.000Z","updatedAt":"2022-07-09T16:38:25.000Z","Questions_Tags":{"questionId":128,"tagId":463}},{"id":467,"name":"autowired","slug":"autowired","createdAt":"2022-07-09T16:38:25.000Z","updatedAt":"2022-07-09T16:38:25.000Z","Questions_Tags":{"questionId":128,"tagId":467}}]},{"id":127,"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397","postType":"QUESTION","createdAt":"2022-07-09T16:38:22.000Z","updatedAt":"2022-07-09T16:38:22.000Z","tags":[{"id":462,"name":"printing","slug":"printing","createdAt":"2022-07-09T16:38:22.000Z","updatedAt":"2022-07-09T16:38:22.000Z","Questions_Tags":{"questionId":127,"tagId":462}}]},{"id":126,"title":"scanf() leaves the newline character in the buffer","slug":"scanf()-leaves-the-newline-character-in-the-buffer-1657384699202","postType":"QUESTION","createdAt":"2022-07-09T16:38:19.000Z","updatedAt":"2022-07-09T16:38:19.000Z","tags":[{"id":459,"name":"scanf","slug":"scanf","createdAt":"2022-07-09T16:38:19.000Z","updatedAt":"2022-07-09T16:38:19.000Z","Questions_Tags":{"questionId":126,"tagId":459}}]}]},"answers":{"126":["\n&lt;p&gt;The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;scanf()&lt;/code&gt;&lt;/a&gt; function skips leading whitespace automatically before trying to parse conversions other than characters.  The character formats (primarily &lt;code&gt;%c&lt;/code&gt;; also scan sets &lt;code&gt;%[]&lt;/code&gt;  and &lt;code&gt;%n&lt;/code&gt;) are the exception; they don&apos;t skip whitespace.&lt;/p&gt;\n\n&lt;p&gt;Use &lt;code&gt;&quot; %c&quot;&lt;/code&gt; with a leading blank to skip optional white space.  Do not use a trailing blank in a &lt;code&gt;scanf()&lt;/code&gt; format string.&lt;/p&gt;\n\n&lt;p&gt;Note that this still doesn&apos;t consume any trailing whitespace left in the input stream, not even to the end of a line, so beware of that if also using &lt;a href=&quot;http://en.cppreference.com/w/c/io/getchar&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;getchar()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; on the same input stream.  We&apos;re just getting scanf to skip over whitespace &lt;em&gt;before&lt;/em&gt; conversions, like it does for &lt;code&gt;%d&lt;/code&gt; and other non-character conversions.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Note that non-whitespace &quot;directives&quot; (to use &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot; rel=&quot;noreferrer&quot;&gt;POSIX scanf terminology&lt;/a&gt;) other than conversions, like the literal text in &lt;code&gt;scanf(&quot;order = %d&quot;, &amp;amp;order);&lt;/code&gt; doesn&apos;t skip whitespace either.  The literal &lt;code&gt;order&lt;/code&gt; has to match the next character to be read.&lt;/p&gt;\n\n&lt;p&gt;So you probably want &lt;code&gt;&quot; order = %d&quot;&lt;/code&gt; there if you want to skip a newline from the previous line but still require a literal match on a fixed string, &lt;a href=&quot;https://stackoverflow.com/questions/49923312/scanf-run-twice-instead-of-one-time-at-assembly-x86-64&quot;&gt;like this question&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;scanf(&quot; %c&quot;, &amp;amp;c2);&lt;/code&gt;. This will solve your problem.&lt;/p&gt;\n    ","\n&lt;p&gt;Another option (that I got from &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;) is to read and discard the newline by using the &lt;em&gt;assignment-supression option&lt;/em&gt;. To do that, we just put a format to read a character with an asterisk between &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d%*c&quot;&lt;/span&gt;,&amp;amp;a); &lt;span class=&quot;hljs-comment&quot;&gt;// line 1&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c%*c&quot;&lt;/span&gt;,&amp;amp;c1); &lt;span class=&quot;hljs-comment&quot;&gt;// line 3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;scanf&lt;/code&gt; will then read the next char (that is, the newline) but not assign it to any pointer.&lt;/p&gt;\n\n&lt;p&gt;In the end, however, I would second &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot; rel=&quot;noreferrer&quot;&gt;the FAQ&apos;s last option&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Or, depending on your requirements, you could also forget about scanf()/getchar(), use fgets() to get a line of text from the user and parse it yourself. &lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;getchar()&lt;/code&gt; before calling second &lt;code&gt;scanf()&lt;/code&gt;.  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c&quot;&lt;/span&gt;, &amp;amp;c1);\ngetchar();  &lt;span class=&quot;hljs-comment&quot;&gt;// &amp;lt;== remove newline&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c&quot;&lt;/span&gt;, &amp;amp;c2);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;To echo what I have posted in &lt;a href=&quot;https://stackoverflow.com/a/52720064/6372809&quot;&gt;another answer about C++&lt;/a&gt;: I suggest to toss &lt;code&gt;scanf()&lt;/code&gt; away, to never use it, and to instead use &lt;code&gt;fgets()&lt;/code&gt; and &lt;code&gt;sscanf()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;The reason for this is, that at least in Unix-like systems by default, the terminal your CLI program runs on does some processing of the user input before your program sees it. It buffers input until a newline is entered, and allows for some rudimentary line editing, like making backspace work.&lt;/p&gt;\n&lt;p&gt;So, you can never get a single character at a time, or a few single characters, just a full line. But that&apos;s not what e.g. &lt;code&gt;scanf(&quot;%d&quot;)&lt;/code&gt; processes, instead it processes just the digits, &lt;em&gt;and stops there&lt;/em&gt;, leaving the rest buffered in the C library, for a future &lt;code&gt;stdio&lt;/code&gt; function to use. If your program has e.g.&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter a number: &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;a);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter a word: &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s&quot;&lt;/span&gt;, word);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you enter the line &lt;code&gt;123 abcd&lt;/code&gt;, it completes &lt;em&gt;both&lt;/em&gt; &lt;code&gt;scanf()&lt;/code&gt;s at once, but only after a newline is given. The first &lt;code&gt;scanf()&lt;/code&gt; doesn&apos;t return when a user has hit space, even though that&apos;s where the number ends (because at that point the line is still in the terminal&apos;s line buffer); and the second &lt;code&gt;scanf()&lt;/code&gt; doesn&apos;t wait for you to enter another line (because the input buffer already contains enough to fill the &lt;code&gt;%s&lt;/code&gt; conversion).&lt;/p&gt;\n&lt;p&gt;This isn&apos;t what users usually expect!&lt;/p&gt;\n&lt;p&gt;Instead, they expect that hitting enter completes the input, and if you hit enter, you either get a default value, or an error, with possibly a suggestion to please really just give the answer.&lt;/p&gt;\n&lt;p&gt;You can&apos;t really do that with &lt;code&gt;scanf(&quot;%d&quot;)&lt;/code&gt;. If the user just hits enter, nothing happens. Because &lt;code&gt;scanf()&lt;/code&gt; is still waiting for the number. The terminal sends the line onward, but your program doesn&apos;t see it, because &lt;code&gt;scanf()&lt;/code&gt; eats it. You don&apos;t get a chance to react to the user&apos;s mistake.&lt;/p&gt;\n&lt;p&gt;That&apos;s also not very useful.&lt;/p&gt;\n&lt;p&gt;Hence, I suggest using &lt;code&gt;fgets()&lt;/code&gt; or &lt;code&gt;getline()&lt;/code&gt; to read a full line of input at a time. This exactly matches what the terminal gives, and always gives your program control after the user has entered a line. What you do with the input line is up to you, if you want a number, you can use &lt;code&gt;atoi()&lt;/code&gt;, &lt;code&gt;strtol()&lt;/code&gt;, or even &lt;code&gt;sscanf(buf, &quot;%d&quot;, &amp;amp;a)&lt;/code&gt; to parse the number. &lt;code&gt;sscanf()&lt;/code&gt; doesn&apos;t have the same mismatch as &lt;code&gt;scanf()&lt;/code&gt;, because the buffer it reads from is limited in size, and when it ends, it ends -- the function can&apos;t wait for more.&lt;/p&gt;\n&lt;p&gt;&lt;sup&gt;(&lt;code&gt;fscanf()&lt;/code&gt; on a regular file can also be fine if the file format is one that supports how it skims over newlines like any whitespace. For line-oriented data, I&apos;d still use &lt;code&gt;fgets()&lt;/code&gt; and &lt;code&gt;sscanf()&lt;/code&gt;.)&lt;/sup&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;So, instead of what I had above, use something like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter a number: &quot;&lt;/span&gt;);\n\nfgets(buf, bufsize, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;sscanf&lt;/span&gt;(buf, &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;a);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or, actually, check the return value of &lt;code&gt;sscanf()&lt;/code&gt; too, so you can detect empty lines and otherwise invalid data:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; bufsize = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buf[bufsize];\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ret;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; word[bufsize];\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter a number: &quot;&lt;/span&gt;);\n    fgets(buf, bufsize, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n\n    ret = &lt;span class=&quot;hljs-built_in&quot;&gt;sscanf&lt;/span&gt;(buf, &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;a);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Ok, you don&apos;t have to.\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter a word: &quot;&lt;/span&gt;);\n    fgets(buf, bufsize, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n\n    ret = &lt;span class=&quot;hljs-built_in&quot;&gt;sscanf&lt;/span&gt;(buf, &lt;span class=&quot;hljs-string&quot;&gt;&quot;%s&quot;&lt;/span&gt;, word);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;You make me sad.\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;You entered %d and %s\\n&quot;&lt;/span&gt;, a, word);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Of course, if you want the program to insist, you can create a simple function to loop over the &lt;code&gt;fgets()&lt;/code&gt; and &lt;code&gt;sscanf()&lt;/code&gt; until the user deigns to do what they&apos;re told; or to just exit with an error immediately. Depends on what you think your program should do if the user doesn&apos;t want to play ball.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;You could do something similar e.g. by looping over &lt;code&gt;getchar()&lt;/code&gt; to read characters until a newline after &lt;code&gt;scanf(&quot;%d&quot;)&lt;/code&gt; returned, thus clearing up any garbage left in the buffer, but that doesn&apos;t do anything about the case where the user just hits enter on an empty line. Anyway, &lt;code&gt;fgets()&lt;/code&gt; would read until a newline, so you don&apos;t have to do it yourself.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/*Take char input using scanf after int input using scanf just use fflush(stdin) function  after int input */&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;conio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n  &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; y;\n  clrscr();\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot; enter an int &quot;&lt;/span&gt;);\n  &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);\n  fflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n Now enter a char&quot;&lt;/span&gt;);\n  &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c&quot;&lt;/span&gt;,&amp;amp;y);\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n X=%d and Y=%c&quot;&lt;/span&gt;,x,y);\n  getch();\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "],"127":["\n&lt;p&gt;Since Java 5 you can use &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#toString-int:A-&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Arrays.toString(arr)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#deepToString-java.lang.Object:A-&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Arrays.deepToString(arr)&lt;/code&gt;&lt;/a&gt; for arrays within arrays. Note that the &lt;code&gt;Object[]&lt;/code&gt; version calls &lt;code&gt;.toString()&lt;/code&gt; on each object in the array. The output is even decorated in the exact way you&apos;re asking.&lt;/p&gt;\n&lt;p&gt;Examples:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;h3&gt;Simple Array:&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] array = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;};\nSystem.out.println(Arrays.toString(array));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;[John, Mary, Bob]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;h3&gt;Nested Array:&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[][] deepArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[][] {{&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;}, {&lt;span class=&quot;hljs-string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;}};\nSystem.out.println(Arrays.toString(deepArray));\n&lt;span class=&quot;hljs-comment&quot;&gt;//output: [[Ljava.lang.String;@106d69c, [Ljava.lang.String;@52e922]&lt;/span&gt;\nSystem.out.println(Arrays.deepToString(deepArray));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;[[John, Mary], [Alice, Bob]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;h3&gt;&lt;code&gt;double&lt;/code&gt; Array:&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;[] doubleArray = { &lt;span class=&quot;hljs-number&quot;&gt;7.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3.0&lt;/span&gt; };\nSystem.out.println(Arrays.toString(doubleArray));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;7.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3.0&lt;/span&gt; ]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;h3&gt;&lt;code&gt;int&lt;/code&gt; Array:&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = { &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; };\nSystem.out.println(Arrays.toString(intArray));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; ]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Always check the standard libraries first.  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Arrays;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then try:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;System.out.println(Arrays.toString(array));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if your array contains other arrays as elements:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;System.out.println(Arrays.deepToString(array));\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is nice to know, however, as for &quot;always check the standard libraries first&quot; I&apos;d never have stumbled upon the trick of &lt;code&gt;Arrays.toString( myarray )&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;--since I was concentrating on the type of myarray to see how to do this. I didn&apos;t want to have to iterate through the thing: I wanted an easy call to make it come out similar to what I see in the Eclipse debugger and myarray.toString() just wasn&apos;t doing it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Arrays;\n.\n.\n.\nSystem.out.println( Arrays.toString( myarray ) );\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In JDK1.8 you can use aggregate operations and a lambda expression:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] strArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// #1&lt;/span&gt;\nArrays.asList(strArray).stream().forEach(s -&amp;gt; System.out.println(s));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// #2&lt;/span&gt;\nStream.of(strArray).forEach(System.out::println);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// #3&lt;/span&gt;\nArrays.stream(strArray).forEach(System.out::println);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* output:\nJohn\nMary\nBob\n*/&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h2&gt;Arrays.toString&lt;/h2&gt;\n&lt;p&gt;As a direct answer, &lt;a href=&quot;https://stackoverflow.com/a/409795/365237&quot;&gt;the solution provided by several, including @Esko&lt;/a&gt;, using the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#toString%28java.lang.Object%5B%5D%29&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Arrays.toString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#deepToString%28java.lang.Object%5B%5D%29&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Arrays.deepToString&lt;/code&gt;&lt;/a&gt; methods, is simply the best.&lt;/p&gt;\n&lt;h2&gt;Java 8 - Stream.collect(joining()), Stream.forEach&lt;/h2&gt;\n&lt;p&gt;Below I try to list some of the other methods suggested, attempting to improve a little, with the most notable addition being the use of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Stream.collect&lt;/code&gt;&lt;/a&gt; operator, using a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#joining-java.lang.CharSequence-&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;joining&lt;/code&gt;&lt;/a&gt; &lt;code&gt;Collector&lt;/code&gt;, to mimic what the &lt;code&gt;String.join&lt;/code&gt; is doing.&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] ints = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\nSystem.out.println(IntStream.of(ints).mapToObj(Integer::toString).collect(Collectors.joining(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;)));\nSystem.out.println(IntStream.of(ints).boxed().map(Object::toString).collect(Collectors.joining(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;)));\nSystem.out.println(Arrays.toString(ints));\n\nString[] strs = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;};\nSystem.out.println(Stream.of(strs).collect(Collectors.joining(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;)));\nSystem.out.println(String.join(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;, strs));\nSystem.out.println(Arrays.toString(strs));\n\nDayOfWeek [] days = { FRIDAY, MONDAY, TUESDAY };\nSystem.out.println(Stream.of(days).map(Object::toString).collect(Collectors.joining(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;)));\nSystem.out.println(Arrays.toString(days));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// These options are not the same as each item is printed on a new line:&lt;/span&gt;\nIntStream.of(ints).forEach(System.out::println);\nStream.of(strs).forEach(System.out::println);\nStream.of(days).forEach(System.out::println);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Starting with Java 8, one could also take advantage of the &lt;code&gt;join()&lt;/code&gt; method provided by the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#join-java.lang.CharSequence-java.lang.CharSequence...-&quot;&gt;String class&lt;/a&gt; to print out array elements, without the brackets, and separated by a delimiter of choice (which is the space character for the example shown below):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] greeting = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hey&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;there&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;amigo!&quot;&lt;/span&gt;};\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\nString.join(delimiter, greeting) \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output will be &quot;Hey there amigo!&quot;.&lt;/p&gt;\n    ","\n&lt;h2&gt;Prior to Java 8&lt;/h2&gt;\n\n&lt;p&gt;We could have used &lt;code&gt;Arrays.toString(array)&lt;/code&gt; to print one dimensional array and &lt;code&gt;Arrays.deepToString(array)&lt;/code&gt; for multi-dimensional arrays. &lt;/p&gt;\n\n&lt;h2&gt;Java 8&lt;/h2&gt;\n\n&lt;p&gt;Now we have got the option of &lt;code&gt;Stream&lt;/code&gt; and &lt;code&gt;lambda&lt;/code&gt; to print the array.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Printing One dimensional Array:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\n    String[] strArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;};\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Prior to Java 8&lt;/span&gt;\n    System.out.println(Arrays.toString(intArray));\n    System.out.println(Arrays.toString(strArray));\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// In Java 8 we have lambda expressions&lt;/span&gt;\n    Arrays.stream(intArray).forEach(System.out::println);\n    Arrays.stream(strArray).forEach(System.out::println);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output is:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;[1, 2, 3, 4, 5]&lt;br&gt;\n  [John, Mary, Bob]&lt;br&gt;\n  1&lt;br&gt;\n  2&lt;br&gt;\n  3&lt;br&gt;\n  4&lt;br&gt;\n  5&lt;br&gt;\n  John&lt;br&gt;\n  Mary&lt;br&gt;\n  Bob&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Printing Multi-dimensional Array&lt;/strong&gt;\nJust in case we want to print multi-dimensional array we can use &lt;code&gt;Arrays.deepToString(array)&lt;/code&gt; as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[][] int2DArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[][] { {&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;}, { &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;}, {&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;} };\n    String[][] str2DArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[][]{ {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bravo&quot;&lt;/span&gt;} , {&lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Lee&quot;&lt;/span&gt;}, {&lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Johnson&quot;&lt;/span&gt;} };\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Prior to Java 8&lt;/span&gt;\n    System.out.println(Arrays.deepToString(int2DArray));\n    System.out.println(Arrays.deepToString(str2DArray));\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// In Java 8 we have lambda expressions&lt;/span&gt;\n    Arrays.stream(int2DArray).flatMapToInt(x -&amp;gt; Arrays.stream(x)).forEach(System.out::println);\n    Arrays.stream(str2DArray).flatMap(x -&amp;gt; Arrays.stream(x)).forEach(System.out::println);\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now the point to observe is that the method &lt;code&gt;Arrays.stream(T[])&lt;/code&gt;, which in case of &lt;code&gt;int[]&lt;/code&gt; returns us &lt;code&gt;Stream&amp;lt;int[]&amp;gt;&lt;/code&gt; and then method &lt;code&gt;flatMapToInt()&lt;/code&gt; maps each element of stream with the contents of a mapped stream produced by applying the provided mapping function to each element.&lt;/p&gt;\n\n&lt;p&gt;The output is:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;[[11, 12], [21, 22], [31, 32, 33]]&lt;br&gt;\n  [[John, Bravo], [Mary, Lee], [Bob, Johnson]]&lt;br&gt;\n  11&lt;br&gt;\n  12&lt;br&gt;\n  21&lt;br&gt;\n  22&lt;br&gt;\n  31&lt;br&gt;\n  32&lt;br&gt;\n  33&lt;br&gt;\n  John&lt;br&gt;\n  Bravo&lt;br&gt;\n  Mary&lt;br&gt;\n  Lee&lt;br&gt;\n  Bob&lt;br&gt;\n  Johnson&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;If you&apos;re using Java 1.4, you can instead do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;System.out.println(Arrays.asList(array));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(This works in 1.5+ too, of course.)&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;Arrays.deepToString(arr)&lt;/code&gt; only prints on one line. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[][] table = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To actually get a table to print as a two dimensional table, I had to do this: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;System.out.println(Arrays.deepToString(table).replaceAll(&lt;span class=&quot;hljs-string&quot;&gt;&quot;],&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;],&quot;&lt;/span&gt; + System.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;line.separator&quot;&lt;/span&gt;)));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It seems like the &lt;code&gt;Arrays.deepToString(arr)&lt;/code&gt; method should take a separator string, but unfortunately it doesn&apos;t.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n: someArray) {\n    System.out.println(n+&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Different Ways to Print Arrays in Java:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Simple Way   &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;List&amp;lt;String&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;();\nlist.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;One&quot;&lt;/span&gt;);\nlist.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Two&quot;&lt;/span&gt;);\nlist.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Three&quot;&lt;/span&gt;);\nlist.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Four&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// Print the list in console&lt;/span&gt;\nSystem.out.println(list);\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Output:\n      [One, Two, Three, Four]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;&lt;p&gt;Using &lt;strong&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] array = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;One&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Two&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Three&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Four&quot;&lt;/span&gt; };\nSystem.out.println(Arrays.toString(array));\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Output: [One, Two, Three, Four]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;ol start=&quot;3&quot;&gt;\n&lt;li&gt;&lt;p&gt;Printing Array of Arrays&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] arr1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;Fifth&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Sixth&quot;&lt;/span&gt; };\nString[] arr2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;Seventh&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Eight&quot;&lt;/span&gt; };\nString[][] arrayOfArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[][] { arr1, arr2 };\nSystem.out.println(arrayOfArray);\nSystem.out.println(Arrays.toString(arrayOfArray));\nSystem.out.println(Arrays.deepToString(arrayOfArray));\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Output: [[Ljava.lang.String;@1ad086a [[Ljava.lang.String;@10385c1,\n  [Ljava.lang.String;@42719c] [[Fifth, Sixth], [Seventh, Eighth]]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Resource: &lt;a href=&quot;http://howtodoinjava.com/core-java/collections/how-to-print-the-content-of-array-in-java/&quot; rel=&quot;noreferrer&quot;&gt;Access An Array&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Using regular &lt;strong&gt;for&lt;/strong&gt; loop is the simplest way of printing array in my opinion.\nHere you have a sample code based on your intArray&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; intArray.length; i++) {\n   System.out.print(intArray[i] + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It gives output as yours\n    1, 2, 3, 4, 5&lt;/p&gt;\n    ","\n&lt;p&gt;It should always work whichever JDK version you use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;System.out.println(Arrays.asList(array));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will work if the &lt;code&gt;Array&lt;/code&gt; contains Objects. If the &lt;code&gt;Array&lt;/code&gt; contains primitive types, you can use wrapper classes instead storing the primitive directly as..&lt;/p&gt;\n\n&lt;p&gt;Example: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[]{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Replace it with:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Integer[] a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Integer&lt;/span&gt;[]{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Update :&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Yes ! this is to be mention that converting an array to an object array OR to use the Object&apos;s array is costly and may slow the execution. it happens by the nature of java called autoboxing.   &lt;/p&gt;\n\n&lt;p&gt;So only for printing purpose, It should not be used. we can make a function which takes an array as parameter and prints the desired format as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;printArray&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; [] a)&lt;/span&gt;{\n        &lt;span class=&quot;hljs-comment&quot;&gt;//write printing code&lt;/span&gt;\n} \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I came across this post in &lt;a href=&quot;http://vanillajava.blogspot.com/2016/03/printing-arrays-by-hacking-jvm.html&quot; rel=&quot;noreferrer&quot;&gt;Vanilla #Java&lt;/a&gt; recently. It&apos;s not very convenient writing &lt;code&gt;Arrays.toString(arr);&lt;/code&gt;, then importing &lt;code&gt;java.util.Arrays;&lt;/code&gt; all the time.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Please note, this is not a permanent fix by any means. Just a hack that can make debugging simpler.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Printing an array directly gives the internal representation and the hashCode. Now, all classes have &lt;code&gt;Object&lt;/code&gt; as the parent-type. So, why not hack the &lt;code&gt;Object.toString()&lt;/code&gt;? Without modification, the Object class looks like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; getClass().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;@&quot;&lt;/span&gt; + Integer.toHexString(hashCode());\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What if this is changed to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;boolean&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;boolean&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.toString((&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; Object[])\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Arrays.deepToString((Object[]) &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; getClass().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;@&quot;&lt;/span&gt; + Integer.toHexString(hashCode());\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This modded class may simply be added to the class path by adding the following to the command line: &lt;code&gt;-Xbootclasspath/p:target/classes&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Now, with the availability of &lt;code&gt;deepToString(..)&lt;/code&gt; since Java 5, the &lt;code&gt;toString(..)&lt;/code&gt; can easily be changed to &lt;code&gt;deepToString(..)&lt;/code&gt; to add support for arrays that contain other arrays.&lt;/p&gt;\n\n&lt;p&gt;I found this to be a quite useful hack and it would be great if Java could simply add this. I understand potential issues with having very large arrays since the string representations could be problematic. Maybe pass something like a &lt;code&gt;System.out&lt;/code&gt;or a &lt;code&gt;PrintWriter&lt;/code&gt; for such eventualities. &lt;/p&gt;\n    ","\n&lt;p&gt;In java 8 it is easy. there are two keywords&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;stream: &lt;code&gt;Arrays.stream(intArray).forEach&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;method reference: &lt;code&gt;::println&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\nArrays.stream(intArray).forEach(System.out::println);\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;If you want to print all elements in the array in the same line, then just use &lt;code&gt;print&lt;/code&gt; instead of &lt;code&gt;println&lt;/code&gt; i.e. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\nArrays.stream(intArray).forEach(System.out::print);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Another way without method reference just use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\nSystem.out.println(Arrays.toString(intArray));\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You could loop through the array,  printing out each item, as you loop. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] items = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;item 1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;item 2&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;item 3&quot;&lt;/span&gt;};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; items.length; i++) {\n\n    System.out.println(items[i]);\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;item &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nitem &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\nitem &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;There Are Following way to print Array&lt;/strong&gt;          &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 1) toString()  &lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] arrayInt = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;};  \n    System.out.println(Arrays.toString(arrayInt));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// 2 for loop()&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; number : arrayInt) {\n        System.out.println(number);\n    }\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// 3 for each()&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x: arrayInt){\n         System.out.println(x);\n     }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There&apos;s one additional way if your array is of type char[]:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; A[] = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;}; \n\nSystem.out.println(A); &lt;span class=&quot;hljs-comment&quot;&gt;// no other arguments&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;prints &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;abc\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;A simplified shortcut I&apos;ve tried is this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x[] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;printableText&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Arrays.toString(x).replaceAll(&lt;span class=&quot;hljs-string&quot;&gt;&quot;[\\\\[\\\\]]&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;).replaceAll(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;);\n    System.out.println(printableText);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will print&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;No loops required in this approach and it is best for small arrays only&lt;/p&gt;\n    ","\n&lt;p&gt;Using org.apache.commons.lang3.StringUtils.join(*) methods can be an option&lt;br&gt;\nFor example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;String[] strArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt; };\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;arrayAsCSV&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; StringUtils.join(strArray, &lt;span class=&quot;hljs-string&quot;&gt;&quot; , &quot;&lt;/span&gt;);\nSystem.out.printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;[%s]&quot;&lt;/span&gt;, arrayAsCSV);\n&lt;span class=&quot;hljs-comment&quot;&gt;//output: [John , Mary , Bob]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I used the following dependency &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;\n&amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;\n&amp;lt;version&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;3.3&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.2&lt;/span&gt;&amp;lt;/version&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For-each loop can also be used to print elements of array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; array[] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i:array)\n    System.out.println(i);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;It is very simple way to print array without using any loop in JAVA.&lt;/p&gt;\n&lt;p&gt;-&amp;gt; For, Single or simple array:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] array = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[]{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;};\n System.out.println(Arrays.toString(array));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The Output :&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;      [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;-&amp;gt; So, this 2D array can&apos;t be printed with Arrays.toString()&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[][] array = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[][]{{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;}, {&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;}};\n System.out.println(Arrays.deepToString(array));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;   [[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt; Done Keep Code&lt;/p&gt;\n    ","\n&lt;p&gt;To add to all the answers, printing the object as a JSON string is also an option.&lt;/p&gt;\n\n&lt;p&gt;Using Jackson:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;ObjectWriter&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;ow&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ObjectMapper&lt;/span&gt;().writer().withDefaultPrettyPrinter();\nSystem.out.println(ow.writeValueAsString(anyArray));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using Gson:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Gson&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;gson&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Gson&lt;/span&gt;();\nSystem.out.println(gson.toJson(anyArray));\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// array of primitives:&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] intArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[] {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;};\n\nSystem.out.println(Arrays.toString(intArray));\n\noutput: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// array of object references:&lt;/span&gt;\nString[] strArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;};\n\nSystem.out.println(Arrays.toString(strArray));\n\noutput: [John, Mary, Bob]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here a possible printing function:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;printArray&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; [] array)&lt;/span&gt;{\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{ &quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; array.length; i++){\n            System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt; + array[i] + &lt;span class=&quot;hljs-string&quot;&gt;&quot;] &quot;&lt;/span&gt;);\n        }\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;}&quot;&lt;/span&gt;);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For example, if main is like this&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; [] array = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;};\n    printArray(array);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the output will be { [1] [2] [3] [4] }&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;printer&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n        String a[] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;];\n        &lt;span class=&quot;hljs-type&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Scanner&lt;/span&gt;(System.in);\n        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;enter the data&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;; i++) {\n            a[i] = sc.nextLine();\n        }\n        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;the entered data is&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String i : a) {\n            System.out.println(i);\n        }\n      }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is marked as a duplicate for &lt;a href=&quot;https://stackoverflow.com/questions/50977959/cannot-see-the-contents-of-the-array-printed-in-console&quot;&gt;printing a byte[]&lt;/a&gt;. Note: for a byte array there are additional methods which may be appropriate.&lt;/p&gt;\n\n&lt;p&gt;You can print it as a String if it contains ISO-8859-1 chars.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(bytes, StandardChars.ISO_8559);\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = s.getBytes(StandardChars.ISO_8559);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if it contains a UTF-8 string&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(bytes, StandardChars.UTF_8);\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = s.getBytes(StandardChars.UTF_8);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if you want print it as hexadecimal.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; DatatypeConverter.printHexBinary(bytes);\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = DatatypeConverter.parseHexBinary(s);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if you want print it as base64.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; DatatypeConverter.printBase64Binary(bytes);\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = DatatypeConverter.parseBase64Binary(s);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if you want to print an array of signed byte values&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Arrays.toString(bytes);\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\nString[] split = s.substring(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, s.length() - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;byte&lt;/span&gt;[split.length];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; bytes2.length; i++)\n    bytes2[i] = Byte.parseByte(split[i]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or if you want to print an array of unsigned byte values&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Arrays.toString(\n               IntStream.range(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, bytes.length).map(i -&amp;gt; bytes[i] &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;0xFF&lt;/span&gt;).toArray());\nSystem.out.println(s);\n&lt;span class=&quot;hljs-comment&quot;&gt;// to reverse&lt;/span&gt;\nString[] split = s.substring(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, s.length() - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] bytes2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;byte&lt;/span&gt;[split.length];\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; bytes2.length; i++)\n    bytes2[i] = (&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;) Integer.parseInt(split[i]); &lt;span class=&quot;hljs-comment&quot;&gt;// might need a range check.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;if you are running jdk 8. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] array)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;StringJoiner&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;joiner&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StringJoiner&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;]&quot;&lt;/span&gt;);\n    Arrays.stream(array).forEach(element -&amp;gt; joiner.add(element + &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;));\n    System.out.println(joiner.toString());\n}\n\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[] array = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;int&lt;/span&gt;[]{&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\nprint(array);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you are using Java 11&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Arrays;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HelloWorld&lt;/span&gt;{\n\n     &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String []args)&lt;/span&gt;{\n        String[] array = { &lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mahta&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Sara&quot;&lt;/span&gt; };\n       System.out.println(Arrays.toString(array).replace(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span class=&quot;hljs-string&quot;&gt;&quot;[&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span class=&quot;hljs-string&quot;&gt;&quot;]&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;));\n     }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output :&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;John Mahta Sara\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In java 8 :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Arrays.stream(myArray).forEach(System.out::println);\n&lt;/code&gt;&lt;/pre&gt;\n    "],"128":["\n&lt;p&gt;The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn&apos;t know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn&apos;t know to autowire it.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects&apos; dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.&lt;/p&gt;\n\n&lt;p&gt;The IoC container isn&apos;t magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.&lt;/p&gt;\n\n&lt;p&gt;I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;h2&gt;Inject your beans&lt;/h2&gt;\n\n&lt;p&gt;The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Controller&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeController&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; MileageFeeCalculator calc;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&quot;/mileage/{miles}&quot;)&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mileageFee&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; miles)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; calc.mileageCharge(miles);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;h2&gt;Use @Configurable&lt;/h2&gt;\n\n&lt;p&gt;If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object&apos;s constructor that alerts Spring that it&apos;s being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring&apos;s runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Service&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;@Configurable&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeCalculator&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; MileageRateService rateService;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mileageCharge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; miles)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (miles * rateService.ratePerMile());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;h2&gt;Manual bean lookup: not recommended&lt;/h2&gt;\n\n&lt;p&gt;This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.&lt;/p&gt;\n\n&lt;p&gt;To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ApplicationContextHolder&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ApplicationContextAware&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ApplicationContext context;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;setApplicationContext&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; BeansException {\n        context = applicationContext;   \n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ApplicationContext &lt;span class=&quot;hljs-title function_&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; context;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Controller&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeController&lt;/span&gt; {    \n    &lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&quot;/mileage/{miles}&quot;)&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mileageFee&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; miles)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;MileageFeeCalculator&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; calc.mileageCharge(miles);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won&apos;t be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.&lt;/p&gt;\n\n&lt;p&gt;This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.\nMake sure you get it from Appln-context as below.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyDemo&lt;/span&gt; {\n\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; MyService  myService; \n\n    &lt;span class=&quot;hljs-comment&quot;&gt;/**\n     * &lt;span class=&quot;hljs-doctag&quot;&gt;@param&lt;/span&gt; args\n     */&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;);\n            ApplicationContext ctx=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;spring.xml&quot;&lt;/span&gt;);\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ctx&amp;gt;&amp;gt;&quot;&lt;/span&gt;+ctx);\n\n            Customer c1=&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n            MyDemo myDemo=ctx.getBean(MyDemo.class);\n            System.out.println(myDemo);\n            myDemo.callService(ctx);\n\n\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;callService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ApplicationContext ctx)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;\n        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;---callService---&quot;&lt;/span&gt;);\n        System.out.println(myService);\n        myService.callMydao();\n\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.\nfrom your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;MileageFeeCalculator&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeCalculator&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;so it won&apos;t work that way. &lt;/p&gt;\n\n&lt;p&gt;The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.&lt;/p&gt;\n\n&lt;p&gt;Change your Controller class like below.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Controller&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeController&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    MileageFeeCalculator calc;  \n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&quot;/mileage/{miles}&quot;)&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mileageFee&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; miles)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; calc.mileageCharge(miles);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I once encountered the same issue when I was &lt;em&gt;not quite used to the life in the IoC world&lt;/em&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.&lt;/p&gt;\n&lt;p&gt;The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is indeed properly injected), I am &lt;code&gt;new&lt;/code&gt;ing my own instance of that bean type and using it. Of course this one&apos;s &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.&lt;/p&gt;\n    ","\n&lt;p&gt;Your problem is new (object creation in java style)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;MileageFeeCalculator&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeCalculator&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the&lt;br&gt;\n    application context of Spring when server is started. But when we create objects \n    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.&lt;/p&gt;\n\n&lt;p&gt;Check this out:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ConfiguredTenantScopedBeanProcessor&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;BeanFactoryPostProcessor&lt;/span&gt; {\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; BeansException {\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;tenant&quot;&lt;/span&gt;;\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Bean factory post processor is initialized&quot;&lt;/span&gt;); \n    beanFactory.registerScope(&lt;span class=&quot;hljs-string&quot;&gt;&quot;employee&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Employee&lt;/span&gt;());\n\n    Assert.state(beanFactory &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; BeanDefinitionRegistry,\n            &lt;span class=&quot;hljs-string&quot;&gt;&quot;BeanFactory was not a BeanDefinitionRegistry, so CustomScope cannot be used.&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-type&quot;&gt;BeanDefinitionRegistry&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (BeanDefinitionRegistry) beanFactory;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String beanName : beanFactory.getBeanDefinitionNames()) {\n        &lt;span class=&quot;hljs-type&quot;&gt;BeanDefinition&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;definition&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; beanFactory.getBeanDefinition(beanName);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (name.equals(definition.getScope())) {\n            &lt;span class=&quot;hljs-type&quot;&gt;BeanDefinitionHolder&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;proxyHolder&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; ScopedProxyUtils.createScopedProxy(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;BeanDefinitionHolder&lt;/span&gt;(definition, beanName), registry, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n            registry.registerBeanDefinition(beanName, proxyHolder.getBeanDefinition());\n        }\n    }\n}\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It seems to be rare case but here is what happened to me:&lt;/p&gt;\n\n&lt;p&gt;We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Inject&lt;/span&gt;\nCalculator myCalculator\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !&lt;/p&gt;\n\n&lt;p&gt;So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;em&gt;I&apos;m new to Spring, but I discovered this working solution. Please tell me if it&apos;s a deprecable way.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.springframework.beans.factory.annotation.Autowired;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.springframework.context.ApplicationContext;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.springframework.stereotype.Component;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SpringUtils&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ApplicationContext ctx;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;/**\n     * Make Spring inject the application context\n     * and save it on a static variable,\n     * so that it can be accessed from any point in the application. \n     */&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;setApplicationContext&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ApplicationContext applicationContext)&lt;/span&gt; {\n        ctx = applicationContext;       \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can put this code also in the main application class if you want.&lt;/p&gt;\n\n&lt;p&gt;Other classes can use it like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;MyBean&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;myBean&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (MyBean)SpringUtils.ctx.getBean(MyBean.class);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;What hasn&apos;t been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.&lt;/p&gt;\n\n&lt;p&gt;After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.&lt;/p&gt;\n\n&lt;p&gt;Using @PostConstruct solves that:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SpringBootApplication&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Application&lt;/span&gt; {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt; MyComponent comp;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyComponent&lt;/span&gt; {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt; ComponentDAO dao;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;MyComponent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// dao is null here&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@PostConstruct&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// dao is initialized here&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;One of the below will work :&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;The class where you are using @Autowired is not a Bean (You may have used new() somewhere I am sure).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Inside the SpringConfig class you have not mentioned the packages the Spring should look for @Component ( I am talking about @ComponentScan(basePackages&quot;here&quot;) )&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;If above two don&apos;t work .... start putting System.out.println() and figure out where it is going wrong.&lt;/p&gt;\n    ","\n&lt;p&gt;Another solution would be putting call:\n&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;&lt;br&gt;\nTo MileageFeeCalculator constructor like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Service&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MileageFeeCalculator&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; MileageRateService rateService; &lt;span class=&quot;hljs-comment&quot;&gt;// &amp;lt;--- will be autowired when constructor is called&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;MileageFeeCalculator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;)\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mileageCharge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; miles)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (miles * rateService.ratePerMile()); \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;If this is happening in a test class, make sure you haven&apos;t forgotten to annotate the class.&lt;/p&gt;\n\n&lt;p&gt;For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RunWith(SpringRunner.class)&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;@SpringBootTest&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyTests&lt;/span&gt; {\n    ....\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;Some time elapses...&lt;/h2&gt;\n\n&lt;p&gt;Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot; rel=&quot;nofollow noreferrer&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt; &lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//import org.junit.Test; // JUnit4&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.jupiter.api.Test; &lt;span class=&quot;hljs-comment&quot;&gt;// JUnit5&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@SpringBootTest&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyTests&lt;/span&gt; {\n    ....\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.&lt;/p&gt;\n    ","\n&lt;p&gt;I think you have missed to instruct spring to scan classes with annotation. &lt;/p&gt;\n\n&lt;p&gt;You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.\n&lt;br&gt; &lt;/p&gt;\n\n&lt;p&gt;Spring only injects instances of those classes which are either created as bean or marked with annotation.&lt;/p&gt;\n\n&lt;p&gt;Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.&lt;/p&gt;\n\n&lt;p&gt;Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.&lt;/p&gt;\n    ","\n&lt;p&gt;This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don&apos;t need to create object manually. Object creation will be taken care of by IoC container.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I don&apos;t know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[] {\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;common.xml&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;token.xml&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;pep-config.xml&quot;&lt;/span&gt; });\n    &lt;span class=&quot;hljs-type&quot;&gt;TokenInitializer&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;ti&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; context.getBean(TokenInitializer.class);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and in a &lt;code&gt;token.xml&lt;/code&gt; file I&apos;ve had a line&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;context:component-scan base-&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;package.path&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I noticed that the package.path does no longer exist, so I&apos;ve just dropped the line for good. &lt;/p&gt;\n\n&lt;p&gt;And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;bean id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;someAbac&quot;&lt;/span&gt; class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.pep.SomeAbac&quot;&lt;/span&gt; init-method=&lt;span class=&quot;hljs-string&quot;&gt;&quot;init&quot;&lt;/span&gt;/&amp;gt;\n&amp;lt;bean id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;settings&quot;&lt;/span&gt; class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.pep.Settings&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and SomeAbac class has a property declared as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Settings settings;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it&apos;s present and has some bs as a basePackage, everything works well. This line now looks like this: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;context:component-scan base-&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;some.shit&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and it works. May be someone can provide an explanation, but for me it&apos;s enough right now )&lt;/p&gt;\n    ","\n&lt;p&gt;You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Service&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ClassB&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; ClassA classA;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ClassB&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ClassA classA)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.classA = classA;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;useClassAObjectHere&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{\n        classA.callMethodOnObjectA();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;This is only valid in case of Unit test.&lt;/p&gt;\n\n&lt;p&gt;My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.&lt;/p&gt;\n\n&lt;p&gt;This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot; rel=&quot;nofollow noreferrer&quot;&gt;link&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Not entirely related to the question, but if the field injection is null, the constructor based injection will still work fine. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; OrderingClient orderingClient;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Sales2Client sales2Client;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Settings2Client settings2Client;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;BrinkWebTool&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(OrderingClient orderingClient, Sales2Client sales2Client, Settings2Client settings2Client)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.orderingClient = orderingClient;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.sales2Client = sales2Client;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.settings2Client = settings2Client;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In addition, don&apos;t inject to a &lt;code&gt;static&lt;/code&gt; member, it will be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;if you are using a &lt;code&gt;private&lt;/code&gt; method, it will be &lt;code&gt;null&lt;/code&gt;, try to change &lt;code&gt;private&lt;/code&gt; to &lt;code&gt;public&lt;/code&gt; in controller.&lt;/p&gt;\n    "],"129":["\n&lt;p&gt;It&apos;s said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can&apos;t say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn&apos;t happen&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you&apos;re passing an array by value, what you&apos;re really doing is copying a pointer - a pointer to the array&apos;s first element is copied to the parameter (whose type should also be a pointer the array element&apos;s type). This works due to array&apos;s decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array&apos;s size, because it essentially becomes a pointer.  This is why it&apos;s preferred (among other reasons) to pass by reference or pointer.&lt;/p&gt;\n\n&lt;p&gt;Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_value&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T* &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)   &lt;span class=&quot;hljs-comment&quot;&gt;// const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_pointer&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (*&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_reference&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (&amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won&apos;t since the array argument has decayed to be assigned to the parameter.&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;* p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;assert( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p) != &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a) );  &lt;span class=&quot;hljs-comment&quot;&gt;// sizes are not equal&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This lost ability is referred to as &quot;decay&quot;.&lt;/p&gt;\n\n&lt;p&gt;For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot; rel=&quot;noreferrer&quot;&gt;article about array decay&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a\n  string literal used to initialize an array, an expression that has type array of type is\n  converted to an expression with type pointer to type that points to the initial element of\n  the array object and is not an lvalue.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.&lt;/p&gt;\n\n&lt;p&gt;Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn&apos;t cause nearly as much confusion as the automatic conversion of array names to pointers.&lt;/p&gt;\n\n&lt;p&gt;The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An lvalue or rvalue of type array of N T or array of unknown bound of T &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue\n  of type pointer to T.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So the conversion doesn&apos;t &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).&lt;/p&gt;\n\n&lt;p&gt;This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I&apos;m not sure if there&apos;s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn&apos;t lying.&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.&lt;/p&gt;\n&lt;p&gt;Assume the following code:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;char &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[80]&lt;/span&gt;;\nstrcpy(&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;, &quot;This is &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt; test&quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;15-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *dest, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *src)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is not the same thing as an array pointer.  For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *ptr_to_first_element = a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; (*ptr_to_array)[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;] = &amp;amp;a;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-yaml&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;a[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_first_element[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;(*ptr_to_array)[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;*ptr_to_array[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_array[i]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they&apos;ll definitely do the wrong thing if you&apos;re expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; a == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_array == &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it&apos;s not converted to a pointer type.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;) == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *) == whatever the pointer size\n                                                  &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; your platform\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;&lt;/p&gt;\n\n&lt;p&gt;Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[]&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;(arr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (arr == ip) { &lt;span class=&quot;hljs-comment&quot;&gt;/* something; */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the array indexing syntax you are used to seeing, again, the arr is &apos;decayed to a pointer&apos;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;arr&lt;span class=&quot;hljs-selector-attr&quot;&gt;[42]&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(arr + 42); */&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(&amp;amp;(arr[0]) + 42); */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The only times an array doesn&apos;t decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the &apos;address of&apos; operator), or as a string literal used to initialize a character array.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s when array rots and is being pointed at ;-)&lt;/p&gt;\n\n&lt;p&gt;Actually, it&apos;s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;Array decaying means that, when an array is passed as a parameter to a function, it&apos;s treated identically to (&quot;decays to&quot;) a pointer.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int *array) {\n  &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big array is here, because it&apos;s decayed to a pointer.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%i\\n&quot;, sizeof(array));  &lt;span class=&quot;hljs-comment&quot;&gt;// always prints 4 on a 32-bit machine&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt; (int argc, char **argv) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;;\n    int *c;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(a)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 40 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(b)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 80 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(c)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 4 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There are two complications or exceptions to the above.&lt;/p&gt;\n\n&lt;p&gt;First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int array[][&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;])\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big the first dimension is.&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt;(int argc, char *argv[]) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[5]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    return &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h3&gt;tl;dr: When you use an array you&apos;ve defined, you&apos;ll actually be using a pointer to its first element.&lt;/h3&gt;\n&lt;p&gt;Thus:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;When you write &lt;code&gt;arr[idx]&lt;/code&gt; you&apos;re really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;functions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Sort-of exceptions to this rule:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Arrays are automatically passed by pointer in C. &lt;a href=&quot;https://stackoverflow.com/a/671348/7194773&quot;&gt;The rationale behind it can only be speculated&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a[5]&lt;/code&gt;, &lt;code&gt;int *a&lt;/code&gt; and &lt;code&gt;int (*a)[5]&lt;/code&gt; are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. &lt;code&gt;int a[5]&lt;/code&gt; is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. &lt;code&gt;int a[5]&lt;/code&gt; is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.&lt;/p&gt;\n&lt;p&gt;For instance, on &lt;code&gt;int (*a)[5]&lt;/code&gt;, the first dereference on &lt;code&gt;a&lt;/code&gt; will produce an &lt;code&gt;int *&lt;/code&gt; (so the same address, just a different type, and note not &lt;code&gt;int a[5]&lt;/code&gt;), and pointer arithmetic on &lt;code&gt;a&lt;/code&gt; i.e. &lt;code&gt;a+1&lt;/code&gt; or &lt;code&gt;*(a+1)&lt;/code&gt; will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the &lt;code&gt;int&lt;/code&gt;. On &lt;code&gt;int a[5]&lt;/code&gt; however, the first dereference will produce the &lt;code&gt;int&lt;/code&gt; and the pointer arithmetic will be in terms of the size of an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;To a function, you can only pass &lt;code&gt;int *&lt;/code&gt; and &lt;code&gt;int (*)[5]&lt;/code&gt;, and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass &lt;code&gt;a&lt;/code&gt; to a function and &lt;code&gt;a&lt;/code&gt; is defined &lt;code&gt;int a[5]&lt;/code&gt;, then as &lt;code&gt;a&lt;/code&gt; resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it&apos;s an actual address on the stack and is therefore clearly not the array itself.&lt;/p&gt;\n&lt;p&gt;You lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using &lt;code&gt;sizeof&lt;/code&gt;, which works on the type of the value being passed to it. The parameter type &lt;code&gt;int a[5]&lt;/code&gt; instead of &lt;code&gt;int *a&lt;/code&gt; is allowed but is treated as &lt;code&gt;int *&lt;/code&gt; instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to &lt;code&gt;int (*a)[5]&lt;/code&gt;, and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.&lt;/p&gt;\n    ","\n&lt;p&gt;I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test data&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// notice native array init with no copy aka &quot;=&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// not possible in C&lt;/span&gt;\n &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// simple, dangerous and useless&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;as_pointer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T* array)&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;); \n} ;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// for above const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but and also , minimum array size indication might be given too&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// this also does not stop the array decay into T *&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// thus size information is lost&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;by_value_no_size&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T array[&lt;span class=&quot;hljs-number&quot;&gt;0xFF&lt;/span&gt;])&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// decayed to a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size information is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but pointer is asked for&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pointer_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (*array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-comment&quot;&gt;// dealing with native pointer &lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// no C equivalent&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// array by reference&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reference_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (&amp;amp;array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// array is not a pointer here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// it is (almost) a container&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// most of the std:: lib algorithms &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// do work on array reference, for example&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// range for requires std::begin() and std::end()&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// on the type passed as range to iterate over&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;&amp;amp; elem : array )\n    {\n        cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; elem ;\n    }\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n     &lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;as_pointer&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;by_value_no_size&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;pointer_to_array&lt;/span&gt;(&amp;amp;specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;reference_to_array&lt;/span&gt;( specimen ) ;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.&lt;/p&gt;\n\n&lt;p&gt;Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.&lt;/p&gt;\n    ","\n&lt;p&gt;Try this code&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt; {\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in function: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer size: %d\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; *));\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in main: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    f(a);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.&lt;/p&gt;\n&lt;p&gt;You probably heard that &quot;arrays are pointers&quot;, but, this is not exactly true (the &lt;code&gt;sizeof&lt;/code&gt; inside &lt;code&gt;main&lt;/code&gt; prints the correct size). However, when passed, the array &lt;em&gt;decays&lt;/em&gt; to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.&lt;/p&gt;\n&lt;p&gt;In this case, the definition &lt;code&gt;void f(double a[10]&lt;/code&gt; is implicitly transformed by the compiler to &lt;code&gt;void f(double *a)&lt;/code&gt;. You could have equivalently declared the function argument directly as &lt;code&gt;*a&lt;/code&gt;. You could have even written &lt;code&gt;a[100]&lt;/code&gt; or &lt;code&gt;a[1]&lt;/code&gt;, instead of &lt;code&gt;a[10]&lt;/code&gt;, since it is never actually compiled that way (however, you shouldn&apos;t do it obviously, it would confuse the reader).&lt;/p&gt;\n    "],"130":["\n&lt;p&gt;(Background: I have some experience implementing C and C++ compilers.)&lt;/p&gt;\n\n&lt;p&gt;Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;sizeof x&lt;/code&gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a &lt;code&gt;sizeof&lt;/code&gt;-expression at runtime.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Allowing two-dimensional VLAs (&lt;code&gt;int A[x][y]&lt;/code&gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: &lt;code&gt;void foo(int n, int A[][*])&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Less importantly in the C++ world, but extremely important for C&apos;s target audience of embedded-systems programmers, declaring a VLA means chomping an &lt;em&gt;arbitrarily large&lt;/em&gt; chunk of your stack. This is a &lt;em&gt;guaranteed&lt;/em&gt; stack-overflow and crash. (Anytime you declare &lt;code&gt;int A[n]&lt;/code&gt;, you&apos;re implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;&lt;code&gt;n&lt;/code&gt; is definitely less than 1000 here&quot;, then you would just declare &lt;code&gt;int A[1000]&lt;/code&gt;. Substituting the 32-bit integer &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;1000&lt;/code&gt; is an admission that you have no idea what the behavior of your program ought to be.)&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Okay, so let&apos;s move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does but we&apos;ve really started to rely on it in ways that C has not. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;S&lt;/span&gt; { ... };\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; A[n];\nS&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(A)&amp;gt; s;  &lt;span class=&quot;hljs-comment&quot;&gt;// equivalently, S&amp;lt;int[n]&amp;gt; s;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If &lt;code&gt;n&lt;/code&gt; weren&apos;t a compile-time constant (i.e., if &lt;code&gt;A&lt;/code&gt; were of variably modified type), then what on earth would be the type of &lt;code&gt;S&lt;/code&gt;? Would &lt;code&gt;S&lt;/code&gt;&apos;s type &lt;em&gt;also&lt;/em&gt; be determined only at runtime?&lt;/p&gt;\n\n&lt;p&gt;What about this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;myfunc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T&amp;amp; t1, T&amp;amp; t2)&lt;/span&gt; &lt;/span&gt;{ ... };\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; A1[n1], A2[n2];\n&lt;span class=&quot;hljs-built_in&quot;&gt;myfunc&lt;/span&gt;(A1, A2);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The compiler must generate code for some instantiation of &lt;code&gt;myfunc&lt;/code&gt;. What should that code look like? How can we statically generate that code, if we don&apos;t know the type of &lt;code&gt;A1&lt;/code&gt; at compile time?&lt;/p&gt;\n\n&lt;p&gt;Worse, what if it turns out at runtime that &lt;code&gt;n1 != n2&lt;/code&gt;, so that &lt;code&gt;!std::is_same&amp;lt;decltype(A1), decltype(A2)&amp;gt;()&lt;/code&gt;? In that case, the call to &lt;code&gt;myfunc&lt;/code&gt; &lt;strong&gt;shouldn&apos;t even compile&lt;/strong&gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?&lt;/p&gt;\n\n&lt;p&gt;Basically, C++ is moving in the direction of pushing more and more decisions into &lt;em&gt;compile-time&lt;/em&gt;: template code generation, &lt;code&gt;constexpr&lt;/code&gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally &lt;em&gt;compile-time&lt;/em&gt; decisions (e.g. &lt;code&gt;sizeof&lt;/code&gt;) into the &lt;em&gt;runtime&lt;/em&gt;. With this in mind, does it really even make sense to expend any effort &lt;em&gt;trying&lt;/em&gt; to integrate C99-style VLAs into C++?&lt;/p&gt;\n\n&lt;p&gt;As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (&lt;code&gt;std::unique_ptr&amp;lt;int[]&amp;gt; A = new int[n];&lt;/code&gt; or &lt;code&gt;std::vector&amp;lt;int&amp;gt; A(n);&lt;/code&gt; being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully &lt;em&gt;this&lt;/em&gt; answer gives you a good idea of why C99-style VLAs were &lt;strong&gt;not&lt;/strong&gt; a good fit for C++  and not really even a good fit for C99. ;)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For more on the topic, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf&quot; rel=&quot;noreferrer&quot;&gt;N3810 &quot;Alternatives for Array Extensions&quot;&lt;/a&gt;, Bjarne Stroustrup&apos;s October 2013 paper on VLAs. Bjarne&apos;s POV is very different from mine; N3810 focuses more on finding a good C++ish &lt;em&gt;syntax&lt;/em&gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don&apos;t know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;A good blog post that hits many of these same points is &lt;a href=&quot;https://nullprogram.com/blog/2019/10/27/&quot; rel=&quot;noreferrer&quot;&gt;&quot;Legitimate Use of Variable Length Arrays&quot;&lt;/a&gt; (Chris Wellons, 2019-10-27).&lt;/p&gt;\n    ","\n&lt;p&gt;There recently was a discussion about this kicked off in usenet: &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa&quot; rel=&quot;noreferrer&quot;&gt;Why no VLAs in C++0x&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn&apos;t good. The argument is, if you know the size beforehand, you can use a static array. And if you don&apos;t know the size beforehand, you will write unsafe code. &lt;/p&gt;\n\n&lt;p&gt;C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for &lt;code&gt;new&lt;/code&gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn&apos;t escape the scope of the &lt;code&gt;new&lt;/code&gt; operator).&lt;/p&gt;\n\n&lt;p&gt;You can use &lt;code&gt;std::vector&lt;/code&gt;, but it is not quite the same, as it uses dynamic memory, and making it use one&apos;s own stack-allocator isn&apos;t exactly easy (alignment is an issue, too). It also doesn&apos;t solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html&quot; rel=&quot;noreferrer&quot;&gt;C++ Dynamic Array&lt;/a&gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it&apos;s not going to be part of C++0x, as far as I know.&lt;/p&gt;\n    ","\n&lt;p&gt;You could always use alloca() to allocate memory on the stack at runtime, if you wished:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *values = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *)&lt;span class=&quot;hljs-built_in&quot;&gt;alloca&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) * n);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Being allocated on the stack implies that it will automatically be freed when the stack unwinds.&lt;/p&gt;\n\n&lt;p&gt;Quick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.&lt;/p&gt;\n    ","\n&lt;p&gt;In my own work, I&apos;ve realized that every time I&apos;ve wanted something like variable-length automatic arrays or alloca(), I didn&apos;t really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn&apos;t incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.&lt;/p&gt;\n\n&lt;p&gt;I&apos;m not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn&apos;t standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It&apos;s been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.&lt;/p&gt;\n    ","\n&lt;p&gt;There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.&lt;/p&gt;\n\n&lt;p&gt;I think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I&apos;m working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.&lt;/p&gt;\n    ","\n&lt;p&gt;Seems it will be available in C++14:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays&quot; rel=&quot;noreferrer&quot;&gt;https://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Update: It did not make it into C++14.&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;This was considered for inclusion in C++/1x, &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#C99&quot; rel=&quot;noreferrer&quot;&gt;but was dropped&lt;/a&gt; (this is a correction to what I said earlier).&lt;/p&gt;\n\n&lt;p&gt;It would be less useful in C++ anyway since we already have &lt;code&gt;std::vector&lt;/code&gt; to fill this role.&lt;/p&gt;\n    ","\n&lt;p&gt;Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).&lt;/p&gt;\n\n&lt;p&gt;BTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup &lt;a href=&quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh&quot; rel=&quot;nofollow noreferrer&quot;&gt;comp.std.c++&lt;/a&gt; is the place to go to.&lt;/p&gt;\n    ","\n&lt;p&gt;Use std::vector for this. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; values;\nvalues.&lt;span class=&quot;hljs-built_in&quot;&gt;resize&lt;/span&gt;(n);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.&lt;/p&gt;\n    ","\n&lt;p&gt;C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.&lt;/p&gt;\n    ","\n&lt;p&gt;VLAs are a part of a larger family of Variably Modified types.\nThis family of types is very special because they have &lt;em&gt;runtime&lt;/em&gt; components.&lt;/p&gt;\n&lt;p&gt;The code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; A[n];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is seen by compiler as:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; T[n];\nT A;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that the runtime size of array is not bound to the variable &lt;code&gt;A&lt;/code&gt; but to the &lt;strong&gt;type&lt;/strong&gt; of the variable.&lt;/p&gt;\n&lt;p&gt;Nothing prevents one from making new variables of this type:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;T B,C,D;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or the pointers or arrays&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;T *p, Z[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Moreover, pointers allow one to create VLAs with dynamic storage.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;T *p = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(T));\n...\n&lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;(p);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What dispels a &lt;strong&gt;popular myth&lt;/strong&gt; that VLAs can only be allocated on stack.&lt;/p&gt;\n&lt;p&gt;Back to the question.&lt;/p&gt;\n&lt;p&gt;This runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.&lt;/p&gt;\n&lt;p&gt;C++ typing system is static, all types must be fully defined or deduced during &lt;em&gt;compilation&lt;/em&gt;.\nVM types are completed only during program &lt;em&gt;execution&lt;/em&gt;.\nAdditional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application\nare automatic VLAs (&lt;code&gt;int A[n];&lt;/code&gt;) which have an alternative in form of &lt;code&gt;std::vector&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;It a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.&lt;/p&gt;\n&lt;p&gt;In C one can simply write:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; A[n][n][n])&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; ++j)\n      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; k &amp;lt; n; ++k)\n        A[i][j][k] = i * j * k;\n}\n\n...\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;], B[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, A);\n&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, B);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now try to provide as efficient and elegant solution in C++.&lt;/p&gt;\n    ","\n&lt;p&gt;If you know the value at compile time you can do the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; X&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; values[X];\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.&lt;/p&gt;\n    ","\n&lt;p&gt;I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;varTest&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; iSz)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *varArray;\n    __asm {\n        sub esp, iSz       &lt;span class=&quot;hljs-comment&quot;&gt;// Create space on the stack for the variable array here&lt;/span&gt;\n        mov varArray, esp  &lt;span class=&quot;hljs-comment&quot;&gt;// save the end of it to our pointer&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Use the array called varArray here...  &lt;/span&gt;\n\n    __asm {\n        add esp, iSz       &lt;span class=&quot;hljs-comment&quot;&gt;// Variable array is no longer accessible after this point&lt;/span&gt;\n    } \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The dangers here are many but I&apos;ll explain a few:\n1. Changing the variable size half way through would kill the stack position\n2. Overstepping the array bounds would destroy other variables and possible code\n3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).\n4. Compiler specific (may have trouble moving between compilers).  I haven&apos;t tried so I really don&apos;t know.&lt;/p&gt;\n    "]},"page":"97","randomQuestions":[{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"What is the difference between __str__ and __repr__?","slug":"what-is-the-difference-between-__str__-and-__repr__-1657387738760"},{"title":"How to print a number with commas as thousands separators in JavaScript","slug":"how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"How to deal with SettingWithCopyWarning in Pandas","slug":"how-to-deal-with-settingwithcopywarning-in-pandas-1657384778377"},{"title":"JavaScript closure inside loops – simple practical example","slug":"javascript-closure-inside-loops-simple-practical-example-1657384278449"},{"title":"How to return DataSnapshot value as a result of a method?","slug":"how-to-return-datasnapshot-value-as-a-result-of-a-method-1657387538165"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"Disable same origin policy in Chrome","slug":"disable-same-origin-policy-in-chrome-1657387743804"},{"title":"What is a stack trace, and how can I use it to debug my application errors?","slug":"what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors-1657384750732"},{"title":"Useless use of cat?","slug":"useless-use-of-cat-1657388390794"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"Reference — What does this symbol mean in PHP?","slug":"reference-what-does-this-symbol-mean-in-php-1657384561666"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"},{"title":"Why do we always prefer using parameters in SQL statements?","slug":"why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476"},{"title":"Determine Whether Two Date Ranges Overlap","slug":"determine-whether-two-date-ranges-overlap-1657387924335"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"How do I access previous promise results in a .then() chain?","slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"},{"title":"Convert columns into rows with Pandas","slug":"convert-columns-into-rows-with-pandas-1657388374964"}]},"__N_SSG":true}