{"pageProps":{"data":{"count":610,"rows":[{"id":65,"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606","postType":"QUESTION","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","tags":[{"id":239,"name":"typename","slug":"typename","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","Questions_Tags":{"questionId":65,"tagId":239}},{"id":241,"name":"dependent-name","slug":"dependent-name","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","Questions_Tags":{"questionId":65,"tagId":241}}]},{"id":64,"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291","postType":"QUESTION","createdAt":"2022-07-09T16:34:24.000Z","updatedAt":"2022-07-09T16:34:24.000Z","tags":[{"id":236,"name":"var","slug":"var","createdAt":"2022-07-09T16:34:24.000Z","updatedAt":"2022-07-09T16:34:24.000Z","Questions_Tags":{"questionId":64,"tagId":236}}]},{"id":63,"title":"Can a local variable's memory be accessed outside its scope?","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386","postType":"QUESTION","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","tags":[{"id":229,"name":"memory-management","slug":"memory-management","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":229}},{"id":230,"name":"local-variables","slug":"local-variables","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":230}},{"id":231,"name":"dangling-pointer","slug":"dangling-pointer","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":231}}]},{"id":62,"title":"How can I fix 'android.os.NetworkOnMainThreadException'?","slug":"how-can-i-fix-'android.os.networkonmainthreadexception'-1657384454963","postType":"QUESTION","createdAt":"2022-07-09T16:34:15.000Z","updatedAt":"2022-07-09T16:34:15.000Z","tags":[{"id":226,"name":"android-networking","slug":"android-networking","createdAt":"2022-07-09T16:34:15.000Z","updatedAt":"2022-07-09T16:34:15.000Z","Questions_Tags":{"questionId":62,"tagId":226}},{"id":227,"name":"networkonmainthread","slug":"networkonmainthread","createdAt":"2022-07-09T16:34:15.000Z","updatedAt":"2022-07-09T16:34:15.000Z","Questions_Tags":{"questionId":62,"tagId":227}}]},{"id":61,"title":"What are the basic rules and idioms for operator overloading?","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752","postType":"QUESTION","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","tags":[{"id":221,"name":"operators","slug":"operators","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","Questions_Tags":{"questionId":61,"tagId":221}},{"id":222,"name":"operator-overloading","slug":"operator-overloading","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","Questions_Tags":{"questionId":61,"tagId":222}}]}]},"answers":{"61":["\n&lt;h1&gt;Common operators to overload&lt;/h1&gt;\n\n&lt;p&gt;Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operators code wont compile or your users code wont compile or your users code will behave surprisingly.&lt;/p&gt;\n\n&lt;h2&gt;Assignment Operator&lt;/h2&gt;\n\n&lt;p&gt;There&apos;s a lot to be said about assignment. However, most of it has already been said in &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan&apos;s famous Copy-And-Swap FAQ&lt;/a&gt;, so I&apos;ll skip most of it here, only listing the perfect assignment operator for reference:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;X&amp;amp; X::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(X rhs)\n{\n  &lt;span class=&quot;hljs-built_in&quot;&gt;swap&lt;/span&gt;(rhs);\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Bitshift Operators (used for Stream I/O)&lt;/h2&gt;\n\n&lt;p&gt;The bitshift operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.&lt;/p&gt;\n\n&lt;p&gt;The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.\nSince they change their left argument (they alter the streams state), they should, according to the rules of thumb, be implemented as members of their left operands type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard librarys stream types. Thats why you need to implement these operators for your own types as non-member functions.\nThe canonical forms of the two are these:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp; obj)\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// write obj to stream&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; os;\n}\n\nstd::istream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(std::istream&amp;amp; is, T&amp;amp; obj)\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// read obj from stream&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;hljs-comment&quot;&gt;/* no valid object of T found in stream */&lt;/span&gt; )\n    is.&lt;span class=&quot;hljs-built_in&quot;&gt;setstate&lt;/span&gt;(std::ios::failbit);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; is;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When implementing &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, manually setting the streams state is only necessary when the reading itself succeeded, but the result is not what would be expected.&lt;/p&gt;\n\n&lt;h2&gt;Function call operator&lt;/h2&gt;\n\n&lt;p&gt;The function call operator, used to create function objects, also known as functors, must be defined as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function, so it always has the implicit &lt;code&gt;this&lt;/code&gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s an example of the syntax:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Overloaded call operator&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string&amp;amp; y)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Usage:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;foo f;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.&lt;/p&gt;\n\n&lt;h2&gt;Comparison operators&lt;/h2&gt;\n\n&lt;p&gt;The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions&lt;sup&gt;1&lt;/sup&gt;. The unary prefix negation &lt;code&gt;!&lt;/code&gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)&lt;/p&gt;\n\n&lt;p&gt;The standard librarys algorithms (e.g. &lt;code&gt;std::sort()&lt;/code&gt;) and types (e.g. &lt;code&gt;std::map&lt;/code&gt;) will always only expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be present. However, the &lt;em&gt;users of your type will expect all the other operators to be present&lt;/em&gt;, too, so if you define &lt;code&gt;operator&amp;lt;&lt;/code&gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;==(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){ &lt;span class=&quot;hljs-comment&quot;&gt;/* do actual comparison */&lt;/span&gt; }\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;!=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;==(lhs,rhs);}\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;operator&lt;/span&gt;&amp;lt; (&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){ &lt;span class=&quot;hljs-comment&quot;&gt;/* do actual comparison */&lt;/span&gt; }\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;gt; (&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt; (rhs,lhs);}\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;operator&lt;/span&gt;&amp;lt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;gt; (lhs,rhs);}\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs){&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt; (lhs,rhs);}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.&lt;/p&gt;\n\n&lt;p&gt;The syntax for overloading the remaining binary boolean operators (&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) follows the rules of the comparison operators. However, it is &lt;em&gt;very&lt;/em&gt; unlikely that you would find a reasonable use case for these&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be &lt;code&gt;*this&lt;/code&gt;, needs to be &lt;code&gt;const&lt;/code&gt;, too. So a comparison operator implemented as a member function would have to have this signature:&lt;/sub&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs) &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* do actual comparison with *this */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;sub&gt;(Note the &lt;code&gt;const&lt;/code&gt; at the end.)&lt;/sub&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;It should be noted that the built-in version of &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.&lt;/sub&gt;&lt;/p&gt;\n\n&lt;h2&gt;Arithmetic Operators&lt;/h2&gt;\n\n&lt;h3&gt;Unary arithmetic operators&lt;/h3&gt;\n\n&lt;p&gt;The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\nHere is the canonical implementation of increment, decrement follows the same rules:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {\n  X&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;++()\n  {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// do actual increment&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;\n  }\n  X &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;++(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)\n  {\n    &lt;span class=&quot;hljs-function&quot;&gt;X &lt;span class=&quot;hljs-title&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;++();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tmp;\n  }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;\n\n&lt;p&gt;Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions. &lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do &lt;code&gt;i++&lt;/code&gt;, it becomes very hard to remember to do &lt;code&gt;++i&lt;/code&gt; instead when &lt;code&gt;i&lt;/code&gt; is not of a built-in type (plus you&apos;d have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.&lt;/sub&gt;&lt;/p&gt;\n\n&lt;h3&gt;Binary arithmetic operators&lt;/h3&gt;\n\n&lt;p&gt;For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide &lt;code&gt;+&lt;/code&gt;, also provide &lt;code&gt;+=&lt;/code&gt;, if you provide &lt;code&gt;-&lt;/code&gt;, do not omit &lt;code&gt;-=&lt;/code&gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator &lt;code&gt;+&lt;/code&gt; is implemented in terms of &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is implemented in terms of &lt;code&gt;-=&lt;/code&gt; etc.&lt;/p&gt;\n\n&lt;p&gt;According to our rules of thumb, &lt;code&gt;+&lt;/code&gt; and its companions should be non-members, while their compound assignment counterparts (&lt;code&gt;+=&lt;/code&gt; etc.), changing their left argument, should be a member. Here is the exemplary code for &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;; the other binary arithmetic operators should be implemented in the same way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {\n  X&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;+=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs)\n  {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// actual addition of rhs to *this&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;\n  }\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; X &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;+(X lhs, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; X&amp;amp; rhs)\n{\n  lhs += rhs;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lhs;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;operator+=&lt;/code&gt; returns its result per reference, while &lt;code&gt;operator+&lt;/code&gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of &lt;code&gt;operator+&lt;/code&gt;, there is no way around the copying. When you write &lt;code&gt;a + b&lt;/code&gt;, you expect the result to be a new value, which is why &lt;code&gt;operator+&lt;/code&gt; has to return a new value.&lt;sup&gt;3&lt;/sup&gt;\nAlso note that &lt;code&gt;operator+&lt;/code&gt; takes its left operand &lt;strong&gt;&lt;em&gt;by copy&lt;/em&gt;&lt;/strong&gt; rather than by const reference. The reason for this is the same as the reason giving for &lt;code&gt;operator=&lt;/code&gt; taking its argument per copy.&lt;/p&gt;\n\n&lt;p&gt;The bit manipulation operators &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; for output and input) there are very few reasonable use cases for overloading these.&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt;Again, the lesson to be taken from this is that &lt;code&gt;a += b&lt;/code&gt; is, in general, more efficient than &lt;code&gt;a + b&lt;/code&gt; and should be preferred if possible.&lt;/sub&gt;&lt;/p&gt;\n\n&lt;h2&gt;Array Subscripting&lt;/h2&gt;\n\n&lt;p&gt;The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.\nThe canonical form of providing these is this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {\n        value_type&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](index_type idx);\n  &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; value_type&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](index_type idx) &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Unless you do not want users of your class to be able to change data elements returned by &lt;code&gt;operator[]&lt;/code&gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.&lt;/p&gt;\n\n&lt;p&gt;If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {\n  value_type&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](index_type idx);\n  value_type  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](index_type idx) &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Operators for Pointer-like Types&lt;/h2&gt;\n\n&lt;p&gt;For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator &lt;code&gt;*&lt;/code&gt; and the binary infix pointer member access operator &lt;code&gt;-&amp;gt;&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;my_ptr&lt;/span&gt; {\n        value_type&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;*();\n  &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; value_type&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;*() &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;;\n        value_type* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;-&amp;gt;();\n  &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; value_type* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;-&amp;gt;() &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that these, too, will almost always need both a const and a non-const version.\nFor the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator, if &lt;code&gt;value_type&lt;/code&gt; is of &lt;code&gt;class&lt;/code&gt; (or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) type, another &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; is called recursively, until an &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; returns a value of non-class type.&lt;/p&gt;\n\n&lt;p&gt;The unary address-of operator should never be overloaded.&lt;/p&gt;\n\n&lt;p&gt;For &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; see &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;this question&lt;/a&gt;. It&apos;s rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;Conversion Operators&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;h1&gt;The Three Basic Rules of Operator Overloading in C++&lt;/h1&gt;\n&lt;p&gt;When it comes to operator overloading in C++, there are &lt;em&gt;&lt;strong&gt;three basic rules you should follow&lt;/strong&gt;&lt;/em&gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So youd better stick to the following rules.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.&lt;/strong&gt;&lt;/em&gt; &lt;em&gt;Instead, provide a function with a well-chosen name.&lt;/em&gt;&lt;br&gt;\nBasically, the first and foremost rule for overloading operators, at its very heart, says: &lt;em&gt;Dont do it&lt;/em&gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, &lt;em&gt;there are only a surprisingly few cases where operator overloading is appropriate&lt;/em&gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Always stick to the operators well-known semantics.&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;\nC++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary &lt;code&gt;+&lt;/code&gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression &lt;code&gt;a + b&lt;/code&gt; to subtract &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;b&lt;/code&gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Always provide all out of a set of related operations.&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;\n&lt;em&gt;Operators are related to each other&lt;/em&gt; and to other operations. If your type supports &lt;code&gt;a + b&lt;/code&gt;, users will expect to be able to call &lt;code&gt;a += b&lt;/code&gt;, too. If it supports prefix increment &lt;code&gt;++a&lt;/code&gt;, they will expect &lt;code&gt;a++&lt;/code&gt; to work as well. If they can check whether &lt;code&gt;a &amp;lt; b&lt;/code&gt;, they will most certainly expect to also to be able to check whether &lt;code&gt;a &amp;gt; b&lt;/code&gt;. If they can copy-construct your type, they expect assignment to work as well.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;p&gt;Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;The Decision between Member and Non-member&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h2&gt;The Decision between Member and Non-member&lt;/h2&gt;\n&lt;p&gt;The binary operators &lt;code&gt;=&lt;/code&gt; (assignment), &lt;code&gt;[]&lt;/code&gt; (array subscription), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access), as well as the n-ary &lt;code&gt;()&lt;/code&gt; (function call) operator, must always be implemented as &lt;em&gt;&lt;strong&gt;member functions&lt;/strong&gt;&lt;/em&gt;, because the syntax of the language requires them to.&lt;/p&gt;\n&lt;p&gt;Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, whose left operands are stream classes from the standard library which you cannot change.&lt;/p&gt;\n&lt;p&gt;For all operators where you have to choose to either implement them as a member function or a non-member function, &lt;em&gt;&lt;strong&gt;use the following rules of thumb&lt;/strong&gt;&lt;/em&gt; to decide:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;If it is a &lt;em&gt;&lt;strong&gt;unary operator&lt;/strong&gt;&lt;/em&gt;, implement it as a &lt;em&gt;&lt;strong&gt;member&lt;/strong&gt;&lt;/em&gt; function.&lt;/li&gt;\n&lt;li&gt;If a binary operator treats &lt;em&gt;&lt;strong&gt;both operands equally&lt;/strong&gt;&lt;/em&gt; (it leaves them unchanged), implement this operator as a &lt;em&gt;&lt;strong&gt;non-member&lt;/strong&gt;&lt;/em&gt; function.&lt;/li&gt;\n&lt;li&gt;If a binary operator does &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; treat both of its operands &lt;em&gt;&lt;strong&gt;equally&lt;/strong&gt;&lt;/em&gt; (usually it will change its left operand), it might be useful to make it a &lt;em&gt;&lt;strong&gt;member&lt;/strong&gt;&lt;/em&gt; function of its left operands type, if it has to access the operand&apos;s private parts.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Of course, as with all rules of thumb, there are exceptions. If you have a type&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Month&lt;/span&gt; {Jan, Feb, ..., Nov, Dec}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And &lt;code&gt;operator&amp;lt;()&lt;/code&gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.&lt;/p&gt;\n&lt;p&gt;(However, &lt;em&gt;if&lt;/em&gt; you make an exception, do not forget the issue of &lt;code&gt;const&lt;/code&gt;-ness for the operand that, for member functions, becomes the implicit &lt;code&gt;this&lt;/code&gt; argument. If the operator as a non-member function would take its left-most argument as a &lt;code&gt;const&lt;/code&gt; reference, the same operator as a member function needs to have a &lt;code&gt;const&lt;/code&gt; at the end to make &lt;code&gt;*this&lt;/code&gt; a &lt;code&gt;const&lt;/code&gt; reference.)&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common operators to overload&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h1&gt;The General Syntax of operator overloading in C++&lt;/h1&gt;\n&lt;p&gt;You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types&lt;sup&gt;1&lt;/sup&gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.&lt;/p&gt;\n&lt;p&gt;Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: &lt;code&gt;.&lt;/code&gt; &lt;code&gt;::&lt;/code&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; and the only ternary operator in C++, &lt;code&gt;?:&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Among the operators that can be overloaded in C++ are these:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;arithmetic operators: &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt; (all binary infix); &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; (unary prefix); &lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; (unary prefix and postfix)&lt;/li&gt;\n&lt;li&gt;bit manipulation: &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (all binary infix); &lt;code&gt;~&lt;/code&gt; (unary prefix)&lt;/li&gt;\n&lt;li&gt;boolean algebra: &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (all binary infix); &lt;code&gt;!&lt;/code&gt; (unary prefix)&lt;/li&gt;\n&lt;li&gt;memory management: &lt;code&gt;new&lt;/code&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;delete[]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;implicit conversion operators&lt;/li&gt;\n&lt;li&gt;miscellany: &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;code&gt;-&amp;gt;*&lt;/code&gt; &lt;code&gt;,&lt;/code&gt;  (all binary infix); &lt;code&gt;*&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; (all unary prefix) &lt;code&gt;()&lt;/code&gt; (function call, n-ary infix)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;However, the fact that you &lt;em&gt;can&lt;/em&gt; overload all of these does not mean you &lt;em&gt;should&lt;/em&gt; do so. See the basic rules of operator overloading.&lt;/p&gt;\n&lt;p&gt;In C++, operators are overloaded in the form of &lt;em&gt;&lt;strong&gt;functions with special names&lt;/strong&gt;&lt;/em&gt;. As with other functions, overloaded operators can generally be implemented either as a &lt;em&gt;&lt;strong&gt;member function of their left operand&apos;s type&lt;/strong&gt;&lt;/em&gt; or as &lt;em&gt;&lt;strong&gt;non-member functions&lt;/strong&gt;&lt;/em&gt;. Whether you are free to choose or bound to use either one depends on several criteria.&lt;sup&gt;2&lt;/sup&gt; A unary operator &lt;code&gt;@&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;, applied to an object x, is invoked either as &lt;code&gt;operator@(x)&lt;/code&gt; or as &lt;code&gt;x.operator@()&lt;/code&gt;. A binary infix operator &lt;code&gt;@&lt;/code&gt;, applied to the objects &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, is called either as &lt;code&gt;operator@(x,y)&lt;/code&gt; or as &lt;code&gt;x.operator@(y)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;Operators that are implemented as non-member functions are sometimes friend of their operands type.&lt;/p&gt;\n&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;The term user-defined might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.&lt;/sub&gt;&lt;/p&gt;\n&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;This is covered in &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;a later part&lt;/a&gt; of this FAQ.&lt;/sub&gt;&lt;/p&gt;\n&lt;p&gt;&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt;The &lt;code&gt;@&lt;/code&gt; is not a valid operator in C++ which is why I use it as a placeholder.&lt;/sub&gt;&lt;/p&gt;\n&lt;p&gt;&lt;sup&gt;4&lt;/sup&gt; &lt;sub&gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.&lt;/sub&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;The Three Basic Rules of Operator Overloading in C++&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h1&gt;Conversion Operators (also known as User Defined Conversions)&lt;/h1&gt;\n\n&lt;p&gt;In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.&lt;/p&gt;\n\n&lt;h2&gt;Implicit Conversion Operators (C++98/C++03 and C++11)&lt;/h2&gt;\n\n&lt;p&gt;An implicit conversion operator allows the compiler to implicitly convert (like the conversion between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;) the value of a user-defined type to some other type.&lt;/p&gt;\n\n&lt;p&gt;The following is a simple class with an implicit conversion operator:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;my_string&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*() &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; data_;} &lt;span class=&quot;hljs-comment&quot;&gt;// This is the conversion operator&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n  &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* data_;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;\n\nmy_string str;\n&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(str); &lt;span class=&quot;hljs-comment&quot;&gt;// same as f( str.operator const char*() )&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isnt expected to. In the following code, &lt;code&gt;void f(const char*)&lt;/code&gt; will be called because &lt;code&gt;my_string()&lt;/code&gt; is not an &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt;, so the first does not match:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(my_string&amp;amp;)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;my_string&lt;/span&gt;());\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didnt suspect.  These problems can be mitigated by explicit conversion operators.&lt;/p&gt;\n\n&lt;h2&gt;Explicit Conversion Operators (C++11)&lt;/h2&gt;\n\n&lt;p&gt;Unlike implicit conversion operators, explicit conversion operators will never kick in when you don&apos;t expect them to.  The following is a simple class with an explicit conversion operator:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;my_string&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-keyword&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*() &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; data_;}\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n  &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* data_;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notice the &lt;code&gt;explicit&lt;/code&gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:&lt;/p&gt;\n\n&lt;pre&gt;prog.cpp: In function int main():\nprog.cpp:15:18: error: no matching function for call to f(my_string)\nprog.cpp:15:18: note: candidates are:\nprog.cpp:11:10: note: void f(my_string&amp;amp;)\nprog.cpp:11:10: note:   no known conversion for argument 1 from my_string to my_string&amp;amp;\nprog.cpp:12:10: note: void f(const char*)\nprog.cpp:12:10: note:   no known conversion for argument 1 from my_string to const char*\n&lt;/pre&gt;\n\n&lt;p&gt;To invoke the explicit cast operator, you have to use &lt;code&gt;static_cast&lt;/code&gt;, a C-style cast, or a constructor style cast ( i.e. &lt;code&gt;T(value)&lt;/code&gt; ).  &lt;/p&gt;\n\n&lt;p&gt;However, there is one exception to this:  The compiler is allowed to implicitly convert to &lt;code&gt;bool&lt;/code&gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to &lt;code&gt;bool&lt;/code&gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).  &lt;/p&gt;\n\n&lt;p&gt;Because the compiler will not cast &quot;past&quot; &lt;code&gt;bool&lt;/code&gt;, explicit conversion operators now remove the need for the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot; rel=&quot;noreferrer&quot;&gt;Safe Bool idiom&lt;/a&gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.&lt;/p&gt;\n\n&lt;p&gt;Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h1&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators&lt;/h1&gt;\n&lt;p&gt;&lt;sup&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; This only deals with the &lt;em&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/em&gt; of overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, not with the &lt;em&gt;&lt;strong&gt;implementation&lt;/strong&gt;&lt;/em&gt; of such overloaded operators. I think that the semantics of overloading &lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt;&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; deserve their own FAQ&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;, within the topic of operator overloading I can never do it justice.&lt;/sup&gt;&lt;/p&gt;\n&lt;h2&gt;Basics&lt;/h2&gt;\n&lt;p&gt;In C++, when you write a &lt;em&gt;&lt;strong&gt;new expression&lt;/strong&gt;&lt;/em&gt; like &lt;code&gt;new T(arg)&lt;/code&gt; two things happen when this expression is evaluated: First &lt;em&gt;&lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt; is invoked to obtain raw memory, and then the appropriate constructor of &lt;code&gt;T&lt;/code&gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to &lt;code&gt;operator delete&lt;/code&gt;.&lt;br&gt;\nC++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;The first of the basic rules of operator overloading  &lt;em&gt;dont do it&lt;/em&gt;  applies especially to overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;. Almost the only reasons to overload these operators are &lt;em&gt;&lt;strong&gt;performance problems&lt;/strong&gt;&lt;/em&gt; and &lt;em&gt;&lt;strong&gt;memory constraints&lt;/strong&gt;&lt;/em&gt;, and in many cases, other actions, like &lt;em&gt;changes to the algorithms&lt;/em&gt; used, will provide a much &lt;em&gt;&lt;strong&gt;higher cost/gain ratio&lt;/strong&gt;&lt;/em&gt; than attempting to tweak memory management.&lt;/p&gt;\n&lt;p&gt;The C++ standard library comes with a set of predefined &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators. The most important ones are these:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::bad_alloc)&lt;/span&gt;&lt;/span&gt;; \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; \n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[](std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;throw&lt;/span&gt;(std::bad_alloc); \n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[](&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*) &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt;(); \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will &lt;em&gt;&lt;strong&gt;not overload, but replace&lt;/strong&gt;&lt;/em&gt; the ones from the standard library.&lt;br&gt;\nIf you overload &lt;code&gt;operator new&lt;/code&gt;, you should always also overload the matching &lt;code&gt;operator delete&lt;/code&gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the &lt;code&gt;operator delete&lt;/code&gt; matching the &lt;code&gt;operator new&lt;/code&gt; that was called to allocate the memory to create the object in. If you do not provide a matching &lt;code&gt;operator delete&lt;/code&gt;, the default one is called, which is almost always wrong.&lt;br&gt;\nIf you overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, you should consider overloading the array variants, too.&lt;/p&gt;\n&lt;h2&gt;Placement &lt;code&gt;new&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;C++ allows new and delete operators to take additional arguments.&lt;br&gt;\nSo-called placement new allows you to create an object at a certain address which is passed to:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; };\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buffer[ &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(X) ];\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{ \n  X* p = &lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt;(buffer) &lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;(&lt;span class=&quot;hljs-comment&quot;&gt;/*...*/&lt;/span&gt;);\n  &lt;span class=&quot;hljs-comment&quot;&gt;// ... &lt;/span&gt;\n  p-&amp;gt;~&lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// call destructor &lt;/span&gt;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The standard library comes with the appropriate overloads of the new and delete operators for this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* p)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::bad_alloc)&lt;/span&gt;&lt;/span&gt;; \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* p,&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; \n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[](std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* p) &lt;span class=&quot;hljs-built_in&quot;&gt;throw&lt;/span&gt;(std::bad_alloc); \n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[](&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* p,&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*) &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt;(); \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that, in the example code for placement new given above, &lt;code&gt;operator delete&lt;/code&gt; is never called, unless the constructor of X throws an exception.&lt;/p&gt;\n&lt;p&gt;You can also overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword &lt;code&gt;new&lt;/code&gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.&lt;/p&gt;\n&lt;h2&gt;Class-specific new and delete&lt;/h2&gt;\n&lt;p&gt;Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;my_class&lt;/span&gt; { \n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: \n    &lt;span class=&quot;hljs-comment&quot;&gt;// ... &lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[](std::&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt;);\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;[](&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;*);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...  &lt;/span&gt;\n}; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Overloaded thus, new and delete behave like static member functions. For objects of &lt;code&gt;my_class&lt;/code&gt;, the &lt;code&gt;std::size_t&lt;/code&gt; argument will always be &lt;code&gt;sizeof(my_class)&lt;/code&gt;. However, these operators are also called for dynamically allocated objects of &lt;em&gt;&lt;strong&gt;derived classes&lt;/strong&gt;&lt;/em&gt;, in which case it might be greater than that.&lt;/p&gt;\n&lt;h2&gt;Global new and delete&lt;/h2&gt;\n&lt;p&gt;To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/34953523/overloading-the-insertion-operator-questions-theoretical&quot;&gt;Why can&apos;t &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for streaming objects to &lt;code&gt;std::cout&lt;/code&gt; or to a file be a member function?&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Let&apos;s say you have:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a;\n   &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; b;\n\n   std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; out) &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n   {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; out &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; &amp;lt;&amp;lt; b;\n   }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Given that, you cannot use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Foo f = {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20.0&lt;/span&gt;};\nstd::cout &amp;lt;&amp;lt; f;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is overloaded as a member function of &lt;code&gt;Foo&lt;/code&gt;, the LHS of the operator must be a &lt;code&gt;Foo&lt;/code&gt; object. Which means, you will be required to use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Foo f = {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20.0&lt;/span&gt;};\nf &amp;lt;&amp;lt; std::cout\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is very non-intuitive.&lt;/p&gt;\n\n&lt;p&gt;If you define it as a non-member function,&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a;\n   &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; b;\n};\n\nstd::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; out, Foo &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; f)\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; out &amp;lt;&amp;lt; f.a &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; &amp;lt;&amp;lt; f.b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You will be able to use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Foo f = {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20.0&lt;/span&gt;};\nstd::cout &amp;lt;&amp;lt; f;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is very intuitive.&lt;/p&gt;\n    ","\n&lt;p&gt;Making it short and simple, I&apos;ll be referring to some points, which I had come over the past week as I was learning Python and C++, oops and other things, so it goes as follows:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;The Arity of the operator can not be modified further than to what it is!&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Overloaded operators can only have one default argument which the function call operator rest it cannot.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Only built in operator can be overloaded, rest can&apos;t!&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;For more info, you can refer to the following link, which redirects you to the documentation provided by GeekforGeeks.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-39/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.geeksforgeeks.org/g-fact-39/&lt;/a&gt;&lt;/p&gt;\n    "],"62":["\n&lt;p&gt;&lt;strong&gt;NOTE : AsyncTask was deprecated in API level 30.&lt;br&gt;\n&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask&quot; rel=&quot;noreferrer&quot;&gt;AsyncTask | Android Developers&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This exception is thrown when an application attempts to perform a networking operation on its main thread. Run your code in &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;AsyncTask&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RetrieveFeedTask&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;AsyncTask&lt;/span&gt;&amp;lt;String, Void, RSSFeed&amp;gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Exception exception;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; RSSFeed &lt;span class=&quot;hljs-title function_&quot;&gt;doInBackground&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String... urls)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-type&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;URL&lt;/span&gt;(urls[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n            &lt;span class=&quot;hljs-type&quot;&gt;SAXParserFactory&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; SAXParserFactory.newInstance();\n            &lt;span class=&quot;hljs-type&quot;&gt;SAXParser&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parser&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; factory.newSAXParser();\n            &lt;span class=&quot;hljs-type&quot;&gt;XMLReader&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;xmlreader&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; parser.getXMLReader();\n            &lt;span class=&quot;hljs-type&quot;&gt;RssHandler&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;theRSSHandler&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RssHandler&lt;/span&gt;();\n            xmlreader.setContentHandler(theRSSHandler);\n            &lt;span class=&quot;hljs-type&quot;&gt;InputSource&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;InputSource&lt;/span&gt;(url.openStream());\n            xmlreader.parse(is);\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; theRSSHandler.getFeed();\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.exception = e;\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {\n            is.close();\n        }\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onPostExecute&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RSSFeed feed)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// &lt;span class=&quot;hljs-doctag&quot;&gt;TODO:&lt;/span&gt; check this.exception&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// &lt;span class=&quot;hljs-doctag&quot;&gt;TODO:&lt;/span&gt; do something with the feed&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;How to execute the task:&lt;/p&gt;\n&lt;p&gt;In &lt;code&gt;MainActivity.java&lt;/code&gt; file you can add this line within your &lt;code&gt;oncreate()&lt;/code&gt; method&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RetrieveFeedTask&lt;/span&gt;().execute(urlToRssFeed);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Don&apos;t forget to add this to &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;uses-permission android:name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;android.permission.INTERNET&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;You should almost always run network operations on a thread or as an asynchronous task.&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;But it &lt;em&gt;is&lt;/em&gt; possible to remove this restriction and you override the default behavior, if you are willing to accept the consequences.&lt;/p&gt;\n&lt;p&gt;Add:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;StrictMode.&lt;span class=&quot;hljs-type&quot;&gt;ThreadPolicy&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;policy&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StrictMode&lt;/span&gt;.ThreadPolicy.Builder().permitAll().build();\n\nStrictMode.setThreadPolicy(policy);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In your class,&lt;/p&gt;\n&lt;p&gt;and&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Add&lt;/em&gt; this permission in the Android &lt;em&gt;manifest.xml&lt;/em&gt; file:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;uses-permission android:name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;android.permission.INTERNET&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Consequences:&lt;/p&gt;\n&lt;p&gt;Your app will (in areas of spotty Internet connection) become unresponsive and lock up, the user perceives slowness and has to do a force kill, and you risk the activity manager killing your app and telling the user that the app has stopped.&lt;/p&gt;\n&lt;p&gt;Android has some good tips on good programming practices to design for responsiveness:\n&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot; rel=&quot;noreferrer&quot;&gt;NetworkOnMainThreadException | Android Developers&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I solved this problem using a new &lt;code&gt;Thread&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;() {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;  {\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Your code goes here&lt;/span&gt;\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {\n            e.printStackTrace();\n        }\n    }\n});\n\nthread.start(); \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;The accepted answer has some significant downsides. It is not advisable to use AsyncTask for networking unless you &lt;em&gt;really&lt;/em&gt; know what you are doing. Some of the down-sides include:&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;AsyncTask&apos;s created as non-static inner classes have an implicit reference to the enclosing Activity object, its context, and the entire View hierarchy created by that activity. This reference prevents the Activity from being garbage collected until the AsyncTask&apos;s background work completes. If the user&apos;s connection is slow, and/or the download is large, these short-term memory leaks can become a problem - for example, if the orientation changes several times (and you don&apos;t cancel the executing tasks), or the user navigates away from the Activity.&lt;/li&gt;\n&lt;li&gt;AsyncTask has different execution characteristics depending on the platform it executes on: prior to API level 4 AsyncTasks execute serially on a single background thread; from API level 4 through API level 10, AsyncTasks execute on a pool of up to 128 threads; from API level 11 onwards AsyncTask executes serially on a single background thread (unless you use the overloaded &lt;code&gt;executeOnExecutor&lt;/code&gt; method and supply an alternative executor). Code that works fine when running serially on ICS may break when executed concurrently on Gingerbread, say if you have inadvertent order-of-execution dependencies.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;If you want to avoid short-term memory leaks, have well-defined execution characteristics across all platforms, and have a base to build really robust network handling, you might want to consider:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Using a library that does a nice job of this for you - there&apos;s a nice comparison of networking libs in &lt;a href=&quot;https://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley&quot;&gt;this question&lt;/a&gt;, or&lt;/li&gt;\n&lt;li&gt;Using a &lt;code&gt;Service&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt; instead, perhaps with a &lt;code&gt;PendingIntent&lt;/code&gt; to return the result via the Activity&apos;s &lt;code&gt;onActivityResult&lt;/code&gt; method.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=&quot;intentservice-approach&quot;&gt;&lt;em&gt;IntentService approach&lt;/em&gt;&lt;/h2&gt;\n&lt;p&gt;Downsides:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;More code and complexity than &lt;code&gt;AsyncTask&lt;/code&gt;, though not as much as you might think&lt;/li&gt;\n&lt;li&gt;Will queue requests and run them on a &lt;em&gt;single&lt;/em&gt; background thread. You can easily control this by replacing &lt;code&gt;IntentService&lt;/code&gt; with an equivalent &lt;code&gt;Service&lt;/code&gt; implementation, perhaps like &lt;a href=&quot;https://github.com/steveliles/AsyncAndroid/blob/master/AsyncAndroid/src/main/java/com/packt/asyncandroid/chapter6/ConcurrentIntentService.java&quot; rel=&quot;noreferrer&quot;&gt;this one&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;Um, I can&apos;t think of any others right now actually&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Upsides:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Avoids the short-term memory leak problem&lt;/li&gt;\n&lt;li&gt;If your activity restarts while network operations are in-flight it can still receive the result of the download via its &lt;code&gt;onActivityResult&lt;/code&gt; method&lt;/li&gt;\n&lt;li&gt;A better platform than AsyncTask to build and reuse robust networking code. Example: if you need to do an important upload, you could do it from &lt;code&gt;AsyncTask&lt;/code&gt; in an &lt;code&gt;Activity&lt;/code&gt;, but if the user context-switches out of the app to take a phone call, the system &lt;em&gt;may&lt;/em&gt; kill the app before the upload completes. It is &lt;em&gt;less likely&lt;/em&gt; to kill an application with an active &lt;code&gt;Service&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;If you use your own concurrent version of &lt;code&gt;IntentService&lt;/code&gt; (like the one I linked above) you can control the level of concurrency via the &lt;code&gt;Executor&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=&quot;implementation-summary&quot;&gt;&lt;em&gt;Implementation summary&lt;/em&gt;&lt;/h2&gt;\n&lt;p&gt;You can implement an &lt;code&gt;IntentService&lt;/code&gt; to perform downloads on a single background thread quite easily.&lt;/p&gt;\n&lt;p&gt;Step 1: Create an &lt;code&gt;IntentService&lt;/code&gt; to perform the download. You can tell it what to download via &lt;code&gt;Intent&lt;/code&gt; extras, and pass it a &lt;code&gt;PendingIntent&lt;/code&gt; to use to return the result to the &lt;code&gt;Activity&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; android.app.IntentService;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; android.app.PendingIntent;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; android.content.Intent;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; android.util.Log;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.InputStream;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.net.MalformedURLException;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.net.URL;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DownloadIntentService&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;IntentService&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;TAG&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; DownloadIntentService.class.getSimpleName();\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;PENDING_RESULT_EXTRA&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;pending_result&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;URL_EXTRA&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;url&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;RSS_RESULT_EXTRA&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;url&quot;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;RESULT_CODE&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;INVALID_URL_CODE&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;ERROR_CODE&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; IllustrativeRSSParser parser;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;DownloadIntentService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;(TAG);\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// make one and reuse, in the case where more than one intent is queued&lt;/span&gt;\n        parser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;IllustrativeRSSParser&lt;/span&gt;();\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onHandleIntent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Intent intent)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;PendingIntent&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;reply&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; intent.getParcelableExtra(PENDING_RESULT_EXTRA);\n        &lt;span class=&quot;hljs-type&quot;&gt;InputStream&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n                &lt;span class=&quot;hljs-type&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;URL&lt;/span&gt;(intent.getStringExtra(URL_EXTRA));\n                &lt;span class=&quot;hljs-type&quot;&gt;IllustrativeRSS&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;rss&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; parser.parse(in = url.openStream());\n\n                &lt;span class=&quot;hljs-type&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Intent&lt;/span&gt;();\n                result.putExtra(RSS_RESULT_EXTRA, rss);\n\n                reply.send(&lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;, RESULT_CODE, result);\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (MalformedURLException exc) {\n                reply.send(INVALID_URL_CODE);\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception exc) {\n                &lt;span class=&quot;hljs-comment&quot;&gt;// could do better by treating the different sax/xml exceptions individually&lt;/span&gt;\n                reply.send(ERROR_CODE);\n            }\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (PendingIntent.CanceledException exc) {\n            Log.i(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;reply cancelled&quot;&lt;/span&gt;, exc);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Step 2: Register the service in the manifest:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;service\n        android:name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;.DownloadIntentService&quot;&lt;/span&gt;\n        android:exported=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Step 3: Invoke the service from the Activity, passing a PendingResult object which the Service will use to return the result:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;PendingIntent&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;pendingResult&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; createPendingResult(\n    RSS_DOWNLOAD_REQUEST_CODE, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Intent&lt;/span&gt;(), &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;intent&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Intent&lt;/span&gt;(getApplicationContext(), DownloadIntentService.class);\nintent.putExtra(DownloadIntentService.URL_EXTRA, URL);\nintent.putExtra(DownloadIntentService.PENDING_RESULT_EXTRA, pendingResult);\nstartService(intent);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Step 4: Handle the result in onActivityResult:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onActivityResult&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; requestCode, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; resultCode, Intent data)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (requestCode == RSS_DOWNLOAD_REQUEST_CODE) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; (resultCode) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; DownloadIntentService.INVALID_URL_CODE:\n                handleInvalidURL();\n                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; DownloadIntentService.ERROR_CODE:\n                handleError(data);\n                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; DownloadIntentService.RESULT_CODE:\n                handleRSS(data);\n                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n        }\n        handleRSS(data);\n    }\n    &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;.onActivityResult(requestCode, resultCode, data);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A GitHub project containing a complete working Android Studio/&lt;a href=&quot;https://en.wikipedia.org/wiki/Gradle&quot; rel=&quot;noreferrer&quot;&gt;Gradle&lt;/a&gt; project is available &lt;a href=&quot;https://github.com/steveliles/Android-Download-Service-Example&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;You cannot perform network &lt;a href=&quot;http://en.wikipedia.org/wiki/Input/output&quot; rel=&quot;noreferrer&quot;&gt;I/O&lt;/a&gt; on the UI thread on &lt;a href=&quot;https://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot; rel=&quot;noreferrer&quot;&gt;Honeycomb&lt;/a&gt;. Technically, it &lt;em&gt;is&lt;/em&gt; possible on earlier versions of Android, but it is a really bad idea as it will cause your app to stop responding, and can result in the OS killing your app for being badly behaved. You&apos;ll need to run a background process or use AsyncTask to perform your network transaction on a background thread.&lt;/p&gt;\n\n&lt;p&gt;There is an article about &lt;a href=&quot;http://android-developers.blogspot.com/2009/05/painless-threading.html&quot; rel=&quot;noreferrer&quot;&gt;Painless Threading&lt;/a&gt; on the Android developer site which is a good introduction to this, and it will provide you with a much better depth of an answer than can be realistically provided here.&lt;/p&gt;\n    ","\n&lt;p&gt;There are two solutions of this problem.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Don&apos;t use a network call in the main UI thread. Use an async task for that.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Write the below code into your MainActivity file after &lt;em&gt;setContentView(R.layout.activity_main);&lt;/em&gt;:&lt;/p&gt;\n&lt;p&gt;if (android.os.Build.VERSION.SDK_INT &amp;gt; 9) {\nStrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\nStrictMode.setThreadPolicy(policy);\n}&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;And the below import statement into your Java file.&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; android.os.StrictMode;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Do the network actions on another thread.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;(){\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Do network action in this function&lt;/span&gt;\n    }\n}).start();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And add this to file &lt;em&gt;AndroidManifest.xml&lt;/em&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;uses-permission android:name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;android.permission.INTERNET&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;Do not use strictMode (only in debug mode)&lt;/li&gt;\n&lt;li&gt;Do not change SDK version&lt;/li&gt;\n&lt;li&gt;Do not use a separate thread&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Use Service or AsyncTask&lt;/p&gt;\n\n&lt;p&gt;See also Stack&amp;nbsp;Overflow question:&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18297485/i-get-an-android-os-networkonmainthreadexception-sending-an-email-from-android/18297516#18297516&quot;&gt;android.os.NetworkOnMainThreadException sending an email from Android&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;You disable the strict mode using following code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (android.os.Build.VERSION.SDK_INT &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;) {\n    StrictMode.&lt;span class=&quot;hljs-type&quot;&gt;ThreadPolicy&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;policy&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; \n        &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StrictMode&lt;/span&gt;.ThreadPolicy.Builder().permitAll().build();\n    StrictMode.setThreadPolicy(policy);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;This is not recommended&lt;/strong&gt;: use the &lt;code&gt;AsyncTask&lt;/code&gt; interface.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://askanydifference.com/how-to-fix-android-os-networkonmainthreadexception/&quot; rel=&quot;noreferrer&quot;&gt;Full code for both the methods&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Network-based operations cannot be run on the main thread. You need to run all network-based tasks on a child thread or implement AsyncTask.&lt;/p&gt;\n\n&lt;p&gt;This is how you run a task in a child thread:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;(){\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Your implementation goes here&lt;/span&gt;\n        } \n        &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}).start();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Put your code inside:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;(){\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Your implementation&lt;/span&gt;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}).start();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DemoTask&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;AsyncTask&lt;/span&gt;&amp;lt;Void, Void, Void&amp;gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; Void &lt;span class=&quot;hljs-title function_&quot;&gt;doInBackground&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Void... arg0)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;//Your implementation&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onPostExecute&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Void result)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// &lt;span class=&quot;hljs-doctag&quot;&gt;TODO:&lt;/span&gt; do something with the feed&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This happens in Android 3.0 and above. From Android 3.0 and above, they have restricted using network operations (functions that access the Internet) from running in the main thread/UI thread (what spawns from your on create and on resume methods in the activity).&lt;/p&gt;\n\n&lt;p&gt;This is to encourage using separate threads for network operations. See &lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt; for more details on how to perform network activities the right way.&lt;/p&gt;\n    ","\n&lt;p&gt;Using &lt;a href=&quot;http://androidannotations.org/&quot; rel=&quot;noreferrer&quot;&gt;Android Annotations&lt;/a&gt; is an option. It will allow you to simply run any method in a background thread:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// normal method&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    doSomething(); &lt;span class=&quot;hljs-comment&quot;&gt;// do something in background&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@Background&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; \n    &lt;span class=&quot;hljs-comment&quot;&gt;// run your networking code here&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note, that although it provides benefits of simplicity and readability, it has its disadvantages. &lt;/p&gt;\n    ","\n&lt;p&gt;The error is due to executing long running operations in main thread,You can easily rectify the problem by using &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot; rel=&quot;noreferrer&quot;&gt;AsynTask&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot; rel=&quot;noreferrer&quot;&gt;Thread&lt;/a&gt;. You can checkout this library &lt;a href=&quot;http://loopj.com/android-async-http/&quot; rel=&quot;noreferrer&quot;&gt;AsyncHTTPClient&lt;/a&gt; for better handling. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;AsyncHttpClient&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;AsyncHttpClient&lt;/span&gt;();\nclient.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.google.com&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;AsyncHttpResponseHandler&lt;/span&gt;() {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Called before a request is started&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; statusCode, Header[] headers, &lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] response)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Called when response HTTP status is &quot;200 OK&quot;&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onFailure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; statusCode, Header[] headers, &lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;[] errorResponse, Throwable e)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Called when response HTTP status is &quot;4XX&quot; (for example, 401, 403, 404)&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onRetry&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; retryNo)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Called when request is retried&lt;/span&gt;\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You should not do any time-consuming task on the main thread (UI thread), like any network operation, file I/O, or SQLite database operations. So for this kind of operation, you should create a worker thread, but the problem is that you can not directly perform any UI related operation from your worker thread. For that, you have to use &lt;code&gt;Handler&lt;/code&gt; and pass the &lt;code&gt;Message&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;To simplify all these things, Android provides various ways, like &lt;code&gt;AsyncTask&lt;/code&gt;, &lt;code&gt;AsyncTaskLoader&lt;/code&gt;, &lt;code&gt;CursorLoader&lt;/code&gt; or &lt;code&gt;IntentService&lt;/code&gt;. So you can use any of these according to your requirements.&lt;/p&gt;\n    ","\n&lt;p&gt;The top &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-to-fix-android-os-networkonmainthreadexception/6343299#6343299&quot;&gt;answer of spektom&lt;/a&gt; works perfect.&lt;/p&gt;\n\n&lt;p&gt;If you are writing the &lt;code&gt;AsyncTask&lt;/code&gt; inline and not extending as a class, and on top of this, if there is a need to get a response out of the &lt;code&gt;AsyncTask&lt;/code&gt;, one can use the &lt;code&gt;get()&lt;/code&gt; method as below.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;RSSFeed&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;feed&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RetreiveFeedTask&lt;/span&gt;().execute(urlToRssFeed).get();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(From his example.)&lt;/p&gt;\n    ","\n&lt;p&gt;This is only thrown for applications targeting the &lt;a href=&quot;http://en.wikipedia.org/wiki/Android_version_history#Android_3.0_Honeycomb_.28API_level_11.29&quot; rel=&quot;noreferrer&quot;&gt;Honeycomb&lt;/a&gt; SDK or higher. Applications targeting earlier SDK versions are allowed to do networking on their main event loop threads.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot; rel=&quot;noreferrer&quot;&gt;The error is the SDK warning!&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;For me it was this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;uses-sdk\n        android:minSdkVersion=&lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt;\n        android:targetSdkVersion=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt; /&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The device I was testing my app on was 4.1.2 which is SDK Version 16!&lt;/p&gt;\n\n&lt;p&gt;Make the sure the target version is the same as your Android Target Library. If you are unsure what your target library is, right click your Project -&amp;gt; &lt;em&gt;Build Path&lt;/em&gt; -&amp;gt; &lt;em&gt;Android&lt;/em&gt;, and it should be the one that is ticked.&lt;/p&gt;\n\n&lt;p&gt;Also, as others have mentioned, include the correct permissions to access the Internet:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&amp;lt;uses-permission android:name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;android.permission.INTERNET&quot;&lt;/span&gt;/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Use this in Your Activity&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    btnsub.setOnClickListener(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;View&lt;/span&gt;.OnClickListener() {\n        &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(View v)&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;() {\n\n                &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n                &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n                    &lt;span class=&quot;hljs-comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;\n\n                    &lt;span class=&quot;hljs-comment&quot;&gt;//Initialize soap request + add parameters&lt;/span&gt;\n                    &lt;span class=&quot;hljs-type&quot;&gt;SoapObject&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SoapObject&lt;/span&gt;(NAMESPACE, METHOD_NAME1);\n\n                    &lt;span class=&quot;hljs-comment&quot;&gt;//Use this to add parameters&lt;/span&gt;\n                    request.addProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pincode&quot;&lt;/span&gt;, txtpincode.getText().toString());\n                    request.addProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;bg&quot;&lt;/span&gt;, bloodgroup.getSelectedItem().toString());\n\n                    &lt;span class=&quot;hljs-comment&quot;&gt;//Declare the version of the SOAP request&lt;/span&gt;\n                    &lt;span class=&quot;hljs-type&quot;&gt;SoapSerializationEnvelope&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;envelope&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SoapSerializationEnvelope&lt;/span&gt;(SoapEnvelope.VER11);\n\n                    envelope.setOutputSoapObject(request);\n                    envelope.dotNet = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n\n                    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n                        &lt;span class=&quot;hljs-type&quot;&gt;HttpTransportSE&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;androidHttpTransport&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HttpTransportSE&lt;/span&gt;(URL);\n\n                        &lt;span class=&quot;hljs-comment&quot;&gt;//this is the actual part that will call the webservice&lt;/span&gt;\n                        androidHttpTransport.call(SOAP_ACTION1, envelope);\n\n                        &lt;span class=&quot;hljs-comment&quot;&gt;// Get the SoapResult from the envelope body.&lt;/span&gt;\n                        &lt;span class=&quot;hljs-type&quot;&gt;SoapObject&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (SoapObject) envelope.getResponse();\n                        Log.e(&lt;span class=&quot;hljs-string&quot;&gt;&quot;result data&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;data&quot;&lt;/span&gt; + result);\n                        &lt;span class=&quot;hljs-type&quot;&gt;SoapObject&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (SoapObject) result.getProperty(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n                        &lt;span class=&quot;hljs-comment&quot;&gt;// SoapObject s_deals = (SoapObject) root.getProperty(0);&lt;/span&gt;\n                        &lt;span class=&quot;hljs-comment&quot;&gt;// SoapObject s_deals_1 = (SoapObject) s_deals.getProperty(0);&lt;/span&gt;\n                        &lt;span class=&quot;hljs-comment&quot;&gt;//&lt;/span&gt;\n\n                        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;********Count : &quot;&lt;/span&gt; + root.getPropertyCount());\n\n                        value = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;Detailinfo&amp;gt;();\n\n                        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; root.getPropertyCount(); i++) {\n                            &lt;span class=&quot;hljs-type&quot;&gt;SoapObject&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s_deals&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (SoapObject) root.getProperty(i);\n                            &lt;span class=&quot;hljs-type&quot;&gt;Detailinfo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Detailinfo&lt;/span&gt;();\n\n                            info.setFirstName(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Firstname&quot;&lt;/span&gt;).toString());\n                            info.setLastName(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Lastname&quot;&lt;/span&gt;).toString());\n                            info.setDOB(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;DOB&quot;&lt;/span&gt;).toString());\n                            info.setGender(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Gender&quot;&lt;/span&gt;).toString());\n                            info.setAddress(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt;).toString());\n                            info.setCity(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;City&quot;&lt;/span&gt;).toString());\n                            info.setState(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;State&quot;&lt;/span&gt;).toString());\n                            info.setPinecode(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Pinecode&quot;&lt;/span&gt;).toString());\n                            info.setMobile(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Mobile&quot;&lt;/span&gt;).toString());\n                            info.setEmail(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Email&quot;&lt;/span&gt;).toString());\n                            info.setBloodgroup(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Bloodgroup&quot;&lt;/span&gt;).toString());\n                            info.setAdddate(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Adddate&quot;&lt;/span&gt;).toString());\n                            info.setWaight(s_deals.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;waight&quot;&lt;/span&gt;).toString());\n                            value.add(info);\n                        }\n\n                    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {\n                        e.printStackTrace();\n                    }\n                    &lt;span class=&quot;hljs-type&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;intent&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Intent&lt;/span&gt;(getApplicationContext(), ComposeMail.class);\n                    &lt;span class=&quot;hljs-comment&quot;&gt;//intent.putParcelableArrayListExtra(&quot;valuesList&quot;, value);&lt;/span&gt;\n\n                    startActivity(intent);\n                }\n            }).start();\n        }\n    });\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Just to spell out something explicitly:&lt;/p&gt;\n\n&lt;p&gt;The main thread is basically the UI thread.&lt;/p&gt;\n\n&lt;p&gt;So saying that you cannot do networking operations in the main thread means you cannot do networking operations in the UI thread, which means &lt;em&gt;you cannot do networking operations in a &lt;code&gt;*runOnUiThread(new Runnable() { ... }*&lt;/code&gt; block&lt;/em&gt; inside some other thread, either.&lt;/p&gt;\n\n&lt;p&gt;(I just had a long head-scratching moment trying to figure out why I was getting that error somewhere other than my main thread.  This was why; this thread helped; and hopefully this comment will help someone else.)&lt;/p&gt;\n    ","\n&lt;p&gt;This exception occurs due to any heavy task performed on the main thread if that performing task takes &lt;em&gt;too much time&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;To avoid this, we can handle it using &lt;strong&gt;threads&lt;/strong&gt; or &lt;strong&gt;executers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Executors.newSingleThreadExecutor().submit(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// You can perform your task here.&lt;/span&gt;\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. This is intended as a kind of newbie-guide.&lt;/p&gt;\n&lt;p&gt;I will cover several use cases for performing network operations and &lt;em&gt;a&lt;/em&gt; solution or two for each.&lt;/p&gt;\n&lt;h1 id=&quot;rest-over-http-nzt9&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot; rel=&quot;nofollow noreferrer&quot;&gt;REST&lt;/a&gt; over HTTP&lt;/h1&gt;\n&lt;p&gt;&lt;em&gt;Typically JSON, but it can be XML or something else.&lt;/em&gt;&lt;/p&gt;\n&lt;h2 id=&quot;full-api-access-wvsz&quot;&gt;Full API Access&lt;/h2&gt;\n&lt;p&gt;Let&apos;s say you are writing an app that lets users track stock prices, interest rates and currency exchange rates. You find an JSON API that looks something like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;http://api.example.com/stocks                       // ResponseWrapper&amp;lt;String&amp;gt; object containing a\n                                                    // list of strings with ticker symbols\nhttp://api.example.com/stocks/$symbol               // Stock object\nhttp://api.example.com/stocks/$symbol/prices        // PriceHistory&amp;lt;Stock&amp;gt; object\nhttp://api.example.com/currencies                   // ResponseWrapper&amp;lt;String&amp;gt; object containing a\n                                                    // list of currency abbreviation\nhttp://api.example.com/currencies/$currency         // Currency object\nhttp://api.example.com/currencies/$id1/values/$id2  // PriceHistory&amp;lt;Currency&amp;gt; object comparing the prices\n                                                    // of the first currency (id1) to the second (id2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;retrofit-from-square-j5a1&quot;&gt;Retrofit from Square&lt;/h3&gt;\n&lt;p&gt;This is an excellent choice for an API with multiple endpoints and allows you to declare the REST endpoints instead of having to code them individually as with other libraries like &lt;a href=&quot;https://amzn.github.io/ion-docs/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Amazon Ion Java&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/training/volley/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Volley&lt;/a&gt; (website: &lt;em&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Retrofit&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;\n&lt;p&gt;How do you use it with the finances API?&lt;/p&gt;\n&lt;h3 id=&quot;file-build.gradle-uu1e&quot;&gt;File &lt;em&gt;build.gradle&lt;/em&gt;&lt;/h3&gt;\n&lt;p&gt;Add these lines to your &lt;em&gt;module&lt;/em&gt; level &lt;em&gt;build.gradle&lt;/em&gt; file:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;implementation &lt;span class=&quot;hljs-string&quot;&gt;&apos;com.squareup.retrofit2:retrofit:2.3.0&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// Retrofit library, current as of September 21, 2017&lt;/span&gt;\nimplementation &lt;span class=&quot;hljs-string&quot;&gt;&apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// Gson serialization and deserialization support for retrofit, version must match retrofit version&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;file-financesapi.java-lwca&quot;&gt;File &lt;em&gt;FinancesApi.java&lt;/em&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;FinancesApi&lt;/span&gt; {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;stocks&quot;)&lt;/span&gt;\n    Call&amp;lt;ResponseWrapper&amp;lt;String&amp;gt;&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;listStocks&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;stocks/{symbol}&quot;)&lt;/span&gt;\n    Call&amp;lt;Stock&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getStock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@Path(&quot;symbol&quot;)&lt;/span&gt;String tickerSymbol)&lt;/span&gt;;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;stocks/{symbol}/prices&quot;)&lt;/span&gt;\n    Call&amp;lt;PriceHistory&amp;lt;Stock&amp;gt;&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getPriceHistory&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@Path(&quot;symbol&quot;)&lt;/span&gt;String tickerSymbol)&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;currencies&quot;)&lt;/span&gt;\n    Call&amp;lt;ResponseWrapper&amp;lt;String&amp;gt;&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;listCurrencies&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;currencies/{symbol}&quot;)&lt;/span&gt;\n    Call&amp;lt;Currency&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getCurrency&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@Path(&quot;symbol&quot;)&lt;/span&gt;String currencySymbol)&lt;/span&gt;;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@GET(&quot;currencies/{symbol}/values/{compare_symbol}&quot;)&lt;/span&gt;\n    Call&amp;lt;PriceHistory&amp;lt;Currency&amp;gt;&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getComparativeHistory&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-meta&quot;&gt;@Path(&quot;symbol&quot;)&lt;/span&gt;String currency, &lt;span class=&quot;hljs-meta&quot;&gt;@Path(&quot;compare_symbol&quot;)&lt;/span&gt;String currencyToPriceAgainst)&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;class-financesapibuilder-7lsi&quot;&gt;Class &lt;em&gt;FinancesApiBuilder&lt;/em&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;FinancesApiBuilder&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; FinancesApi &lt;span class=&quot;hljs-title function_&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String baseUrl)&lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Retrofit&lt;/span&gt;.Builder()\n                    .baseUrl(baseUrl)\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(FinancesApi.class);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;class-financesfragment-snippet-4nuc&quot;&gt;Class &lt;em&gt;FinancesFragment&lt;/em&gt; snippet&lt;/h3&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;FinancesApi&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; FinancesApiBuilder.build(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://api.example.com/&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//trailing &apos;/&apos; required for predictable behavior&lt;/span&gt;\napi.getStock(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INTC&quot;&lt;/span&gt;).enqueue(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Callback&lt;/span&gt;&amp;lt;Stock&amp;gt;(){\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Call&amp;lt;Stock&amp;gt; stockCall, Response&amp;lt;Stock&amp;gt; stockResponse)&lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;Stock&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;stock&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; stockCall.body();\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Do something with the stock&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Call&amp;lt;Stock&amp;gt; stockCall, Throwable t)&lt;/span&gt;{\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Something bad happened&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If your API requires an API key or other header, like a user token, etc. to be sent, Retrofit makes this easy (see &lt;a href=&quot;https://stackoverflow.com/questions/42898920/add-header-parameter-in-retrofit/42899766#42899766&quot;&gt;this awesome answer&lt;/a&gt; to &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/42898920/&quot;&gt;Add Header Parameter in Retrofit&lt;/a&gt;&lt;/em&gt; for details).&lt;/p&gt;\n&lt;h2 id=&quot;one-off-rest-api-access-z59h&quot;&gt;One-off REST API access&lt;/h2&gt;\n&lt;p&gt;Let&apos;s say you&apos;re building a &quot;mood weather&quot; app that looks up the user&apos;s GPS location and checks the current temperature in that area and tells them the mood. This type of app doesn&apos;t need to declare API endpoints; it just needs to be able to access one API endpoint.&lt;/p&gt;\n&lt;h3 id=&quot;ion-oacp&quot;&gt;Ion&lt;/h3&gt;\n&lt;p&gt;This is a great library for this type of access.&lt;/p&gt;\n&lt;p&gt;Please read &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-can-i-fix-android-os-networkonmainthreadexception/28559884#28559884&quot;&gt;msysmilu&apos;s great answer&lt;/a&gt; to &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6343166&quot;&gt;How can I fix &apos;android.os.NetworkOnMainThreadException&apos;?&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;h1 id=&quot;load-images-via-http-8qty&quot;&gt;Load images via HTTP&lt;/h1&gt;\n&lt;h2 id=&quot;volley-ct3h&quot;&gt;Volley&lt;/h2&gt;\n&lt;p&gt;&lt;em&gt;Volley can also be used for REST APIs, but due to the more complicated setup required, I prefer to use &lt;a href=&quot;http://square.github.io/retrofit/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Retrofit&lt;/a&gt; from Square as above.&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;Let&apos;s say you are building a social networking app and want to load profile pictures of friends.&lt;/p&gt;\n&lt;h3 id=&quot;file-build.gradle-1-xq8r&quot;&gt;File &lt;em&gt;build.gradle&lt;/em&gt;&lt;/h3&gt;\n&lt;p&gt;Add this line to your &lt;em&gt;module&lt;/em&gt; level &lt;em&gt;build.gradle&lt;/em&gt; file:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;implementation &lt;span class=&quot;hljs-string&quot;&gt;&apos;com.android.volley:volley:1.0.0&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;file-imagefetch.java-g0ls&quot;&gt;File &lt;em&gt;ImageFetch.java&lt;/em&gt;&lt;/h3&gt;\n&lt;p&gt;Volley requires more setup than Retrofit. You will need to create a class like this to setup a RequestQueue, an ImageLoader and an ImageCache, but it&apos;s not too bad:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ImageFetch&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;ImageLoader&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;imageLoader&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;RequestQueue&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;imageQueue&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ImageLoader &lt;span class=&quot;hljs-title function_&quot;&gt;getImageLoader&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Context ctx)&lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(imageLoader == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;){\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(imageQueue == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;){\n                imageQueue = Volley.newRequestQueue(ctx.getApplicationContext());\n            }\n            imageLoader = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ImageLoader&lt;/span&gt;(imageQueue, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ImageLoader&lt;/span&gt;.ImageCache() {\n                Map&amp;lt;String, Bitmap&amp;gt; cache = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HashMap&lt;/span&gt;&amp;lt;String, Bitmap&amp;gt;();\n                &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n                &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Bitmap &lt;span class=&quot;hljs-title function_&quot;&gt;getBitmap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String url)&lt;/span&gt; {\n                    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; cache.get(url);\n                }\n                &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n                &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;putBitmap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String url, Bitmap bitmap)&lt;/span&gt; {\n                    cache.put(url, bitmap);\n                }\n            });\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; imageLoader;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;file-user_view_dialog.xml-vi6y&quot;&gt;File &lt;em&gt;user_view_dialog.xml&lt;/em&gt;&lt;/h3&gt;\n&lt;p&gt;Add the following to your layout XML file to add an image:&lt;/p&gt;\n&lt;pre class=&quot;lang-xml s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;com.android.volley.toolbox.NetworkImageView&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;android:id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;@+id/profile_picture&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;32dp&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;32dp&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;android:layout_alignParentTop&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;android:layout_centerHorizontal&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;app:srcCompat&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;@android:drawable/spinner_background&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=&quot;file-userviewdialog.java-qsy0&quot;&gt;File &lt;em&gt;UserViewDialog.java&lt;/em&gt;&lt;/h3&gt;\n&lt;p&gt;Add the following code to the onCreate method (Fragment, Activity) or the constructor (Dialog):&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;NetworkImageView&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;profilePicture&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; view.findViewById(R.id.profile_picture);\nprofilePicture.setImageUrl(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://example.com/users/images/profile.jpg&quot;&lt;/span&gt;, ImageFetch.getImageLoader(getContext());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=&quot;picasso-iipo&quot;&gt;Picasso&lt;/h2&gt;\n&lt;p&gt;&lt;a href=&quot;http://square.github.io/picasso/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Picasso&lt;/a&gt; is another excellent library from Square. Please see the website for some great examples.&lt;/p&gt;\n    ","\n&lt;p&gt;In simple words,&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;Do not do network work in the UI thread&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;For example, if you do an HTTP request, that is a network action.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;You have to create a new Thread&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Or&lt;/strong&gt; use the &lt;a href=&quot;https://www.google.com.np/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CB0QFjAAahUKEwjgivqS0-3GAhUGOJQKHV_YD84&amp;amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FAsyncTask.html&amp;amp;ei=RfquVaDUPIbw0ATfsL_wDA&amp;amp;usg=AFQjCNE8gLVXz1Hwq4rI8oxRkZNHjhRzpQ&amp;amp;sig2=qTI0AgoyYUXyDwHFQup9sw&quot; rel=&quot;nofollow noreferrer&quot;&gt;AsyncTask class&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;Way:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Put all your works inside&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;The &lt;code&gt;run()&lt;/code&gt; method of the new thread&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Or&lt;/strong&gt; the &lt;code&gt;doInBackground()&lt;/code&gt; method of the AsyncTask class.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;But:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;When you get something from a network response and want to show it on your view (like display response message in TextView), you need to &lt;strong&gt;return back to the UI&lt;/strong&gt; thread.&lt;/p&gt;\n&lt;p&gt;If you don&apos;t do it, you will get &lt;code&gt;ViewRootImpl$CalledFromWrongThreadException&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;How-to&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;While using AsyncTask, update the view from the &lt;code&gt;onPostExecute()&lt;/code&gt; method&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Or&lt;/strong&gt; call the &lt;a href=&quot;https://stackoverflow.com/questions/11140285/how-to-use-runonuithread&quot;&gt;&lt;code&gt;runOnUiThread()&lt;/code&gt;&lt;/a&gt; method and update the view inside the &lt;code&gt;run()&lt;/code&gt; method.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;You are able to move a part of your code into another thread to offload the &lt;code&gt;main thread&lt;/code&gt; and avoid getting &lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;ANR&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;NetworkOnMainThreadException&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/java/lang/IllegalStateException.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;IllegalStateException&lt;/a&gt; (e.g., cannot access database on the main thread since it may potentially lock the UI for a long period of time).&lt;/p&gt;\n&lt;p&gt;There are some approaches that you should choose depends on the situation&lt;/p&gt;\n&lt;p&gt;Java &lt;a href=&quot;https://developer.android.com/reference/java/lang/Thread.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Thread&lt;/a&gt; or Android &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;HandlerThread&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Java threads are one-time use only and die after executing its run method.&lt;/p&gt;\n&lt;p&gt;HandlerThread is a handy class for starting a new thread that has a looper.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;AsyncTask&lt;/a&gt; (&lt;strong&gt;deprecated&lt;/strong&gt; in API level 30)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;AsyncTask&lt;/strong&gt; is designed to be a helper class around &lt;strong&gt;Thread&lt;/strong&gt; and &lt;strong&gt;Handler&lt;/strong&gt; and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as &lt;strong&gt;Executor&lt;/strong&gt;, &lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt; and &lt;strong&gt;FutureTask&lt;/strong&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Since the &lt;em&gt;main&lt;/em&gt; thread monopolizes UI components, it is not possible to access to some View, and that is why Handler comes to the rescue&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/66567556/4770877&quot;&gt;[Executor framework]&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ThreadPoolExecutor class that implements ExecutorService which gives fine control on the thread pool (E.g., core pool size, max pool size, keep alive time, etc.)&lt;/p&gt;\n&lt;p&gt;ScheduledThreadPoolExecutor - a class that extends ThreadPoolExecutor. It can schedule tasks after a given delay or periodically.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/FutureTask.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;FutureTask&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;FutureTask performs asynchronous processing, however, if the result is not ready yet or processing has not complete, calling get() will be block the thread&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/content/AsyncTaskLoader.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;AsyncTaskLoaders&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;AsyncTaskLoaders as they solve a lot of problems that are inherent to AsyncTask&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/IntentService.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;IntentService&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;This is the de facto choice for long running processing on Android, a good example would be to upload or download large files. The upload and download may continue even if the user exits the app and you certainly do not want to block the user from being able to use the app while these tasks are going on.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/job/JobScheduler.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;JobScheduler&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Effectively, you have to create a Service and create a job using JobInfo.Builder that specifies your criteria for when to run the service.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot; rel=&quot;nofollow noreferrer&quot;&gt;RxJava&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Library for composing asynchronous and event-based programs by using observable sequences.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coroutines&lt;/a&gt; (Kotlin)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The main gist of it is, it makes asynchronous code looks so much like synchronous&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Read more &lt;a href=&quot;https://android.jlelse.eu/8-ways-to-do-asynchronous-processing-in-android-and-counting-f634dc6fae4e&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, and &lt;a href=&quot;https://guides.codepath.com/android/Managing-Threads-and-Custom-Services#handlerthread-caveats&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;New &lt;code&gt;Thread&lt;/code&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask.html&quot; rel=&quot;noreferrer&quot;&gt;AsyncTask&lt;/a&gt; solutions have been explained already.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;AsyncTask&lt;/code&gt; should ideally be used for short operations. Normal &lt;code&gt;Thread&lt;/code&gt; is not preferable for Android. &lt;/p&gt;\n\n&lt;p&gt;Have a look at alternate solution using &lt;a href=&quot;https://developer.android.com/reference/android/os/HandlerThread.html&quot; rel=&quot;noreferrer&quot;&gt;HandlerThread&lt;/a&gt; and &lt;a href=&quot;https://developer.android.com/reference/android/os/Handler.html&quot; rel=&quot;noreferrer&quot;&gt;Handler&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;HandlerThread&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that &lt;code&gt;start()&lt;/code&gt; must still be called.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Handler:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A Handler allows you to send and process Message and Runnable objects associated with a thread&apos;s MessageQueue. Each Handler instance is associated with a single thread and that thread&apos;s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Solution:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Create &lt;code&gt;HandlerThread&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Call &lt;code&gt;start()&lt;/code&gt; on &lt;code&gt;HandlerThread&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Create &lt;code&gt;Handler&lt;/code&gt; by getting &lt;code&gt;Looper&lt;/code&gt; from &lt;code&gt;HanlerThread&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Embed your Network operation related code in &lt;code&gt;Runnable&lt;/code&gt; object&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Submit &lt;code&gt;Runnable&lt;/code&gt; task to &lt;code&gt;Handler&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Sample code snippet, which address  &lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;HandlerThread&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;handlerThread&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HandlerThread&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;URLConnection&quot;&lt;/span&gt;);\nhandlerThread.start();\n&lt;span class=&quot;hljs-type&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;mainHandler&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Handler&lt;/span&gt;(handlerThread.getLooper());\n\n&lt;span class=&quot;hljs-type&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;myRunnable&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            Log.d(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Ravi&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Before IO call&quot;&lt;/span&gt;);\n            &lt;span class=&quot;hljs-type&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;URL&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.google.com&quot;&lt;/span&gt;);\n            &lt;span class=&quot;hljs-type&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StringBuffer&lt;/span&gt;();\n            &lt;span class=&quot;hljs-type&quot;&gt;HttpURLConnection&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; (HttpURLConnection) page.openConnection();\n            conn.connect();\n            &lt;span class=&quot;hljs-type&quot;&gt;InputStreamReader&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;InputStreamReader&lt;/span&gt;((InputStream) conn.getContent());\n            &lt;span class=&quot;hljs-type&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;buff&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;BufferedReader&lt;/span&gt;(in);\n            String line;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; ( (line =  buff.readLine()) != &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {\n                text.append(line + &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;);\n            }\n            Log.d(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Ravi&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;After IO call&quot;&lt;/span&gt;);\n            Log.d(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Ravi&quot;&lt;/span&gt;,text.toString());\n\n        }&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;( Exception err){\n            err.printStackTrace();\n        }\n    }\n};\nmainHandler.post(myRunnable);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Pros of using this approach:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Creating new &lt;code&gt;Thread/AsyncTask&lt;/code&gt; for each network operation is expensive. The &lt;code&gt;Thread/AsyncTask&lt;/code&gt; will be destroyed and re-created for next Network operations. But with &lt;code&gt;Handler&lt;/code&gt; and &lt;code&gt;HandlerThread&lt;/code&gt; approach, you can submit many network operations (as Runnable tasks) to single &lt;code&gt;HandlerThread&lt;/code&gt; by using &lt;code&gt;Handler&lt;/code&gt;. &lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;Although above there is a huge solution pool, no one mentioned &lt;code&gt;com.koushikdutta.ion&lt;/code&gt;: &lt;a href=&quot;https://github.com/koush/ion&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/koush/ion&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;It&apos;s also &lt;strong&gt;asynchronous&lt;/strong&gt; and &lt;strong&gt;very simple&lt;/strong&gt; to use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Ion.with(context)\n.load(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://example.com/thing.json&quot;&lt;/span&gt;)\n.asJsonObject()\n.setCallback(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;FutureCallback&lt;/span&gt;&amp;lt;JsonObject&amp;gt;() {\n   &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onCompleted&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Exception e, JsonObject result)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// do stuff with the result or error&lt;/span&gt;\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This works. I just made &lt;a href=&quot;https://stackoverflow.com/questions/6343166/how-can-i-fix-android-os-networkonmainthreadexception/14443056#14443056&quot;&gt;Dr.Luiji&apos;s answer&lt;/a&gt; a little simpler.&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Your code goes here&lt;/span&gt;\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}.start();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h2&gt; Kotlin &lt;/h2&gt;\n&lt;p&gt;If you are using Kotlin, you can use a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot; rel=&quot;nofollow noreferrer&quot;&gt;coroutine&lt;/a&gt;&lt;/em&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;fun &lt;span class=&quot;hljs-title function_&quot;&gt;doSomeNetworkStuff&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    GlobalScope.launch(Dispatchers.IO) {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The main thread is the UI thread, and you cannot do an operation in the main thread which may block the user interaction. You can solve this in two ways:&lt;/p&gt;\n\n&lt;p&gt;Force to do the task in the main thread like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;StrictMode.&lt;span class=&quot;hljs-type&quot;&gt;ThreadPolicy&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;threadPolicy&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StrictMode&lt;/span&gt;.ThreadPolicy.Builder().permitAll().build();\nStrictMode.setThreadPolicy(threadPolicy);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or create a simple handler and update the main thread if you want.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Runnable runnable;\nHandler newHandler;\n\nnewHandler = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Handler&lt;/span&gt;();\nrunnable = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Runnable&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n         &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {\n            &lt;span class=&quot;hljs-comment&quot;&gt;//update UI&lt;/span&gt;\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {\n            e.printStackTrace();\n        } \n    }\n};\nnewHandler.post(runnable);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And to stop the thread use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;newHandler.removeCallbacks(runnable);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For more information check this out: &lt;em&gt;&lt;a href=&quot;https://android-developers.googleblog.com/2009/05/painless-threading.html&quot; rel=&quot;noreferrer&quot;&gt;Painless threading&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;RxAndroid&lt;/code&gt; is another better alternative to this problem and it saves us from hassles of creating threads and then posting results on Android UI thread.&lt;/p&gt;\n&lt;p&gt;We just need to specify threads on which tasks need to be executed and everything is handled internally.&lt;/p&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Observable&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; musicShowsObservable = Observable.fromCallable(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Callable&lt;/span&gt;&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() {\n\n  &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title function_&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mRestClient.getFavoriteMusicShows();\n  }\n\n});\n\nmMusicShowSubscription = musicShowsObservable\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Observer&lt;/span&gt;&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onCompleted&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; { }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Throwable e)&lt;/span&gt; { }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;String&amp;gt; musicShows)&lt;/span&gt; {\n        listMusicShows(musicShows);\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;By specifiying &lt;code&gt;(Schedulers.io())&lt;/code&gt;, RxAndroid will run &lt;code&gt;getFavoriteMusicShows()&lt;/code&gt; on a different thread.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;By using &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; we want to observe this Observable on the UI thread, i.e., we want our &lt;code&gt;onNext()&lt;/code&gt; callback to be called on the UI thread.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n    "],"63":["\n&lt;blockquote&gt;\n  &lt;p&gt;How can it be? Isn&apos;t the memory of a local variable inaccessible outside its function?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!&lt;/p&gt;\n\n&lt;p&gt;A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;How can that be? Aren&apos;t the contents of a hotel room drawer inaccessible if you haven&apos;t rented the room?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.&lt;/p&gt;\n\n&lt;p&gt;The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn&apos;t make a contract with them that said that if you leave stuff behind, they&apos;ll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn&apos;t make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else&apos;s book can be there and yours could be in the hotel&apos;s furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around. &lt;/p&gt;\n\n&lt;p&gt;You don&apos;t know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you&apos;re not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.&lt;/p&gt;\n\n&lt;h2&gt;UPDATE&lt;/h2&gt;\n\n&lt;p&gt;Holy goodness, this answer is getting a lot of attention. (I&apos;m not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)&lt;/p&gt;\n\n&lt;p&gt;I thought it might be germane to update this a bit with a few more technical thoughts.&lt;/p&gt;\n\n&lt;p&gt;Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched. &lt;/p&gt;\n\n&lt;p&gt;The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.&lt;/p&gt;\n\n&lt;p&gt;The second method is to have a short-lived storage area where the lifetime of each byte is well known. Here, the lifetimes follow a nesting pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is nested within the lifetime of longer-lived ones.&lt;/p&gt;\n\n&lt;p&gt;Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method&apos;s local variables come alive. They&apos;ll be dead before the first method&apos;s local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.&lt;/p&gt;\n\n&lt;p&gt;For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off. &lt;/p&gt;\n\n&lt;p&gt;It&apos;s like the hotel decides to only rent out rooms sequentially, and you can&apos;t check out until everyone with a room number higher than you has checked out. &lt;/p&gt;\n\n&lt;p&gt;So let&apos;s think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that&apos;s just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn&apos;t, because that would make the program slower. &lt;/p&gt;\n\n&lt;p&gt;An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn&apos;t because again, that would be expensive.&lt;/p&gt;\n\n&lt;p&gt;An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we&apos;re done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.&lt;/p&gt;\n\n&lt;p&gt;Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.&lt;/p&gt;\n\n&lt;p&gt;This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.&lt;/p&gt;\n\n&lt;p&gt;More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules. &lt;/p&gt;\n\n&lt;p&gt;For further reading:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;What if C# did allow returning references? Coincidentally that is the subject of today&apos;s blog post:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/&quot; rel=&quot;noreferrer&quot;&gt;https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://ericlippert.com/tag/memory-management/&quot; rel=&quot;noreferrer&quot;&gt;https://ericlippert.com/tag/memory-management/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;What you&apos;re doing here is simply reading and writing to memory that &lt;i&gt;used to&lt;/i&gt; be the address of &lt;code&gt;a&lt;/code&gt;. Now that you&apos;re outside of &lt;code&gt;foo&lt;/code&gt;, it&apos;s just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don&apos;t break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you&apos;d break something by doing this (though the symptoms may not appear until much later!)&lt;/p&gt;\n\n&lt;p&gt;When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you&apos;re no longer using that memory and it can be reassigned to something else. If you&apos;re lucky and it never does get reassigned, and the OS doesn&apos;t catch you using it again, then you&apos;ll get away with the lie. Chances are though you&apos;ll end up writing over whatever else ends up with that address.&lt;/p&gt;\n\n&lt;p&gt;Now if you&apos;re wondering why the compiler doesn&apos;t complain, it&apos;s probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you&apos;re doing though, and technically you haven&apos;t violated scope here (there&apos;s no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.&lt;/p&gt;\n\n&lt;p&gt;In short: this won&apos;t usually work, but sometimes will by chance.&lt;/p&gt;\n    ","\n&lt;p&gt;Because the storage space wasn&apos;t stomped on just yet. Don&apos;t count on that behavior.&lt;/p&gt;\n    ","\n&lt;p&gt;A little addition to all the answers:&lt;/p&gt;\n\n&lt;p&gt;if you do something like that:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;a;\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;boo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;;\n\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; * p = &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n    &lt;span class=&quot;hljs-built_in&quot;&gt;boo&lt;/span&gt;();\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;,*p);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the output probably will be: 7&lt;/p&gt;\n\n&lt;p&gt;That is because after returning from foo() the stack is freed and then reused by boo().\nIf you deassemble the executable you will see it clearly.&lt;/p&gt;\n    ","\n&lt;p&gt;In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn&apos;t mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;noreferrer&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...&lt;/p&gt;\n    ","\n&lt;p&gt;You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; q = &lt;span class=&quot;hljs-number&quot;&gt;123456&lt;/span&gt;;\n\n*(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;*)(q) = &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen: &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;. &lt;/li&gt;\n&lt;li&gt;&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there. &lt;/li&gt;\n&lt;li&gt;&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system&apos;s memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it. &lt;/li&gt;\n&lt;li&gt;You win the lottery.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.&lt;/p&gt;\n\n&lt;p&gt;Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.&lt;/p&gt;\n    ","\n&lt;p&gt;Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.&lt;/p&gt;\n\n&lt;p&gt;But I agree with Mark B that the resulting behavior is undefined.&lt;/p&gt;\n    ","\n&lt;p&gt;Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can&apos;t access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The problem you are having is why the program doesn&apos;t signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don&apos;t count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.&lt;/p&gt;\n    ","\n&lt;p&gt;Pay attention to  all warnings . Do not only solve errors.&lt;br&gt;\nGCC shows this Warning &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;warning: address of local variable &apos;a&apos; returned &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.&lt;/p&gt;\n    ","\n&lt;p&gt;It works because the stack has not been altered (yet) since a was put there. \nCall a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)&lt;/p&gt;\n    ","\n&lt;p&gt;You are just returning a memory address, it&apos;s allowed but probably an error.  &lt;/p&gt;\n\n&lt;p&gt;Yes if you try to dereference that memory address you will have undefined behavior.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;hljs-title&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; tmp = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;\n &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;tmp;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; * a = &lt;span class=&quot;hljs-built_in&quot;&gt;ref&lt;/span&gt;();\n &lt;span class=&quot;hljs-comment&quot;&gt;//Up until this point there is defined results&lt;/span&gt;\n &lt;span class=&quot;hljs-comment&quot;&gt;//You can even print the address returned&lt;/span&gt;\n &lt;span class=&quot;hljs-comment&quot;&gt;// but yes probably a bug&lt;/span&gt;\n\n cout &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; endl;&lt;span class=&quot;hljs-comment&quot;&gt;//Undefined results&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it&apos;s an easy way to get crashes.&lt;/p&gt;\n\n&lt;p&gt;For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;x;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *c )&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;;\n   *c = &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;;\n   cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;y=&quot;&lt;/span&gt; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-built_in&quot;&gt;b&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;a&lt;/span&gt;() );\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.&lt;/p&gt;\n    ","\n&lt;p&gt;That&apos;s classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that&apos;s been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.&lt;/p&gt;\n    ","\n&lt;p&gt;You actually invoked undefined behaviour.&lt;/p&gt;\n\n&lt;p&gt;Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.&lt;/p&gt;\n\n&lt;p&gt;So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing. &lt;/p&gt;\n    ","\n&lt;p&gt;In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it&apos;s a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.&lt;/p&gt;\n\n&lt;p&gt;However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!&lt;/p&gt;\n    ","\n&lt;p&gt;It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.&lt;/p&gt;\n\n&lt;p&gt;What you&apos;re doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.&lt;/p&gt;\n    ","\n&lt;p&gt;The things with correct (?) console output can change dramatically if you use ::printf but not cout. \nYou can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; \n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n  ::&lt;span class=&quot;hljs-built_in&quot;&gt;strcpy&lt;/span&gt;(buf, &lt;span class=&quot;hljs-string&quot;&gt;&quot;TEST);\n  return buf;\n}\n\nint main() \n{\n  char* s = foo();    //place breakpoint &amp;amp; check &apos;s&apos; varialbe here\n  ::printf(&quot;&lt;/span&gt;%s\\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;, s); \n}\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It&apos;s &apos;Dirty&apos; way of using memory addresses. When you return an address (pointer) you don&apos;t know whether it belongs to local scope of a function. It&apos;s just an address. Now that you invoked the &apos;foo&apos; function, that address (memory location) of &apos;a&apos; was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the &apos;foo&apos; function returned, the address of &apos;a&apos; can be considered &apos;dirty&apos; but it&apos;s there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn&apos;t stop you from such &apos;dirty&apos; access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.&lt;/p&gt;\n    ","\n&lt;p&gt;After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.&lt;/p&gt;\n\n&lt;p&gt;So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.&lt;/p&gt;\n    ","\n&lt;p&gt;Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.&lt;/p&gt;\n\n&lt;p&gt;That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).&lt;/p&gt;\n\n&lt;p&gt;This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all. &lt;/p&gt;\n\n&lt;p&gt;Consider this example, instead, and test it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;;\n   *x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n    std::cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//better to put a new-line in the output, IMO&lt;/span&gt;\n    *p = &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; *p;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; p;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Unlike your example, with this example you are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;allocating memory for int into a local function&lt;/li&gt;\n&lt;li&gt;that memory address is still valid also when function expires, (it is not deleted by anyone)&lt;/li&gt;\n&lt;li&gt;the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)&lt;/li&gt;\n&lt;li&gt;the memory address should be deleted when not used. (see the delete at the end of the program)&lt;/li&gt;\n&lt;/ul&gt;\n    "],"64":["\n&lt;h2&gt;TLDR&lt;/h2&gt;\n&lt;p&gt;JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.&lt;/p&gt;\n&lt;p&gt;The four scopes are:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Global - visible by everything&lt;/li&gt;\n&lt;li&gt;Function - visible within a function (and its sub-functions and blocks)&lt;/li&gt;\n&lt;li&gt;Block - visible within a block (and its sub-blocks)&lt;/li&gt;\n&lt;li&gt;Module - visible within a module&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Outside of the special cases of global and module scope, variables are declared using &lt;code&gt;var&lt;/code&gt; (function scope), &lt;code&gt;let&lt;/code&gt; (block scope), and &lt;code&gt;const&lt;/code&gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.&lt;/p&gt;\n&lt;h2&gt;Overview&lt;/h2&gt;\n&lt;p&gt;Scope is the region of the codebase over which an identifier is valid.&lt;/p&gt;\n&lt;p&gt;A lexical environment is a mapping between identifier names and the values associated with them.&lt;/p&gt;\n&lt;p&gt;Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.&lt;/p&gt;\n&lt;p&gt;These linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.&lt;/p&gt;\n&lt;p&gt;Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.&lt;/p&gt;\n&lt;p&gt;There are three pertinent factors in deciding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot; rel=&quot;noreferrer&quot;&gt;scope&lt;/a&gt; of an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot; rel=&quot;noreferrer&quot;&gt;identifier&lt;/a&gt; in JavaScript:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;How an identifier was declared&lt;/li&gt;\n&lt;li&gt;Where an identifier was declared&lt;/li&gt;\n&lt;li&gt;Whether you are in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot; rel=&quot;noreferrer&quot;&gt;strict mode&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot; rel=&quot;noreferrer&quot;&gt;non-strict mode&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Some of the ways identifiers can be declared:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Function parameters&lt;/li&gt;\n&lt;li&gt;Catch block parameter&lt;/li&gt;\n&lt;li&gt;Function declarations&lt;/li&gt;\n&lt;li&gt;Named function expressions&lt;/li&gt;\n&lt;li&gt;Implicitly defined properties on the global object (i.e., missing out &lt;code&gt;var&lt;/code&gt; in non-strict mode)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;import&lt;/code&gt; statements&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Some of the locations identifiers can be declared:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Global context&lt;/li&gt;\n&lt;li&gt;Function body&lt;/li&gt;\n&lt;li&gt;Ordinary block&lt;/li&gt;\n&lt;li&gt;The top of a control structure (e.g., loop, if, while, etc.)&lt;/li&gt;\n&lt;li&gt;Control structure body&lt;/li&gt;\n&lt;li&gt;Modules&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2&gt;Declaration Styles&lt;/h2&gt;\n&lt;h3&gt;var&lt;/h3&gt;\n&lt;p&gt;Identifiers declared using &lt;code&gt;var&lt;/code&gt; &lt;strong&gt;have function scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in &lt;code&gt;eval&lt;/code&gt; functions.&lt;/p&gt;\n&lt;h3&gt;let and const&lt;/h3&gt;\n&lt;p&gt;Identifiers declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; &lt;strong&gt;have block scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they have global scope.&lt;/p&gt;\n&lt;p&gt;Note: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;are all hoisted&lt;/a&gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;g&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x)\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-title function_&quot;&gt;g&lt;/span&gt;()\n}\n&lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;() &lt;span class=&quot;hljs-comment&quot;&gt;// 1 because x is hoisted even though declared with `let`!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h3&gt;Function parameter names&lt;/h3&gt;\n&lt;p&gt;Function parameter names are scoped to the function body. Note that there is a slight complexity to this. Functions declared as default arguments close over the &lt;a href=&quot;https://stackoverflow.com/questions/61208843/where-are-arguments-positioned-in-the-lexical-environment/&quot;&gt;parameter list&lt;/a&gt;, and not the body of the function.&lt;/p&gt;\n&lt;h3&gt;Function declarations&lt;/h3&gt;\n&lt;p&gt;Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.&lt;/p&gt;\n&lt;h3&gt;Named function expressions&lt;/h3&gt;\n&lt;p&gt;Named function expressions are scoped to themselves (e.g., for the purpose of recursion).&lt;/p&gt;\n&lt;h3&gt;Implicitly defined properties on the global object&lt;/h3&gt;\n&lt;p&gt;In non-strict mode, implicitly defined properties on the global object have global scope, because the global object sits at the top of the scope chain. In strict mode, these are not permitted.&lt;/p&gt;\n&lt;h3&gt;eval&lt;/h3&gt;\n&lt;p&gt;In &lt;code&gt;eval&lt;/code&gt; strings, variables declared using &lt;code&gt;var&lt;/code&gt; will be placed in the current scope, or, if &lt;code&gt;eval&lt;/code&gt; is used indirectly, as properties on the global object.&lt;/p&gt;\n&lt;h2&gt;Examples&lt;/h2&gt;\n&lt;p&gt;The following will throw a ReferenceError because the names&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; have no meaning outside of the function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; z = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; x) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined (because var has function scope!)&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; y) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined (because the body of the function is a block)&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; z) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined (because the body of the function is a block)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;The following will throw a ReferenceError for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, but not for &lt;code&gt;x&lt;/code&gt;, because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block. Blocks that define the bodies of control structures like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;while&lt;/code&gt;, behave similarly.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; z = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; y) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined because `y` has block scope&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; z) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined because `z` has block scope&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif3&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In the following, &lt;code&gt;x&lt;/code&gt; is visible outside of the loop because &lt;code&gt;var&lt;/code&gt; has function scope:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; ++x) {}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 5 (note this is outside the loop!)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif4&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;...because of this behavior, you need to be careful about closing over variables declared using &lt;code&gt;var&lt;/code&gt; in loops. There is only one instance of variable &lt;code&gt;x&lt;/code&gt; declared here, and it sits logically outside of the loop.&lt;/p&gt;\n&lt;p&gt;The following prints &lt;code&gt;5&lt;/code&gt;, five times, and then prints &lt;code&gt;5&lt;/code&gt; a sixth time for the &lt;code&gt;console.log&lt;/code&gt; outside the loop:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; ++x) {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;() =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x)) &lt;span class=&quot;hljs-comment&quot;&gt;// closes over the `x` which is logically positioned at the top of the enclosing scope, above the loop&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// note: visible outside the loop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif5&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;The following prints &lt;code&gt;undefined&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for &lt;code&gt;let&lt;/code&gt; variables means that each anonymous function closed over a different variable named &lt;code&gt;x&lt;/code&gt; (unlike it would have done with &lt;code&gt;var&lt;/code&gt;), and so integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt; are printed.:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; ++x) {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;() =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x)) &lt;span class=&quot;hljs-comment&quot;&gt;// `let` declarations are re-declared on a per-iteration basis, so the closures capture different variables&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; x) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif6&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;The following will NOT throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block; it will, however, print &lt;code&gt;undefined&lt;/code&gt; because the variable has not been initialised (because of the &lt;code&gt;if&lt;/code&gt; statement).&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// here, `x` has been declared, but not initialised&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif7&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;A variable declared at the top of a &lt;code&gt;for&lt;/code&gt; loop using &lt;code&gt;let&lt;/code&gt; is scoped to the body of the loop:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; ++x) {} \n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; x) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `x` is block-scoped&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif8&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;The following will throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is constrained by the block:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; x) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `x` is block-scoped&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif9&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;Variables declared using &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; are all scoped to modules:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// module1.js&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//module2.js&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; f &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;module1.js&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// throws ReferenceError&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The following will declare a property on the global object because variables declared using &lt;code&gt;var&lt;/code&gt; within the global context are added as properties to the global object:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;)) &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif10&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in the global context do not add properties to the global object, but still have global scope:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;)) &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif11&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;Function parameters can be considered to be declared in the function body:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;) {}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; x) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `x` is scoped to the function&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif12&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;Catch block parameters are scoped to the catch-block body:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(e) {}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; e) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `e` is scoped to the catch block&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif13&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;Named function expressions are scoped only to the expression itself:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) { &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo) })()\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; foo) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `foo` is scoped to its own expression&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif14&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In non-strict mode, implicitly defined properties on the global object are globally scoped. In strict mode, you get an error.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// implicitly defined property on the global object (no &quot;var&quot;!)&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;)) &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif15&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In non-strict mode, function declarations have function scope. In strict mode, they have block scope.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&apos;use strict&apos;&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {}\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; foo) &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `foo` is block-scoped&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif16&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h2&gt;How it works under the hood&lt;/h2&gt;\n&lt;p&gt;Scope is defined as the &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;lexical&lt;/a&gt; region of code over which an identifier is valid.&lt;/p&gt;\n&lt;p&gt;In JavaScript, every function-object has a hidden &lt;code&gt;[[Environment]]&lt;/code&gt; reference that is a reference to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot; rel=&quot;noreferrer&quot;&gt;lexical environment&lt;/a&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot; rel=&quot;noreferrer&quot;&gt;execution context&lt;/a&gt; (stack frame) within which it was created.&lt;/p&gt;\n&lt;p&gt;When you invoke a function, the hidden &lt;code&gt;[[Call]]&lt;/code&gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the &lt;code&gt;[[Environment]]&lt;/code&gt; value on the function-object, into an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot; rel=&quot;noreferrer&quot;&gt;outer reference&lt;/a&gt; field on the lexical environment of the new execution context.&lt;/p&gt;\n&lt;p&gt;Note that this link between the new execution context and the lexical environment of the function object is called a &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;closure&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Thus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot; rel=&quot;noreferrer&quot;&gt;searching up the chain&lt;/a&gt; for a matching identifier.&lt;/p&gt;\n&lt;p&gt;Find out &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot; rel=&quot;noreferrer&quot;&gt;more&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It&apos;s always the position in the source that defines the scope.&lt;/p&gt;\n\n&lt;p&gt;An element in the scope chain is basically a Map with a pointer to its parent scope.&lt;/p&gt;\n\n&lt;p&gt;When resolving a variable, javascript starts at the innermost scope and searches outwards.&lt;/p&gt;\n    ","\n&lt;p&gt;Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.&lt;/p&gt;\n\n&lt;p&gt;(I&apos;m sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot; rel=&quot;noreferrer&quot;&gt;this page&lt;/a&gt; about what exactly &lt;code&gt;this&lt;/code&gt; means at any time. Hopefully &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot; rel=&quot;noreferrer&quot;&gt;this more introductory link&lt;/a&gt; is enough to get you started though.)&lt;/p&gt;\n    ","\n&lt;h1&gt;Old school JavaScript&lt;/h1&gt;\n&lt;p&gt;Traditionally, JavaScript really only has two types of scope :&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;Global Scope&lt;/strong&gt; : Variables are known throughout the application, from the start of the application &lt;em&gt;(*)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variables are known within &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; they are declared in, from the start of the function &lt;em&gt;(*)&lt;/em&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;I will not elaborate on this, since there are already many other answers explaining the difference.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h1&gt;Modern JavaScript&lt;/h1&gt;\n&lt;p&gt;The &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;most recent JavaScript specs&lt;/strong&gt;&lt;/a&gt; now also allow a third scope :&lt;/p&gt;\n&lt;ol start=&quot;3&quot;&gt;\n&lt;li&gt;&lt;strong&gt;Block Scope&lt;/strong&gt; : Identifiers are &quot;known&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;from the top of the scope they are declared within&lt;/a&gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h3&gt;How do I create block scope variables?&lt;/h3&gt;\n&lt;p&gt;Traditionally, you create your variables like this :&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myVariable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Some text&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Block scope variables are created like this :&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; myVariable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Some text&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h3&gt;So what is the difference between functional scope and block scope?&lt;/h3&gt;\n&lt;p&gt;To understand the difference between functional scope and block scope, consider the following code :&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// i IS NOT known here&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;loop&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;arr&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// i IS known here, but undefined&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but has a value only the second time loop is called&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.&lt;span class=&quot;hljs-property&quot;&gt;length&lt;/span&gt;; i++ ) {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// i IS known here, and has a value&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but has a value only the second time loop is called&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n    };\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// i IS known here, and has a value&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but has a value only the second time loop is called&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; arr.&lt;span class=&quot;hljs-property&quot;&gt;length&lt;/span&gt;; j++ ) {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// i IS known here, and has a value&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// j IS known here, and has a value&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but has a value only the second time loop is called&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n    };\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// i IS known here, and has a value&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, but has a value only the second time loop is called&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;loop&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; k = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; k &amp;lt; arr.&lt;span class=&quot;hljs-property&quot;&gt;length&lt;/span&gt;; k++ ) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// i IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, and has a value&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; l = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; l &amp;lt; arr.&lt;span class=&quot;hljs-property&quot;&gt;length&lt;/span&gt;; l++ ) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// i IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, and has a value&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// l IS known here, and has a value&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;loop&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// i IS NOT known here&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// j IS NOT known here&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// k IS known here, and has a value&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// l IS NOT known here&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.&lt;/p&gt;\n&lt;p&gt;Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You&apos;re also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3&gt;Is it safe to use block scope variables today?&lt;/h3&gt;\n&lt;p&gt;Whether or not it is safe to use today, depends on your environment :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re writing client-side JavaScript code and don&apos;t use a transpiler, you need to consider browser support.&lt;/p&gt;\n&lt;p&gt;These are some browsers that don&apos;t support &lt;code&gt;let&lt;/code&gt; at all :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Internet explorer 10&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Firefox 43&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Safari 9&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Android browser 4&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Opera 27&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Chome 40&lt;/strong&gt; and below&lt;/li&gt;\n&lt;li&gt;ANY version of &lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/J9kEC.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/J9kEC.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3&gt;How to keep track of browser support&lt;/h3&gt;\n&lt;p&gt;For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s an example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&amp;lt;script&amp;gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; globalVariable = &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//==window.globalVariable&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;aGlobal&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; param &lt;/span&gt;) { &lt;span class=&quot;hljs-comment&quot;&gt;//==window.aGlobal(); &lt;/span&gt;\n                            &lt;span class=&quot;hljs-comment&quot;&gt;//param is only accessible in this function&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; scopedToFunction = {\n    &lt;span class=&quot;hljs-comment&quot;&gt;//can&apos;t be accessed outside of this function&lt;/span&gt;\n\n    nested : &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;//accessible by: scopedToFunction.nested&lt;/span&gt;\n  };\n\n  anotherGlobal = {\n    &lt;span class=&quot;hljs-comment&quot;&gt;//global because there&apos;s no `var`&lt;/span&gt;\n  }; \n\n}\n\n&amp;lt;/script&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You&apos;ll want to investigate closures, and how to use them to make &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot; rel=&quot;noreferrer&quot;&gt;private members&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;Here is a good article on the subject.&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In &quot;Javascript 1.7&quot; (Mozilla&apos;s extension to Javascript) one can also declare block-scope variables with &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; (a = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) {\n   &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n }\n &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(a);   &lt;span class=&quot;hljs-comment&quot;&gt;// 4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The idea of scoping in JavaScript when originally designed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; came from the &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; scripting language &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.&lt;/p&gt;\n\n&lt;p&gt;This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.&lt;/p&gt;\n\n&lt;p&gt;The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be &lt;code&gt;window&lt;/code&gt; or a constructor function.&lt;/p&gt;\n\n&lt;p&gt;These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution. &lt;/p&gt;\n\n&lt;p&gt;So that is the technical explanation. In practice, it is important to remember that in JavaScript&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Scopes are technically &quot;Execution Contexts&quot;&lt;/li&gt;\n&lt;li&gt;Contexts form a stack of environments where variables are stored&lt;/li&gt;\n&lt;li&gt;The top of the stack takes precedence (the bottom being the global context)&lt;/li&gt;\n&lt;li&gt;Each function creates an execution context (but not always a new this binding)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Applying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six&apos;s immediately invoked function.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;i&lt;/em&gt;) The outer context. It has a variable environment of a = 1&lt;br&gt;\n &lt;em&gt;ii&lt;/em&gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack&lt;br&gt;\n &lt;em&gt;iii&lt;/em&gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/v45hL.png&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/v45hL.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;1) There is a global scope, a function scope, and the with and catch scopes. There is no &apos;block&apos; level scope in general for variable&apos;s -- the with and the catch statements add names to their blocks.&lt;/p&gt;\n\n&lt;p&gt;2) Scopes are nested by functions all the way to the global scope.&lt;/p&gt;\n\n&lt;p&gt;3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.&lt;/p&gt;\n\n&lt;p&gt;EDIT: ECMAAScript 6 (Harmony) is spec&apos;ed to support let, and I know chrome allows a &apos;harmony&apos; flag, so perhaps it does support it..&lt;/p&gt;\n\n&lt;p&gt;Let would be a support for block level scoping, but you have to use the keyword to make it happen.&lt;/p&gt;\n\n&lt;p&gt;EDIT: Based on Benjamin&apos;s pointing out of the with and catch statements in the comments, I&apos;ve edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that &lt;em&gt;is&lt;/em&gt; a block scope. These variables are aliased to the properties of the objects passed into them.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;//chrome (v8)&lt;/span&gt;\n\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = { &lt;span class=&quot;hljs-string&quot;&gt;&apos;test1&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;test1val&apos;&lt;/span&gt; }\n test1   &lt;span class=&quot;hljs-comment&quot;&gt;// error not defined&lt;/span&gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; (a) { &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; test1 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;replaced&apos;&lt;/span&gt; }\n test1   &lt;span class=&quot;hljs-comment&quot;&gt;// undefined&lt;/span&gt;\n a       &lt;span class=&quot;hljs-comment&quot;&gt;// a.test1 = &apos;replaced&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;EDIT: Clarifying example:&lt;/p&gt;\n\n&lt;p&gt;test1 is scoped to the with block, but is aliased to a.test1.  &apos;Var test1&apos; creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is. &lt;/p&gt;\n\n&lt;p&gt;Yikes!  Be careful using &apos;with&apos; -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.&lt;/p&gt;\n    ","\n&lt;p&gt;I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.&lt;/p&gt;\n\n&lt;p&gt;Try the feature at:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://prettydiff.com/jspretty.xhtml?c=white&amp;amp;jsscope&quot; rel=&quot;noreferrer&quot;&gt;http://prettydiff.com/jspretty.xhtml?c=white&amp;amp;jsscope&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;See a demo at:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://prettydiff.com/jspretty.xhtml?c=white&amp;amp;jsscope&amp;amp;s=http://prettydiff.com/lib/markup_beauty.js&quot; rel=&quot;noreferrer&quot;&gt;http://prettydiff.com/jspretty.xhtml?c=white&amp;amp;jsscope&amp;amp;s=http://prettydiff.com/lib/markup_beauty.js&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;View the code at:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://prettydiff.com/lib/jspretty.js&quot; rel=&quot;noreferrer&quot;&gt;http://prettydiff.com/lib/jspretty.js&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/austincheney/Pretty-Diff/blob/master/lib/jspretty.js&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.&lt;/p&gt;\n    ","\n&lt;h2&gt;Inline handlers&lt;/h2&gt;\n&lt;p&gt;A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with&lt;/p&gt;\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The scope of the variables that an &lt;code&gt;on*&lt;/code&gt; attribute can reference &lt;em&gt;must&lt;/em&gt; be either:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;global (working inline handlers almost always reference global variables)&lt;/li&gt;\n&lt;li&gt;a property of the document (eg, &lt;code&gt;querySelector&lt;/code&gt; as a standalone variable will point to &lt;code&gt;document.querySelector&lt;/code&gt;; rare)&lt;/li&gt;\n&lt;li&gt;a property of the element the handler is attached to (like above; rare)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Otherwise, you&apos;ll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined &lt;em&gt;inside&lt;/em&gt; &lt;code&gt;window.onload&lt;/code&gt; or &lt;code&gt;$(function() {&lt;/code&gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;true&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;&lt;div class=&quot;snippet-display&quot; style=&quot;vertical-align: center&quot;&gt;&lt;p&gt;&lt;a class=&quot;snippet-show-link-chevron&quot;&gt;&lt;span class=&quot;expander-arrow-hide&quot; style=&quot;vertical-align: middle;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;snippet-show-link&quot;&gt;&lt;span class=&quot;show-hide&quot; data-ishidden=&quot;true&quot; style=&quot;vertical-align: middle&quot;&gt;Show code snippet&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;\n&lt;div class=&quot;snippet-code snippet-currently-hidden&quot; style=&quot;display: none;&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;DOMContentLoaded&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;() =&amp;gt;&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo running&apos;&lt;/span&gt;);\n  }\n});&lt;/code&gt;&lt;/pre&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif17&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;Properties of the &lt;code&gt;document&lt;/code&gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;inside&lt;/em&gt; of two &lt;code&gt;with&lt;/code&gt; blocks&lt;/a&gt;, one for the &lt;code&gt;document&lt;/code&gt;, one for the element. The scope chain of variables inside these handlers is &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremely unintuitive&lt;/a&gt;, and a working event handler will &lt;em&gt;probably&lt;/em&gt; require a function to be global (and unnecessary global pollution &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;should probably be avoided&lt;/a&gt;).&lt;/p&gt;\n&lt;p&gt;Since the scope chain inside inline handlers is &lt;em&gt;so weird&lt;/em&gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it&apos;s probably easier to avoid them. Instead, attach event handlers using Javascript (like with &lt;code&gt;addEventListener&lt;/code&gt;), rather than with HTML markup.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;true&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;&lt;div class=&quot;snippet-display&quot; style=&quot;vertical-align: center&quot;&gt;&lt;p&gt;&lt;a class=&quot;snippet-show-link-chevron&quot;&gt;&lt;span class=&quot;expander-arrow-hide&quot; style=&quot;vertical-align: middle;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;snippet-show-link&quot;&gt;&lt;span class=&quot;show-hide&quot; data-ishidden=&quot;true&quot; style=&quot;vertical-align: middle&quot;&gt;Show code snippet&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;\n&lt;div class=&quot;snippet-code snippet-currently-hidden&quot; style=&quot;display: none;&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo running&apos;&lt;/span&gt;);\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;querySelector&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;.my-button&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;click&apos;&lt;/span&gt;, foo);&lt;/code&gt;&lt;/pre&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;my-button&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif18&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h2&gt;Modules (&lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;)&lt;/h2&gt;\n&lt;p&gt;On a different note, unlike normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is global, so you can reference it in other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, like this:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;true&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;&lt;div class=&quot;snippet-display&quot; style=&quot;vertical-align: center&quot;&gt;&lt;p&gt;&lt;a class=&quot;snippet-show-link-chevron&quot;&gt;&lt;span class=&quot;expander-arrow-hide&quot; style=&quot;vertical-align: middle;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;snippet-show-link&quot;&gt;&lt;span class=&quot;show-hide&quot; data-ishidden=&quot;true&quot; style=&quot;vertical-align: middle&quot;&gt;Show code snippet&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;\n&lt;div class=&quot;snippet-code snippet-currently-hidden&quot; style=&quot;display: none;&quot;&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;;\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo);\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif19&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;But the top level of an ES6 module is &lt;em&gt;not&lt;/em&gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly &lt;code&gt;export&lt;/code&gt;ed, or unless it&apos;s assigned to a property of the global object.&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;true&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;&lt;div class=&quot;snippet-display&quot; style=&quot;vertical-align: center&quot;&gt;&lt;p&gt;&lt;a class=&quot;snippet-show-link-chevron&quot;&gt;&lt;span class=&quot;expander-arrow-hide&quot; style=&quot;vertical-align: middle;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;snippet-show-link&quot;&gt;&lt;span class=&quot;show-hide&quot; data-ishidden=&quot;true&quot; style=&quot;vertical-align: middle&quot;&gt;Show code snippet&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;\n&lt;div class=&quot;snippet-code snippet-currently-hidden&quot; style=&quot;display: none;&quot;&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;module&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;;\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Can&apos;t access foo here, because the other script is a module&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; foo);\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif20&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.&lt;/p&gt;\n    ","\n&lt;p&gt;JavaScript have only two type of scope : &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;Global Scope&lt;/strong&gt; : Global is nothing but a window level scope.Here, variable present throughout the application.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variable declared within a function with &lt;code&gt;var&lt;/code&gt; keyword has functional scope.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;em&gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.&lt;/em&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;        a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;global&quot;&lt;/span&gt;;\n         &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;outer&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){ \n              b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;local&quot;&lt;/span&gt;;\n              &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a+b); &lt;span class=&quot;hljs-comment&quot;&gt;//&quot;globallocal&quot;&lt;/span&gt;\n         }\n&lt;span class=&quot;hljs-title function_&quot;&gt;outer&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Scope chain --&amp;gt;  &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Window level - &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;outer&lt;/code&gt; function are at top level in scope chain.&lt;/li&gt;\n&lt;li&gt;when outer function called a new &lt;code&gt;variable scope object&lt;/code&gt;(and included in scope chain) added with variable &lt;code&gt;b&lt;/code&gt; inside it.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Now when a variable &lt;code&gt;a&lt;/code&gt; required it first searches for nearest variable scope and if variable is not there than it move&apos;s to next object of variable scope chain.which is in this case is window level.&lt;/p&gt;\n    ","\n&lt;p&gt;run the code. hope this will give an idea about scoping &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global data&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;current document data&apos;&lt;/span&gt;;\n(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;,&lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;&lt;/span&gt;){\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;local data&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myObj = {\n    &lt;span class=&quot;hljs-title class_&quot;&gt;Name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;object data&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n        &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt;);\n    }\n};\n\nmyObj.&lt;span class=&quot;hljs-property&quot;&gt;newFun&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n    &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;testFun&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n    &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Window Scope : &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt; + \n          &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\nLocal Scope : &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-title class_&quot;&gt;Name&lt;/span&gt; + \n          &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\nObject Scope : &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt; + \n          &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\nCurrent document Scope : &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;Name&lt;/span&gt;\n         );\n}\n\n\ntestFun.&lt;span class=&quot;hljs-title function_&quot;&gt;call&lt;/span&gt;(myObj);\n})(&lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;,&lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h2&gt;Global Scope :&lt;/h2&gt;\n\n&lt;p&gt;Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//global variable&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//global function&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n   &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a);  &lt;span class=&quot;hljs-comment&quot;&gt;//access global variable&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Local Scope :&lt;/h2&gt;\n\n&lt;p&gt;If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.&lt;/p&gt;\n\n&lt;p&gt;Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n   &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//local variable&lt;/span&gt;\n   &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(d);\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;dog&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a); }\n     &lt;span class=&quot;hljs-title function_&quot;&gt;dog&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;//execute local function&lt;/span&gt;\n}\n\n &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(d); &lt;span class=&quot;hljs-comment&quot;&gt;//ReferenceError: dddddd is not defined    &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.thatjsdude.com/jsConcepts/concepts/scope.html&quot; rel=&quot;noreferrer&quot;&gt;Check this article for in-depth understanding of scope&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it&apos;s compiling and executing the code.&lt;/p&gt;\n\n&lt;p&gt;So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/0kqpZ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/0kqpZ.png&quot; alt=&quot;image&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Quoting from his ebook:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The building represents our programs nested scope ruleset. The first\n  floor of the building represents your currently executing scope,\n  wherever you are. The top level of the building is the global scope.\n  You resolve LHS and RHS references by looking on your current floor,\n  and if you dont find it, taking the elevator to the next floor,\n  looking there, then the next, and so on. Once you get to the top floor\n  (the global scope), you either find what youre looking for, or you\n  dont. But you have to stop regardless.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;One thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.&lt;/p&gt;\n\n&lt;p&gt;This idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it&apos;s being looked up in a nested function.\nHere is a link that goes into all these details, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot; rel=&quot;noreferrer&quot;&gt;Everything you wanted to know about javascript scope&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;There are ALMOST only two types of JavaScript scopes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;the scope of each var declaration is associated with the most immediately enclosing function&lt;/li&gt;\n&lt;li&gt;if there is no enclosing function for a var declaration, it is global scope&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, v = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; i++) { &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; }\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(i, v);\n&lt;span class=&quot;hljs-comment&quot;&gt;// output 5 5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using functions instead:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, v = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n$.&lt;span class=&quot;hljs-title function_&quot;&gt;each&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;], &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;i&lt;/span&gt;) { &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; });\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(i,v);\n&lt;span class=&quot;hljs-comment&quot;&gt;// output 10 10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.&lt;/p&gt;\n\n&lt;p&gt;That&apos;s almost all you need to know in terms of JavaScript scoping, except:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope&lt;/li&gt;\n&lt;li&gt;with-clause apparently is another exception, but using with-clause it highly discouraged (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot; rel=&quot;noreferrer&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt;)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top&lt;/li&gt;\n&lt;li&gt;multiple var declarations within the same scope are combined&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So this code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;abc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n  i = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(i);     &lt;span class=&quot;hljs-comment&quot;&gt;// outputs 1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is equivalent to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;abc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i;     &lt;span class=&quot;hljs-comment&quot;&gt;// var declaration moved to the top of the scope&lt;/span&gt;\n  i = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n  i = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;     &lt;span class=&quot;hljs-comment&quot;&gt;// the assignment stays where it is&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(i);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.&lt;/p&gt;\n    ","\n&lt;h1&gt;Modern Js, ES6+, &apos;&lt;code&gt;const&lt;/code&gt;&apos; and &apos;&lt;code&gt;let&lt;/code&gt;&apos;&lt;/h1&gt;\n&lt;p&gt;You should be using block scoping for every variable you create, just like most other major languages. &lt;code&gt;var&lt;/code&gt; is &lt;em&gt;obsolete&lt;/em&gt;. This makes your code safer and more maintainable.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;const&lt;/code&gt; should be used for &lt;strong&gt;95% of cases&lt;/strong&gt;. It makes it so the variable &lt;em&gt;reference&lt;/em&gt; can&apos;t change. Array, object, and DOM node properties can change and should likely be &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;let&lt;/code&gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.&lt;/p&gt;\n    ","\n&lt;p&gt;Try this curious example. In the example below if a were a numeric initialized at 0, you&apos;d see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Date&lt;/span&gt;();\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;b&lt;/span&gt;)\n{\n    b.&lt;span class=&quot;hljs-title function_&quot;&gt;setDate&lt;/span&gt;(b.&lt;span class=&quot;hljs-title function_&quot;&gt;getDate&lt;/span&gt;()+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(b.&lt;span class=&quot;hljs-title function_&quot;&gt;getDate&lt;/span&gt;());\n}\n&lt;span class=&quot;hljs-title function_&quot;&gt;f1&lt;/span&gt;(a);\n&lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(a.&lt;span class=&quot;hljs-title function_&quot;&gt;getDate&lt;/span&gt;());\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There are only function scopes in JS. Not block scopes!\nYou can see what is hoisting too.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; global_variable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;global_variable&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; hoisting_variable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;global_hoist&quot;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Global variables printed&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;global_scope: - global_variable: &quot;&lt;/span&gt; + global_variable);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;global_scope: - hoisting_variable: &quot;&lt;/span&gt; + hoisting_variable);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// The variable block will be global, on true condition.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; block = &lt;span class=&quot;hljs-string&quot;&gt;&quot;block&quot;&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;global_scope: - block: &quot;&lt;/span&gt; + block);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;local_function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; local_variable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;local_variable&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;local_scope: - local_variable: &quot;&lt;/span&gt; + local_variable);\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;local_scope: - global_variable: &quot;&lt;/span&gt; + global_variable);\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;local_scope: - block: &quot;&lt;/span&gt; + block);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// The hoisting_variable is undefined at the moment.&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;local_scope: - hoisting_variable: &quot;&lt;/span&gt; + hoisting_variable);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; hoisting_variable = &lt;span class=&quot;hljs-string&quot;&gt;&quot;local_hoist&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// The hoisting_variable is now set as a local one.&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;local_scope: - hoisting_variable: &quot;&lt;/span&gt; + hoisting_variable);\n}\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;local_function&lt;/span&gt;();\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// No variable in a separate function is visible into the global scope.&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;global_scope: - local_variable: &quot;&lt;/span&gt; + local_variable);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword &apos;var&apos;, either within a function or outside, and block scope is indicated with the keyword &apos;let&apos;.&lt;/p&gt;\n\n&lt;p&gt;For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS. &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In JavaScript there are two types of scope:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Local scope &lt;/li&gt;\n&lt;li&gt;Global scope&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The Below function has a local scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is not accessible from outside of the function.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; carName = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Volvo&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(carName);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The Below Class has a Global scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is accessible from everywhere in the class.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; carName = &lt;span class=&quot;hljs-string&quot;&gt;&quot; Volvo&quot;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;alert&lt;/span&gt;(carName);\n        &lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName &lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I really like the accepted answer but I want to add this:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Scope collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Scope is a set of rules for looking up variables by their identifier name.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;If a variable cannot be found in the immediate scope, Engine consults the next outer containing scope, continuing until is found or until the outermost (a.k.a., global) scope has been reached. &lt;/li&gt;\n&lt;li&gt;Is the set of rules that determines where and how a variable (identifier) can be looked up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. &lt;/li&gt;\n&lt;li&gt;LHS references result from assignment operations. Scope-related assignments can occur either with the = operator or by passing arguments to (assign to) function parameters.&lt;/li&gt;\n&lt;li&gt;The JavaScript engine first compiles code before it executes, and in so doing, it splits up statements like var a = 2; into two separate steps: 1st. First, var a to declare it in that scope. This is performed at the beginning, before code execution. 2nd. Later, a = 2 to look up the variable (LHS reference) and assign to it if found.&lt;/li&gt;\n&lt;li&gt;Both LHS and RHS reference look-ups start at the currently executing scope, and if need be (that is, they dont find what theyre looking for there), they work their way up the nested scope, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or dont. Unfulfilled RHS references result in ReferenceError being thrown. Unfulfilled LHS references result in an automatic, implicitly created global of that name (if not in Strict Mode), or a ReferenceError (if in Strict Mode).&lt;/li&gt;\n&lt;li&gt;scope consists of a series of bubbles that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author time.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;h2&gt;&lt;code&gt;ES5&lt;/code&gt; and earlier:&lt;/h2&gt;\n&lt;p&gt;Variables in Javascript were initially (pre &lt;code&gt;ES6&lt;/code&gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by &apos;looking&apos; at the code.&lt;/p&gt;\n&lt;p&gt;Every variable declared with the &lt;code&gt;var&lt;/code&gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a &lt;strong&gt;scope chain&lt;/strong&gt;. It works in the following manner:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside &lt;strong&gt;other&lt;/strong&gt; &lt;strong&gt;functions&lt;/strong&gt; which are in this scope).&lt;/li&gt;\n&lt;li&gt;If it cannot find the variable inside the function body it &lt;strong&gt;will climb up to the chain&lt;/strong&gt; and look at the variable scope in the function in &lt;strong&gt;where the function was defined&lt;/strong&gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2&gt;Example:&lt;/h2&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// global scope&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foobar = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global&apos;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;outerFunc&lt;/span&gt; () {\n &lt;span class=&quot;hljs-comment&quot;&gt;// outerFunc scope&lt;/span&gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;hljs-string&quot;&gt;&apos;outerFunc&apos;&lt;/span&gt;;\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foobar = &lt;span class=&quot;hljs-string&quot;&gt;&apos;outerFunc&apos;&lt;/span&gt;;\n &lt;span class=&quot;hljs-title function_&quot;&gt;innerFunc&lt;/span&gt;();\n \n &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;innerFunc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n &lt;span class=&quot;hljs-comment&quot;&gt;// innerFunc scope&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;hljs-string&quot;&gt;&apos;innerFunc&apos;&lt;/span&gt;;\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo);\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(bar);\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foobar);\n  }\n}\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;outerFunc&lt;/span&gt;();&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif21&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;What happens when we are trying to log the variables &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;foobar&lt;/code&gt; to the console is the following:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;We try to log foo to the console, foo can be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, the value of foo is resolved to the string &lt;code&gt;innerFunc&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;We try to log bar to the console, bar cannot be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt;. We first look in the outer function in which the function &lt;code&gt;innerFunc&lt;/code&gt; was defined. This is the function &lt;code&gt;outerFunc&lt;/code&gt;. In the scope of &lt;code&gt;outerFunc&lt;/code&gt; we can find the variable bar, which holds the string &apos;outerFunc&apos;.&lt;/li&gt;\n&lt;li&gt;foobar cannot be found in innerFunc. . Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt; to the innerFunc scope. It also cannot be found here, we climb another level to the &lt;strong&gt;global scope&lt;/strong&gt; (i.e. the outermost scope). We find the variable foobar here which holds the string &apos;global&apos;. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a &lt;strong&gt;referenceError&lt;/strong&gt;.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2&gt;&lt;code&gt;ES6&lt;/code&gt; (ES 2015) and older:&lt;/h2&gt;\n&lt;p&gt;The same concepts of lexically scope and scopechain still apply in &lt;code&gt;ES6&lt;/code&gt;. However a new ways to declare variables were introduced. There are the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;let&lt;/code&gt;: creates a block scoped variable&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;const&lt;/code&gt;: creates a block scoped variable which has to be initialized and cannot be reassigned&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The biggest difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; is that &lt;code&gt;var&lt;/code&gt; is function scoped whereas &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; are block scoped. Here is an example to illustrate this:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; letVar = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; varVar = &lt;span class=&quot;hljs-string&quot;&gt;&apos;global&apos;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt; () {\n  \n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// this variable declared with let is scoped to the if block, block scoped&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; letVar = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// this variable declared with let is scoped to the function block, function scoped&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; varVar = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n  }\n  \n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(letVar);\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(varVar);\n}\n\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;();&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif22&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In the above example letVar logs the value global because variables declared with &lt;code&gt;let&lt;/code&gt; are block scoped. They cease to exist outside their respective block, so the variable can&apos;t be accessed outside the if block.&lt;/p&gt;\n    ","\n&lt;p&gt;In EcmaScript5, there are mainly two scopes, &lt;strong&gt;local scope&lt;/strong&gt; and &lt;strong&gt;global scope&lt;/strong&gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called &lt;strong&gt;block scope&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;Example of block scope is :-&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ( &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i++)\n{\n statement1...\nstatement2...&lt;span class=&quot;hljs-comment&quot;&gt;// inside this scope we can access the value of i, if we want to access the value of i outside for loop it will give undefined.&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; z = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n{\n  x = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; z = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;\n  {\n    x = &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// x is in the global scope because of the &apos;var&apos; keyword&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// y is in the local scope because of the &apos;let&apos; keyword&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; z = &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// z is in the local scope because of the &apos;const&apos; keyword&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 30&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(y) &lt;span class=&quot;hljs-comment&quot;&gt;// 30&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(z) &lt;span class=&quot;hljs-comment&quot;&gt;// 30&lt;/span&gt;\n  }\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 30&lt;/span&gt;\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(y) &lt;span class=&quot;hljs-comment&quot;&gt;// 20&lt;/span&gt;\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(z) &lt;span class=&quot;hljs-comment&quot;&gt;// 20&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x) &lt;span class=&quot;hljs-comment&quot;&gt;// 30&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(y) &lt;span class=&quot;hljs-comment&quot;&gt;// 10&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(z) &lt;span class=&quot;hljs-comment&quot;&gt;// 10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) { &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo) })();\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; foo); &lt;span class=&quot;hljs-comment&quot;&gt;// undefined, because `foo` is scoped to its own expression&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//but, like this&lt;/span&gt;\n(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;1:&apos;&lt;/span&gt;, foo) &lt;span class=&quot;hljs-comment&quot;&gt;// function foo&lt;/span&gt;\n    foo = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;2:&apos;&lt;/span&gt;, foo) &lt;span class=&quot;hljs-comment&quot;&gt;// function foo, is not 100, why?&lt;/span&gt;\n})()&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif23&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;There are two types of scopes in JavaScript. &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Global scope&lt;/strong&gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; carName = &lt;span class=&quot;hljs-string&quot;&gt;&quot; BMW&quot;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n     &lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Functional scope or Local scope&lt;/strong&gt;: variable declared in this scope can be used in its own function only. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// code here can not use carName&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n   &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; carName = &lt;span class=&quot;hljs-string&quot;&gt;&quot;BMW&quot;&lt;/span&gt;;\n   &lt;span class=&quot;hljs-comment&quot;&gt;// code here can use carName&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    "],"65":["\n&lt;p&gt;(See &lt;a href=&quot;https://stackoverflow.com/a/17579889/4561887&quot;&gt;here also for my C++11 answer&lt;/a&gt;)&lt;/p&gt;\n\n&lt;p&gt;In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;t * f;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;How should this be parsed? For many languages a compiler doesn&apos;t need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it&apos;s a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it&apos;s not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. &lt;strong&gt;If a name has this property - that it can&apos;t be looked up until the actual template arguments are known - then it&apos;s called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;You might recommend to just wait till the user instantiates the template: &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;em&gt;Let&apos;s wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt; &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template&apos;s text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template&apos;s users (poor colleagues!) with errors made by a template&apos;s author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. &lt;/p&gt;\n\n&lt;p&gt;So there has to be a way to tell the compiler that certain names are types and that certain names aren&apos;t. &lt;/p&gt;\n\n&lt;h2&gt;The &quot;typename&quot; keyword&lt;/h2&gt;\n\n&lt;p&gt;The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// t::x is taken as non-type, but as an expression the following misses an&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// operator between the two names or a semicolon separating them.&lt;/span&gt;\nt::x f;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.&lt;/p&gt;\n\n&lt;p&gt;A similar gotcha exists for names that denote templates, as hinted at by the introductory text.&lt;/p&gt;\n\n&lt;h2&gt;The &quot;template&quot; keyword&lt;/h2&gt;\n\n&lt;p&gt;Remember the initial quote above and how the Standard requires special handling for templates as well? Let&apos;s take the following innocent-looking example: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;boost::function&amp;lt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;() &amp;gt; f;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; boost { &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; function = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; }\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ \n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; f = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n  boost::function&amp;lt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;() &amp;gt; f; \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That&apos;s actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt; &lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot; rel=&quot;noreferrer&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is\n  always taken as the beginning of a template-argument-list and never as a name followed by the less-than\n  operator.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can&apos;t know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;t::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// call a function template&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// call a function template&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;Dependencies&lt;/h2&gt;\n\n&lt;p&gt;For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I&apos;ll talk a bit about how this is specified in the Standard.&lt;/p&gt;\n\n&lt;p&gt;In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.&lt;/p&gt;\n\n&lt;p&gt;The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions. &lt;/p&gt;\n\n&lt;h3&gt;Dependent names&lt;/h3&gt;\n\n&lt;p&gt;The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). &lt;/p&gt;\n\n&lt;p&gt;To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.&lt;/p&gt;\n\n&lt;p&gt;A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. &lt;/p&gt;\n\n&lt;h3&gt;Dependent function names&lt;/h3&gt;\n\n&lt;p&gt;Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Additional notes and examples&lt;/h2&gt;\n\n&lt;p&gt;In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Tail&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;UnionNode&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Tail {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;inUnion&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Tail::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; inUnion&amp;lt;U&amp;gt; dummy;\n    };\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The keyword &lt;code&gt;template&lt;/code&gt; doesn&apos;t always have to appear in the last part of a name. It can appear in the middle before a class name that&apos;s used as a scope, like in the following example&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; t::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; iterator&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;::value_type v;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In some cases, the keywords are forbidden, as detailed below&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It&apos;s assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;derive_from_Has_type&lt;/span&gt; : &lt;span class=&quot;hljs-comment&quot;&gt;/* typename */&lt;/span&gt; SomeBase&amp;lt;T&amp;gt;::type \n { };\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In using-declarations it&apos;s not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot; rel=&quot;noreferrer&quot;&gt;said&lt;/a&gt; not to work on a solution. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;derive_from_Has_type&lt;/span&gt; : SomeBase&amp;lt;T&amp;gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; SomeBase&amp;lt;T&amp;gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; type; &lt;span class=&quot;hljs-comment&quot;&gt;// error&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; SomeBase&amp;lt;T&amp;gt;::type; &lt;span class=&quot;hljs-comment&quot;&gt;// typename *is* allowed&lt;/span&gt;\n };\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;h2&gt;C++11&lt;/h2&gt;\n\n&lt;h3&gt;Problem&lt;/h3&gt;\n\n&lt;p&gt;While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result_type;\n\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// error, &quot;this&quot; is dependent, &quot;template&quot; keyword needed&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;g&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&amp;gt;();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;g&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&amp;gt;();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// error, &quot;A&amp;lt;T&amp;gt;&quot; is dependent, &quot;typename&quot; keyword needed&lt;/span&gt;\n    A&amp;lt;T&amp;gt;::result_type n1;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    result_type n2; \n  }\n\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U&amp;gt;\n  &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!). &lt;/p&gt;\n\n&lt;h3&gt;Current instantiation&lt;/h3&gt;\n\n&lt;p&gt;To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations). &lt;/p&gt;\n\n&lt;p&gt;Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt; &lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). &lt;/p&gt;\n\n&lt;p&gt;The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result_type;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;C&lt;/span&gt; { }; &lt;span class=&quot;hljs-comment&quot;&gt;// could be specialized!&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;D&lt;/span&gt; : B, C&amp;lt;T&amp;gt; {\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK, member of current instantiation!&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// A::result_type is not dependent: int&lt;/span&gt;\n    D::result_type r1;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// error, not a member of the current instantiation&lt;/span&gt;\n    D::questionable_type r2;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK for now - relying on C&amp;lt;T&amp;gt; to provide it&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// But not a member of the current instantiation&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; D::questionable_type r3;        \n  }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That&apos;s impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;C&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; result_type;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; questionable_type;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. &lt;/p&gt;\n\n&lt;h3&gt;Unknown specializations&lt;/h3&gt;\n\n&lt;p&gt;In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. &lt;/p&gt;\n\n&lt;p&gt;Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; A&amp;lt;T&amp;gt;::questionable_type x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).&lt;/p&gt;\n\n&lt;h3&gt;Examples and trivia&lt;/h3&gt;\n\n&lt;p&gt;You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  &lt;/p&gt;\n\n&lt;p&gt;The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; B { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; };\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;C&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; B, T {\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(); }\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ \n  C&amp;lt;A&amp;gt; c; c.&lt;span class=&quot;hljs-built_in&quot;&gt;g&lt;/span&gt;(); \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot; rel=&quot;noreferrer&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Preface&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb&apos;s post&lt;/a&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;h1&gt;What&apos;s the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.&lt;/p&gt;\n&lt;p&gt;There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.&lt;/p&gt;\n&lt;p&gt;This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;A snippet says more than 1000 words&lt;/h2&gt;\n&lt;p&gt;Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f_tmpl&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ T::foo * x; &lt;span class=&quot;hljs-comment&quot;&gt;/* &amp;lt;-- (A) */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;sup&gt;&lt;br&gt;&lt;/sup&gt;\nIt might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;       foo;       }; &lt;span class=&quot;hljs-comment&quot;&gt;/* (C) --&amp;gt; */&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;f_tmpl&lt;/span&gt;&amp;lt;X&amp;gt; ();\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Y&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt;  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;/* (D) --&amp;gt; */&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;f_tmpl&lt;/span&gt;&amp;lt;Y&amp;gt; ();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;sup&gt;&lt;br&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;The two different scenarios&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;br&gt;\n&lt;hr&gt;\n&lt;h2&gt;The Rationale&lt;/h2&gt;\n&lt;p&gt;The C++ Standard cares about our safety and well-being, at least in this case.&lt;/p&gt;\n&lt;p&gt;To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we&apos;d like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.&lt;/p&gt;\n&lt;br&gt;\n&lt;hr&gt;\n&lt;h2&gt;How to handle dependent names?&lt;/h2&gt;\n&lt;p&gt;If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.&lt;/p&gt;\n&lt;p&gt;A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.\n&lt;sup&gt;&lt;br&gt;&lt;br&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;g_tmpl&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n   SomeTrait&amp;lt;T&amp;gt;::type                   foo; &lt;span class=&quot;hljs-comment&quot;&gt;// (E), ill-formed&lt;/span&gt;\n   SomeTrait&amp;lt;T&amp;gt;::NestedTrait&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;::type bar; &lt;span class=&quot;hljs-comment&quot;&gt;// (F), ill-formed&lt;/span&gt;\n   foo.&lt;span class=&quot;hljs-built_in&quot;&gt;data&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; ();                         &lt;span class=&quot;hljs-comment&quot;&gt;// (G), ill-formed    &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;)\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;)\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;G&lt;/strong&gt;)\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don&apos;t explicitly say otherwise).\n&lt;sup&gt;&lt;br&gt;&lt;br&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;h3&gt;The solution&lt;/h3&gt;\n&lt;p&gt;To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;g_tmpl&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; SomeTrait&amp;lt;T&amp;gt;::type foo;                            &lt;span class=&quot;hljs-comment&quot;&gt;// (G), legal&lt;/span&gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; SomeTrait&amp;lt;T&amp;gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; NestedTrait&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;::type bar; &lt;span class=&quot;hljs-comment&quot;&gt;// (H), legal&lt;/span&gt;\n   foo.&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;data&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; ();                                  &lt;span class=&quot;hljs-comment&quot;&gt;// (I), legal&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt; &lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it&apos;s quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there&apos;s no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we&apos;d like to treat as such.&lt;/p&gt;\n&lt;br&gt;\n&lt;hr&gt;\n&lt;h2&gt;Can I just stick the &lt;em&gt;keywords&lt;/em&gt; in front of any name?&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don&apos;t want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn&apos;t &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; N {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; { };\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;sup&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;         N::         X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; a; &lt;span class=&quot;hljs-comment&quot;&gt;// ...  legal&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; N::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; b; &lt;span class=&quot;hljs-comment&quot;&gt;// (K), legal&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; c; &lt;span class=&quot;hljs-comment&quot;&gt;// (L), ill-formed&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn&apos;t mean that you should.&lt;/sup&gt;&lt;/p&gt;\n&lt;br&gt;\n&lt;p&gt;Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Every name written in a derived class&apos;s &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;                    &lt;span class=&quot;hljs-comment&quot;&gt;// .------- the base-specifier-list&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-comment&quot;&gt;// v&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Derived&lt;/span&gt;      : &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; SomeTrait&amp;lt;T&amp;gt;::type &lt;span class=&quot;hljs-comment&quot;&gt;/* &amp;lt;- ill-formed */&lt;/span&gt; {\n    ...\n  };\n&lt;/code&gt;&lt;/pre&gt;\n &lt;br&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class&apos;s &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Base&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;type&lt;/span&gt; { };\n  };\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Derived&lt;/span&gt; : Base {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Base::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; type; &lt;span class=&quot;hljs-comment&quot;&gt;// ill-formed&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Base::type;          &lt;span class=&quot;hljs-comment&quot;&gt;// legal&lt;/span&gt;\n  };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;&lt;sub&gt;\n&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;\n&lt;/sub&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you&apos;re using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; type = T; &lt;span class=&quot;hljs-comment&quot;&gt;// no typename required&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; underlying_type = &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T::type &lt;span class=&quot;hljs-comment&quot;&gt;// typename required&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don&apos;t have to specify &lt;code&gt;typename&lt;/code&gt;, for example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// typename required&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; type = &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::conditional&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp;, T&amp;amp;&amp;amp;&amp;gt;::type;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// no typename required&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; integer = std::conditional&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&amp;gt;::type;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:&lt;/p&gt;\n\n&lt;p&gt;Given this struct and function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U&amp;gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;{\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;get\\n&quot;&lt;/span&gt;;\n    }\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; test&amp;lt;T&amp;gt;&amp;amp; t)&lt;/span&gt; &lt;/span&gt;{\n    t.&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// error&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;main.cpp:13:11: error: expected primary-expression before &apos;int&apos;\n     t.get&amp;lt;int&amp;gt;();\n           ^\nmain.cpp:13:11: error: expected &apos;;&apos; before &apos;int&apos;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;t.template get&amp;lt;int&amp;gt;()&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Tail::inUnion&amp;lt;U&amp;gt; dummy;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, I&apos;m not sure you&apos;re implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; TypeList&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Contains&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Head, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Tail&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Contains&lt;/span&gt;&amp;lt;T, UnionNode&amp;lt;Head, Tail&amp;gt; &amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { result = Contains&amp;lt;T, Tail&amp;gt;::result };\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Tail&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Contains&lt;/span&gt;&amp;lt;T, UnionNode&amp;lt;T, Tail&amp;gt; &amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { result = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; };\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Contains&lt;/span&gt;&amp;lt;T, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { result = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt; };\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot; rel=&quot;noreferrer&quot;&gt;Boost::Variant&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot; rel=&quot;noreferrer&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu&apos;s book: Modern C++ Design&lt;/p&gt;\n    ","\n&lt;h2&gt;C++20 aka C++2a&lt;/h2&gt;\n&lt;p&gt;As outlined in this &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html&quot; rel=&quot;noreferrer&quot;&gt;Proposal&lt;/a&gt;, C++20 / C++2a has further relaxed the requirements for the &lt;code&gt;typename&lt;/code&gt; keyword. In particular, &lt;code&gt;typename&lt;/code&gt; may now be omitted in all those places, where syntactically only a type is legal. So, if an unknown token must be a type, C++20 will actually treat it as a type. For backwards compatibility, &lt;code&gt;typename&lt;/code&gt; may still be used, though.&lt;/p&gt;\n&lt;p&gt;In particular, most &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;typedef&lt;/code&gt; declarations can now be written without &lt;code&gt;typename&lt;/code&gt;. &lt;code&gt;typename&lt;/code&gt; can also be omitted in the declaration of method return types (including trailing return types), in the declaration of method and lambda parameters and in the type argument to &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;reinterpret_cast&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;One notable exception, where &lt;code&gt;typename&lt;/code&gt; is still required, is in the argument list of instantiations of user or library defined templates: Even, if that particular argument was declared to be a type, the &lt;code&gt;typename&lt;/code&gt; keyword is still required. So &lt;code&gt;static_cast&amp;lt;A::B&amp;gt;(arg)&lt;/code&gt; is legal in C++20, but &lt;code&gt;my_template_class&amp;lt;A::B&amp;gt;(arg)&lt;/code&gt; is ill-formed, if A is a dependant scope and &lt;code&gt;my_template_class&lt;/code&gt; expects a type.&lt;/p&gt;\n&lt;p&gt;A few examples:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; type; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; val { &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; }; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; type; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; val { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; }; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;C&lt;/span&gt; {};\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; I&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;D&lt;/span&gt; {};\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {\n    T::type v;                                  &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;T::type &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T::type arg)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; arg; }      &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;T::type &lt;span class=&quot;hljs-title&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;T::type&amp;gt;(arg); } &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// C&amp;lt;T::type&amp;gt; c1;                           // error&lt;/span&gt;\n    D&amp;lt;T::val&amp;gt; d;                                &lt;span class=&quot;hljs-comment&quot;&gt;// OK (as has always been)&lt;/span&gt;\n    C&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T::type&amp;gt; c2;                     &lt;span class=&quot;hljs-comment&quot;&gt;// OK (old style)&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; T::type mytype;                     &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; mytypeagain = T::type;                &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    C&amp;lt;mytype&amp;gt; c3;                               &lt;span class=&quot;hljs-comment&quot;&gt;// OK (via typedef / using)&lt;/span&gt;\n};\nX&amp;lt;A&amp;gt; xa;\nX&amp;lt;B&amp;gt; xb;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I am placing JLBorges&apos;s excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot; rel=&quot;nofollow noreferrer&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I&apos;ve read on the subject.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T &amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( T&amp;amp; x, std::string str, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; count )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// these names are looked up during the second phase&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// when foo is instantiated and the type T is known&lt;/span&gt;\n    x.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// dependant name (non-type)&lt;/span&gt;\n    T::instance_count ; &lt;span class=&quot;hljs-comment&quot;&gt;// dependant name (non-type)&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T::iterator i ; &lt;span class=&quot;hljs-comment&quot;&gt;// dependant name (type)&lt;/span&gt;\n      \n    &lt;span class=&quot;hljs-comment&quot;&gt;// during the first phase, &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// T::instance_count is treated as a non-type (this is the default)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// the typename keyword specifies that T::iterator is to be treated as a type.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// these names are looked up during the first phase&lt;/span&gt;\n    std::string::size_type s ; &lt;span class=&quot;hljs-comment&quot;&gt;// non-dependant name (type)&lt;/span&gt;\n    std::string::npos ; &lt;span class=&quot;hljs-comment&quot;&gt;// non-dependant name (non-type)&lt;/span&gt;\n    str.&lt;span class=&quot;hljs-built_in&quot;&gt;empty&lt;/span&gt;() ; &lt;span class=&quot;hljs-comment&quot;&gt;// non-dependant name (non-type)&lt;/span&gt;\n    count ; &lt;span class=&quot;hljs-comment&quot;&gt;// non-dependant name (non-type)&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.&lt;/p&gt;\n&lt;p&gt;During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.&lt;/p&gt;\n    ","\n&lt;p&gt;Dependent name is a name depends on template parameters, we need to instruct compiler in order to compile the template class/function properly before actually instiatiate them.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;typename -&amp;gt; tell compiler the dependent name is an actual type&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DependentType&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T::type a;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Type=&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T::type;\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;template -&amp;gt; tell compiler the dependent name is a template function/class&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DependentTemplate&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// template function&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;U&lt;/span&gt;&amp;gt;\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// template class&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;U&lt;/span&gt;&amp;gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ClassName&lt;/span&gt;{};\n};\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T2&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// 3 ways to call a dependent template function&lt;/span&gt;\n  DependentTemplate&amp;lt;T1&amp;gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;func&lt;/span&gt;&amp;lt;T2&amp;gt;();\n  &lt;span class=&quot;hljs-built_in&quot;&gt;DependentTemplate&lt;/span&gt;&amp;lt;T1&amp;gt;().&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;func&lt;/span&gt;&amp;lt;T2&amp;gt;();\n  (&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;DependentTemplate&lt;/span&gt;&amp;lt;T1&amp;gt;())-&amp;gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;func&lt;/span&gt;&amp;lt;T2&amp;gt;();\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// You need both typename and template to reference a dependent template class&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; DependentTemplate&amp;lt;T1&amp;gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; ClassName&amp;lt;T2&amp;gt; obj;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Type=&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; DependentTemplate&amp;lt;T1&amp;gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; ClassName&amp;lt;T2&amp;gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    "]},"page":"110","randomQuestions":[{"title":"What does \"list comprehension\" and similar mean? How does it work and how can I use it?","slug":"what-does-\"list-comprehension\"-and-similar-mean-how-does-it-work-and-how-can-i-use-it-1657387996940"},{"title":"What is a StackOverflowError?","slug":"what-is-a-stackoverflowerror-1657388319634"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"CSS selector for first element with class","slug":"css-selector-for-first-element-with-class-1657388028765"},{"title":"Post an HTML Table to ADO.NET DataTable","slug":"post-an-html-table-to-ado.net-datatable-1657387462723"},{"title":"PHP - Failed to open stream : No such file or directory","slug":"php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"What is the difference between \"px\", \"dip\", \"dp\" and \"sp\"?","slug":"what-is-the-difference-between-\"px\"-\"dip\"-\"dp\"-and-\"sp\"-1657388093250"},{"title":"Dynamic tabs with user-click chosen components","slug":"dynamic-tabs-with-user-click-chosen-components-1657388465232"},{"title":"How to affect other elements when one element is hovered","slug":"how-to-affect-other-elements-when-one-element-is-hovered-1657387832363"},{"title":"How do I make a flat list out of a list of lists?","slug":"how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439"},{"title":"How can I upload files asynchronously with jQuery?","slug":"how-can-i-upload-files-asynchronously-with-jquery-1657384815389"},{"title":"Serialize and Deserialize Json and Json Array in Unity","slug":"serialize-and-deserialize-json-and-json-array-in-unity-1657388273270"},{"title":"Remove duplicate values from JS array [duplicate]","slug":"remove-duplicate-values-from-js-array-duplicate-1657387801931"},{"title":"Difference between single and double quotes in Bash","slug":"difference-between-single-and-double-quotes-in-bash-1657385460827"},{"title":"Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop","slug":"iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824"},{"title":"What is an undefined reference/unresolved external symbol error and how do I fix it?","slug":"what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179"}]},"__N_SSG":true}