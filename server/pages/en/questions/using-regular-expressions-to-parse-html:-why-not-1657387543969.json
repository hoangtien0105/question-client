{"pageProps":{"data":{"answer":["\n&lt;p&gt;Entire HTML parsing is not possible with regular expressions, since it depends on matching the opening and the closing tag which is not possible with regexps.&lt;/p&gt;\n\n&lt;p&gt;Regular expressions can only match &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot; rel=&quot;noreferrer&quot;&gt;regular languages&lt;/a&gt; but HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot; rel=&quot;noreferrer&quot;&gt;context-free language&lt;/a&gt; and &lt;em&gt;not&lt;/em&gt; a regular language (As @StefanPochmann pointed out, regular languages are also context-free, so context-free doesn&apos;t necessarily mean not regular). The only thing you can do with regexps on HTML is heuristics but that will not work on every condition. It should be possible to present a HTML file that will be matched wrongly by any regular expression.&lt;/p&gt;\n    ","\n&lt;p&gt;For quick´n´dirty regexp will do fine.  But the fundamental thing to know is that it is &lt;em&gt;impossible&lt;/em&gt; to construct a regexp that will &lt;em&gt;correctly&lt;/em&gt; parse HTML.&lt;/p&gt;\n\n&lt;p&gt;The reason is that regexps cant handle arbitarly nested expressions.  See &lt;a href=&quot;https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns&quot;&gt;Can regular expressions be used to match nested patterns?&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;(From &lt;a href=&quot;http://htmlparsing.com/regexes&quot; rel=&quot;noreferrer&quot;&gt;http://htmlparsing.com/regexes&lt;/a&gt;)&lt;/p&gt;\n\n&lt;p&gt;Say you&apos;ve got a file of HTML where you&apos;re trying to extract URLs from\n&amp;lt;img&amp;gt; tags.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://example.com/whatever.jpg&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So you write a regex like this in Perl:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;hljs-variable&quot;&gt;$html&lt;/span&gt; =~ /&amp;lt;img src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;(.+)&quot;&lt;/span&gt;/ ) {\n    &lt;span class=&quot;hljs-variable&quot;&gt;$url&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In this case, &lt;code&gt;$url&lt;/code&gt; will indeed contain\n&lt;code&gt;http://example.com/whatever.jpg&lt;/code&gt;.  But what happens when\nyou start getting HTML like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;http://example.com/whatever.jpg&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;http://example.com/whatever.jpg&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;border&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://example.com/whatever.jpg&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://example.com/whatever.jpg&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or you start getting false positives from&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&amp;lt;!-- // commented out\n&amp;lt;img src=&quot;http://example.com/outdated.png&quot;&amp;gt;\n--&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It looks so simple, and it might be simple for a single, unchanging file, but for anything that you&apos;re going to be doing on arbitrary HTML data, regexes are just a recipe for future heartache.&lt;/p&gt;\n    ","\n&lt;p&gt;Two quick reasons:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;writing a regex that can stand up to malicious input is hard; way harder than using a prebuilt tool&lt;/li&gt;\n&lt;li&gt;writing a regex that can work with the ridiculous markup that you will inevitably be stuck with is hard; way harder than using a prebuilt tool&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Regarding the suitability of regexes for parsing in general: they aren&apos;t suitable. Have you ever seen the sorts of regexes you would need to parse most languages?&lt;/p&gt;\n    ","\n&lt;p&gt;As far as parsing goes, regular expressions can be useful in the &quot;lexical analysis&quot; (lexer) stage, where the input is broken down into tokens. It&apos;s less useful in the actual &quot;build a parse tree&quot; stage.&lt;/p&gt;\n\n&lt;p&gt;For an HTML parser, I&apos;d expect it to only accept well-formed HTML and that requires capabilities outside what a regular expression can do (they cannot &quot;count&quot; and make sure that a given number of opening elements are balanced by the same number of closing elements).&lt;/p&gt;\n    ","\n&lt;p&gt;Because there are many ways to &quot;screw up&quot; HTML that browsers will treat in a rather liberal way but it would take quite some effort to reproduce the browser&apos;s liberal behaviour to cover all cases with regular expressions, so your regex will inevitably fail on some special cases, and that would possibly introduce serious security gaps in your system.&lt;/p&gt;\n    ","\n&lt;p&gt;The problem is that most users who ask a question that has to do with HTML and regex do this because they can&apos;t find an own regex that works. Then one has to think whether everything would be easier when using a DOM or SAX parser or something similar. They are optimized and constructed for the purpose of working with XML-like document structures.&lt;/p&gt;\n\n&lt;p&gt;Sure, there are problems that can be solved easily with regular expressions. But the emphasis lies on &lt;strong&gt;easily&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;If you just want to find all URLs that look like &lt;code&gt;http://.../&lt;/code&gt; you&apos;re fine with regexps. But if you want to find all URLs that are in a a-Element that has the class &apos;mylink&apos; you probably better use a appropriate parser.&lt;/p&gt;\n    ","\n&lt;p&gt;Regular expressions were not designed to handle a nested tag structure, and it is at best complicated (at worst, impossible) to handle all the possible edge cases you get with real HTML.&lt;/p&gt;\n    ","\n&lt;p&gt;I believe that the answer lies in computation theory. For a language to be parsed using regex it must be by definition &quot;regular&quot; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_language&quot; rel=&quot;noreferrer&quot;&gt;link&lt;/a&gt;). HTML is not a regular language as it does not meet a number of criteria for a regular language (much to do with the many levels of nesting inherent in html code). If you are interested in the theory of computation I would recommend &lt;a href=&quot;http://books.google.co.uk/books?id=eRYFAAAACAAJ&amp;amp;dq=theory+of+computation&amp;amp;ei=WqimSamaGYvCMvCFrIQO&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; book.&lt;/p&gt;\n    ","\n&lt;p&gt;HTML/XML is divided into markup and content. \nRegex is only useful doing a lexical tag parse.\nI guess you could deduce the content.\nIt would be a good choice for a SAX parser.\nTags and content could be delivered to a user\ndefined function where nesting/closure of elements\ncan be kept track of.  &lt;/p&gt;\n\n&lt;p&gt;As far as just parsing the tags, it can be done with\nregex and used to strip tags from a document.&lt;/p&gt;\n\n&lt;p&gt;Over years of testing, I&apos;ve found the secret to the\nway browsers parse tags, both well and ill formed.  &lt;/p&gt;\n\n&lt;p&gt;The normal elements are parsed with this form:&lt;/p&gt;\n\n&lt;p&gt;The core of these tags use this regex&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-lisp&quot;&gt; (?:\n      &lt;span class=&quot;hljs-string&quot;&gt;&quot; [\\S\\s]*? &quot;&lt;/span&gt; \n   |  &apos; [\\S\\s]*? &apos; \n   |  [^&amp;gt;]? \n )+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You&apos;ll notice this &lt;code&gt;[^&amp;gt;]?&lt;/code&gt; as one of the alternations.\nThis will match unbalanced quotes from ill-formed tags.  &lt;/p&gt;\n\n&lt;p&gt;It is also, the single most &lt;em&gt;root of all evil&lt;/em&gt; to regular expressions.\nThe way it&apos;s used will trigger a bump-along to satisfy it&apos;s greedy, must-match\nquantified container.  &lt;/p&gt;\n\n&lt;p&gt;If used passively, there is never a problem\nBut, if you &lt;em&gt;force&lt;/em&gt; something to match by interspersing it with\na wanted attribute/value pair, and don&apos;t provide adequate protection\nfrom backtracking, it&apos;s an out of control nightmare.&lt;/p&gt;\n\n&lt;p&gt;This is the general form for just plain old tags.\nNotice the  &lt;code&gt;[\\w:]&lt;/code&gt; representing the tag name?\nIn reality, the &lt;em&gt;legal&lt;/em&gt; characters representing the tag name\nare an incredible list of Unicode characters.  &lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-lisp&quot;&gt; &amp;lt;     \n (?:\n      [\\w:]+ \n      \\s+ \n      (?:\n           &lt;span class=&quot;hljs-string&quot;&gt;&quot; [\\S\\s]*? &quot;&lt;/span&gt; \n        |  &apos; [\\S\\s]*? &apos; \n        |  [^&amp;gt;]? \n      )+\n      \\s* /?\n )\n &amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Moving on, we also see that you just can&apos;t search for a specific tag\nwithout parsing &lt;em&gt;ALL&lt;/em&gt; tags.\nI mean you could, but it would have to use a combination of\nverbs like (*SKIP)(*FAIL) but still all tags have to be parsed.&lt;/p&gt;\n\n&lt;p&gt;The reason is that tag syntax may be hidden inside other tags, etc.&lt;/p&gt;\n\n&lt;p&gt;So, to passively parse all tags, a regex is needed like the one below.\nThis particular one matches &lt;em&gt;invisible content&lt;/em&gt; as well.&lt;/p&gt;\n\n&lt;p&gt;As new HTML or xml or any other develop new constructs, just add it as\none of the alternations. &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;em&gt;Web page note - I&apos;ve never seen a web page (or xhtml/xml) that this&lt;br&gt;\nhad trouble with. If you find one, let me know.&lt;/em&gt;  &lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Performance note - It&apos;s quick. This is the fastest tag parser I&apos;ve seen&lt;br&gt;\n(there may be faster, who knows).&lt;br&gt;\nI have several specific versions.  It is also excellent as scraper&lt;br&gt;\n(if you&apos;re the hands-on type).&lt;/em&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Complete raw regex  &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;&amp;lt;(?:(?:(?:(script|style|object|embed|applet|noframes|noscript|noembed)(?:\\s+(?&amp;gt;&quot;[\\S\\s]*?&quot;|&apos;[\\S\\s]*?&apos;|(?:(?!/&amp;gt;)[^&amp;gt;])?)+)?\\s*&amp;gt;)[\\S\\s]*?&amp;lt;/\\1\\s*(?=&amp;gt;))|(?:/?[\\w:]+\\s*/?)|(?:[\\w:]+\\s+(?:&quot;[\\S\\s]*?&quot;|&apos;[\\S\\s]*?&apos;|[^&amp;gt;]?)+\\s*/?)|\\?[\\S\\s]*?\\?|(?:!(?:(?:DOCTYPE[\\S\\s]*?)|(?:\\[CDATA\\[[\\S\\s]*?\\]\\])|(?:--[\\S\\s]*?--)|(?:ATTLIST[\\S\\s]*?)|(?:ENTITY[\\S\\s]*?)|(?:ELEMENT[\\S\\s]*?))))&amp;gt;&lt;/code&gt;  &lt;/p&gt;\n\n&lt;p&gt;Formatted look  &lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-lisp&quot;&gt; &amp;lt;\n (?:\n      (?:\n           (?:\n                # Invisible content&lt;span class=&quot;hljs-comment&quot;&gt;; end tag req&apos;d&lt;/span&gt;\n                (                             &lt;span class=&quot;hljs-name&quot;&gt;#&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; start)\n                     script\n                  |  style\n                  |  object\n                  |  embed\n                  |  applet\n                  |  noframes\n                  |  noscript\n                  |  noembed \n                )                             # (1 end)\n                (?:\n                     \\s+ \n                     (?&amp;gt;\n                          &quot; [\\S\\s]*? &quot;\n                       |  &apos; [\\S\\s]*? &apos;\n                       |  (?:\n                               (?! /&amp;gt; )\n                               [^&amp;gt;] \n                          )?\n                     )+\n                )?\n                \\s* &amp;gt;\n           )\n\n           [\\S\\s]*? &amp;lt;/ \\1 \\s* \n           (?= &amp;gt; )\n      )\n\n   |  (?: /? [\\w:]+ \\s* /? )\n   |  (?:\n           [\\w:]+ \n           \\s+ \n           (?:\n                &lt;span class=&quot;hljs-string&quot;&gt;&quot; [\\S\\s]*? &quot;&lt;/span&gt; \n             |  &apos; [\\S\\s]*? &apos; \n             |  [^&amp;gt;]? \n           )+\n           \\s* /?\n      )\n   |  \\? [\\S\\s]*? \\?\n   |  (?:\n           !\n           (?:\n                (?: DOCTYPE [\\S\\s]*? )\n             |  (?: \\[CDATA\\[ [\\S\\s]*? \\]\\] )\n             |  (?: -- [\\S\\s]*? -- )\n             |  (?: ATTLIST [\\S\\s]*? )\n             |  (?: ENTITY [\\S\\s]*? )\n             |  (?: ELEMENT [\\S\\s]*? )\n           )\n      )\n )\n &amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This expression retrieves attributes from HTML elements. It supports:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;unquoted / quoted attributes,&lt;/li&gt;\n&lt;li&gt;single / double quotes,&lt;/li&gt;\n&lt;li&gt;escaped quotes inside attributes,&lt;/li&gt;\n&lt;li&gt;spaces around equals signs,&lt;/li&gt;\n&lt;li&gt;any number of attributes,&lt;/li&gt;\n&lt;li&gt;check only for attributes inside tags,&lt;/li&gt;\n&lt;li&gt;escape comments, and&lt;/li&gt;\n&lt;li&gt;manage different quotes within an attribute value.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;code&gt;(?:\\&amp;lt;\\!\\-\\-(?:(?!\\-\\-\\&amp;gt;)\\r\\n?|\\n|.)*?-\\-\\&amp;gt;)|(?:&amp;lt;(\\S+)\\s+(?=.*&amp;gt;)|(?&amp;lt;=[=\\s])\\G)(?:((?:(?!\\s|=).)*)\\s*?=\\s*?[\\&quot;&apos;]?((?:(?&amp;lt;=\\&quot;)(?:(?&amp;lt;=\\\\)\\&quot;|[^\\&quot;])*|(?&amp;lt;=&apos;)(?:(?&amp;lt;=\\\\)&apos;|[^&apos;])*)|(?:(?!\\&quot;|&apos;)(?:(?!\\/&amp;gt;|&amp;gt;|\\s).)+))[\\&quot;&apos;]?\\s*)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://regex101.com/r/wRD0zq/1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Check it out&lt;/a&gt;. It works better with the &quot;gisx&quot; flags, as in the demo.&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;It depends&quot; though. It&apos;s true that regexes don&apos;t and can&apos;t parse HTML with true accuracy, for all the reasons given here. If, however, the consequences of getting it wrong (such as not handling nested tags) are minor, and if regexes are super-convenient in your environment (such as when you&apos;re hacking Perl), go ahead.&lt;/p&gt;\n\n&lt;p&gt;Suppose you&apos;re, oh, maybe parsing web pages that link to your site--perhaps you found them with a Google link search--and you want a quick way to get a general idea of the context surround your link. You&apos;re trying to run a little report that might alert you to link spam, something like that.&lt;/p&gt;\n\n&lt;p&gt;In that case, misparsing some of the documents isn&apos;t going to be a big deal. Nobody but you will see the mistakes, and if you&apos;re very lucky there will be few enough that you can follow up individually.&lt;/p&gt;\n\n&lt;p&gt;I guess I&apos;m saying it&apos;s a tradeoff. Sometimes implementing or using a correct parser--as easy as that may be--might not be worth the trouble if accuracy isn&apos;t critical.&lt;/p&gt;\n\n&lt;p&gt;Just be careful with your assumptions. I can think of a few ways the regexp shortcut can backfire if you&apos;re trying to parse something that will be shown in public, for example.&lt;/p&gt;\n    ","\n&lt;p&gt;There are definitely cases where using a regular expression to parse some information from HTML is the correct way to go - it depends a lot on the specific situation.&lt;/p&gt;\n\n&lt;p&gt;The consensus above is that in general it is a bad idea. However if the HTML structure is known (and unlikely to change) then it is still a valid approach.&lt;/p&gt;\n    ","\n&lt;p&gt;Keep in mind that while HTML itself isn&apos;t regular, portions of a page you are looking at &lt;em&gt;might&lt;/em&gt; be regular.&lt;/p&gt;\n\n&lt;p&gt;For example, it is an error for &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags to be nested; if the web page is working correctly, then using a regular expression to grab a &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; would be completely reasonable.&lt;/p&gt;\n\n&lt;p&gt;I recently did some web scraping using only Selenium and regular expressions.  I got away with it because the data I wanted was put in a &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, and put in a simple table format (so I could even count on &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; to be non-nested--which is actually highly unusual).  In some degree, regular expressions were even almost necessary, because some of the structure I needed to access was delimited by comments.  (Beautiful Soup can give you comments, but it would have been difficult to grab &lt;code&gt;&amp;lt;!-- BEGIN --&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;!-- END --&amp;gt;&lt;/code&gt; blocks using Beautiful Soup.)&lt;/p&gt;\n\n&lt;p&gt;If I had to worry about nested tables, however, my approach simply would not have worked!  I would have had to fall back on Beautiful Soup.  Even then, however, sometimes you can use a regular expression to grab the chunk you need, and then drill down from there.&lt;/p&gt;\n    ","\n&lt;p&gt;Actually, HTML parsing with regex is perfectly possible in PHP. You just have to parse the whole string backwards using &lt;code&gt;strrpos&lt;/code&gt; to find &lt;code&gt;&amp;lt;&lt;/code&gt; and repeat the regex from there using ungreedy specifiers each time to get over nested tags. Not fancy and terribly slow on large things, but I used it for my own personal template editor for my website. I wasn&apos;t actually parsing HTML, but a few custom tags I made for querying database entries to display tables of data (my &lt;code&gt;&amp;lt;#if()&amp;gt;&lt;/code&gt; tag could highlight special entries this way). I wasn&apos;t prepared to go for an XML parser on just a couple of self created tags (with very non-XML data within them) here and there.&lt;/p&gt;\n\n&lt;p&gt;So, even though this question is considerably dead, it still shows up in a Google search. I read it and thought &quot;challenge accepted&quot; and finished fixing my simple code without having to replace everything. Decided to offer a different opinion to anyone searching for a similar reason. Also the last answer was posted 4 hours ago so this is still a hot topic.&lt;/p&gt;\n    ","\n&lt;p&gt;I tried my hand at a regex for this too. It&apos;s mostly useful for finding chunks of content paired with the next HTML tag, and it doesn&apos;t look for &lt;strong&gt;&lt;em&gt;matching&lt;/em&gt;&lt;/strong&gt; close tags, but it will pick up close tags. Roll a stack in your own language to check those. &lt;/p&gt;\n\n&lt;p&gt;Use with &apos;sx&apos; options.  &apos;g&apos; too if you&apos;re feeling lucky:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php-template&quot;&gt;&lt;span class=&quot;language-xml&quot;&gt;(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;content&lt;/span&gt;&amp;gt;&lt;/span&gt;.*?)                # Content up to next tag\n(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;markup&lt;/span&gt;&amp;gt;&lt;/span&gt;                     # Entire tag\n  &amp;lt;!\\[CDATA\\[(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;cdata&lt;/span&gt;&amp;gt;&lt;/span&gt;.+?)]]&amp;gt;| # &amp;lt;![CDATA[ ... ]]&amp;gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;&amp;lt;!--(?P&amp;lt;comment&amp;gt;.+?)--&amp;gt;&lt;/span&gt;|      # &lt;span class=&quot;hljs-comment&quot;&gt;&amp;lt;!-- Comment --&amp;gt;&lt;/span&gt;\n  &amp;lt;/\\s*(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;close_tag&lt;/span&gt;&amp;gt;&lt;/span&gt;\\w+)\\s*&amp;gt;|  # &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;tag&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &amp;lt;(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tag&lt;/span&gt;&amp;gt;&lt;/span&gt;\\w+)                 # &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;...&lt;/span&gt;\n    (?&lt;span class=&quot;hljs-attr&quot;&gt;P&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-attr&quot;&gt;attributes&lt;/span&gt;&amp;gt;&lt;/span&gt;\n      (?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;attribute&lt;/span&gt;&amp;gt;&lt;/span&gt;\\s+\n# &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;snip&lt;/span&gt;&amp;gt;&lt;/span&gt;: Use this part to get the attributes out of &apos;attributes&apos; group.\n        (?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;attribute_name&lt;/span&gt;&amp;gt;&lt;/span&gt;\\w+)\n        (?:\\s*=\\s*\n          (?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;attribute_value&lt;/span&gt;&amp;gt;&lt;/span&gt;\n            [\\w:/.\\-]+|         # Unquoted\n            (?=(?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;_v&lt;/span&gt;&amp;gt;&lt;/span&gt;          # Quoted\n              (?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;_q&lt;/span&gt;&amp;gt;&lt;/span&gt;[&apos;\\&quot;]).*?(?&amp;lt;!\\\\)(?P=_q)))\n            (?P=_v)\n          ))?\n# &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;snip&lt;/span&gt;&amp;gt;&lt;/span&gt;\n      )*\n    )\\s*\n  (?P&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;is_self_closing&lt;/span&gt;&amp;gt;&lt;/span&gt;/?)   # Self-closing indicator\n  &amp;gt;)                        # End of tag\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This one is designed for Python (it might work for other languages, haven&apos;t tried it, it uses positive lookaheads, negative lookbehinds, and named backreferences).  Supports:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Open Tag - &lt;code&gt;&amp;lt;div ...&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Close Tag - &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Comment - &lt;code&gt;&amp;lt;!-- ... --&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;CDATA - &lt;code&gt;&amp;lt;![CDATA[ ... ]]&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Self-Closing Tag - &lt;code&gt;&amp;lt;div .../&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Optional Attribute Values - &lt;code&gt;&amp;lt;input checked&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Unquoted / Quoted Attribute Values - &lt;code&gt;&amp;lt;div style=&apos;...&apos;&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Single / Double Quotes - &lt;code&gt;&amp;lt;div style=&quot;...&quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Escaped Quotes - &lt;code&gt;&amp;lt;a title=&apos;John\\&apos;s Story&apos;&amp;gt;&lt;/code&gt;&lt;br&gt;\n&lt;em&gt;(this isn&apos;t really valid HTML, but I&apos;m a nice guy)&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Spaces Around Equals Signs - &lt;code&gt;&amp;lt;a href = &apos;...&apos;&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Named Captures For Interesting Bits&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;It&apos;s also pretty good about not triggering on malformed tags, like when you forget a &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If your regex flavor supports repeated named captures then you&apos;re golden, but Python &lt;code&gt;re&lt;/code&gt; doesn&apos;t (I know regex does, but I need to use vanilla Python). Here&apos;s what you get:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;content&lt;/code&gt; - All of the content up to the next tag. You could leave this out.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;markup&lt;/code&gt; - The entire tag with everything in it.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;comment&lt;/code&gt; - If it&apos;s a comment, the comment contents.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;cdata&lt;/code&gt; - If it&apos;s a &lt;code&gt;&amp;lt;![CDATA[...]]&amp;gt;&lt;/code&gt;, the CDATA contents.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;close_tag&lt;/code&gt; - If it&apos;s a close tag (&lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;), the tag name.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;tag&lt;/code&gt; - If it&apos;s an open tag (&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;), the tag name.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;attributes&lt;/code&gt; - All attributes inside the tag. Use this to get all attributes if you don&apos;t get repeated groups.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;attribute&lt;/code&gt; - Repeated, each attribute.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;attribute_name&lt;/code&gt; - Repeated, each attribute name.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;attribute_value&lt;/code&gt; - Repeated, each attribute value. This includes the quotes if it was quoted.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;is_self_closing&lt;/code&gt; - This is &lt;code&gt;/&lt;/code&gt; if it&apos;s a self-closing tag, otherwise nothing.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;_q&lt;/code&gt; and &lt;code&gt;_v&lt;/code&gt; - Ignore these; they&apos;re used internally for backreferences.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If your regex engine doesn&apos;t support repeated named captures, there&apos;s a section called out that you can use to get each attribute. Just run that regex on the &lt;code&gt;attributes&lt;/code&gt; group to get each &lt;code&gt;attribute&lt;/code&gt;, &lt;code&gt;attribute_name&lt;/code&gt; and &lt;code&gt;attribute_value&lt;/code&gt; out of it.&lt;/p&gt;\n\n&lt;p&gt;Demo here: &lt;a href=&quot;https://regex101.com/r/mH8jSu/11&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://regex101.com/r/mH8jSu/11&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Regular expressions are not powerful enough for such a language like HTML. Sure, there are some examples where you can use regular expressions. But in general it is not appropriate for parsing.&lt;/p&gt;\n    ","\n&lt;p&gt;You, know...there&apos;s a lot of mentality of you &lt;strong&gt;CAN&apos;T&lt;/strong&gt; do it and I think that everyone on both sides of the fence are right and wrong.  You &lt;strong&gt;CAN&lt;/strong&gt; do it, but it takes a little more processing than just running one regex against it.  Take &lt;a href=&quot;http://bit.ly/1MKKkXh&quot; rel=&quot;nofollow&quot;&gt;this&lt;/a&gt; (I wrote this inside of an hour) as an example.  It assumes the HTML is completely valid, but depending on what language you&apos;re using to apply the aforementioned regex, you could do some fixing of the HTML to make sure that it will succeed.  For example, removing closing tags that are not supposed to be there: &lt;em&gt;&lt;code&gt;&amp;lt;/img&amp;gt;&lt;/code&gt;&lt;/em&gt; for example.  Then, add the closing single HTML forward slash to elements that are missing them, etc.&lt;/p&gt;\n\n&lt;p&gt;I&apos;d use this in the context of writing a library that would allow me to perform HTML element retrieval akin to that of JavaScript&apos;s &lt;code&gt;[x].getElementsByTagName()&lt;/code&gt;, for example.  I&apos;d just splice up the functionality I wrote in the DEFINE section of the regex and use it for stepping inside of a tree of elements, one at time.&lt;/p&gt;\n\n&lt;p&gt;So, will this be the final 100% answer for validating HTML?  No.  But it&apos;s a start and with a little more work, it can be done.  However, trying to do it inside of one regex execution is not practical, nor efficient.&lt;/p&gt;\n    "],"id":298,"title":"Using regular expressions to parse HTML: why not?","content":"\n                \n&lt;p&gt;It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an &quot;answer&quot; that says not to use regex to parse HTML.&lt;/p&gt;\n\n&lt;p&gt;Why not? I&apos;m aware that there are quote-unquote &quot;real&quot; HTML parsers out there like &lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot; rel=&quot;noreferrer&quot;&gt;Beautiful Soup&lt;/a&gt;, and I&apos;m sure they&apos;re powerful and useful, but if you&apos;re just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?&lt;/p&gt;\n\n&lt;p&gt;Moreover, is there just something fundamental that I don&apos;t understand about regex that makes them a bad choice for parsing in general?&lt;/p&gt;\n    ","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969","postType":"QUESTION","createdAt":"2022-07-09T17:25:43.000Z","updatedAt":"2022-07-09T17:25:43.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to access the correct `this` inside a callback","slug":"how-to-access-the-correct-this-inside-a-callback-1657384283261"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"What are valid values for the id attribute in HTML?","slug":"what-are-valid-values-for-the-id-attribute-in-html-1657384874780"},{"title":"How to reshape data from long to wide format","slug":"how-to-reshape-data-from-long-to-wide-format-1657384486421"},{"title":"How do I compare strings in Java?","slug":"how-do-i-compare-strings-in-java-1657384243187"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"How do I match any character across multiple lines in a regular expression?","slug":"how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720"},{"title":"My regex is matching too much. How do I make it stop? [duplicate]","slug":"my-regex-is-matching-too-much.-how-do-i-make-it-stop-duplicate-1657384845028"},{"title":"Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on","slug":"cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019"},{"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038"},{"title":"Why are global variables evil? [closed]","slug":"why-are-global-variables-evil-closed-1657388260006"},{"title":"Reference: What is variable scope, which variables are accessible from where and what are \"undefined variable\" errors?","slug":"reference:-what-is-variable-scope-which-variables-are-accessible-from-where-and-what-are-\"undefined-variable\"-errors-1657384644697"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"},{"title":"Deep cloning objects","slug":"deep-cloning-objects-1657387930865"},{"title":"How can I read and parse CSV files in C++?","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"How to create RecyclerView with multiple view types","slug":"how-to-create-recyclerview-with-multiple-view-types-1657388121512"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"How do I profile C++ code running on Linux?","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272"},{"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"}]},"__N_SSG":true}