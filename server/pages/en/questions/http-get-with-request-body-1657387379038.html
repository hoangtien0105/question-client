<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>HTTP GET with request body | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I&#x27;m developing a new RESTful webservice for our application.
When doing a GET on certain entities, clients can request the contents of the entity.
If they want to add some parameters (for example sorting a list) they can add these parameters in the query string.
Alternatively I want people to be able to specify these parameters in the request body.
HTTP/1.1 does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex XML requests.
My questions:

Is this a good idea altogether?
Will HTTP clients have issues with using request bodies within a GET request?

https://www.rfc-editor.org/rfc/rfc2616
    "/><meta property="og:title" content="HTTP GET with request body | Solutions Checker"/><meta property="og:description" content="I&#x27;m developing a new RESTful webservice for our application.
When doing a GET on certain entities, clients can request the contents of the entity.
If they want to add some parameters (for example sorting a list) they can add these parameters in the query string.
Alternatively I want people to be able to specify these parameters in the request body.
HTTP/1.1 does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex XML requests.
My questions:

Is this a good idea altogether?
Will HTTP clients have issues with using request bodies within a GET request?

https://www.rfc-editor.org/rfc/rfc2616
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"HTTP GET with request body","text":"I&apos;m developing a new RESTful webservice for our application.\nWhen doing a GET on certain entities, clients can request the contents of the entity.\nIf they want to add some parameters (for example sorting a list) they can add these parameters in the query string.\nAlternatively I want people to be able to specify these parameters in the request body.\nHTTP/1.1 does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex XML requests.\nMy questions:\n\nIs this a good idea altogether?\nWill HTTP clients have issues with using request bodies within a GET request?\n\nhttps://www.rfc-editor.org/rfc/rfc2616\n    ","answerCount":22,"upVoteCount":500,"suggestedAnswer":[{"text":"Roy Fielding&apos;s comment about including a body with a GET request.\n\nYes. In other words, any HTTP request message is allowed to contain a message body, and thus must parse messages with that in mind. Server semantics for GET, however, are restricted such that a body, if any, has no semantic meaning to the request. The requirements on parsing are separate from the requirements on method semantics.\nSo, yes, you can send a body with GET, and no, it is never useful to do so.\nThis is part of the layered design of HTTP/1.1 that will become clear again once the spec is partitioned (work in progress).\n....Roy\n\nYes, you can send a request body with GET but it should not have any meaning. If you give it meaning by parsing it on the server and changing your response based on its contents, then you are ignoring this recommendation in the HTTP/1.1 spec, section 4.3:\n\n...if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.\n\nAnd the description of the GET method in the HTTP/1.1 spec, section 9.3:\n\nThe GET method means retrieve whatever information ([...]) is identified by the Request-URI.\n\nwhich states that the request-body is not part of the identification of the resource in a GET request, only the request URI.\nUpdate\nThe RFC2616 referenced as &quot;HTTP/1.1 spec&quot; is now obsolete. In 2014 it was replaced by RFCs 7230-7237. Quote &quot;the message-body SHOULD be ignored when handling the request&quot; has been deleted. It&apos;s now just &quot;Request message framing is independent of method semantics, even if the method doesn&apos;t define any use for a message body&quot; The 2nd quote &quot;The GET method means retrieve whatever information ... is identified by the Request-URI&quot; was deleted.  - From a comment\nFrom the HTTP 1.1 2014 Spec:\n\nA payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"While you can do that, insofar as it isn&apos;t explicitly precluded by the HTTP specification, I would suggest avoiding it simply because people don&apos;t expect things to work that way.  There are many phases in an HTTP request chain and while they &quot;mostly&quot; conform to the HTTP spec, the only thing you&apos;re assured is that they will behave as traditionally used by web browsers.  (I&apos;m thinking of things like transparent proxies, accelerators, A/V toolkits, etc.)\n\nThis is the spirit behind the Robustness Principle roughly &quot;be liberal in what you accept, and conservative in what you send&quot;, you don&apos;t want to push the boundaries of a specification without good reason.  \n\nHowever, if you have a good reason, go for it.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"You will likely encounter problems if you ever try to take advantage of caching. Proxies are not going to look in the GET body to see if the parameters have an impact on the response.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Neither restclient nor REST console support this but curl does.\n\nThe HTTP specification says in section 4.3\n\n\n  A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.\n\n\nSection 5.1.1 redirects us to section 9.x for the various methods. None of them explicitly prohibit the inclusion of a message body. However...\n\nSection 5.2 says \n\n\n  The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.\n\n\nand Section 9.3 says\n\n\n  The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.\n\n\nWhich together suggest that when processing a GET request, a server is not required to examine anything other that the Request-URI and Host header field.\n\nIn summary, the HTTP spec doesn&apos;t prevent you from sending a message-body with GET but there is sufficient ambiguity that it wouldn&apos;t surprise me if it was not supported by all servers. \n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Elasticsearch accepts GET requests with a body. It even seems that this is the preferred way: Elasticsearch guide\n\nSome client libraries (like the Ruby driver) can log the cry command to stdout in development mode and it is using this syntax extensively.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"You can either send a GET with a body or send a POST and give up RESTish religiosity (it&apos;s not so bad, 5 years ago there was only one member of that faith -- his comments linked above).\n\nNeither are great decisions, but sending a GET body may prevent problems for some clients -- and some servers.  \n\nDoing a POST might have obstacles with some RESTish frameworks. \n\nJulian Reschke suggested above using a non-standard HTTP header like &quot;SEARCH&quot; which could be an elegant solution, except that it&apos;s even less likely to be supported.\n\nIt might be most productive to list clients that can and cannot do each of the above.\n\nClients that cannot send a GET with body (that I know of):\n\n\nXmlHTTPRequest Fiddler\n\n\nClients that can send a GET with body:\n\n\nmost browsers\n\n\nServers &amp; libraries that can retrieve a body from GET:\n\n\nApache\nPHP\n\n\nServers (and proxies) that strip a body from GET:\n\n\n?\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"What you&apos;re trying to achieve has been done for a long time with a much more common method, and one that doesn&apos;t rely on using a payload with GET.\n\nYou can simply build your specific search mediatype, or if you want to be more RESTful, use something like OpenSearch, and POST the request to the URI the server instructed, say /search. The server can then generate the search result or build the final URI and redirect using a 303.\n\nThis has the advantage of following the traditional PRG method, helps cache intermediaries cache the results, etc.\n\nThat said, URIs are encoded anyway for anything that is not ASCII, and so are application/x-www-form-urlencoded and multipart/form-data. I&apos;d recommend using this rather than creating yet another custom json format if your intention is to support ReSTful scenarios.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"I put this question to the IETF HTTP WG.  The comment from Roy Fielding (author of http/1.1 document in 1998) was that\n\n\n  &quot;... an implementation would be broken to do anything other than to parse and discard that body if received&quot;\n\n\nRFC 7213 (HTTPbis) states:\n\n\n  &quot;A payload within a GET request message has no defined semantics;&quot;\n\n\nIt seems clear now that the intention was that semantic meaning on GET request bodies is prohibited, which means that the request body can&apos;t be used to affect the result.\n\nThere are proxies out there that will definitely break your request in various ways if you include a body on GET.\n\nSo in summary, don&apos;t do it.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"GET, with a body!?\nSpecification-wise you could, but, it&apos;s not a good idea to do so injudiciously, as we shall see.\nRFC 7231 §4.3.1 states that a body &quot;has no defined semantics&quot;, but that&apos;s not to say it is forbidden. If you attach a body to the request and what your server/app makes out of it is up to you. The RFC goes on to state that GET can be &quot;a programmatic view on various database records&quot;. Obviously such view is many times tailored by a large number of input parameters, which are not always convenient or even safe to put in the query component of the request-target.\nThe good: I like the verbiage. It&apos;s clear that one read/get a resource without any observable side-effects on the server (the method is &quot;safe&quot;), and, the request can be repeated with the same intended effect regardless of the outcome of the first request (the method is &quot;idempotent&quot;).\nThe bad: An early draft of HTTP/1.1 forbade GET to have a body, and - allegedly - some implementations will even up until today drop the body, ignore the body or reject the message. For example, a dumb HTTP cache may construct a cache key out of the request-target only, being oblivious to the presence or content of a body. An even dumber server could be so ignorant that it treats the body as a new request, which effectively is called &quot;request smuggling&quot; (which is the act of sending &quot;a request to one device without the other device being aware of it&quot; - source).\nDue to what I believe is primarily a concern with inoperability amongst implementations, work in progress suggests to categorize a GET body as a &quot;SHOULD NOT&quot;, &quot;unless [the request] is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported&quot; (emphasis mine).\nThe fix: There&apos;s a few hacks that can be employed for some of the problems with this approach. For example, body-unaware caches can indirectly become body-aware simply by appending a hash derived from the body to the query component, or disable caching altogether by responding a cache-control: no-cache header from the server.\nAlas when it comes to the request chain, one is often not in control of- or even aware, of all present and future HTTP intermediaries and how they will deal with a GET body. That&apos;s why this approach must be considered generally unreliable.\nBut POST, is not idempotent!\nPOST is an alternative. The POST request usually includes a message body (just for the record, body is not a requirement, see RFC 7230 §3.3.2). The very first use case example from RFC 7231 (§4.3.3) is &quot;providing a block of data [...] to a data-handling process&quot;. So just like GET with a body, what happens with the body on the back-end side is up to you.\nThe good: Perhaps a more common method to apply when one wish to send a request body, for whatever purpose, and so, will likely yield the least amount of noise from your team members (some may still falsely believe that POST must create a resource).\nAlso, what we often pass parameters to is a search function operating upon constantly evolving data, and a POST response is only cacheable if explicit freshness information is provided in the response.\nThe bad: POST requests are not defined as idempotent, leading to request retry hesitancy. For example, on page reload, browsers are unwilling to resubmit an HTML form without prompting the user with a nonreadable cryptic message.\nThe fix: Well, just because POST is not defined to be idempotent doesn&apos;t mean it mustn&apos;t be. Indeed, RFC 7230 §6.3.1 writes: &quot;a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically&quot;. So, unless your client is an HTML form, this is probably not a real problem.\nQUERY is the holy grail\nThere&apos;s a proposal for a new method QUERY which does define semantics for a message body and defines the method as idempotent. See this.\nEdit: As a side-note, I stumbled into this StackOverflow question after having discovered a codebase where they solely used PUT requests for server-side search functions. This were their idea to include a body with parameters and also be idempotent. Alas the problem with PUT is that the request body has very precise semantics. Specifically, the PUT &quot;requests that the state of the target resource be created or replaced with the state [in the body]&quot; (RFC 7231 §4.3.4). Clearly, this excludes PUT as a viable option.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"From RFC 2616, section 4.3, &quot;Message Body&quot;:\n\nA server SHOULD read and forward a message-body on any request; if the\nrequest method does not include defined semantics for an entity-body,\nthen the message-body SHOULD be ignored when handling the request.\n\nThat is, servers should always read any provided request body from the network (check Content-Length or read a chunked body, etc). Also, proxies should forward any such request body they receive. Then, if the RFC defines semantics for the body for the given method, the server can actually use the request body in generating a response. However, if the RFC does not define semantics for the body, then the server should ignore it.\nThis is in line with the quote from Fielding above.\nSection 9.3, &quot;GET&quot;, describes the semantics of the GET method, and doesn&apos;t mention request bodies. Therefore, a server should ignore any request body it receives on a GET request.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"\n  Which server will ignore it?  fijiaaron Aug 30 &apos;12 at 21:27\n\n\nGoogle for instance is doing worse than ignoring it, it will consider it an error!\n\nTry it yourself with a simple netcat:\n\n$ netcat www.google.com 80\nGET / HTTP/1.1\nHost: www.google.com\nContent-length: 6\n\n1234\n\n\n(the 1234 content is followed by CR-LF, so that is a total of 6 bytes)\n\nand you will get:\n\nHTTP/1.1 400 Bad Request\nServer: GFE/2.0\n(....)\nError 400 (Bad Request)\n400. Thats an error.\nYour client has issued a malformed or illegal request. Thats all we know.\n\n\nYou do also get 400 Bad Request from Bing, Apple, etc... which are served by AkamaiGhost.\n\nSo I wouldn&apos;t advise using GET requests with a body entity.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"According to XMLHttpRequest, it&apos;s not valid. From the standard:\n\n\n  4.5.6 The send() method\n  \n  \nclient . send([body = null])\n    \n    Initiates the request. The optional argument provides the request\n    body. The argument is ignored if request method is GET or HEAD.\n    \n    Throws an InvalidStateError exception if either state is not\n    opened or the send() flag is set.\n  \n  \n  The send(body) method must run these steps:\n  \n  \n  If state is not opened, throw an InvalidStateError exception.\n  If the send() flag is set, throw an InvalidStateError exception.\n  If the request method is GET or HEAD, set body to null.\n  If body is null, go to the next step.\n  \n\n\nAlthough, I don&apos;t think it should because GET request might need big body content.\n\nSo, if you rely on XMLHttpRequest of a browser, it&apos;s likely it won&apos;t work.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"If you really want to send cachable JSON/XML body to web application the only reasonable place to put your data is query string encoded with RFC4648: Base 64 Encoding with URL and Filename Safe Alphabet. Of course you could just urlencode JSON and put is in URL param&apos;s value, but Base64 gives smaller result. Keep in mind that there are URL size restrictions, see What is the maximum length of a URL in different browsers? .\nYou may think that Base64&apos;s padding = character may be bad for URL&apos;s param value, however it seems not - see this discussion: http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html . However you shouldn&apos;t put encoded data without param name because encoded string with padding will be interpreted as param key with empty value.\nI would use something like ?_b64=&lt;encodeddata&gt;.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I wouldn&apos;t advise this, it goes against standard practices, and doesn&apos;t offer that much in return. You want to keep the body for content, not options.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"You have a list of options which are far better than using a request body with GET.\n\nLet&apos; assume you have categories and items for each category. Both to be identified by an id (&quot;catid&quot; / &quot;itemid&quot; for the sake of this example). You want to sort according to another parameter &quot;sortby&quot; in a specific &quot;order&quot;. You want to pass parameters for &quot;sortby&quot; and &quot;order&quot;:\n\nYou can:\n\n\nUse query strings, e.g.\nexample.com/category/{catid}/item/{itemid}?sortby=itemname&amp;order=asc\nUse mod_rewrite (or similar) for paths:\nexample.com/category/{catid}/item/{itemid}/{sortby}/{order}\nUse individual HTTP headers you pass with the request\nUse a different method, e.g. POST, to retrieve a resource.\n\n\nAll have their downsides, but are far better than using a GET with a body.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"I&apos;m upset that REST as protocol doesn&apos;t support OOP and Get method is proof. As a solution, you can serialize your a DTO to JSON and then create a query string. On server side you&apos;ll able to deserialize the query string to the DTO.\n\nTake a look on:\n\n\nMessage-based design in ServiceStack\nBuilding RESTful Message Based Web Services with WCF\n\n\nMessage based approach can help you to solve Get method restriction. You&apos;ll able to send any DTO as with request body\n\nNelibur web service framework provides functionality which you can use\n\nvar client = new JsonServiceClient(Settings.Default.ServiceAddress);\nvar request = new GetClientRequest\n    {\n        Id = new Guid(&quot;2217239b0e-b35b-4d32-95c7-5db43e2bd573&quot;)\n    };\nvar response = client.Get&lt;GetClientRequest, ClientResponse&gt;(request);\n\nas you can see, the GetClientRequest was encoded to the following query string\n\nhttp://localhost/clients/GetWithResponse?type=GetClientRequest&amp;data=%7B%22Id%22:%2217239b0e-b35b-4d32-95c7-5db43e2bd573%22%7D\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"What about nonconforming base64 encoded headers? &quot;SOMETHINGAPP-PARAMS:sdfSD45fdg45/aS&quot;\n\nLength restrictions hm. Can&apos;t you make your POST handling distinguish between the meanings? If you want simple parameters like sorting, I don&apos;t see why this would be a problem. I guess it&apos;s certainty you&apos;re worried about.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"IMHO you could just send the JSON encoded (ie. encodeURIComponent) in the URL, this way you do not violate the HTTP specs and get your JSON to the server.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"For example, it works with Curl, Apache and PHP.\n\nPHP file:\n\n&lt;?php\necho $_SERVER[&apos;REQUEST_METHOD&apos;] . PHP_EOL;\necho file_get_contents(&apos;php://input&apos;) . PHP_EOL;\n\n\nConsole command:\n\n$ curl -X GET -H &quot;Content-Type: application/json&quot; -d &apos;{&quot;the&quot;: &quot;body&quot;}&apos; &apos;http://localhost/test/get.php&apos;\n\n\nOutput:\n\nGET\n{&quot;the&quot;: &quot;body&quot;}\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Even if a popular tool use this, as cited frequently on this page, I think it is still quite a bad idea, being too exotic, despite not forbidden by the spec.\n\nMany intermediate infrastructures may just reject such requests.\n\nBy example, forget about using some of the available CDN in front of your web site, like this one:\n\n\n  If a viewer GET request includes a body, CloudFront returns an HTTP status code 403 (Forbidden) to the viewer.\n\n\nAnd yes, your client libraries may also not support emitting such requests, as reported in this comment.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"An idea on an old question:\nAdd the content on the body, and a hash of the body on the querystring, so caching won&apos;t be a problem and you&apos;ll be able to send tons of data when needed :)\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Create a Requestfactory class\nimport java.net.URI;\n\nimport javax.annotation.PostConstruct;\n\nimport org.apache.http.client.methods.HttpEntityEnclosingRequestBase;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\n\n@Component\npublic class RequestFactory {\n    private RestTemplate restTemplate = new RestTemplate();\n\n    @PostConstruct\n    public void init() {\n        this.restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestWithBodyFactory());\n    }\n\n    private static final class HttpComponentsClientHttpRequestWithBodyFactory extends HttpComponentsClientHttpRequestFactory {\n        @Override\n        protected HttpUriRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n            if (httpMethod == HttpMethod.GET) {\n                return new HttpGetRequestWithEntity(uri);\n            }\n            return super.createHttpUriRequest(httpMethod, uri);\n        }\n    }\n\n    private static final class HttpGetRequestWithEntity extends HttpEntityEnclosingRequestBase {\n        public HttpGetRequestWithEntity(final URI uri) {\n            super.setURI(uri);\n        }\n\n        @Override\n        public String getMethod() {\n            return HttpMethod.GET.name();\n        }\n    }\n\n    public RestTemplate getRestTemplate() {\n        return restTemplate;\n    }\n}\n\nand @Autowired where ever you require and use, Here is one sample code GET request with RequestBody\n @RestController\n @RequestMapping(&quot;/v1/API&quot;)\npublic class APIServiceController {\n    \n    @Autowired\n    private RequestFactory requestFactory;\n    \n\n    @RequestMapping(method = RequestMethod.GET, path = &quot;/getData&quot;)\n    public ResponseEntity&lt;APIResponse&gt; getLicenses(@RequestBody APIRequest2 APIRequest){\n        APIResponse response = new APIResponse();\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        Gson gson = new Gson();\n        try {\n            StringBuilder createPartUrl = new StringBuilder(PART_URL).append(PART_URL2);\n            \n            HttpEntity&lt;String&gt; entity = new HttpEntity&lt;String&gt;(gson.toJson(APIRequest),headers);\n            ResponseEntity&lt;APIResponse&gt; storeViewResponse = requestFactory.getRestTemplate().exchange(createPartUrl.toString(), HttpMethod.GET, entity, APIResponse.class); //.getForObject(createLicenseUrl.toString(), APIResponse.class, entity);\n    \n            if(storeViewResponse.hasBody()) {\n                response = storeViewResponse.getBody();\n            }\n            return new ResponseEntity&lt;APIResponse&gt;(response, HttpStatus.OK);\n        }catch (Exception e) {\n            e.printStackTrace();\n            return new ResponseEntity&lt;APIResponse&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n        \n    }\n}\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/http-get-with-request-body-1657387379038#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/http-get-with-request-body-1657387379038"><h1>HTTP GET with request body</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/http-get">http-get</a></div></div><div class="question-content mt-5">
                
<p>I'm developing a new RESTful webservice for our application.</p>
<p>When doing a GET on certain entities, clients can request the contents of the entity.
If they want to add some parameters (for example sorting a list) they can add these parameters in the query string.</p>
<p>Alternatively I want people to be able to specify these parameters in the request body.
<a href="https://www.rfc-editor.org/rfc/rfc2616" rel="noreferrer">HTTP/1.1</a> does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex XML requests.</p>
<p>My questions:</p>
<ul>
<li>Is this a good idea altogether?</li>
<li>Will HTTP clients have issues with using request bodies within a GET request?</li>
</ul>
<p><a href="https://www.rfc-editor.org/rfc/rfc2616" rel="noreferrer">https://www.rfc-editor.org/rfc/rfc2616</a></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://groups.yahoo.com/neo/groups/rest-discuss/conversations/messages/9962" rel="noreferrer">Roy Fielding's comment about including a body with a GET request</a>.</p>
<blockquote>
<p>Yes. In other words, any HTTP request message is allowed to contain a message body, and thus must parse messages with that in mind. Server semantics for GET, however, are restricted such that a body, if any, has no semantic meaning to the request. The requirements on parsing are separate from the requirements on method semantics.</p>
<p>So, yes, you can send a body with GET, and no, it is never useful to do so.</p>
<p>This is part of the layered design of HTTP/1.1 that will become clear again once the spec is partitioned (work in progress).</p>
<p>....Roy</p>
</blockquote>
<p>Yes, you can send a request body with GET but it should not have any meaning. If you give it meaning by parsing it on the server and <em>changing your response based on its contents</em>, then you are ignoring this recommendation in <a href="https://www.rfc-editor.org/rfc/rfc2616#section-4.3" rel="noreferrer">the HTTP/1.1 spec, section 4.3</a>:</p>
<blockquote>
<p>...if the request method does not include defined semantics for an entity-body, then the message-body <a href="https://www.ietf.org/rfc/rfc2119.txt" rel="noreferrer">SHOULD</a> be ignored when handling the request.</p>
</blockquote>
<p>And the description of the GET method in <a href="https://www.rfc-editor.org/rfc/rfc2616#section-9.3" rel="noreferrer">the HTTP/1.1 spec, section 9.3</a>:</p>
<blockquote>
<p>The GET method means retrieve whatever information ([...]) is identified by the Request-URI.</p>
</blockquote>
<p>which states that the request-body is not part of the identification of the resource in a GET request, only the request URI.</p>
<p><strong>Update</strong></p>
<p>The RFC2616 referenced as "HTTP/1.1 spec" is now obsolete. In 2014 it was replaced by RFCs 7230-7237. Quote "the message-body SHOULD be ignored when handling the request" has been deleted. It's now just "Request message framing is independent of method semantics, even if the method doesn't define any use for a message body" The 2nd quote "The GET method means retrieve whatever information ... is identified by the Request-URI" was deleted.  - From a comment</p>
<p>From the <a href="https://www.rfc-editor.org/rfc/rfc7231#page-24" rel="noreferrer">HTTP 1.1 2014 Spec</a>:</p>
<blockquote>
<p>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p>
</blockquote>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While you <em>can</em> do that, insofar as it isn't explicitly precluded by the HTTP specification, I would suggest avoiding it simply because people don't expect things to work that way.  There are many phases in an HTTP request chain and while they "mostly" conform to the HTTP spec, the only thing you're assured is that they will behave as traditionally used by web browsers.  (I'm thinking of things like transparent proxies, accelerators, A/V toolkits, etc.)</p>

<p>This is the spirit behind the <a href="http://en.wikipedia.org/wiki/Robustness_Principle" rel="noreferrer">Robustness Principle</a> roughly "be liberal in what you accept, and conservative in what you send", you don't want to push the boundaries of a specification without good reason.  </p>

<p>However, if you have a good reason, go for it.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You will likely encounter problems if you ever try to take advantage of caching. Proxies are not going to look in the <code>GET</code> body to see if the parameters have an impact on the response.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Neither <a href="http://restclient.net" rel="noreferrer">restclient</a> nor <a href="https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn" rel="noreferrer">REST console</a> support this but curl does.</p>

<p>The <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3" rel="noreferrer">HTTP specification</a> says in section 4.3</p>

<blockquote>
  <p>A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.</p>
</blockquote>

<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1" rel="noreferrer">Section 5.1.1</a> redirects us to section 9.x for the various methods. None of them explicitly prohibit the inclusion of a message body. However...</p>

<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2" rel="noreferrer">Section 5.2</a> says </p>

<blockquote>
  <p>The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.</p>
</blockquote>

<p>and <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec9.3" rel="noreferrer">Section 9.3</a> says</p>

<blockquote>
  <p>The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.</p>
</blockquote>

<p>Which together suggest that when processing a GET request, a server is not <em>required</em> to examine anything other that the Request-URI and Host header field.</p>

<p>In summary, the HTTP spec doesn't prevent you from sending a message-body with GET but there is sufficient ambiguity that it wouldn't surprise me if it was not supported by all servers. </p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Elasticsearch accepts GET requests with a body. It even seems that this is the preferred way: <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html#get_vs_post" rel="noreferrer">Elasticsearch guide</a></p>

<p>Some client libraries (like the Ruby driver) can log the cry command to stdout in development mode and it is using this syntax extensively.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can either send a GET with a body or send a POST and give up RESTish religiosity (it's not so bad, 5 years ago there was only one member of that faith -- his comments linked above).</p>

<p>Neither are great decisions, but sending a GET body may prevent problems for some clients -- and some servers.  </p>

<p>Doing a POST might have obstacles with some RESTish frameworks. </p>

<p>Julian Reschke suggested above using a non-standard HTTP header like "SEARCH" which could be an elegant solution, except that it's even less likely to be supported.</p>

<p>It might be most productive to list clients that can and cannot do each of the above.</p>

<p>Clients that cannot send a GET with body (that I know of):</p>

<ul>
<li>XmlHTTPRequest Fiddler</li>
</ul>

<p>Clients that can send a GET with body:</p>

<ul>
<li>most browsers</li>
</ul>

<p>Servers &amp; libraries that can retrieve a body from GET:</p>

<ul>
<li>Apache</li>
<li>PHP</li>
</ul>

<p>Servers (and proxies) that strip a body from GET:</p>

<ul>
<li>?</li>
</ul>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What you're trying to achieve has been done for a long time with a much more common method, and one that doesn't rely on using a payload with GET.</p>

<p>You can simply build your specific search mediatype, or if you want to be more RESTful, use something like OpenSearch, and POST the request to the URI the server instructed, say /search. The server can then generate the search result or build the final URI and redirect using a 303.</p>

<p>This has the advantage of following the traditional PRG method, helps cache intermediaries cache the results, etc.</p>

<p>That said, URIs are encoded anyway for anything that is not ASCII, and so are application/x-www-form-urlencoded and multipart/form-data. I'd recommend using this rather than creating yet another custom json format if your intention is to support ReSTful scenarios.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I put this question to the IETF HTTP WG.  The comment from Roy Fielding (author of http/1.1 document in 1998) was that</p>

<blockquote>
  <p>"... an implementation would be broken to do anything other than to parse and discard that body if received"</p>
</blockquote>

<p>RFC 7213 (HTTPbis) states:</p>

<blockquote>
  <p>"A payload within a GET request message has no defined semantics;"</p>
</blockquote>

<p>It seems clear now that the intention was that semantic meaning on GET request bodies is prohibited, which means that the request body can't be used to affect the result.</p>

<p>There are proxies out there that will <strong>definitely</strong> break your request in various ways if you include a body on GET.</p>

<p>So in summary, don't do it.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><code>GET</code>, with a body!?</h2>
<p>Specification-wise you could, but, it's not a good idea to do so injudiciously, as we shall see.</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1" rel="noreferrer">RFC 7231 §4.3.1</a> states that a body "has no defined semantics", but that's not to say it is forbidden. If you attach a body to the request and what your server/app makes out of it is up to you. The RFC goes on to state that GET can be "a programmatic view on various database records". Obviously such view is many times tailored by a large number of input parameters, which are not always convenient or even safe to put in the query component of the request-target.</p>
<p><em>The good:</em> I like the verbiage. It's clear that one read/get a resource without any observable side-effects on the server (the method is "safe"), and, the request can be repeated with the same intended effect regardless of the outcome of the first request (the method is "idempotent").</p>
<p><em>The bad:</em> An early draft of HTTP/1.1 forbade GET to have a body, and - allegedly - some implementations will even up until today drop the body, ignore the body or reject the message. For example, a dumb HTTP cache may construct a cache key out of the request-target only, being oblivious to the presence or content of a body. An even dumber server could be so ignorant that it treats the body as a new request, which effectively is called "request smuggling" (which is the act of sending "a request to one device without the other device being aware of it" - <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" rel="noreferrer">source</a>).</p>
<p>Due to what I believe is primarily a concern with inoperability amongst implementations, <a href="https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.9.3.1" rel="noreferrer">work in progress</a> suggests to categorize a GET body as a "SHOULD NOT", "<strong>unless</strong> [the request] is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported" (emphasis mine).</p>
<p><em>The fix:</em> There's a few hacks that can be employed for some of the problems with this approach. For example, body-unaware caches can indirectly become body-aware simply by appending a hash derived from the body to the query component, or disable caching altogether by responding a <code>cache-control: no-cache</code> header from the server.</p>
<p>Alas when it comes to the request chain, one is often not in control of- or even aware, of all present and future HTTP intermediaries and how they will deal with a GET body. That's why this approach must be considered generally unreliable.</p>
<h2>But <code>POST</code>, is not idempotent!</h2>
<p><code>POST</code> is an alternative. The POST request usually includes a message body (just for the record, body is not a requirement, see <a href="https://tools.ietf.org/html/rfc7230#section-3.3.2" rel="noreferrer">RFC 7230 §3.3.2</a>). The very first use case example from RFC 7231 (<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3" rel="noreferrer">§4.3.3</a>) is "providing a block of data [...] to a data-handling process". So just like GET with a body, what happens with the body on the back-end side is up to you.</p>
<p><em>The good:</em> Perhaps a more common method to apply when one wish to send a request body, for whatever purpose, and so, will likely yield the least amount of noise from your team members (some may still falsely believe that POST must create a resource).</p>
<p>Also, what we often pass parameters to is a search function operating upon constantly evolving data, and a POST response is only cacheable if explicit freshness information is provided in the response.</p>
<p><em>The bad:</em> POST requests are not defined as idempotent, leading to request retry hesitancy. For example, on page reload, browsers are unwilling to resubmit an HTML form without prompting the user with a nonreadable cryptic message.</p>
<p><em>The fix:</em> Well, just because POST is not defined to be idempotent doesn't mean it mustn't be. Indeed, <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-6.3.1" rel="noreferrer">RFC 7230 §6.3.1</a> writes: "a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically". So, unless your client is an HTML form, this is probably not a real problem.</p>
<h2><code>QUERY</code> is the holy grail</h2>
<p>There's a proposal for a new method <code>QUERY</code> which does define semantics for a message body <em>and</em> defines the method as idempotent. See <a href="https://www.ietf.org/id/draft-ietf-httpbis-safe-method-w-body-02.html" rel="noreferrer">this</a>.</p>
<p><strong>Edit</strong>: As a side-note, I stumbled into this StackOverflow question after having discovered a codebase where they solely used <code>PUT</code> requests for server-side search functions. This were their idea to include a body with parameters and also be idempotent. Alas the problem with PUT is that the request body has very precise semantics. Specifically, the PUT "requests that the state of the target resource be created or replaced with the state [in the body]" (<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4" rel="noreferrer">RFC 7231 §4.3.4</a>). Clearly, this excludes PUT as a viable option.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From <a href="https://www.rfc-editor.org/rfc/rfc2616#section-4.3" rel="nofollow noreferrer">RFC 2616, section 4.3</a>, "Message Body":</p>
<blockquote>
<p>A server SHOULD read and forward a message-body on any request; if the
request method does not include defined semantics for an entity-body,
then the message-body SHOULD be ignored when handling the request.</p>
</blockquote>
<p>That is, servers should always read any provided request body from the network (check Content-Length or read a chunked body, etc). Also, proxies should forward any such request body they receive. Then, if the RFC defines semantics for the body for the given method, the server can actually use the request body in generating a response. However, if the RFC <em>does not</em> define semantics for the body, then the server should ignore it.</p>
<p>This is in line with the quote from Fielding above.</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc2616#section-9.3" rel="nofollow noreferrer">Section 9.3</a>, "GET", describes the semantics of the GET method, and doesn't mention request bodies. Therefore, a server should ignore any request body it receives on a GET request.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Which server will ignore it?  fijiaaron Aug 30 '12 at 21:27</p>
</blockquote>

<p><strong>Google</strong> for instance is doing worse than ignoring it, it will consider it an <strong>error</strong>!</p>

<p>Try it yourself with a simple netcat:</p>

<pre><code>$ netcat www.google.com 80
GET / HTTP/1.1
Host: www.google.com
Content-length: 6

1234
</code></pre>

<p>(the 1234 content is followed by CR-LF, so that is a total of 6 bytes)</p>

<p>and you will get:</p>

<pre><code>HTTP/1.1 400 Bad Request
Server: GFE/2.0
(....)
Error 400 (Bad Request)
400. Thats an error.
Your client has issued a malformed or illegal request. Thats all we know.
</code></pre>

<p>You do also get 400 Bad Request from Bing, Apple, etc... which are served by AkamaiGhost.</p>

<p>So I wouldn't advise using GET requests with a body entity.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>According to XMLHttpRequest, it's not valid. From the <a href="https://xhr.spec.whatwg.org/#the-send()-method" rel="noreferrer">standard</a>:</p>

<blockquote>
  <h3>4.5.6 The <code>send()</code> method</h3>
  
  <blockquote>
<pre><code><i>client</i> . send([<i>body</i> = null])</code></pre>
    
    <p>Initiates the request. The optional argument provides the request
    body. The argument is ignored if request method is <code>GET</code> or <code>HEAD</code>.</p>
    
    <p>Throws an <code>InvalidStateError</code> exception if either state is not
    <em>opened</em> or the <code>send()</code> flag is set.</p>
  </blockquote>
  
  <p>The <code>send(<i>body</i>)</code> method must run these steps:</p>
  
  <ol>
  <li>If state is not <em>opened</em>, throw an <code>InvalidStateError</code> exception.</li>
  <li>If the <code>send()</code> flag is set, throw an <code>InvalidStateError</code> exception.</li>
  <li>If the request method is <code>GET</code> or <code>HEAD</code>, set <em>body</em> to null.</li>
  <li>If <em>body</em> is null, go to the next step.</li>
  </ol>
</blockquote>

<p>Although, I don't think it should because GET request might need big body content.</p>

<p>So, if you rely on XMLHttpRequest of a browser, it's likely it won't work.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you really want to send cachable JSON/XML body to web application the only reasonable place to put your data is query string encoded with <a href="https://www.rfc-editor.org/rfc/rfc4648#section-5" rel="nofollow noreferrer">RFC4648: Base 64 Encoding with URL and Filename Safe Alphabet</a>. Of course you could just urlencode JSON and put is in URL param's value, but Base64 gives smaller result. Keep in mind that there are URL size restrictions, see <a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url">What is the maximum length of a URL in different browsers?</a> .</p>
<p>You may think that Base64's padding <code>=</code> character may be bad for URL's param value, however it seems not - see this discussion: <a href="http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html" rel="nofollow noreferrer">http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html</a> . However you shouldn't put encoded data without param name because encoded string with padding will be interpreted as param key with empty value.
I would use something like <code>?_b64=&lt;encodeddata&gt;</code>.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wouldn't advise this, it goes against standard practices, and doesn't offer that much in return. You want to keep the body for content, not options.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You have a list of options which are far better than using a request body with GET.</p>

<p>Let' assume you have categories and items for each category. Both to be identified by an id ("catid" / "itemid" for the sake of this example). You want to sort according to another parameter "sortby" in a specific "order". You want to pass parameters for "sortby" and "order":</p>

<p>You can:</p>

<ol>
<li>Use query strings, e.g.
<code>example.com/category/{catid}/item/{itemid}?sortby=itemname&amp;order=asc</code></li>
<li>Use mod_rewrite (or similar) for paths:
<code>example.com/category/{catid}/item/{itemid}/{sortby}/{order}</code></li>
<li>Use individual HTTP headers you pass with the request</li>
<li>Use a different method, e.g. POST, to retrieve a resource.</li>
</ol>

<p>All have their downsides, but are far better than using a GET with a body.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm upset that REST as protocol doesn't support OOP and <code>Get</code> method is proof. As a solution, you can serialize your a DTO to JSON and then create a query string. On server side you'll able to deserialize the query string to the DTO.</p>

<p>Take a look on:</p>

<ul>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/What-is-a-message-based-web-service?" rel="nofollow">Message-based design in ServiceStack</a></li>
<li><a href="http://www.codeproject.com/Articles/712689/Building-RESTful-Message-Based-Web-Services-with-W" rel="nofollow">Building RESTful Message Based Web Services with WCF</a></li>
</ul>

<p>Message based approach can help you to solve Get method restriction. You'll able to send any DTO as with request body</p>

<p><a href="https://github.com/Nelibur/Nelibur" rel="nofollow">Nelibur web service framework provides functionality which you can use</a></p>

<pre><code>var client = new JsonServiceClient(Settings.Default.ServiceAddress);
var request = new GetClientRequest
    {
        Id = new Guid("2217239b0e-b35b-4d32-95c7-5db43e2bd573")
    };
var response = client.Get&lt;GetClientRequest, ClientResponse&gt;(request);

as you can see, the GetClientRequest was encoded to the following query string

http://localhost/clients/GetWithResponse?type=GetClientRequest&amp;data=%7B%22Id%22:%2217239b0e-b35b-4d32-95c7-5db43e2bd573%22%7D
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What about nonconforming base64 encoded headers? "SOMETHINGAPP-PARAMS:sdfSD45fdg45/aS"</p>

<p>Length restrictions hm. Can't you make your POST handling distinguish between the meanings? If you want simple parameters like sorting, I don't see why this would be a problem. I guess it's certainty you're worried about.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>IMHO you could just send the <code>JSON</code> encoded (ie. <code>encodeURIComponent</code>) in the <code>URL</code>, this way you do not violate the <code>HTTP</code> specs and get your <code>JSON</code> to the server.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For example, it works with Curl, Apache and PHP.</p>

<p>PHP file:</p>

<pre><code>&lt;?php
echo $_SERVER['REQUEST_METHOD'] . PHP_EOL;
echo file_get_contents('php://input') . PHP_EOL;
</code></pre>

<p>Console command:</p>

<pre><code>$ curl -X GET -H "Content-Type: application/json" -d '{"the": "body"}' 'http://localhost/test/get.php'
</code></pre>

<p>Output:</p>

<pre><code>GET
{"the": "body"}
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Even if a popular tool use this, as cited frequently on this page, I think it is still quite a bad idea, being too exotic, despite not forbidden by the spec.</p>

<p>Many intermediate infrastructures may just reject such requests.</p>

<p>By example, forget about using some of the available CDN in front of your web site, like this <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#RequestCustom-get-body" rel="nofollow noreferrer">one</a>:</p>

<blockquote>
  <p>If a viewer <code>GET</code> request includes a body, CloudFront returns an HTTP status code 403 (Forbidden) to the viewer.</p>
</blockquote>

<p>And yes, your client libraries may also not support emitting such requests, as reported in this <a href="https://stackoverflow.com/questions/978061/http-get-with-request-body/58215864#comment32122408_978094">comment</a>.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An idea on an old question:</p>
<p>Add the content on the body, and a hash of the body on the querystring, so caching won't be a problem and you'll be able to send tons of data when needed :)</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rest">rest</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/http-get">http-get</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Create a Requestfactory class</p>
<pre><code>import java.net.URI;

import javax.annotation.PostConstruct;

import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpUriRequest;
import org.springframework.http.HttpMethod;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class RequestFactory {
    private RestTemplate restTemplate = new RestTemplate();

    @PostConstruct
    public void init() {
        this.restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestWithBodyFactory());
    }

    private static final class HttpComponentsClientHttpRequestWithBodyFactory extends HttpComponentsClientHttpRequestFactory {
        @Override
        protected HttpUriRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {
            if (httpMethod == HttpMethod.GET) {
                return new HttpGetRequestWithEntity(uri);
            }
            return super.createHttpUriRequest(httpMethod, uri);
        }
    }

    private static final class HttpGetRequestWithEntity extends HttpEntityEnclosingRequestBase {
        public HttpGetRequestWithEntity(final URI uri) {
            super.setURI(uri);
        }

        @Override
        public String getMethod() {
            return HttpMethod.GET.name();
        }
    }

    public RestTemplate getRestTemplate() {
        return restTemplate;
    }
}
</code></pre>
<p>and @Autowired where ever you require and use, Here is one sample code GET request with RequestBody</p>
<pre><code> @RestController
 @RequestMapping("/v1/API")
public class APIServiceController {
    
    @Autowired
    private RequestFactory requestFactory;
    

    @RequestMapping(method = RequestMethod.GET, path = "/getData")
    public ResponseEntity&lt;APIResponse&gt; getLicenses(@RequestBody APIRequest2 APIRequest){
        APIResponse response = new APIResponse();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        Gson gson = new Gson();
        try {
            StringBuilder createPartUrl = new StringBuilder(PART_URL).append(PART_URL2);
            
            HttpEntity&lt;String&gt; entity = new HttpEntity&lt;String&gt;(gson.toJson(APIRequest),headers);
            ResponseEntity&lt;APIResponse&gt; storeViewResponse = requestFactory.getRestTemplate().exchange(createPartUrl.toString(), HttpMethod.GET, entity, APIResponse.class); //.getForObject(createLicenseUrl.toString(), APIResponse.class, entity);
    
            if(storeViewResponse.hasBody()) {
                response = storeViewResponse.getBody();
            }
            return new ResponseEntity&lt;APIResponse&gt;(response, HttpStatus.OK);
        }catch (Exception e) {
            e.printStackTrace();
            return new ResponseEntity&lt;APIResponse&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
        
    }
}
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-is-this-weird-colon-member-(%22-:-%22)-syntax-in-the-constructor-1657387264047">What is this weird colon-member (&quot; : &quot;) syntax in the constructor?</a><a href="/questions/is-there-a-difference-between-%22%22-and-%22is%22-1657387902231">Is there a difference between &quot;==&quot; and &quot;is&quot;?</a><a href="/questions/why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458">Why does jQuery or a DOM method such as getElementById not find the element?</a><a href="/questions/do-dom-tree-elements-with-ids-become-global-properties-1657387475110">Do DOM tree elements with IDs become global properties?</a><a href="/questions/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444">Why is processing a sorted array faster than processing an unsorted array?</a><a href="/questions/iterator-invalidation-rules-for-c++-containers-1657387561090">Iterator invalidation rules for C++ containers</a><a href="/questions/is-it-possible-for-flex-items-to-align-tightly-to-the-items-above-them-1657388511179">Is it possible for flex items to align tightly to the items above them?</a><a href="/questions/how-to-manage-startactivityforresult-on-android-1657387967393">How to manage startActivityForResult on Android</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/.prop()-vs-.attr()-1657384898328">.prop() vs .attr()</a><a href="/questions/flexbox:-center-horizontally-and-vertically-1657384587888">Flexbox: center horizontally and vertically</a><a href="/questions/why-can&#x27;t-an-element-with-a-z-index-value-cover-its-child-1657387707187">Why can&#x27;t an element with a z-index value cover its child?</a><a href="/questions/self-references-in-object-literals-initializers-1657384835356">Self-references in object literals / initializers</a><a href="/questions/removing-duplicates-in-lists-1657388207448">Removing duplicates in lists</a><a href="/questions/learning-regular-expressions-closed-1657384719460">Learning Regular Expressions [closed]</a><a href="/questions/how-can-i-return-pivot-table-output-in-mysql-1657384715043">How can I return pivot table output in MySQL?</a><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392">Big O, how do you calculate/approximate it?</a><a href="/questions/what-is-a-plain-english-explanation-of-%22big-o%22-notation-1657387641953">What is a plain English explanation of &quot;Big O&quot; notation?</a><a href="/questions/how-to-convert-string-representation-of-list-to-a-list-1657387384181">How to convert string representation of list to a list</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://groups.yahoo.com/neo/groups/rest-discuss/conversations/messages/9962\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Roy Fielding\u0026apos;s comment about including a body with a GET request\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Yes. In other words, any HTTP request message is allowed to contain a message body, and thus must parse messages with that in mind. Server semantics for GET, however, are restricted such that a body, if any, has no semantic meaning to the request. The requirements on parsing are separate from the requirements on method semantics.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, yes, you can send a body with GET, and no, it is never useful to do so.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is part of the layered design of HTTP/1.1 that will become clear again once the spec is partitioned (work in progress).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;....Roy\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Yes, you can send a request body with GET but it should not have any meaning. If you give it meaning by parsing it on the server and \u0026lt;em\u0026gt;changing your response based on its contents\u0026lt;/em\u0026gt;, then you are ignoring this recommendation in \u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616#section-4.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the HTTP/1.1 spec, section 4.3\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;...if the request method does not include defined semantics for an entity-body, then the message-body \u0026lt;a href=\u0026quot;https://www.ietf.org/rfc/rfc2119.txt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SHOULD\u0026lt;/a\u0026gt; be ignored when handling the request.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;And the description of the GET method in \u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616#section-9.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the HTTP/1.1 spec, section 9.3\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The GET method means retrieve whatever information ([...]) is identified by the Request-URI.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;which states that the request-body is not part of the identification of the resource in a GET request, only the request URI.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The RFC2616 referenced as \u0026quot;HTTP/1.1 spec\u0026quot; is now obsolete. In 2014 it was replaced by RFCs 7230-7237. Quote \u0026quot;the message-body SHOULD be ignored when handling the request\u0026quot; has been deleted. It\u0026apos;s now just \u0026quot;Request message framing is independent of method semantics, even if the method doesn\u0026apos;t define any use for a message body\u0026quot; The 2nd quote \u0026quot;The GET method means retrieve whatever information ... is identified by the Request-URI\u0026quot; was deleted.  - From a comment\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc7231#page-24\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTTP 1.1 2014 Spec\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; do that, insofar as it isn\u0026apos;t explicitly precluded by the HTTP specification, I would suggest avoiding it simply because people don\u0026apos;t expect things to work that way.  There are many phases in an HTTP request chain and while they \u0026quot;mostly\u0026quot; conform to the HTTP spec, the only thing you\u0026apos;re assured is that they will behave as traditionally used by web browsers.  (I\u0026apos;m thinking of things like transparent proxies, accelerators, A/V toolkits, etc.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the spirit behind the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Robustness_Principle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Robustness Principle\u0026lt;/a\u0026gt; roughly \u0026quot;be liberal in what you accept, and conservative in what you send\u0026quot;, you don\u0026apos;t want to push the boundaries of a specification without good reason.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you have a good reason, go for it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You will likely encounter problems if you ever try to take advantage of caching. Proxies are not going to look in the \u0026lt;code\u0026gt;GET\u0026lt;/code\u0026gt; body to see if the parameters have an impact on the response.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Neither \u0026lt;a href=\u0026quot;http://restclient.net\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;restclient\u0026lt;/a\u0026gt; nor \u0026lt;a href=\u0026quot;https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;REST console\u0026lt;/a\u0026gt; support this but curl does.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTTP specification\u0026lt;/a\u0026gt; says in section 4.3\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Section 5.1.1\u0026lt;/a\u0026gt; redirects us to section 9.x for the various methods. None of them explicitly prohibit the inclusion of a message body. However...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Section 5.2\u0026lt;/a\u0026gt; says \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;a href=\u0026quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec9.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Section 9.3\u0026lt;/a\u0026gt; says\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which together suggest that when processing a GET request, a server is not \u0026lt;em\u0026gt;required\u0026lt;/em\u0026gt; to examine anything other that the Request-URI and Host header field.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In summary, the HTTP spec doesn\u0026apos;t prevent you from sending a message-body with GET but there is sufficient ambiguity that it wouldn\u0026apos;t surprise me if it was not supported by all servers. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Elasticsearch accepts GET requests with a body. It even seems that this is the preferred way: \u0026lt;a href=\u0026quot;https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html#get_vs_post\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Elasticsearch guide\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some client libraries (like the Ruby driver) can log the cry command to stdout in development mode and it is using this syntax extensively.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can either send a GET with a body or send a POST and give up RESTish religiosity (it\u0026apos;s not so bad, 5 years ago there was only one member of that faith -- his comments linked above).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Neither are great decisions, but sending a GET body may prevent problems for some clients -- and some servers.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Doing a POST might have obstacles with some RESTish frameworks. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Julian Reschke suggested above using a non-standard HTTP header like \u0026quot;SEARCH\u0026quot; which could be an elegant solution, except that it\u0026apos;s even less likely to be supported.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It might be most productive to list clients that can and cannot do each of the above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Clients that cannot send a GET with body (that I know of):\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;XmlHTTPRequest Fiddler\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Clients that can send a GET with body:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;most browsers\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Servers \u0026amp;amp; libraries that can retrieve a body from GET:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Apache\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;PHP\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Servers (and proxies) that strip a body from GET:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What you\u0026apos;re trying to achieve has been done for a long time with a much more common method, and one that doesn\u0026apos;t rely on using a payload with GET.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can simply build your specific search mediatype, or if you want to be more RESTful, use something like OpenSearch, and POST the request to the URI the server instructed, say /search. The server can then generate the search result or build the final URI and redirect using a 303.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has the advantage of following the traditional PRG method, helps cache intermediaries cache the results, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That said, URIs are encoded anyway for anything that is not ASCII, and so are application/x-www-form-urlencoded and multipart/form-data. I\u0026apos;d recommend using this rather than creating yet another custom json format if your intention is to support ReSTful scenarios.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I put this question to the IETF HTTP WG.  The comment from Roy Fielding (author of http/1.1 document in 1998) was that\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;... an implementation would be broken to do anything other than to parse and discard that body if received\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;RFC 7213 (HTTPbis) states:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;A payload within a GET request message has no defined semantics;\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It seems clear now that the intention was that semantic meaning on GET request bodies is prohibited, which means that the request body can\u0026apos;t be used to affect the result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are proxies out there that will \u0026lt;strong\u0026gt;definitely\u0026lt;/strong\u0026gt; break your request in various ways if you include a body on GET.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So in summary, don\u0026apos;t do it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;GET\u0026lt;/code\u0026gt;, with a body!?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Specification-wise you could, but, it\u0026apos;s not a good idea to do so injudiciously, as we shall see.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RFC 7231 §4.3.1\u0026lt;/a\u0026gt; states that a body \u0026quot;has no defined semantics\u0026quot;, but that\u0026apos;s not to say it is forbidden. If you attach a body to the request and what your server/app makes out of it is up to you. The RFC goes on to state that GET can be \u0026quot;a programmatic view on various database records\u0026quot;. Obviously such view is many times tailored by a large number of input parameters, which are not always convenient or even safe to put in the query component of the request-target.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The good:\u0026lt;/em\u0026gt; I like the verbiage. It\u0026apos;s clear that one read/get a resource without any observable side-effects on the server (the method is \u0026quot;safe\u0026quot;), and, the request can be repeated with the same intended effect regardless of the outcome of the first request (the method is \u0026quot;idempotent\u0026quot;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The bad:\u0026lt;/em\u0026gt; An early draft of HTTP/1.1 forbade GET to have a body, and - allegedly - some implementations will even up until today drop the body, ignore the body or reject the message. For example, a dumb HTTP cache may construct a cache key out of the request-target only, being oblivious to the presence or content of a body. An even dumber server could be so ignorant that it treats the body as a new request, which effectively is called \u0026quot;request smuggling\u0026quot; (which is the act of sending \u0026quot;a request to one device without the other device being aware of it\u0026quot; - \u0026lt;a href=\u0026quot;https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;source\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Due to what I believe is primarily a concern with inoperability amongst implementations, \u0026lt;a href=\u0026quot;https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.9.3.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;work in progress\u0026lt;/a\u0026gt; suggests to categorize a GET body as a \u0026quot;SHOULD NOT\u0026quot;, \u0026quot;\u0026lt;strong\u0026gt;unless\u0026lt;/strong\u0026gt; [the request] is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported\u0026quot; (emphasis mine).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The fix:\u0026lt;/em\u0026gt; There\u0026apos;s a few hacks that can be employed for some of the problems with this approach. For example, body-unaware caches can indirectly become body-aware simply by appending a hash derived from the body to the query component, or disable caching altogether by responding a \u0026lt;code\u0026gt;cache-control: no-cache\u0026lt;/code\u0026gt; header from the server.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alas when it comes to the request chain, one is often not in control of- or even aware, of all present and future HTTP intermediaries and how they will deal with a GET body. That\u0026apos;s why this approach must be considered generally unreliable.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;But \u0026lt;code\u0026gt;POST\u0026lt;/code\u0026gt;, is not idempotent!\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;POST\u0026lt;/code\u0026gt; is an alternative. The POST request usually includes a message body (just for the record, body is not a requirement, see \u0026lt;a href=\u0026quot;https://tools.ietf.org/html/rfc7230#section-3.3.2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RFC 7230 §3.3.2\u0026lt;/a\u0026gt;). The very first use case example from RFC 7231 (\u0026lt;a href=\u0026quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;§4.3.3\u0026lt;/a\u0026gt;) is \u0026quot;providing a block of data [...] to a data-handling process\u0026quot;. So just like GET with a body, what happens with the body on the back-end side is up to you.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The good:\u0026lt;/em\u0026gt; Perhaps a more common method to apply when one wish to send a request body, for whatever purpose, and so, will likely yield the least amount of noise from your team members (some may still falsely believe that POST must create a resource).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also, what we often pass parameters to is a search function operating upon constantly evolving data, and a POST response is only cacheable if explicit freshness information is provided in the response.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The bad:\u0026lt;/em\u0026gt; POST requests are not defined as idempotent, leading to request retry hesitancy. For example, on page reload, browsers are unwilling to resubmit an HTML form without prompting the user with a nonreadable cryptic message.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The fix:\u0026lt;/em\u0026gt; Well, just because POST is not defined to be idempotent doesn\u0026apos;t mean it mustn\u0026apos;t be. Indeed, \u0026lt;a href=\u0026quot;https://datatracker.ietf.org/doc/html/rfc7230#section-6.3.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RFC 7230 §6.3.1\u0026lt;/a\u0026gt; writes: \u0026quot;a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically\u0026quot;. So, unless your client is an HTML form, this is probably not a real problem.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;QUERY\u0026lt;/code\u0026gt; is the holy grail\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;There\u0026apos;s a proposal for a new method \u0026lt;code\u0026gt;QUERY\u0026lt;/code\u0026gt; which does define semantics for a message body \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; defines the method as idempotent. See \u0026lt;a href=\u0026quot;https://www.ietf.org/id/draft-ietf-httpbis-safe-method-w-body-02.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit\u0026lt;/strong\u0026gt;: As a side-note, I stumbled into this StackOverflow question after having discovered a codebase where they solely used \u0026lt;code\u0026gt;PUT\u0026lt;/code\u0026gt; requests for server-side search functions. This were their idea to include a body with parameters and also be idempotent. Alas the problem with PUT is that the request body has very precise semantics. Specifically, the PUT \u0026quot;requests that the state of the target resource be created or replaced with the state [in the body]\u0026quot; (\u0026lt;a href=\u0026quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RFC 7231 §4.3.4\u0026lt;/a\u0026gt;). Clearly, this excludes PUT as a viable option.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616#section-4.3\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;RFC 2616, section 4.3\u0026lt;/a\u0026gt;, \u0026quot;Message Body\u0026quot;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;A server SHOULD read and forward a message-body on any request; if the\nrequest method does not include defined semantics for an entity-body,\nthen the message-body SHOULD be ignored when handling the request.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;That is, servers should always read any provided request body from the network (check Content-Length or read a chunked body, etc). Also, proxies should forward any such request body they receive. Then, if the RFC defines semantics for the body for the given method, the server can actually use the request body in generating a response. However, if the RFC \u0026lt;em\u0026gt;does not\u0026lt;/em\u0026gt; define semantics for the body, then the server should ignore it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is in line with the quote from Fielding above.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616#section-9.3\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Section 9.3\u0026lt;/a\u0026gt;, \u0026quot;GET\u0026quot;, describes the semantics of the GET method, and doesn\u0026apos;t mention request bodies. Therefore, a server should ignore any request body it receives on a GET request.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Which server will ignore it?  fijiaaron Aug 30 \u0026apos;12 at 21:27\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Google\u0026lt;/strong\u0026gt; for instance is doing worse than ignoring it, it will consider it an \u0026lt;strong\u0026gt;error\u0026lt;/strong\u0026gt;!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Try it yourself with a simple netcat:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$ netcat www.google.com 80\nGET / HTTP/1.1\nHost: www.google.com\nContent-length: 6\n\n1234\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(the 1234 content is followed by CR-LF, so that is a total of 6 bytes)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;and you will get:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;HTTP/1.1 400 Bad Request\nServer: GFE/2.0\n(....)\nError 400 (Bad Request)\n400. Thats an error.\nYour client has issued a malformed or illegal request. Thats all we know.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You do also get 400 Bad Request from Bing, Apple, etc... which are served by AkamaiGhost.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I wouldn\u0026apos;t advise using GET requests with a body entity.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;According to XMLHttpRequest, it\u0026apos;s not valid. From the \u0026lt;a href=\u0026quot;https://xhr.spec.whatwg.org/#the-send()-method\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;standard\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;4.5.6 The \u0026lt;code\u0026gt;send()\u0026lt;/code\u0026gt; method\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;blockquote\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026lt;i\u0026gt;client\u0026lt;/i\u0026gt; . send([\u0026lt;i\u0026gt;body\u0026lt;/i\u0026gt; = null])\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    \n    \u0026lt;p\u0026gt;Initiates the request. The optional argument provides the request\n    body. The argument is ignored if request method is \u0026lt;code\u0026gt;GET\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;HEAD\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    \n    \u0026lt;p\u0026gt;Throws an \u0026lt;code\u0026gt;InvalidStateError\u0026lt;/code\u0026gt; exception if either state is not\n    \u0026lt;em\u0026gt;opened\u0026lt;/em\u0026gt; or the \u0026lt;code\u0026gt;send()\u0026lt;/code\u0026gt; flag is set.\u0026lt;/p\u0026gt;\n  \u0026lt;/blockquote\u0026gt;\n  \n  \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;send(\u0026lt;i\u0026gt;body\u0026lt;/i\u0026gt;)\u0026lt;/code\u0026gt; method must run these steps:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;If state is not \u0026lt;em\u0026gt;opened\u0026lt;/em\u0026gt;, throw an \u0026lt;code\u0026gt;InvalidStateError\u0026lt;/code\u0026gt; exception.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;If the \u0026lt;code\u0026gt;send()\u0026lt;/code\u0026gt; flag is set, throw an \u0026lt;code\u0026gt;InvalidStateError\u0026lt;/code\u0026gt; exception.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;If the request method is \u0026lt;code\u0026gt;GET\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;HEAD\u0026lt;/code\u0026gt;, set \u0026lt;em\u0026gt;body\u0026lt;/em\u0026gt; to null.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;If \u0026lt;em\u0026gt;body\u0026lt;/em\u0026gt; is null, go to the next step.\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Although, I don\u0026apos;t think it should because GET request might need big body content.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, if you rely on XMLHttpRequest of a browser, it\u0026apos;s likely it won\u0026apos;t work.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you really want to send cachable JSON/XML body to web application the only reasonable place to put your data is query string encoded with \u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc4648#section-5\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;RFC4648: Base 64 Encoding with URL and Filename Safe Alphabet\u0026lt;/a\u0026gt;. Of course you could just urlencode JSON and put is in URL param\u0026apos;s value, but Base64 gives smaller result. Keep in mind that there are URL size restrictions, see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url\u0026quot;\u0026gt;What is the maximum length of a URL in different browsers?\u0026lt;/a\u0026gt; .\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You may think that Base64\u0026apos;s padding \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; character may be bad for URL\u0026apos;s param value, however it seems not - see this discussion: \u0026lt;a href=\u0026quot;http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html\u0026lt;/a\u0026gt; . However you shouldn\u0026apos;t put encoded data without param name because encoded string with padding will be interpreted as param key with empty value.\nI would use something like \u0026lt;code\u0026gt;?_b64=\u0026amp;lt;encodeddata\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wouldn\u0026apos;t advise this, it goes against standard practices, and doesn\u0026apos;t offer that much in return. You want to keep the body for content, not options.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You have a list of options which are far better than using a request body with GET.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos; assume you have categories and items for each category. Both to be identified by an id (\u0026quot;catid\u0026quot; / \u0026quot;itemid\u0026quot; for the sake of this example). You want to sort according to another parameter \u0026quot;sortby\u0026quot; in a specific \u0026quot;order\u0026quot;. You want to pass parameters for \u0026quot;sortby\u0026quot; and \u0026quot;order\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Use query strings, e.g.\n\u0026lt;code\u0026gt;example.com/category/{catid}/item/{itemid}?sortby=itemname\u0026amp;amp;order=asc\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use mod_rewrite (or similar) for paths:\n\u0026lt;code\u0026gt;example.com/category/{catid}/item/{itemid}/{sortby}/{order}\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use individual HTTP headers you pass with the request\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use a different method, e.g. POST, to retrieve a resource.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;All have their downsides, but are far better than using a GET with a body.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m upset that REST as protocol doesn\u0026apos;t support OOP and \u0026lt;code\u0026gt;Get\u0026lt;/code\u0026gt; method is proof. As a solution, you can serialize your a DTO to JSON and then create a query string. On server side you\u0026apos;ll able to deserialize the query string to the DTO.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take a look on:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/ServiceStack/ServiceStack/wiki/What-is-a-message-based-web-service?\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Message-based design in ServiceStack\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.codeproject.com/Articles/712689/Building-RESTful-Message-Based-Web-Services-with-W\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Building RESTful Message Based Web Services with WCF\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Message based approach can help you to solve Get method restriction. You\u0026apos;ll able to send any DTO as with request body\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/Nelibur/Nelibur\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Nelibur web service framework provides functionality which you can use\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;var client = new JsonServiceClient(Settings.Default.ServiceAddress);\nvar request = new GetClientRequest\n    {\n        Id = new Guid(\u0026quot;2217239b0e-b35b-4d32-95c7-5db43e2bd573\u0026quot;)\n    };\nvar response = client.Get\u0026amp;lt;GetClientRequest, ClientResponse\u0026amp;gt;(request);\n\nas you can see, the GetClientRequest was encoded to the following query string\n\nhttp://localhost/clients/GetWithResponse?type=GetClientRequest\u0026amp;amp;data=%7B%22Id%22:%2217239b0e-b35b-4d32-95c7-5db43e2bd573%22%7D\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What about nonconforming base64 encoded headers? \u0026quot;SOMETHINGAPP-PARAMS:sdfSD45fdg45/aS\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Length restrictions hm. Can\u0026apos;t you make your POST handling distinguish between the meanings? If you want simple parameters like sorting, I don\u0026apos;t see why this would be a problem. I guess it\u0026apos;s certainty you\u0026apos;re worried about.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;IMHO you could just send the \u0026lt;code\u0026gt;JSON\u0026lt;/code\u0026gt; encoded (ie. \u0026lt;code\u0026gt;encodeURIComponent\u0026lt;/code\u0026gt;) in the \u0026lt;code\u0026gt;URL\u0026lt;/code\u0026gt;, this way you do not violate the \u0026lt;code\u0026gt;HTTP\u0026lt;/code\u0026gt; specs and get your \u0026lt;code\u0026gt;JSON\u0026lt;/code\u0026gt; to the server.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For example, it works with Curl, Apache and PHP.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;PHP file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;?php\necho $_SERVER[\u0026apos;REQUEST_METHOD\u0026apos;] . PHP_EOL;\necho file_get_contents(\u0026apos;php://input\u0026apos;) . PHP_EOL;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Console command:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$ curl -X GET -H \u0026quot;Content-Type: application/json\u0026quot; -d \u0026apos;{\u0026quot;the\u0026quot;: \u0026quot;body\u0026quot;}\u0026apos; \u0026apos;http://localhost/test/get.php\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;GET\n{\u0026quot;the\u0026quot;: \u0026quot;body\u0026quot;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Even if a popular tool use this, as cited frequently on this page, I think it is still quite a bad idea, being too exotic, despite not forbidden by the spec.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Many intermediate infrastructures may just reject such requests.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By example, forget about using some of the available CDN in front of your web site, like this \u0026lt;a href=\u0026quot;https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#RequestCustom-get-body\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;one\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If a viewer \u0026lt;code\u0026gt;GET\u0026lt;/code\u0026gt; request includes a body, CloudFront returns an HTTP status code 403 (Forbidden) to the viewer.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And yes, your client libraries may also not support emitting such requests, as reported in this \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/978061/http-get-with-request-body/58215864#comment32122408_978094\u0026quot;\u0026gt;comment\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An idea on an old question:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Add the content on the body, and a hash of the body on the querystring, so caching won\u0026apos;t be a problem and you\u0026apos;ll be able to send tons of data when needed :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Create a Requestfactory class\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;import java.net.URI;\n\nimport javax.annotation.PostConstruct;\n\nimport org.apache.http.client.methods.HttpEntityEnclosingRequestBase;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\n\n@Component\npublic class RequestFactory {\n    private RestTemplate restTemplate = new RestTemplate();\n\n    @PostConstruct\n    public void init() {\n        this.restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestWithBodyFactory());\n    }\n\n    private static final class HttpComponentsClientHttpRequestWithBodyFactory extends HttpComponentsClientHttpRequestFactory {\n        @Override\n        protected HttpUriRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n            if (httpMethod == HttpMethod.GET) {\n                return new HttpGetRequestWithEntity(uri);\n            }\n            return super.createHttpUriRequest(httpMethod, uri);\n        }\n    }\n\n    private static final class HttpGetRequestWithEntity extends HttpEntityEnclosingRequestBase {\n        public HttpGetRequestWithEntity(final URI uri) {\n            super.setURI(uri);\n        }\n\n        @Override\n        public String getMethod() {\n            return HttpMethod.GET.name();\n        }\n    }\n\n    public RestTemplate getRestTemplate() {\n        return restTemplate;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and @Autowired where ever you require and use, Here is one sample code GET request with RequestBody\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; @RestController\n @RequestMapping(\u0026quot;/v1/API\u0026quot;)\npublic class APIServiceController {\n    \n    @Autowired\n    private RequestFactory requestFactory;\n    \n\n    @RequestMapping(method = RequestMethod.GET, path = \u0026quot;/getData\u0026quot;)\n    public ResponseEntity\u0026amp;lt;APIResponse\u0026amp;gt; getLicenses(@RequestBody APIRequest2 APIRequest){\n        APIResponse response = new APIResponse();\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        Gson gson = new Gson();\n        try {\n            StringBuilder createPartUrl = new StringBuilder(PART_URL).append(PART_URL2);\n            \n            HttpEntity\u0026amp;lt;String\u0026amp;gt; entity = new HttpEntity\u0026amp;lt;String\u0026amp;gt;(gson.toJson(APIRequest),headers);\n            ResponseEntity\u0026amp;lt;APIResponse\u0026amp;gt; storeViewResponse = requestFactory.getRestTemplate().exchange(createPartUrl.toString(), HttpMethod.GET, entity, APIResponse.class); //.getForObject(createLicenseUrl.toString(), APIResponse.class, entity);\n    \n            if(storeViewResponse.hasBody()) {\n                response = storeViewResponse.getBody();\n            }\n            return new ResponseEntity\u0026amp;lt;APIResponse\u0026amp;gt;(response, HttpStatus.OK);\n        }catch (Exception e) {\n            e.printStackTrace();\n            return new ResponseEntity\u0026amp;lt;APIResponse\u0026amp;gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n        \n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":242,"title":"HTTP GET with request body","content":"\n                \n\u0026lt;p\u0026gt;I\u0026apos;m developing a new RESTful webservice for our application.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When doing a GET on certain entities, clients can request the contents of the entity.\nIf they want to add some parameters (for example sorting a list) they can add these parameters in the query string.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively I want people to be able to specify these parameters in the request body.\n\u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTTP/1.1\u0026lt;/a\u0026gt; does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex XML requests.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;My questions:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Is this a good idea altogether?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Will HTTP clients have issues with using request bodies within a GET request?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.rfc-editor.org/rfc/rfc2616\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.rfc-editor.org/rfc/rfc2616\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"http-get-with-request-body-1657387379038","postType":"QUESTION","createdAt":"2022-07-09T17:22:59.000Z","updatedAt":"2022-07-09T17:22:59.000Z","tags":[{"id":1594,"name":"rest","slug":"rest","createdAt":"2022-07-09T17:22:59.000Z","updatedAt":"2022-07-09T17:22:59.000Z","Questions_Tags":{"questionId":242,"tagId":1594}},{"id":1595,"name":"http-get","slug":"http-get","createdAt":"2022-07-09T17:22:59.000Z","updatedAt":"2022-07-09T17:22:59.000Z","Questions_Tags":{"questionId":242,"tagId":1595}}],"relatedQuestions":[{"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038","tags":[{"name":"rest","Questions_Tags":{"questionId":242,"tagId":1594}},{"name":"http-get","Questions_Tags":{"questionId":242,"tagId":1595}}]}]},"randomQuestions":[{"title":"What is this weird colon-member (\" : \") syntax in the constructor?","slug":"what-is-this-weird-colon-member-(\"-:-\")-syntax-in-the-constructor-1657387264047"},{"title":"Is there a difference between \"==\" and \"is\"?","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231"},{"title":"Why does jQuery or a DOM method such as getElementById not find the element?","slug":"why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458"},{"title":"Do DOM tree elements with IDs become global properties?","slug":"do-dom-tree-elements-with-ids-become-global-properties-1657387475110"},{"title":"Why is processing a sorted array faster than processing an unsorted array?","slug":"why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444"},{"title":"Iterator invalidation rules for C++ containers","slug":"iterator-invalidation-rules-for-c++-containers-1657387561090"},{"title":"Is it possible for flex items to align tightly to the items above them?","slug":"is-it-possible-for-flex-items-to-align-tightly-to-the-items-above-them-1657388511179"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":".prop() vs .attr()","slug":".prop()-vs-.attr()-1657384898328"},{"title":"Flexbox: center horizontally and vertically","slug":"flexbox:-center-horizontally-and-vertically-1657384587888"},{"title":"Why can't an element with a z-index value cover its child?","slug":"why-can't-an-element-with-a-z-index-value-cover-its-child-1657387707187"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"},{"title":"Removing duplicates in lists","slug":"removing-duplicates-in-lists-1657388207448"},{"title":"Learning Regular Expressions [closed]","slug":"learning-regular-expressions-closed-1657384719460"},{"title":"How can I return pivot table output in MySQL?","slug":"how-can-i-return-pivot-table-output-in-mysql-1657384715043"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"How to convert string representation of list to a list","slug":"how-to-convert-string-representation-of-list-to-a-list-1657387384181"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"http-get-with-request-body-1657387379038"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>