<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="generics,raw-types,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-is-a-raw-type-and-why-shouldn&apos;t-we-use-it-1657384481079","name":"Questions"}}]}</script><title>What is a raw type and why shouldn&#x27;t we use it? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Questions:


What are raw types in Java, and why do I often hear that they shouldn&#x27;t be used in new code?
What is the alternative if we can&#x27;t use raw types, and how is it better?

    "/><meta property="og:title" content="What is a raw type and why shouldn&#x27;t we use it? | Solution Checker"/><meta property="og:description" content="Questions:


What are raw types in Java, and why do I often hear that they shouldn&#x27;t be used in new code?
What is the alternative if we can&#x27;t use raw types, and how is it better?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is a raw type and why shouldn&apos;t we use it?","text":"Questions:\n\n\nWhat are raw types in Java, and why do I often hear that they shouldn&apos;t be used in new code?\nWhat is the alternative if we can&apos;t use raw types, and how is it better?\n\n    ","answerCount":15,"upVoteCount":500,"suggestedAnswer":[{"text":"What is a raw type?\nThe Java Language Specification defines a raw type as follows:\nJLS 4.8 Raw Types\n\nA raw type is defined to be one of:\n\nThe reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.\n\nAn array type whose element type is a raw type.\n\nA non-static member type of a raw type R that is not inherited from a superclass or superinterface of R.\n\n\n\nHere&apos;s an example to illustrate:\npublic class MyType&lt;E&gt; {\n    class Inner { }\n    static class Nested { }\n    \n    public static void main(String[] args) {\n        MyType mt;          // warning: MyType is a raw type\n        MyType.Inner inn;   // warning: MyType.Inner is a raw type\n\n        MyType.Nested nest; // no warning: not parameterized type\n        MyType&lt;Object&gt; mt1; // no warning: type parameter given\n        MyType&lt;?&gt; mt2;      // no warning: type parameter given (wildcard OK!)\n    }\n}\n\nHere, MyType&lt;E&gt; is a parameterized type (JLS 4.5). It is common to colloquially refer to this type as simply MyType for short, but technically the name is MyType&lt;E&gt;.\nmt has a raw type (and generates a compilation warning) by the first bullet point in the above definition; inn also has a raw type by the third bullet point.\nMyType.Nested is not a parameterized type, even though it&apos;s a member type of a parameterized type MyType&lt;E&gt;, because it&apos;s static.\nmt1, and mt2 are both declared with actual type parameters, so they&apos;re not raw types.\n\nWhat&apos;s so special about raw types?\nEssentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.\nList names = new ArrayList(); // warning: raw type!\nnames.add(&quot;John&quot;);\nnames.add(&quot;Mary&quot;);\nnames.add(Boolean.FALSE); // not a compilation error!\n\nThe above code runs just fine, but suppose you also have the following:\nfor (Object o : names) {\n    String name = (String) o;\n    System.out.println(name);\n} // throws ClassCastException!\n  //    java.lang.Boolean cannot be cast to java.lang.String\n\nNow we run into trouble at run-time, because names contains something that isn&apos;t an instanceof String.\nPresumably, if you want names to contain only String, you could perhaps still use a raw type and manually check every add yourself, and then manually cast to String every item from names. Even better, though is NOT to use a raw type and let the compiler do all the work for you, harnessing the power of Java generics.\nList&lt;String&gt; names = new ArrayList&lt;String&gt;();\nnames.add(&quot;John&quot;);\nnames.add(&quot;Mary&quot;);\nnames.add(Boolean.FALSE); // compilation error!\n\nOf course, if you DO want names to allow a Boolean, then you can declare it as List&lt;Object&gt; names, and the above code would compile.\nSee also\n\nJava Tutorials/Generics\n\n\nHow&apos;s a raw type different from using &lt;Object&gt; as type parameters?\nThe following is a quote from Effective Java 2nd Edition, Item 23: Don&apos;t use raw types in new code:\n\nJust what is the difference between the raw type List and the parameterized type List&lt;Object&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a List&lt;String&gt; to a parameter of type List, you can&apos;t pass it to a parameter of type List&lt;Object&gt;. There are subtyping rules for generics, and List&lt;String&gt; is a subtype of the raw type List, but not of the parameterized type List&lt;Object&gt;. As a consequence, you lose type safety if you use raw type like List, but not if you use a parameterized type like List&lt;Object&gt;.\n\nTo illustrate the point, consider the following method which takes a List&lt;Object&gt; and appends a new Object().\nvoid appendNewObject(List&lt;Object&gt; list) {\n   list.add(new Object());\n}\n\nGenerics in Java are invariant. A List&lt;String&gt; is not a List&lt;Object&gt;, so the following would generate a compiler warning:\nList&lt;String&gt; names = new ArrayList&lt;String&gt;();\nappendNewObject(names); // compilation error!\n\nIf you had declared appendNewObject to take a raw type List as parameter, then this would compile, and you&apos;d therefore lose the type safety that you get from generics.\nSee also\n\nWhat is the difference between &lt;E extends Number&gt; and &lt;Number&gt;?\njava generics (not) covariance\n\n\nHow&apos;s a raw type different from using &lt;?&gt; as a type parameter?\nList&lt;Object&gt;, List&lt;String&gt;, etc are all List&lt;?&gt;, so it may be tempting to just say that they&apos;re just List instead. However, there is a major difference: since a List&lt;E&gt; defines only add(E), you can&apos;t add just any arbitrary object to a List&lt;?&gt;. On the other hand, since the raw type List does not have type safety, you can add just about anything to a List.\nConsider the following variation of the previous snippet:\nstatic void appendNewObject(List&lt;?&gt; list) {\n    list.add(new Object()); // compilation error!\n}\n//...\n\nList&lt;String&gt; names = new ArrayList&lt;String&gt;();\nappendNewObject(names); // this part is fine!\n\nThe compiler did a wonderful job of protecting you from potentially violating the type invariance of the List&lt;?&gt;! If you had declared the parameter as the raw type List list, then the code would compile, and you&apos;d violate the type invariant of List&lt;String&gt; names.\n\nA raw type is the erasure of that type\nBack to JLS 4.8:\n\nIt is possible to use as a type the erasure of a parameterized type or the erasure of an array type whose element type is a parameterized type. Such a type is called a raw type.\n[...]\nThe superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.\nThe type of a constructor, instance method, or non-static field of a raw type C that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to C.\n\nIn simpler terms, when a raw type is used, the constructors, instance methods and non-static fields are also erased.\nTake the following example:\nclass MyType&lt;E&gt; {\n    List&lt;String&gt; getNames() {\n        return Arrays.asList(&quot;John&quot;, &quot;Mary&quot;);\n    }\n\n    public static void main(String[] args) {\n        MyType rawType = new MyType();\n        // unchecked warning!\n        // required: List&lt;String&gt; found: List\n        List&lt;String&gt; names = rawType.getNames();\n        // compilation error!\n        // incompatible types: Object cannot be converted to String\n        for (String str : rawType.getNames())\n            System.out.print(str);\n    }\n}\n\nWhen we use the raw MyType, getNames becomes erased as well, so that it returns a raw List!\nJLS 4.6 continues to explain the following:\n\nType erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables. The erasure of a constructor or method signature s is a signature consisting of the same name as s and the erasures of all the formal parameter types given in s.\nThe return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor&apos;s signature is erased.\nThe erasure of the signature of a generic method has no type parameters.\n\nThe following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: https://bugs.openjdk.java.net/browse/JDK-6400189. (In short, it makes the specification simpler.)\n\nIf it&apos;s unsafe, why is it allowed to use a raw type?\nHere&apos;s another quote from JLS 4.8:\n\nThe use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.\n\nEffective Java 2nd Edition also has this to add:\n\nGiven that you shouldn&apos;t use raw types, why did the language designers allow them? To provide compatibility.\nThe Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as migration compatibility, drove the decision to support raw types.\n\nIn summary, raw types should NEVER be used in new code. You should always use parameterized types.\n\nAre there no exceptions?\nUnfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:\n\nClass literals, e.g. List.class, not List&lt;String&gt;.class\ninstanceof operand, e.g. o instanceof Set, not o instanceof Set&lt;String&gt;\n\nSee also\n\nWhy is Collection&lt;String&gt;.class Illegal?\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"\n  What are raw types in Java, and why do I often hear that they shouldn&apos;t be used in new code?\n\n\nRaw-types are ancient history of the Java language. In the beginning there were Collections and they held Objects nothing more and nothing less. Every operation on Collections required casts from Object to the desired type.\n\nList aList = new ArrayList();\nString s = &quot;Hello World!&quot;;\naList.add(s);\nString c = (String)aList.get(0);\n\n\nWhile this worked most of the time, errors did happen\n\nList aNumberList = new ArrayList();\nString one = &quot;1&quot;;//Number one\naNumberList.add(one);\nInteger iOne = (Integer)aNumberList.get(0);//Insert ClassCastException here\n\n\nThe old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.\nGenerics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.\n\nList&lt;String&gt; aNumberList = new ArrayList&lt;String&gt;();\naNumberList.add(&quot;one&quot;);\nInteger iOne = aNumberList.get(0);//Compile time error\nString sOne = aNumberList.get(0);//works fine\n\n\nFor Comparison:\n\n// Old style collections now known as raw types\nList aList = new ArrayList(); //Could contain anything\n// New style collections with Generics\nList&lt;String&gt; aList = new ArrayList&lt;String&gt;(); //Contains only Strings\n\n\nMore complex the Compareable interface:\n\n//raw, not type save can compare with Other classes\nclass MyCompareAble implements CompareAble\n{\n   int id;\n   public int compareTo(Object other)\n   {return this.id - ((MyCompareAble)other).id;}\n}\n//Generic\nclass MyCompareAble implements CompareAble&lt;MyCompareAble&gt;\n{\n   int id;\n   public int compareTo(MyCompareAble other)\n   {return this.id - other.id;}\n}\n\n\nNote that it is impossible to implement the CompareAble interface with compareTo(MyCompareAble) with raw types.\nWhy you should not use them:\n\n\nAny Object stored in a Collection has to be cast before it can be used\nUsing generics enables compile time checks\nUsing raw types is the same as storing each value as Object\n\n\nWhat the compiler does:\nGenerics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.\n\nList&lt;String&gt; someStrings = new ArrayList&lt;String&gt;();\nsomeStrings.add(&quot;one&quot;);\nString one = someStrings.get(0);\n\n\nWill be compiled as:\n\nList someStrings = new ArrayList();\nsomeStrings.add(&quot;one&quot;); \nString one = (String)someStrings.get(0);\n\n\nThis is the same code you would write if you used the raw types directly. Thought I&apos;m not sure what happens with the CompareAble interface, I guess that it creates two compareTo functions, one taking a MyCompareAble and the other taking an Object and passing it to the first after casting it.\n\nWhat are the alternatives to raw types: Use generics\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\npublic class Box&lt;T&gt; {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box&lt;T&gt;, you supply an actual type argument for the formal type parameter T:\nBox&lt;Integer&gt; intBox = new Box&lt;&gt;();\n\nIf the actual type argument is omitted, you create a raw type of Box&lt;T&gt;:\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box&lt;T&gt;. However, a non-generic class or interface type is not a raw type.\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior  a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\nBox&lt;String&gt; stringBox = new Box&lt;&gt;();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\nBox rawBox = new Box();           // rawBox is a raw type of Box&lt;T&gt;\nBox&lt;Integer&gt; intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\nBox&lt;String&gt; stringBox = new Box&lt;&gt;();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.\nThe Type Erasure section has more information on how the Java compiler uses raw types.\nUnchecked Error Messages\nAs mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:\n\nNote: Example.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\n\nThis can happen when using an older API that operates on raw types, as shown in the following example:\npublic class WarningDemo {\n    public static void main(String[] args){\n        Box&lt;Integer&gt; bi;\n        bi = createBox();\n    }\n\n    static Box createBox(){\n        return new Box();\n    }\n}\n\nThe term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.\nRecompiling the previous example with -Xlint:unchecked reveals the following additional information:\nWarningDemo.java:4: warning: [unchecked] unchecked conversion\nfound   : Box\nrequired: Box&lt;java.lang.Integer&gt;\n        bi = createBox();\n                      ^\n1 warning\n\nTo completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&quot;unchecked&quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.\nOriginal source: Java Tutorials\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.\n\nFor example, before Java generics was available, you would use a collection class like this:\n\nLinkedList list = new LinkedList();\nlist.add(new MyObject());\nMyObject myObject = (MyObject)list.get(0);\n\n\nWhen you add your object to the list, it doesn&apos;t care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.\n\nUsing generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:\n\nLinkedList&lt;MyObject&gt; list = new LinkedList&lt;MyObject&gt;();\nlist.add(new MyObject());\nMyObject myObject = list.get(0);\n\n\nNotice that with generics you don&apos;t have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":" private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n\nYou should specify the type-parameter. \n\nThe warning advises that types that are defined to support generics should be parameterized, rather than using their raw form.\n\nList is defined to support generics: public class List&lt;E&gt;. This allows many type-safe operations, that are checked compile-time.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"What is a raw type and why do I often hear that they shouldn&apos;t be used in new code?\n\nA &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using List instead of List&lt;String&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.\n\n&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.\n\nWhat is the alternative if we can&apos;t use raw types, and how is it better?\n\nThe preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. List&lt;String&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.\n\nFor example, for a method where the programmer wants to ensure a List variable called &apos;names&apos; contains only Strings:\n\nList&lt;String&gt; names = new ArrayList&lt;String&gt;();\nnames.add(&quot;John&quot;);          // OK\nnames.add(new Integer(1));  // compile error\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Here I am Considering multiple cases  through which you can clearify  the concept\n\n1. ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();\n2. ArrayList&lt;String&gt; arr = new ArrayList();\n3. ArrayList arr = new ArrayList&lt;String&gt;();\n\n\nCase 1\n\nArrayList&lt;String&gt; arr it is a ArrayList reference variable with type String which reference to a ArralyList Object of Type String. It means it can hold only String type Object.\n\nIt is a Strict to String not  a Raw Type so, It will never raise an warning .\n\n    arr.add(&quot;hello&quot;);// alone statement will compile successfully and no warning.\n\n    arr.add(23);  //prone to compile time error.\n     //error: no suitable method found for add(int)\n\n\nCase 2\n\nIn this case ArrayList&lt;String&gt; arr is a strict type but your Object new ArrayList(); is a raw type. \n\n    arr.add(&quot;hello&quot;); //alone this compile but raise the warning.\n    arr.add(23);  //again prone to compile time error.\n    //error: no suitable method found for add(int)\n\n\nhere arr is a Strict type. So, It will raise compile time error when adding a integer.\n\n\n  Warning :- A Raw Type Object is referenced to a Strict type Referenced Variable of ArrayList.\n\n\nCase 3\n\nIn this case ArrayList arr is a raw type but your Object new ArrayList&lt;String&gt;(); is a Strict type. \n\n    arr.add(&quot;hello&quot;);  \n    arr.add(23);  //compiles fine but raise the warning.\n\n\nIt will add any type of Object into it because arr is a Raw Type.\n\n\n  Warning :- A Strict Type Object is referenced to a raw type referenced Variable.\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The compiler wants you to write this:\n\nprivate static List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n\nbecause otherwise, you could add any type you like into list, making the instantiation as new ArrayList&lt;String&gt;() pointless. Java generics are a compile-time feature only, so an object created with new ArrayList&lt;String&gt;() will happily accept Integer or JFrame elements if assigned to a reference of the &quot;raw type&quot; List - the object itself knows nothing about what types it&apos;s supposed to contain, only the compiler does.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s another case where raw types will bite you:\npublic class StrangeClass&lt;T&gt; {\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public &lt;X&gt; X getSomethingElse() {\n    return (X)&quot;Testing something else!&quot;;\n  }\n\n  public static void main(String[] args) {\n    final StrangeClass&lt;String&gt; withGeneric    = new StrangeClass&lt;&gt;();\n    final StrangeClass         withoutGeneric = new StrangeClass();\n    final String               value1,\n                               value2;\n\n    // Compiles\n    value1 = withGeneric.getSomethingElse();\n\n    // Produces compile error:\n    // incompatible types: java.lang.Object cannot be converted to java.lang.String\n    value2 = withoutGeneric.getSomethingElse();\n  }\n}\n\nThis is counter-intuitive because you&apos;d expect the raw type to only affect methods bound to the class type parameter, but it actually also affects generic methods with their own type parameters.\nAs was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just Object).\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"A raw-type is the a lack of a type parameter when using a generic type.\n\nRaw-type should not be used because it could cause runtime errors, like inserting a double into what was supposed to be a Set of ints.\n\nSet set = new HashSet();\nset.add(3.45); //ok\n\n\nWhen retrieving the stuff from the Set, you don&apos;t know what is coming out. Let&apos;s assume that you expect it to be all ints, you are casting it to Integer; exception at runtime when the double 3.45 comes along.\n\nWith a type parameter added to your Set, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).\n\nSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\nset.add(3.45); //NOT ok.\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Avoid raw types.\nRaw types refer to using a generic type without specifying a type parameter.\nFor example:\nA list is a raw type, while List&lt;String&gt; is a parameterized type.\nWhen generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java.\nAlthough using raw types is still possible, they should be avoided:\n\nThey usually require casts.\nThey aren&apos;t type safe, and some important kinds of errors will only appear at runtime.\nThey are less expressive, and don&apos;t self-document in the same way as parameterized types..\n\nExample:\nimport java.util.*;\npublic final class AvoidRawTypes {\n    void withRawType() {\n        //Raw List doesn&apos;t self-document, \n        //doesn&apos;t state explicitly what it can contain\n        List stars = Arrays.asList(&quot;Arcturus&quot;, &quot;Vega&quot;, &quot;Altair&quot;);\n        Iterator iter = stars.iterator();\n        while (iter.hasNext()) {\n            String star = (String) iter.next(); //cast needed\n            log(star);\n        }\n    }\n\n    void withParameterizedType() {\n        List &lt; String &gt; stars = Arrays.asList(&quot;Spica&quot;, &quot;Regulus&quot;, &quot;Antares&quot;);\n        for (String star: stars) {\n            log(star);\n        }\n    }\n\n    private void log(Object message) {\n        System.out.println(Objects.toString(message));\n    }\n}\n \n\nFor reference: https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"What is saying is that your list is a List of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).\n\nIn general is a better idea to parametrize the collections, so you don&apos;t have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.\n\nprivate static List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"tutorial page.  \n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:  \n\npublic class Box&lt;T&gt; {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\n\nTo create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:  \n\nBox&lt;Integer&gt; intBox = new Box&lt;&gt;();\n\n\nIf the actual type argument is omitted, you create a raw type of Box:  \n\nBox rawBox = new Box();\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I found this page after doing some sample exercises and having the exact same puzzlement.\n\n============== I went from this code as provide by the sample ===============\n\npublic static void main(String[] args) throws IOException {\n\n    Map wordMap = new HashMap();\n    if (args.length &gt; 0) {\n        for (int i = 0; i &lt; args.length; i++) {\n            countWord(wordMap, args[i]);\n        }\n    } else {\n        getWordFrequency(System.in, wordMap);\n    }\n    for (Iterator i = wordMap.entrySet().iterator(); i.hasNext();) {\n        Map.Entry entry = (Map.Entry) i.next();\n        System.out.println(entry.getKey() + &quot; :\\t&quot; + entry.getValue());\n    }\n\n\n====================== To This code ========================\n\npublic static void main(String[] args) throws IOException {\n    // replace with TreeMap to get them sorted by name\n    Map&lt;String, Integer&gt; wordMap = new HashMap&lt;String, Integer&gt;();\n    if (args.length &gt; 0) {\n        for (int i = 0; i &lt; args.length; i++) {\n            countWord(wordMap, args[i]);\n        }\n    } else {\n        getWordFrequency(System.in, wordMap);\n    }\n    for (Iterator&lt;Entry&lt;String, Integer&gt;&gt; i = wordMap.entrySet().iterator(); i.hasNext();) {\n        Entry&lt;String, Integer&gt; entry =   i.next();\n        System.out.println(entry.getKey() + &quot; :\\t&quot; + entry.getValue());\n    }\n\n}\n\n\n===============================================================================\n\nIt may be safer but took 4  hours to demuddle the philosophy...\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Raw types are fine when they express what you want to express.\n\nFor example, a deserialisation function might return a List, but it doesn&apos;t know the list&apos;s element type. So List is the appropriate return type here.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-a-raw-type-and-why-shouldn&#x27;t-we-use-it-1657384481079#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-a-raw-type-and-why-shouldn&#x27;t-we-use-it-1657384481079"><h1>What is a raw type and why shouldn&#x27;t we use it?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/raw-types">raw-types</a></div></div><div class="question-content mt-5">
                
<h3>Questions:</h3>

<ul>
<li>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</li>
<li>What is the alternative if we can't use raw types, and how is it better?</li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>What is a raw type?</h2>
<p>The Java Language Specification defines a <em>raw type</em> as follows:</p>
<h3><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8" rel="noreferrer">JLS 4.8 Raw Types</a></h3>
<blockquote>
<p>A raw type is defined to be one of:</p>
<ul>
<li><p>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</p>
</li>
<li><p>An array type whose element type is a raw type.</p>
</li>
<li><p>A non-<code>static</code> member type of a raw type <code>R</code> that is not inherited from a superclass or superinterface of <code>R</code>.</p>
</li>
</ul>
</blockquote>
<p>Here's an example to illustrate:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyType</span>&lt;E&gt; {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> { }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nested</span> { }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        MyType mt;          <span class="hljs-comment">// warning: MyType is a raw type</span>
        MyType.Inner inn;   <span class="hljs-comment">// warning: MyType.Inner is a raw type</span>

        MyType.Nested nest; <span class="hljs-comment">// no warning: not parameterized type</span>
        MyType&lt;Object&gt; mt1; <span class="hljs-comment">// no warning: type parameter given</span>
        MyType&lt;?&gt; mt2;      <span class="hljs-comment">// no warning: type parameter given (wildcard OK!)</span>
    }
}
</code></pre>
<p>Here, <code>MyType&lt;E&gt;</code> is a <em>parameterized type</em> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5" rel="noreferrer">JLS 4.5</a>). It is common to colloquially refer to this type as simply <code>MyType</code> for short, but technically the name is <code>MyType&lt;E&gt;</code>.</p>
<p><code>mt</code> has a raw type (and generates a compilation warning) by the first bullet point in the above definition; <code>inn</code> also has a raw type by the third bullet point.</p>
<p><code>MyType.Nested</code> is not a parameterized type, even though it's a member type of a parameterized type <code>MyType&lt;E&gt;</code>, because it's <code>static</code>.</p>
<p><code>mt1</code>, and <code>mt2</code> are both declared with actual type parameters, so they're not raw types.</p>
<hr>
<h2>What's so special about raw types?</h2>
<p>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">List</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// warning: raw type!</span>
names.add(<span class="hljs-string">"John"</span>);
names.add(<span class="hljs-string">"Mary"</span>);
names.add(Boolean.FALSE); <span class="hljs-comment">// not a compilation error!</span>
</code></pre>
<p>The above code runs just fine, but suppose you also have the following:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">for</span> (Object o : names) {
    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) o;
    System.out.println(name);
} <span class="hljs-comment">// throws ClassCastException!</span>
  <span class="hljs-comment">//    java.lang.Boolean cannot be cast to java.lang.String</span>
</code></pre>
<p>Now we run into trouble at run-time, because <code>names</code> contains something that isn't an <code>instanceof String</code>.</p>
<p>Presumably, if you want <code>names</code> to contain only <code>String</code>, you <em>could</em> perhaps still use a raw type and <em>manually check every</em> <code>add</code> yourself, and then <em>manually cast</em> to <code>String</code> every item from <code>names</code>. <strong>Even better</strong>, though is NOT to use a raw type and <em>let the compiler do all the work for you</em>, harnessing the power of Java generics.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
names.add(<span class="hljs-string">"John"</span>);
names.add(<span class="hljs-string">"Mary"</span>);
names.add(Boolean.FALSE); <span class="hljs-comment">// compilation error!</span>
</code></pre>
<p>Of course, if you <em>DO</em> want <code>names</code> to allow a <code>Boolean</code>, then you can declare it as <code>List&lt;Object&gt; names</code>, and the above code would compile.</p>
<h3>See also</h3>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/" rel="noreferrer">Java Tutorials/Generics</a></li>
</ul>
<hr>
<h2>How's a raw type different from using <code>&lt;Object&gt;</code> as type parameters?</h2>
<p>The following is a quote from <em>Effective Java 2nd Edition, Item 23: Don't use raw types in new code</em>:</p>
<blockquote>
<p>Just what is the difference between the raw type <code>List</code> and the parameterized type <code>List&lt;Object&gt;</code>? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a <code>List&lt;String&gt;</code> to a parameter of type <code>List</code>, you can't pass it to a parameter of type <code>List&lt;Object&gt;</code>. There are subtyping rules for generics, and <code>List&lt;String&gt;</code> is a subtype of the raw type <code>List</code>, but not of the parameterized type <code>List&lt;Object&gt;</code>. As a consequence, <strong>you lose type safety if you use raw type like <code>List</code>, but not if you use a parameterized type like <code>List&lt;Object&gt;</code></strong>.</p>
</blockquote>
<p>To illustrate the point, consider the following method which takes a <code>List&lt;Object&gt;</code> and appends a <code>new Object()</code>.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">appendNewObject</span><span class="hljs-params">(List&lt;Object&gt; list)</span> {
   list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());
}
</code></pre>
<p>Generics in Java are invariant. A <code>List&lt;String&gt;</code> is not a <code>List&lt;Object&gt;</code>, so the following would generate a compiler warning:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
appendNewObject(names); <span class="hljs-comment">// compilation error!</span>
</code></pre>
<p>If you had declared <code>appendNewObject</code> to take a raw type <code>List</code> as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</p>
<h3>See also</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2770264/what-is-the-difference-between-e-extends-number-and-number/">What is the difference between <code>&lt;E extends Number&gt;</code> and <code>&lt;Number&gt;</code>?</a></li>
<li><a href="https://stackoverflow.com/questions/2660827/java-generics-covariance">java generics (not) covariance</a></li>
</ul>
<hr>
<h2>How's a raw type different from using <code>&lt;?&gt;</code> as a type parameter?</h2>
<p><code>List&lt;Object&gt;</code>, <code>List&lt;String&gt;</code>, etc are all <code>List&lt;?&gt;</code>, so it may be tempting to just say that they're just <code>List</code> instead. However, there is a major difference: since a <code>List&lt;E&gt;</code> defines only <code>add(E)</code>, you can't add just any arbitrary object to a <code>List&lt;?&gt;</code>. On the other hand, since the raw type <code>List</code> does not have type safety, you can <code>add</code> just about anything to a <code>List</code>.</p>
<p>Consider the following variation of the previous snippet:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendNewObject</span><span class="hljs-params">(List&lt;?&gt; list)</span> {
    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()); <span class="hljs-comment">// compilation error!</span>
}
<span class="hljs-comment">//...</span>

List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
appendNewObject(names); <span class="hljs-comment">// this part is fine!</span>
</code></pre>
<p>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the <code>List&lt;?&gt;</code>! If you had declared the parameter as the raw type <code>List list</code>, then the code would compile, and you'd violate the type invariant of <code>List&lt;String&gt; names</code>.</p>
<hr>
<h2>A raw type is the erasure of that type</h2>
<p>Back to JLS 4.8:</p>
<blockquote>
<p>It is possible to use as a type <strong>the erasure</strong> of a parameterized type or the erasure of an array type whose element type is a parameterized type. <strong>Such a type is called a <em>raw type</em>.</strong></p>
<p><em>[...]</em></p>
<p>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</p>
<p>The type of a constructor, instance method, or non-<code>static</code> field of a raw type <code>C</code> that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to <code>C</code>.</p>
</blockquote>
<p>In simpler terms, when a raw type is used, the constructors, instance methods and non-<code>static</code> fields are <em>also erased</em>.</p>
<p>Take the following example:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyType</span>&lt;E&gt; {
    List&lt;String&gt; <span class="hljs-title function_">getNames</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Mary"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">MyType</span> <span class="hljs-variable">rawType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyType</span>();
        <span class="hljs-comment">// unchecked warning!</span>
        <span class="hljs-comment">// required: List&lt;String&gt; found: List</span>
        List&lt;String&gt; names = rawType.getNames();
        <span class="hljs-comment">// compilation error!</span>
        <span class="hljs-comment">// incompatible types: Object cannot be converted to String</span>
        <span class="hljs-keyword">for</span> (String str : rawType.getNames())
            System.out.print(str);
    }
}
</code></pre>
<p>When we use the raw <code>MyType</code>, <code>getNames</code> becomes erased as well, so that it returns a raw <code>List</code>!</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="noreferrer">JLS 4.6</a> continues to explain the following:</p>
<blockquote>
<p><strong>Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.</strong> The erasure of a constructor or method signature <code>s</code> is a signature consisting of the same name as <code>s</code> and the erasures of all the formal parameter types given in <code>s</code>.</p>
<p><strong>The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.</strong></p>
<p>The erasure of the signature of a generic method has no type parameters.</p>
</blockquote>
<p>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: <a href="https://bugs.openjdk.java.net/browse/JDK-6400189" rel="noreferrer">https://bugs.openjdk.java.net/browse/JDK-6400189</a>. (In short, it makes the specification simpler.)</p>
<hr>
<h2>If it's unsafe, why is it allowed to use a raw type?</h2>
<p>Here's another quote from JLS 4.8:</p>
<blockquote>
<p>The use of raw types is allowed only as a concession to compatibility of legacy code. <em>The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.</em></p>
</blockquote>
<p><em>Effective Java 2nd Edition</em> also has this to add:</p>
<blockquote>
<p>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</p>
<p>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as <em>migration compatibility</em>, drove the decision to support raw types.</p>
</blockquote>
<p>In summary, raw types should NEVER be used in new code. <strong>You should always use parameterized types</strong>.</p>
<hr>
<h2>Are there no exceptions?</h2>
<p>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</p>
<ul>
<li>Class literals, e.g. <code>List.class</code>, not <code>List&lt;String&gt;.class</code></li>
<li><code>instanceof</code> operand, e.g. <code>o instanceof Set</code>, not <code>o instanceof Set&lt;String&gt;</code></li>
</ul>
<h3>See also</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2745193/why-is-collectionstring-class-illegal/">Why is <code>Collection&lt;String&gt;.class</code> Illegal?</a></li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</p>
</blockquote>

<p>Raw-types are ancient history of the Java language. In the beginning there were <code>Collections</code> and they held <code>Objects</code> nothing more and nothing less. Every operation on <code>Collections</code> required casts from <code>Object</code> to the desired type.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">List</span> <span class="hljs-variable">aList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello World!"</span>;
aList.add(s);
<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (String)aList.get(<span class="hljs-number">0</span>);
</code></pre>

<p>While this worked most of the time, errors did happen</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">List</span> <span class="hljs-variable">aNumberList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-type">String</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1"</span>;<span class="hljs-comment">//Number one</span>
aNumberList.add(one);
<span class="hljs-type">Integer</span> <span class="hljs-variable">iOne</span> <span class="hljs-operator">=</span> (Integer)aNumberList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//Insert ClassCastException here</span>
</code></pre>

<p>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.<br>
Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;String&gt; aNumberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
aNumberList.add(<span class="hljs-string">"one"</span>);
<span class="hljs-type">Integer</span> <span class="hljs-variable">iOne</span> <span class="hljs-operator">=</span> aNumberList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//Compile time error</span>
<span class="hljs-type">String</span> <span class="hljs-variable">sOne</span> <span class="hljs-operator">=</span> aNumberList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//works fine</span>
</code></pre>

<p>For Comparison:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// Old style collections now known as raw types</span>
<span class="hljs-type">List</span> <span class="hljs-variable">aList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">//Could contain anything</span>
<span class="hljs-comment">// New style collections with Generics</span>
List&lt;String&gt; aList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//Contains only Strings</span>
</code></pre>

<p>More complex the Compareable interface:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">//raw, not type save can compare with Other classes</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompareAble</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompareAble</span>
{
   <span class="hljs-type">int</span> id;
   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object other)</span>
   {<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id - ((MyCompareAble)other).id;}
}
<span class="hljs-comment">//Generic</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompareAble</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompareAble</span>&lt;MyCompareAble&gt;
{
   <span class="hljs-type">int</span> id;
   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyCompareAble other)</span>
   {<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id - other.id;}
}
</code></pre>

<p>Note that it is impossible to implement the <code>CompareAble</code> interface with <code>compareTo(MyCompareAble)</code> with raw types.
Why you should not use them:</p>

<ul>
<li>Any <code>Object</code> stored in a <code>Collection</code> has to be cast before it can be used</li>
<li>Using generics enables compile time checks</li>
<li>Using raw types is the same as storing each value as <code>Object</code></li>
</ul>

<p>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;String&gt; someStrings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
someStrings.add(<span class="hljs-string">"one"</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> someStrings.get(<span class="hljs-number">0</span>);
</code></pre>

<p>Will be compiled as:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">List</span> <span class="hljs-variable">someStrings</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
someStrings.add(<span class="hljs-string">"one"</span>); 
<span class="hljs-type">String</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> (String)someStrings.get(<span class="hljs-number">0</span>);
</code></pre>

<p>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the <code>CompareAble</code> interface, I guess that it creates two <code>compareTo</code> functions, one taking a <code>MyCompareAble</code> and the other taking an <code>Object</code> and passing it to the first after casting it.</p>

<p>What are the alternatives to raw types: Use <a href="http://java.sun.com/docs/books/tutorial/extra/generics/index.html" rel="noreferrer">generics</a></p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>To create a parameterized type of <code>Box&lt;T&gt;</code>, you supply an actual type argument for the formal type parameter <code>T</code>:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Box&lt;Integer&gt; intBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();
</code></pre>
<p>If the actual type argument is omitted, you create a raw type of <code>Box&lt;T&gt;</code>:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();
</code></pre>
<p>Therefore, <code>Box</code> is the raw type of the generic type <code>Box&lt;T&gt;</code>. However, a non-generic class or interface type is not a raw type.</p>
<p>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior  a <code>Box</code> gives you <code>Object</code>s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();
<span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> stringBox;               <span class="hljs-comment">// OK</span>
</code></pre>
<p>But if you assign a raw type to a parameterized type, you get a warning:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();           <span class="hljs-comment">// rawBox is a raw type of Box&lt;T&gt;</span>
Box&lt;Integer&gt; intBox = rawBox;     <span class="hljs-comment">// warning: unchecked conversion</span>
</code></pre>
<p>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();
<span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> stringBox;
rawBox.set(<span class="hljs-number">8</span>);  <span class="hljs-comment">// warning: unchecked invocation to set(T)</span>
</code></pre>
<p>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</p>
<p>The Type Erasure section has more information on how the Java compiler uses raw types.</p>
<h3>Unchecked Error Messages</h3>
<p>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</p>
<blockquote>
<p>Note: Example.java uses unchecked or unsafe operations.</p>
<p>Note: Recompile with -Xlint:unchecked for details.</p>
</blockquote>
<p>This can happen when using an older API that operates on raw types, as shown in the following example:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarningDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
        Box&lt;Integer&gt; bi;
        bi = createBox();
    }

    <span class="hljs-keyword">static</span> Box <span class="hljs-title function_">createBox</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();
    }
}
</code></pre>
<p>The term "unchecked" means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The "unchecked" warning is disabled, by default, though the compiler gives a hint. To see all "unchecked" warnings, recompile with -Xlint:unchecked.</p>
<p>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">WarningDemo.java:<span class="hljs-number">4</span>: warning: [unchecked] unchecked conversion
found   : Box
required: Box&lt;java.lang.Integer&gt;
        bi = createBox();
                      ^
<span class="hljs-number">1</span> warning
</code></pre>
<p>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The <code>@SuppressWarnings("unchecked")</code> annotation suppresses unchecked warnings. If you are unfamiliar with the <code>@SuppressWarnings</code> syntax, see Annotations.</p>
<p>Original source: <a href="http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="noreferrer">Java Tutorials</a></p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A "raw" type in Java is a class which is non-generic and deals with "raw" Objects, rather than type-safe generic type parameters.</p>

<p>For example, before Java generics was available, you would use a collection class like this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">LinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();
list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());
<span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> (MyObject)list.get(<span class="hljs-number">0</span>);
</code></pre>

<p>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</p>

<p>Using generics, you remove the "unknown" factor, because you must explicitly specify which type of objects can go in the list:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">LinkedList&lt;MyObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;MyObject&gt;();
list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());
<span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);
</code></pre>

<p>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-java s-code-block"><code class="hljs language-java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
</code></pre>

<p>You should specify the type-parameter. </p>

<p>The warning advises that types that are defined to support <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html" rel="noreferrer">generics</a> should be parameterized, rather than using their raw form.</p>

<p><code>List</code> is defined to support generics: <code>public class List&lt;E&gt;</code>. This allows many type-safe operations, that are checked compile-time.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>What is a raw type and why do I often hear that they shouldn't be used in new code?</em></p>

<p>A "raw type" is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using <code>List</code> instead of <code>List&lt;String&gt;</code>. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a "raw type" (without specifying a type argument) allowed legacy code to still compile.</p>

<p>"Raw types" are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</p>

<p><em>What is the alternative if we can't use raw types, and how is it better?</em></p>

<p>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. <code>List&lt;String&gt;</code>). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</p>

<p>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
names.add(<span class="hljs-string">"John"</span>);          <span class="hljs-comment">// OK</span>
names.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>));  <span class="hljs-comment">// compile error</span>
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here I am Considering multiple cases  through which you can clearify  the concept</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-number">1.</span> ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
<span class="hljs-number">2.</span> ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-number">3.</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
</code></pre>

<h2>Case 1</h2>

<p><code>ArrayList&lt;String&gt; arr</code> it is a <code>ArrayList</code> reference variable with type <code>String</code> which reference to a <code>ArralyList</code> Object of Type <code>String</code>. It means it can hold only String type Object.</p>

<p>It is a Strict to <code>String</code> not  a Raw Type so, It will never raise an warning .</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    arr.add(<span class="hljs-string">"hello"</span>);<span class="hljs-comment">// alone statement will compile successfully and no warning.</span>

    arr.add(<span class="hljs-number">23</span>);  <span class="hljs-comment">//prone to compile time error.</span>
     <span class="hljs-comment">//error: no suitable method found for add(int)</span>
</code></pre>

<h2>Case 2</h2>

<p>In this case <code>ArrayList&lt;String&gt; arr</code> is a strict type but your Object <code>new ArrayList();</code> is a raw type. </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    arr.add(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">//alone this compile but raise the warning.</span>
    arr.add(<span class="hljs-number">23</span>);  <span class="hljs-comment">//again prone to compile time error.</span>
    <span class="hljs-comment">//error: no suitable method found for add(int)</span>
</code></pre>

<p>here <code>arr</code> is a Strict type. So, It will raise compile time error when adding a <code>integer</code>.</p>

<blockquote>
  <p><strong>Warning</strong> :- A <code>Raw</code> Type Object is referenced to a <code>Strict</code> type Referenced Variable of <code>ArrayList</code>.</p>
</blockquote>

<h2>Case 3</h2>

<p>In this case <code>ArrayList arr</code> is a raw type but your Object <code>new ArrayList&lt;String&gt;();</code> is a Strict type. </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    arr.add(<span class="hljs-string">"hello"</span>);  
    arr.add(<span class="hljs-number">23</span>);  <span class="hljs-comment">//compiles fine but raise the warning.</span>
</code></pre>

<p>It will add any type of Object into it because <code>arr</code> is a Raw Type.</p>

<blockquote>
  <p><strong>Warning</strong> :- A <code>Strict</code> Type Object is referenced to a <code>raw</code> type referenced Variable.</p>
</blockquote>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The compiler wants you to write this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
</code></pre>

<p>because otherwise, you could add any type you like into <code>list</code>, making the instantiation as <code>new ArrayList&lt;String&gt;()</code> pointless. Java generics are a compile-time feature only, so an object created with <code>new ArrayList&lt;String&gt;()</code> will happily accept <code>Integer</code> or <code>JFrame</code> elements if assigned to a reference of the "raw type" <code>List</code> - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's another case where raw types will bite you:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrangeClass</span>&lt;T&gt; {
  <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
  <span class="hljs-keyword">public</span> &lt;X&gt; X <span class="hljs-title function_">getSomethingElse</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> (X)<span class="hljs-string">"Testing something else!"</span>;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-keyword">final</span> StrangeClass&lt;String&gt; withGeneric    = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrangeClass</span>&lt;&gt;();
    <span class="hljs-keyword">final</span> <span class="hljs-type">StrangeClass</span>         <span class="hljs-variable">withoutGeneric</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrangeClass</span>();
    <span class="hljs-keyword">final</span> String               value1,
                               value2;

    <span class="hljs-comment">// Compiles</span>
    value1 = withGeneric.getSomethingElse();

    <span class="hljs-comment">// Produces compile error:</span>
    <span class="hljs-comment">// incompatible types: java.lang.Object cannot be converted to java.lang.String</span>
    value2 = withoutGeneric.getSomethingElse();
  }
}
</code></pre>
<p>This is counter-intuitive because you'd expect the raw type to only affect methods bound to the class type parameter, but it actually <em>also</em> affects generic methods with their own type parameters.</p>
<p>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just <code>Object</code>).</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A <em>raw</em>-type is the a lack of a <em>type parameter</em> when using a generic type.</p>

<p>Raw-type should not be used because it could cause runtime errors, like inserting a <code>double</code> into what was supposed to be a <code>Set</code> of <code>int</code>s.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();
set.add(<span class="hljs-number">3.45</span>); <span class="hljs-comment">//ok</span>
</code></pre>

<p>When retrieving the stuff from the <code>Set</code>, you don't know what is coming out. Let's assume that you expect it to be all <code>int</code>s, you are casting it to <code>Integer</code>; exception at runtime when the <code>double</code> 3.45 comes along.</p>

<p>With a <em>type parameter</em> added to your <code>Set</code>, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();
set.add(<span class="hljs-number">3.45</span>); <span class="hljs-comment">//NOT ok.</span>
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Avoid raw types.</strong></p>
<p>Raw types refer to using a generic type without specifying a type parameter.</p>
<p>For example:</p>
<p>A <code>list</code> is a raw type, while <code>List&lt;String&gt;</code> is a parameterized type.</p>
<p>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java.</p>
<p>Although using raw types is still possible, they should be avoided:</p>
<ul>
<li>They usually require casts.</li>
<li>They aren't type safe, and some important kinds of errors will only appear at runtime.</li>
<li>They are less expressive, and don't self-document in the same way as parameterized types..</li>
</ul>
<p>Example:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AvoidRawTypes</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withRawType</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//Raw List doesn't self-document, </span>
        <span class="hljs-comment">//doesn't state explicitly what it can contain</span>
        <span class="hljs-type">List</span> <span class="hljs-variable">stars</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-string">"Arcturus"</span>, <span class="hljs-string">"Vega"</span>, <span class="hljs-string">"Altair"</span>);
        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> stars.iterator();
        <span class="hljs-keyword">while</span> (iter.hasNext()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> (String) iter.next(); <span class="hljs-comment">//cast needed</span>
            log(star);
        }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withParameterizedType</span><span class="hljs-params">()</span> {
        List &lt; String &gt; stars = Arrays.asList(<span class="hljs-string">"Spica"</span>, <span class="hljs-string">"Regulus"</span>, <span class="hljs-string">"Antares"</span>);
        <span class="hljs-keyword">for</span> (String star: stars) {
            log(star);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(Object message)</span> {
        System.out.println(Objects.toString(message));
    }
}
 
</code></pre>
<p>For reference: <a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="nofollow noreferrer">https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html</a></p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What is saying is that your <code>list</code> is a <code>List</code> of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</p>

<p>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="nofollow noreferrer">tutorial page</a>.  </p>

<p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:  </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-comment">// ...</span>
}
</code></pre>

<p>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:  </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Box&lt;Integer&gt; intBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();
</code></pre>

<p>If the actual type argument is omitted, you create a raw type of Box:  </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I found this page after doing some sample exercises and having the exact same puzzlement.</p>

<p>============== I went from this code as provide by the sample ===============</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {

    <span class="hljs-type">Map</span> <span class="hljs-variable">wordMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();
    <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) {
            countWord(wordMap, args[i]);
        }
    } <span class="hljs-keyword">else</span> {
        getWordFrequency(System.in, wordMap);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> wordMap.entrySet().iterator(); i.hasNext();) {
        Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) i.next();
        System.out.println(entry.getKey() + <span class="hljs-string">" :\t"</span> + entry.getValue());
    }
</code></pre>

<p>====================== To This code ========================</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// replace with TreeMap to get them sorted by name</span>
    Map&lt;String, Integer&gt; wordMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();
    <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) {
            countWord(wordMap, args[i]);
        }
    } <span class="hljs-keyword">else</span> {
        getWordFrequency(System.in, wordMap);
    }
    <span class="hljs-keyword">for</span> (Iterator&lt;Entry&lt;String, Integer&gt;&gt; i = wordMap.entrySet().iterator(); i.hasNext();) {
        Entry&lt;String, Integer&gt; entry =   i.next();
        System.out.println(entry.getKey() + <span class="hljs-string">" :\t"</span> + entry.getValue());
    }

}
</code></pre>

<p>===============================================================================</p>

<p>It may be safer but took 4  hours to demuddle the philosophy...</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/generics">generics</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/raw-types">raw-types</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Raw types are fine when they express what you want to express.</p>

<p>For example, a deserialisation function might return a <code>List</code>, but it doesn't know the list's element type. So <code>List</code> is the appropriate return type here.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190">How to remove all duplicates from an array of objects?</a><a href="/questions/how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760">How to access a local variable from a different function using pointers?</a><a href="/questions/what-is-the-difference-between-a-definition-and-a-declaration-1657387851618">What is the difference between a definition and a declaration?</a><a href="/questions/how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988">How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?</a><a href="/questions/the-definitive-c-book-guide-and-list-1657384747653">The Definitive C Book Guide and List</a><a href="/questions/how-do-i-use-extern-to-share-variables-between-source-files-1657387453605">How do I use extern to share variables between source files?</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/convert-rows-to-columns-using-&#x27;pivot&#x27;-in-sql-server-1657388372528">Convert Rows to columns using &#x27;Pivot&#x27; in SQL Server</a><a href="/questions/how-do-i-pass-data-between-activities-in-android-application-1657384739839">How do I pass data between Activities in Android application?</a><a href="/questions/should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399">Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?</a><a href="/questions/how-to-fix-%22headers-already-sent%22-error-in-php-1657384315553">How to fix &quot;Headers already sent&quot; error in PHP</a><a href="/questions/how-to-generate-all-permutations-of-a-list-1657388537371">How to generate all permutations of a list</a><a href="/questions/how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720">How do I match any character across multiple lines in a regular expression?</a><a href="/questions/relative-imports-for-the-billionth-time-1657387756383">Relative imports for the billionth time</a><a href="/questions/scroll-to-an-element-with-jquery-1657388523178">Scroll to an element with jQuery</a><a href="/questions/how-do-i-return-the-response-from-an-asynchronous-call-1657384208012">How do I return the response from an asynchronous call?</a><a href="/questions/what-is-the-best-algorithm-for-overriding-gethashcode-1657387848932">What is the best algorithm for overriding GetHashCode?</a><a href="/questions/android-permission-doesn&#x27;t-work-even-if-i-have-declared-it-1657387726990">Android permission doesn&#x27;t work even if I have declared it</a><a href="/questions/what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538">What is the purpose of the var keyword and when should I use it (or omit it)?</a><a href="/questions/how-to-filter-object-array-based-on-attributes-1657388211247">How to filter object array based on attributes?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;What is a raw type?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The Java Language Specification defines a \u0026lt;em\u0026gt;raw type\u0026lt;/em\u0026gt; as follows:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JLS 4.8 Raw Types\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;A raw type is defined to be one of:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;An array type whose element type is a raw type.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A non-\u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; member type of a raw type \u0026lt;code\u0026gt;R\u0026lt;/code\u0026gt; that is not inherited from a superclass or superinterface of \u0026lt;code\u0026gt;R\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s an example to illustrate:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyType\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Inner\u0026lt;/span\u0026gt; { }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Nested\u0026lt;/span\u0026gt; { }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        MyType mt;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning: MyType is a raw type\u0026lt;/span\u0026gt;\n        MyType.Inner inn;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning: MyType.Inner is a raw type\u0026lt;/span\u0026gt;\n\n        MyType.Nested nest; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no warning: not parameterized type\u0026lt;/span\u0026gt;\n        MyType\u0026amp;lt;Object\u0026amp;gt; mt1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no warning: type parameter given\u0026lt;/span\u0026gt;\n        MyType\u0026amp;lt;?\u0026amp;gt; mt2;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no warning: type parameter given (wildcard OK!)\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;MyType\u0026amp;lt;E\u0026amp;gt;\u0026lt;/code\u0026gt; is a \u0026lt;em\u0026gt;parameterized type\u0026lt;/em\u0026gt; (\u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JLS 4.5\u0026lt;/a\u0026gt;). It is common to colloquially refer to this type as simply \u0026lt;code\u0026gt;MyType\u0026lt;/code\u0026gt; for short, but technically the name is \u0026lt;code\u0026gt;MyType\u0026amp;lt;E\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;mt\u0026lt;/code\u0026gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; \u0026lt;code\u0026gt;inn\u0026lt;/code\u0026gt; also has a raw type by the third bullet point.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;MyType.Nested\u0026lt;/code\u0026gt; is not a parameterized type, even though it\u0026apos;s a member type of a parameterized type \u0026lt;code\u0026gt;MyType\u0026amp;lt;E\u0026amp;gt;\u0026lt;/code\u0026gt;, because it\u0026apos;s \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;mt1\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;mt2\u0026lt;/code\u0026gt; are both declared with actual type parameters, so they\u0026apos;re not raw types.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;What\u0026apos;s so special about raw types?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;names\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning: raw type!\u0026lt;/span\u0026gt;\nnames.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);\nnames.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;);\nnames.add(Boolean.FALSE); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not a compilation error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The above code runs just fine, but suppose you also have the following:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Object o : names) {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (String) o;\n    System.out.println(name);\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// throws ClassCastException!\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//    java.lang.Boolean cannot be cast to java.lang.String\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now we run into trouble at run-time, because \u0026lt;code\u0026gt;names\u0026lt;/code\u0026gt; contains something that isn\u0026apos;t an \u0026lt;code\u0026gt;instanceof String\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Presumably, if you want \u0026lt;code\u0026gt;names\u0026lt;/code\u0026gt; to contain only \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;, you \u0026lt;em\u0026gt;could\u0026lt;/em\u0026gt; perhaps still use a raw type and \u0026lt;em\u0026gt;manually check every\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;add\u0026lt;/code\u0026gt; yourself, and then \u0026lt;em\u0026gt;manually cast\u0026lt;/em\u0026gt; to \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; every item from \u0026lt;code\u0026gt;names\u0026lt;/code\u0026gt;. \u0026lt;strong\u0026gt;Even better\u0026lt;/strong\u0026gt;, though is NOT to use a raw type and \u0026lt;em\u0026gt;let the compiler do all the work for you\u0026lt;/em\u0026gt;, harnessing the power of Java generics.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;String\u0026amp;gt; names = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\nnames.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);\nnames.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;);\nnames.add(Boolean.FALSE); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compilation error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Of course, if you \u0026lt;em\u0026gt;DO\u0026lt;/em\u0026gt; want \u0026lt;code\u0026gt;names\u0026lt;/code\u0026gt; to allow a \u0026lt;code\u0026gt;Boolean\u0026lt;/code\u0026gt;, then you can declare it as \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt; names\u0026lt;/code\u0026gt;, and the above code would compile.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;See also\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/tutorial/java/generics/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java Tutorials/Generics\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;How\u0026apos;s a raw type different from using \u0026lt;code\u0026gt;\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt; as type parameters?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The following is a quote from \u0026lt;em\u0026gt;Effective Java 2nd Edition, Item 23: Don\u0026apos;t use raw types in new code\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Just what is the difference between the raw type \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; and the parameterized type \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt; to a parameter of type \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;, you can\u0026apos;t pass it to a parameter of type \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;. There are subtyping rules for generics, and \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt; is a subtype of the raw type \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;, but not of the parameterized type \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;. As a consequence, \u0026lt;strong\u0026gt;you lose type safety if you use raw type like \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;, but not if you use a parameterized type like \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;To illustrate the point, consider the following method which takes a \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt; and appends a \u0026lt;code\u0026gt;new Object()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;appendNewObject\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(List\u0026amp;lt;Object\u0026amp;gt; list)\u0026lt;/span\u0026gt; {\n   list.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Generics in Java are invariant. A \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt; is not a \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;, so the following would generate a compiler warning:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;String\u0026amp;gt; names = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\nappendNewObject(names); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compilation error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you had declared \u0026lt;code\u0026gt;appendNewObject\u0026lt;/code\u0026gt; to take a raw type \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; as parameter, then this would compile, and you\u0026apos;d therefore lose the type safety that you get from generics.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;See also\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2770264/what-is-the-difference-between-e-extends-number-and-number/\u0026quot;\u0026gt;What is the difference between \u0026lt;code\u0026gt;\u0026amp;lt;E extends Number\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;Number\u0026amp;gt;\u0026lt;/code\u0026gt;?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2660827/java-generics-covariance\u0026quot;\u0026gt;java generics (not) covariance\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;How\u0026apos;s a raw type different from using \u0026lt;code\u0026gt;\u0026amp;lt;?\u0026amp;gt;\u0026lt;/code\u0026gt; as a type parameter?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt;, etc are all \u0026lt;code\u0026gt;List\u0026amp;lt;?\u0026amp;gt;\u0026lt;/code\u0026gt;, so it may be tempting to just say that they\u0026apos;re just \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; instead. However, there is a major difference: since a \u0026lt;code\u0026gt;List\u0026amp;lt;E\u0026amp;gt;\u0026lt;/code\u0026gt; defines only \u0026lt;code\u0026gt;add(E)\u0026lt;/code\u0026gt;, you can\u0026apos;t add just any arbitrary object to a \u0026lt;code\u0026gt;List\u0026amp;lt;?\u0026amp;gt;\u0026lt;/code\u0026gt;. On the other hand, since the raw type \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; does not have type safety, you can \u0026lt;code\u0026gt;add\u0026lt;/code\u0026gt; just about anything to a \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Consider the following variation of the previous snippet:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;appendNewObject\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(List\u0026amp;lt;?\u0026amp;gt; list)\u0026lt;/span\u0026gt; {\n    list.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compilation error!\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...\u0026lt;/span\u0026gt;\n\nList\u0026amp;lt;String\u0026amp;gt; names = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\nappendNewObject(names); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this part is fine!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The compiler did a wonderful job of protecting you from potentially violating the type invariance of the \u0026lt;code\u0026gt;List\u0026amp;lt;?\u0026amp;gt;\u0026lt;/code\u0026gt;! If you had declared the parameter as the raw type \u0026lt;code\u0026gt;List list\u0026lt;/code\u0026gt;, then the code would compile, and you\u0026apos;d violate the type invariant of \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt; names\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;A raw type is the erasure of that type\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Back to JLS 4.8:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;It is possible to use as a type \u0026lt;strong\u0026gt;the erasure\u0026lt;/strong\u0026gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. \u0026lt;strong\u0026gt;Such a type is called a \u0026lt;em\u0026gt;raw type\u0026lt;/em\u0026gt;.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;[...]\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The type of a constructor, instance method, or non-\u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; field of a raw type \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In simpler terms, when a raw type is used, the constructors, instance methods and non-\u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; fields are \u0026lt;em\u0026gt;also erased\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Take the following example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyType\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt; {\n    List\u0026amp;lt;String\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getNames\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Arrays.asList(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyType\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawType\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyType\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// unchecked warning!\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// required: List\u0026amp;lt;String\u0026amp;gt; found: List\u0026lt;/span\u0026gt;\n        List\u0026amp;lt;String\u0026amp;gt; names = rawType.getNames();\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compilation error!\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// incompatible types: Object cannot be converted to String\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (String str : rawType.getNames())\n            System.out.print(str);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When we use the raw \u0026lt;code\u0026gt;MyType\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;getNames\u0026lt;/code\u0026gt; becomes erased as well, so that it returns a raw \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JLS 4.6\u0026lt;/a\u0026gt; continues to explain the following:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.\u0026lt;/strong\u0026gt; The erasure of a constructor or method signature \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is a signature consisting of the same name as \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and the erasures of all the formal parameter types given in \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor\u0026apos;s signature is erased.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The erasure of the signature of a generic method has no type parameters.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: \u0026lt;a href=\u0026quot;https://bugs.openjdk.java.net/browse/JDK-6400189\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://bugs.openjdk.java.net/browse/JDK-6400189\u0026lt;/a\u0026gt;. (In short, it makes the specification simpler.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;If it\u0026apos;s unsafe, why is it allowed to use a raw type?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s another quote from JLS 4.8:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The use of raw types is allowed only as a concession to compatibility of legacy code. \u0026lt;em\u0026gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Effective Java 2nd Edition\u0026lt;/em\u0026gt; also has this to add:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Given that you shouldn\u0026apos;t use raw types, why did the language designers allow them? To provide compatibility.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as \u0026lt;em\u0026gt;migration compatibility\u0026lt;/em\u0026gt;, drove the decision to support raw types.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In summary, raw types should NEVER be used in new code. \u0026lt;strong\u0026gt;You should always use parameterized types\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Are there no exceptions?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Class literals, e.g. \u0026lt;code\u0026gt;List.class\u0026lt;/code\u0026gt;, not \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;.class\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;instanceof\u0026lt;/code\u0026gt; operand, e.g. \u0026lt;code\u0026gt;o instanceof Set\u0026lt;/code\u0026gt;, not \u0026lt;code\u0026gt;o instanceof Set\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;See also\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2745193/why-is-collectionstring-class-illegal/\u0026quot;\u0026gt;Why is \u0026lt;code\u0026gt;Collection\u0026amp;lt;String\u0026amp;gt;.class\u0026lt;/code\u0026gt; Illegal?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What are raw types in Java, and why do I often hear that they shouldn\u0026apos;t be used in new code?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Raw-types are ancient history of the Java language. In the beginning there were \u0026lt;code\u0026gt;Collections\u0026lt;/code\u0026gt; and they held \u0026lt;code\u0026gt;Objects\u0026lt;/code\u0026gt; nothing more and nothing less. Every operation on \u0026lt;code\u0026gt;Collections\u0026lt;/code\u0026gt; required casts from \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; to the desired type.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;aList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello World!\u0026quot;\u0026lt;/span\u0026gt;;\naList.add(s);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (String)aList.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While this worked most of the time, errors did happen\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;aNumberList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Number one\u0026lt;/span\u0026gt;\naNumberList.add(one);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;iOne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (Integer)aNumberList.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Insert ClassCastException here\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.\u0026lt;br\u0026gt;\nGenerics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;String\u0026amp;gt; aNumberList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\naNumberList.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;iOne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; aNumberList.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Compile time error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;sOne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; aNumberList.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//works fine\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For Comparison:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Old style collections now known as raw types\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;aList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Could contain anything\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// New style collections with Generics\u0026lt;/span\u0026gt;\nList\u0026amp;lt;String\u0026amp;gt; aList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Contains only Strings\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;More complex the Compareable interface:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//raw, not type save can compare with Other classes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyCompareAble\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CompareAble\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; id;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compareTo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object other)\u0026lt;/span\u0026gt;\n   {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.id - ((MyCompareAble)other).id;}\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Generic\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyCompareAble\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CompareAble\u0026lt;/span\u0026gt;\u0026amp;lt;MyCompareAble\u0026amp;gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; id;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compareTo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(MyCompareAble other)\u0026lt;/span\u0026gt;\n   {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.id - other.id;}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that it is impossible to implement the \u0026lt;code\u0026gt;CompareAble\u0026lt;/code\u0026gt; interface with \u0026lt;code\u0026gt;compareTo(MyCompareAble)\u0026lt;/code\u0026gt; with raw types.\nWhy you should not use them:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Any \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; stored in a \u0026lt;code\u0026gt;Collection\u0026lt;/code\u0026gt; has to be cast before it can be used\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Using generics enables compile time checks\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Using raw types is the same as storing each value as \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;What the compiler does:\nGenerics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;String\u0026amp;gt; someStrings = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\nsomeStrings.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; someStrings.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Will be compiled as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;someStrings\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;();\nsomeStrings.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one\u0026quot;\u0026lt;/span\u0026gt;); \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (String)someStrings.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is the same code you would write if you used the raw types directly. Thought I\u0026apos;m not sure what happens with the \u0026lt;code\u0026gt;CompareAble\u0026lt;/code\u0026gt; interface, I guess that it creates two \u0026lt;code\u0026gt;compareTo\u0026lt;/code\u0026gt; functions, one taking a \u0026lt;code\u0026gt;MyCompareAble\u0026lt;/code\u0026gt; and the other taking an \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; and passing it to the first after casting it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What are the alternatives to raw types: Use \u0026lt;a href=\u0026quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;generics\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T t)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To create a parameterized type of \u0026lt;code\u0026gt;Box\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, you supply an actual type argument for the formal type parameter \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Box\u0026amp;lt;Integer\u0026amp;gt; intBox = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If the actual type argument is omitted, you create a raw type of \u0026lt;code\u0026gt;Box\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawBox\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Therefore, \u0026lt;code\u0026gt;Box\u0026lt;/code\u0026gt; is the raw type of the generic type \u0026lt;code\u0026gt;Box\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;. However, a non-generic class or interface type is not a raw type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior  a \u0026lt;code\u0026gt;Box\u0026lt;/code\u0026gt; gives you \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Box\u0026amp;lt;String\u0026amp;gt; stringBox = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawBox\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; stringBox;               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But if you assign a raw type to a parameterized type, you get a warning:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawBox\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;();           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// rawBox is a raw type of Box\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;\nBox\u0026amp;lt;Integer\u0026amp;gt; intBox = rawBox;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning: unchecked conversion\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Box\u0026amp;lt;String\u0026amp;gt; stringBox = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawBox\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; stringBox;\nrawBox.set(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning: unchecked invocation to set(T)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The Type Erasure section has more information on how the Java compiler uses raw types.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Unchecked Error Messages\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note: Example.java uses unchecked or unsafe operations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note: Recompile with -Xlint:unchecked for details.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This can happen when using an older API that operates on raw types, as shown in the following example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;WarningDemo\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;{\n        Box\u0026amp;lt;Integer\u0026amp;gt; bi;\n        bi = createBox();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Box \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createBox\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The term \u0026quot;unchecked\u0026quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The \u0026quot;unchecked\u0026quot; warning is disabled, by default, though the compiler gives a hint. To see all \u0026quot;unchecked\u0026quot; warnings, recompile with -Xlint:unchecked.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;WarningDemo.java:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: warning: [unchecked] unchecked conversion\nfound   : Box\nrequired: Box\u0026amp;lt;java.lang.Integer\u0026amp;gt;\n        bi = createBox();\n                      ^\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; warning\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The \u0026lt;code\u0026gt;@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\u0026lt;/code\u0026gt; annotation suppresses unchecked warnings. If you are unfamiliar with the \u0026lt;code\u0026gt;@SuppressWarnings\u0026lt;/code\u0026gt; syntax, see Annotations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Original source: \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java Tutorials\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026quot;raw\u0026quot; type in Java is a class which is non-generic and deals with \u0026quot;raw\u0026quot; Objects, rather than type-safe generic type parameters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, before Java generics was available, you would use a collection class like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;();\nlist.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;myObject\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (MyObject)list.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When you add your object to the list, it doesn\u0026apos;t care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using generics, you remove the \u0026quot;unknown\u0026quot; factor, because you must explicitly specify which type of objects can go in the list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;LinkedList\u0026amp;lt;MyObject\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;MyObject\u0026amp;gt;();\nlist.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;myObject\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; list.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice that with generics you don\u0026apos;t have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; List\u0026amp;lt;String\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You should specify the type-parameter. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The warning advises that types that are defined to support \u0026lt;a href=\u0026quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;generics\u0026lt;/a\u0026gt; should be parameterized, rather than using their raw form.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; is defined to support generics: \u0026lt;code\u0026gt;public class List\u0026amp;lt;E\u0026amp;gt;\u0026lt;/code\u0026gt;. This allows many type-safe operations, that are checked compile-time.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;What is a raw type and why do I often hear that they shouldn\u0026apos;t be used in new code?\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A \u0026quot;raw type\u0026quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a \u0026quot;raw type\u0026quot; (without specifying a type argument) allowed legacy code to still compile.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;Raw types\u0026quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;What is the alternative if we can\u0026apos;t use raw types, and how is it better?\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, for a method where the programmer wants to ensure a List variable called \u0026apos;names\u0026apos; contains only Strings:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;String\u0026amp;gt; names = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\nnames.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\nnames.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compile error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here I am Considering multiple cases  through which you can clearify  the concept\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt; ArrayList\u0026amp;lt;String\u0026amp;gt; arr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt; ArrayList\u0026amp;lt;String\u0026amp;gt; arr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;arr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Case 1\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ArrayList\u0026amp;lt;String\u0026amp;gt; arr\u0026lt;/code\u0026gt; it is a \u0026lt;code\u0026gt;ArrayList\u0026lt;/code\u0026gt; reference variable with type \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; which reference to a \u0026lt;code\u0026gt;ArralyList\u0026lt;/code\u0026gt; Object of Type \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;. It means it can hold only String type Object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is a Strict to \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; not  a Raw Type so, It will never raise an warning .\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    arr.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// alone statement will compile successfully and no warning.\u0026lt;/span\u0026gt;\n\n    arr.add(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prone to compile time error.\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error: no suitable method found for add(int)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Case 2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In this case \u0026lt;code\u0026gt;ArrayList\u0026amp;lt;String\u0026amp;gt; arr\u0026lt;/code\u0026gt; is a strict type but your Object \u0026lt;code\u0026gt;new ArrayList();\u0026lt;/code\u0026gt; is a raw type. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    arr.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//alone this compile but raise the warning.\u0026lt;/span\u0026gt;\n    arr.add(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//again prone to compile time error.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error: no suitable method found for add(int)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;here \u0026lt;code\u0026gt;arr\u0026lt;/code\u0026gt; is a Strict type. So, It will raise compile time error when adding a \u0026lt;code\u0026gt;integer\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Warning\u0026lt;/strong\u0026gt; :- A \u0026lt;code\u0026gt;Raw\u0026lt;/code\u0026gt; Type Object is referenced to a \u0026lt;code\u0026gt;Strict\u0026lt;/code\u0026gt; type Referenced Variable of \u0026lt;code\u0026gt;ArrayList\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Case 3\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In this case \u0026lt;code\u0026gt;ArrayList arr\u0026lt;/code\u0026gt; is a raw type but your Object \u0026lt;code\u0026gt;new ArrayList\u0026amp;lt;String\u0026amp;gt;();\u0026lt;/code\u0026gt; is a Strict type. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    arr.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;);  \n    arr.add(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//compiles fine but raise the warning.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It will add any type of Object into it because \u0026lt;code\u0026gt;arr\u0026lt;/code\u0026gt; is a Raw Type.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Warning\u0026lt;/strong\u0026gt; :- A \u0026lt;code\u0026gt;Strict\u0026lt;/code\u0026gt; Type Object is referenced to a \u0026lt;code\u0026gt;raw\u0026lt;/code\u0026gt; type referenced Variable.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The compiler wants you to write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; List\u0026amp;lt;String\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;because otherwise, you could add any type you like into \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;, making the instantiation as \u0026lt;code\u0026gt;new ArrayList\u0026amp;lt;String\u0026amp;gt;()\u0026lt;/code\u0026gt; pointless. Java generics are a compile-time feature only, so an object created with \u0026lt;code\u0026gt;new ArrayList\u0026amp;lt;String\u0026amp;gt;()\u0026lt;/code\u0026gt; will happily accept \u0026lt;code\u0026gt;Integer\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;JFrame\u0026lt;/code\u0026gt; elements if assigned to a reference of the \u0026quot;raw type\u0026quot; \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; - the object itself knows nothing about what types it\u0026apos;s supposed to contain, only the compiler does.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s another case where raw types will bite you:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StrangeClass\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026amp;lt;X\u0026amp;gt; X \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getSomethingElse\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (X)\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Testing something else!\u0026quot;\u0026lt;/span\u0026gt;;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; StrangeClass\u0026amp;lt;String\u0026amp;gt; withGeneric    = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StrangeClass\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StrangeClass\u0026lt;/span\u0026gt;         \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;withoutGeneric\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StrangeClass\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; String               value1,\n                               value2;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiles\u0026lt;/span\u0026gt;\n    value1 = withGeneric.getSomethingElse();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Produces compile error:\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// incompatible types: java.lang.Object cannot be converted to java.lang.String\u0026lt;/span\u0026gt;\n    value2 = withoutGeneric.getSomethingElse();\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is counter-intuitive because you\u0026apos;d expect the raw type to only affect methods bound to the class type parameter, but it actually \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; affects generic methods with their own type parameters.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;raw\u0026lt;/em\u0026gt;-type is the a lack of a \u0026lt;em\u0026gt;type parameter\u0026lt;/em\u0026gt; when using a generic type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Raw-type should not be used because it could cause runtime errors, like inserting a \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; into what was supposed to be a \u0026lt;code\u0026gt;Set\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Set\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashSet\u0026lt;/span\u0026gt;();\nset.add(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.45\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ok\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When retrieving the stuff from the \u0026lt;code\u0026gt;Set\u0026lt;/code\u0026gt;, you don\u0026apos;t know what is coming out. Let\u0026apos;s assume that you expect it to be all \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s, you are casting it to \u0026lt;code\u0026gt;Integer\u0026lt;/code\u0026gt;; exception at runtime when the \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; 3.45 comes along.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With a \u0026lt;em\u0026gt;type parameter\u0026lt;/em\u0026gt; added to your \u0026lt;code\u0026gt;Set\u0026lt;/code\u0026gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Set\u0026amp;lt;Integer\u0026amp;gt; set = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashSet\u0026lt;/span\u0026gt;\u0026amp;lt;Integer\u0026amp;gt;();\nset.add(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.45\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//NOT ok.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Avoid raw types.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Raw types refer to using a generic type without specifying a type parameter.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt; is a raw type, while \u0026lt;code\u0026gt;List\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt; is a parameterized type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Although using raw types is still possible, they should be avoided:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;They usually require casts.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;They aren\u0026apos;t type safe, and some important kinds of errors will only appear at runtime.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;They are less expressive, and don\u0026apos;t self-document in the same way as parameterized types..\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.*;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AvoidRawTypes\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;withRawType\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Raw List doesn\u0026apos;t self-document, \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//doesn\u0026apos;t state explicitly what it can contain\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;stars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Arrays.asList(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Arcturus\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Vega\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Altair\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Iterator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;iter\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; stars.iterator();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (iter.hasNext()) {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;star\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (String) iter.next(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//cast needed\u0026lt;/span\u0026gt;\n            log(star);\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;withParameterizedType\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        List \u0026amp;lt; String \u0026amp;gt; stars = Arrays.asList(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Spica\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Regulus\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Antares\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (String star: stars) {\n            log(star);\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object message)\u0026lt;/span\u0026gt; {\n        System.out.println(Objects.toString(message));\n    }\n}\n \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For reference: \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What is saying is that your \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt; is a \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In general is a better idea to parametrize the collections, so you don\u0026apos;t have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; List\u0026amp;lt;String\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;tutorial page\u0026lt;/a\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T t)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Box\u0026amp;lt;Integer\u0026amp;gt; intBox = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If the actual type argument is omitted, you create a raw type of Box:  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rawBox\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found this page after doing some sample exercises and having the exact same puzzlement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;============== I went from this code as provide by the sample ===============\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throws\u0026lt;/span\u0026gt; IOException {\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Map\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;wordMap\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (args.length \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; args.length; i++) {\n            countWord(wordMap, args[i]);\n        }\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n        getWordFrequency(System.in, wordMap);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Iterator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; wordMap.entrySet().iterator(); i.hasNext();) {\n        Map.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Entry\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;entry\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (Map.Entry) i.next();\n        System.out.println(entry.getKey() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; :\\t\u0026quot;\u0026lt;/span\u0026gt; + entry.getValue());\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;====================== To This code ========================\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throws\u0026lt;/span\u0026gt; IOException {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// replace with TreeMap to get them sorted by name\u0026lt;/span\u0026gt;\n    Map\u0026amp;lt;String, Integer\u0026amp;gt; wordMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (args.length \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; args.length; i++) {\n            countWord(wordMap, args[i]);\n        }\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n        getWordFrequency(System.in, wordMap);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Iterator\u0026amp;lt;Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt; i = wordMap.entrySet().iterator(); i.hasNext();) {\n        Entry\u0026amp;lt;String, Integer\u0026amp;gt; entry =   i.next();\n        System.out.println(entry.getKey() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; :\\t\u0026quot;\u0026lt;/span\u0026gt; + entry.getValue());\n    }\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;===============================================================================\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It may be safer but took 4  hours to demuddle the philosophy...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Raw types are fine when they express what you want to express.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, a deserialisation function might return a \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt;, but it doesn\u0026apos;t know the list\u0026apos;s element type. So \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; is the appropriate return type here.\u0026lt;/p\u0026gt;\n    "],"id":70,"title":"What is a raw type and why shouldn't we use it?","content":"\n                \n\u0026lt;h3\u0026gt;Questions:\u0026lt;/h3\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;What are raw types in Java, and why do I often hear that they shouldn\u0026apos;t be used in new code?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What is the alternative if we can\u0026apos;t use raw types, and how is it better?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079","postType":"QUESTION","createdAt":"2022-07-09T16:34:41.000Z","updatedAt":"2022-07-09T16:34:41.000Z","tags":[{"id":257,"name":"generics","slug":"generics","createdAt":"2022-07-09T16:34:41.000Z","updatedAt":"2022-07-09T16:34:41.000Z","Questions_Tags":{"questionId":70,"tagId":257}},{"id":258,"name":"raw-types","slug":"raw-types","createdAt":"2022-07-09T16:34:41.000Z","updatedAt":"2022-07-09T16:34:41.000Z","Questions_Tags":{"questionId":70,"tagId":258}}],"relatedQuestions":[{"title":"What is a raw type and why shouldn't we use it?","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079","tags":[{"name":"generics","Questions_Tags":{"questionId":70,"tagId":257}},{"name":"raw-types","Questions_Tags":{"questionId":70,"tagId":258}}]}]},"randomQuestions":[{"title":"How to remove all duplicates from an array of objects?","slug":"how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?","slug":"how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988"},{"title":"The Definitive C Book Guide and List","slug":"the-definitive-c-book-guide-and-list-1657384747653"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"Convert Rows to columns using 'Pivot' in SQL Server","slug":"convert-rows-to-columns-using-'pivot'-in-sql-server-1657388372528"},{"title":"How do I pass data between Activities in Android application?","slug":"how-do-i-pass-data-between-activities-in-android-application-1657384739839"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"How to fix \"Headers already sent\" error in PHP","slug":"how-to-fix-\"headers-already-sent\"-error-in-php-1657384315553"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"How do I match any character across multiple lines in a regular expression?","slug":"how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720"},{"title":"Relative imports for the billionth time","slug":"relative-imports-for-the-billionth-time-1657387756383"},{"title":"Scroll to an element with jQuery","slug":"scroll-to-an-element-with-jquery-1657388523178"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"What is the best algorithm for overriding GetHashCode?","slug":"what-is-the-best-algorithm-for-overriding-gethashcode-1657387848932"},{"title":"Android permission doesn't work even if I have declared it","slug":"android-permission-doesn't-work-even-if-i-have-declared-it-1657387726990"},{"title":"What is the purpose of the var keyword and when should I use it (or omit it)?","slug":"what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538"},{"title":"How to filter object array based on attributes?","slug":"how-to-filter-object-array-based-on-attributes-1657388211247"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>