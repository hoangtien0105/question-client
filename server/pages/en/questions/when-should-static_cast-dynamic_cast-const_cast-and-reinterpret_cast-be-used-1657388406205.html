<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205","name":"Questions"}}]}</script><title>When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What are the proper uses of:

static_cast
dynamic_cast
const_cast
reinterpret_cast
(type)value (C-style cast)
type(value) (function-style cast)

How does one decide which to use in which specific cases?
    "/><meta property="og:title" content="When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used? | Solution Checker"/><meta property="og:description" content="What are the proper uses of:

static_cast
dynamic_cast
const_cast
reinterpret_cast
(type)value (C-style cast)
type(value) (function-style cast)

How does one decide which to use in which specific cases?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","text":"What are the proper uses of:\n\nstatic_cast\ndynamic_cast\nconst_cast\nreinterpret_cast\n(type)value (C-style cast)\ntype(value) (function-style cast)\n\nHow does one decide which to use in which specific cases?\n    ","answerCount":10,"upVoteCount":500,"suggestedAnswer":[{"text":"static_cast is the first cast you should attempt to use. It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating static_cast isn&apos;t necessary, but it&apos;s important to note that the T(something) syntax is equivalent to (T)something and should be avoided (more on that later). A T(something, something_else) is safe, however, and guaranteed to call the constructor.\n\nstatic_cast can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn&apos;t cast through virtual inheritance. It does not do checking, however, and it is undefined behavior to static_cast down a hierarchy to a type that isn&apos;t actually the type of the object.\n\n\n\nconst_cast can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even reinterpret_cast). It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn&apos;t declared with const, it is safe. This can be useful when overloading member functions based on const, for instance. It can also be used to add const to an object, such as to call a member function overload.\n\nconst_cast also works similarly on volatile, though that&apos;s less common.\n\n\n\ndynamic_cast is exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards  you can cast sideways or even up another chain. The dynamic_cast will seek out the desired object and return it if possible. If it can&apos;t, it will return nullptr in the case of a pointer, or throw std::bad_cast in the case of a reference.\n\ndynamic_cast has some limitations, though. It doesn&apos;t work if there are multiple objects of the same type in the inheritance hierarchy (the so-called &apos;dreaded diamond&apos;) and you aren&apos;t using virtual inheritance. It also can only go through public inheritance - it will always fail to travel through protected or private inheritance. This is rarely an issue, however, as such forms of inheritance are rare.\n\n\n\nreinterpret_cast is the most dangerous cast, and should be used very sparingly. It turns one type directly into another  such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things. Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type). There are a number of conversions that reinterpret_cast cannot do, too. It&apos;s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of a pointer to aligned data.\n\n\n\nC-style cast and function-style cast are casts using (type)object or type(object), respectively, and are functionally equivalent. They are defined as the first of the following which succeeds:\n\n\nconst_cast\nstatic_cast (though ignoring access restrictions)\nstatic_cast (see above), then const_cast\nreinterpret_cast\nreinterpret_cast, then const_cast\n\n\nIt can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a reinterpret_cast, and the latter should be preferred when explicit casting is needed, unless you are sure static_cast will succeed or reinterpret_cast will fail. Even then, consider the longer, more explicit option.\n\nC-style casts also ignore access control when performing a static_cast, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"\nUse dynamic_cast for converting pointers/references within an inheritance hierarchy.\n\nUse static_cast for ordinary type conversions.\n\nUse reinterpret_cast for low-level reinterpreting of bit patterns.  Use with extreme caution.\n\nUse const_cast for casting away const/volatile.  Avoid this unless you are stuck using a const-incorrect API.\n\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"(A lot of theoretical and conceptual explanation has been given above) \n\nBelow are some of the practical examples when I used static_cast, dynamic_cast, const_cast, reinterpret_cast.\n\n(Also referes this to understand the explaination : http://www.cplusplus.com/doc/tutorial/typecasting/)\n\nstatic_cast :\n\nOnEventData(void* pData)\n\n{\n  ......\n\n  //  pData is a void* pData, \n\n  //  EventData is a structure e.g. \n  //  typedef struct _EventData {\n  //  std::string id;\n  //  std:: string remote_id;\n  //  } EventData;\n\n  // On Some Situation a void pointer *pData\n  // has been static_casted as \n  // EventData* pointer \n\n  EventData *evtdata = static_cast&lt;EventData*&gt;(pData);\n  .....\n}\n\n\ndynamic_cast :\n\nvoid DebugLog::OnMessage(Message *msg)\n{\n    static DebugMsgData *debug;\n    static XYZMsgData *xyz;\n\n    if(debug = dynamic_cast&lt;DebugMsgData*&gt;(msg-&gt;pdata)){\n        // debug message\n    }\n    else if(xyz = dynamic_cast&lt;XYZMsgData*&gt;(msg-&gt;pdata)){\n        // xyz message\n    }\n    else/* if( ... )*/{\n        // ...\n    }\n}\n\n\nconst_cast :\n\n// *Passwd declared as a const\n\nconst unsigned char *Passwd\n\n\n// on some situation it require to remove its constness\n\nconst_cast&lt;unsigned char*&gt;(Passwd)\n\n\nreinterpret_cast :\n\ntypedef unsigned short uint16;\n\n// Read Bytes returns that 2 bytes got read. \n\nbool ByteBuffer::ReadUInt16(uint16&amp; val) {\n  return ReadBytes(reinterpret_cast&lt;char*&gt;(&amp;val), 2);\n}\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"It might help if you know little bit of internals...\nstatic_cast\n\nC++ compiler already knows how to convert between scaler types such as float to int. Use static_cast for them.\nWhen you ask compiler to convert from type A to B, static_cast calls B&apos;s constructor passing A as param. Alternatively, A could have a conversion operator (i.e. A::operator B()).  If B doesn&apos;t have such constructor, or A doesn&apos;t have a conversion operator, then you get compile time error.\nCast from A* to B* always succeeds if A and B are in inheritance hierarchy (or void) otherwise you get compile error.\nGotcha: If you cast base pointer to derived pointer but if actual object is not really derived type then you don&apos;t get error. You get bad pointer and  very likely a segfault at runtime. Same goes for A&amp; to B&amp;.\nGotcha: Cast from Derived to Base or viceversa creates new copy! For people coming from C#/Java, this can be a huge surprise because the result is basically a chopped off object created from Derived.\n\ndynamic_cast\n\ndynamic_cast uses runtime type information to figure out if cast is valid. For example, (Base*) to (Derived*) may fail if pointer is not actually of derived type.\nThis means, dynamic_cast is very expensive compared to static_cast!\nFor A* to B*, if cast is invalid then dynamic_cast will return nullptr.\nFor A&amp; to B&amp; if cast is invalid then dynamic_cast will throw bad_cast exception.\nUnlike other casts, there is runtime overhead.\n\nconst_cast\n\nWhile static_cast can do non-const to const it can&apos;t go other way around. The const_cast can do both ways.\nOne example where this comes handy is iterating through some container like set&lt;T&gt; which only returns its elements as const to make sure you don&apos;t change its key. However if your intent is to modify object&apos;s non-key members then it should be ok. You can use const_cast to remove constness.\nAnother example is when you want to implement T&amp; SomeClass::foo() as well as const T&amp; SomeClass::foo() const. To avoid code duplication, you can apply const_cast to return value of one function from another.\n\nreinterpret_cast\n\nThis basically says that take these bytes at this memory location and think of it as given object.\nFor example, you can load 4 bytes of float to 4 bytes of int to see how bits in float looks like.\nObviously, if data is not correct for the type, you may get segfault.\nThere is no runtime overhead for this cast.\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Does this answer your question?\n\nI have never used reinterpret_cast, and wonder whether running into a case that needs it isn&apos;t a smell of bad design. In the code base I work on dynamic_cast is used a lot. The difference with  static_cast is that a dynamic_cast does runtime checking which may (safer) or may not (more overhead) be what you want (see msdn).\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In addition to the other answers so far, here is unobvious example where static_cast is not sufficient so that reinterpret_cast is needed. Suppose there is a function which in an output parameter returns pointers to objects of different classes (which do not share a common base class). A real example of such function is CoCreateInstance() (see the last parameter, which is in fact void**). Suppose you request particular class of object from this function, so you know in advance the type for the pointer (which you often do for COM objects). In this case you cannot cast pointer to your pointer into void** with static_cast: you need reinterpret_cast&lt;void**&gt;(&amp;yourPointer). \n\nIn code:\n\n#include &lt;windows.h&gt;\n#include &lt;netfw.h&gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = nullptr;\nHRESULT hr = CoCreateInstance(__uuidof(NetFwPolicy2), nullptr,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    //static_cast&lt;void**&gt;(&amp;pNetFwPolicy2) would give a compile error\n    reinterpret_cast&lt;void**&gt;(&amp;pNetFwPolicy2) );\n\n\nHowever, static_cast works for simple pointers (not pointers to pointers), so the above code can be rewritten to avoid reinterpret_cast (at a price of an extra variable) in the following way:\n\n#include &lt;windows.h&gt;\n#include &lt;netfw.h&gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = nullptr;\nvoid* tmp = nullptr;\nHRESULT hr = CoCreateInstance(__uuidof(NetFwPolicy2), nullptr,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    &amp;tmp );\npNetFwPolicy2 = static_cast&lt;INetFwPolicy2*&gt;(tmp);\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"static_cast vs dynamic_cast vs reinterpret_cast internals view on a downcast/upcast\nIn this answer, I want to compare these three mechanisms on a concrete upcast/downcast example and analyze what happens to the underlying pointers/memory/assembly to give a concrete understanding of how they compare.\nI believe that this will give a good intuition on how those casts are different:\n\nstatic_cast: does one address offset at runtime (low runtime impact) and no safety checks that a downcast is correct.\n\ndyanamic_cast: does the same address offset at runtime like static_cast, but also and an expensive safety check that a downcast is correct using RTTI.\nThis safety check allows you to query if a base class pointer is of a given type at runtime by checking a return of nullptr which indicates an invalid downcast.\nTherefore, if your code is not able to check for that nullptr and take a valid non-abort action, you should just use static_cast instead of dynamic cast.\nIf an abort is the only action your code can take, maybe you only want to enable the dynamic_cast in debug builds (-NDEBUG), and use static_cast otherwise, e.g. as done here, to not slow down your fast runs.\n\nreinterpret_cast: does nothing at runtime, not even the address offset. The pointer must point exactly to the correct type, not even a base class works. You generally don&apos;t want this unless raw byte streams are involved.\n\n\nConsider the following code example:\nmain.cpp\n#include &lt;iostream&gt;\n\nstruct B1 {\n    B1(int int_in_b1) : int_in_b1(int_in_b1) {}\n    virtual ~B1() {}\n    void f0() {}\n    virtual int f1() { return 1; }\n    int int_in_b1;\n};\n\nstruct B2 {\n    B2(int int_in_b2) : int_in_b2(int_in_b2) {}\n    virtual ~B2() {}\n    virtual int f2() { return 2; }\n    int int_in_b2;\n};\n\nstruct D : public B1, public B2 {\n    D(int int_in_b1, int int_in_b2, int int_in_d)\n        : B1(int_in_b1), B2(int_in_b2), int_in_d(int_in_d) {}\n    void d() {}\n    int f2() { return 3; }\n    int int_in_d;\n};\n\nint main() {\n    B2 *b2s[2];\n    B2 b2{11};\n    D *dp;\n    D d{1, 2, 3};\n\n    // The memory layout must support the virtual method call use case.\n    b2s[0] = &amp;b2;\n    // An upcast is an implicit static_cast&lt;&gt;().\n    b2s[1] = &amp;d;\n    std::cout &lt;&lt; &quot;&amp;d           &quot; &lt;&lt; &amp;d           &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;b2s[0]       &quot; &lt;&lt; b2s[0]       &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;b2s[1]       &quot; &lt;&lt; b2s[1]       &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;b2s[0]-&gt;f2() &quot; &lt;&lt; b2s[0]-&gt;f2() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;b2s[1]-&gt;f2() &quot; &lt;&lt; b2s[1]-&gt;f2() &lt;&lt; std::endl;\n\n    // Now for some downcasts.\n\n    // Cannot be done implicitly\n    // error: invalid conversion from B2* to D* [-fpermissive]\n    // dp = (b2s[0]);\n\n    // Undefined behaviour to an unrelated memory address because this is a B2, not D.\n    dp = static_cast&lt;D*&gt;(b2s[0]);\n    std::cout &lt;&lt; &quot;static_cast&lt;D*&gt;(b2s[0])            &quot; &lt;&lt; dp           &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;static_cast&lt;D*&gt;(b2s[0])-&gt;int_in_d  &quot; &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;\n\n    // OK\n    dp = static_cast&lt;D*&gt;(b2s[1]);\n    std::cout &lt;&lt; &quot;static_cast&lt;D*&gt;(b2s[1])            &quot; &lt;&lt; dp           &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;static_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d  &quot; &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;\n\n    // Segfault because dp is nullptr.\n    dp = dynamic_cast&lt;D*&gt;(b2s[0]);\n    std::cout &lt;&lt; &quot;dynamic_cast&lt;D*&gt;(b2s[0])           &quot; &lt;&lt; dp           &lt;&lt; std::endl;\n    //std::cout &lt;&lt; &quot;dynamic_cast&lt;D*&gt;(b2s[0])-&gt;int_in_d &quot; &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;\n\n    // OK\n    dp = dynamic_cast&lt;D*&gt;(b2s[1]);\n    std::cout &lt;&lt; &quot;dynamic_cast&lt;D*&gt;(b2s[1])           &quot; &lt;&lt; dp           &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;dynamic_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d &quot; &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;\n\n    // Undefined behaviour to an unrelated memory address because this\n    // did not calculate the offset to get from B2* to D*.\n    dp = reinterpret_cast&lt;D*&gt;(b2s[1]);\n    std::cout &lt;&lt; &quot;reinterpret_cast&lt;D*&gt;(b2s[1])           &quot; &lt;&lt; dp           &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;reinterpret_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d &quot; &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;\n}\n\n\nCompile, run and disassemble with:\ng++ -ggdb3 -O0 -std=c++11 -Wall -Wextra -pedantic -o main.out main.cpp\nsetarch `uname -m` -R ./main.out\ngdb -batch -ex &quot;disassemble/rs main&quot; main.out\n\nwhere setarch is used to disable ASLR to make it easier to compare runs.\nPossible output:\n&amp;d           0x7fffffffc930\nb2s[0]       0x7fffffffc920\nb2s[1]       0x7fffffffc940\nb2s[0]-&gt;f2() 2\nb2s[1]-&gt;f2() 3\nstatic_cast&lt;D*&gt;(b2s[0])            0x7fffffffc910\nstatic_cast&lt;D*&gt;(b2s[0])-&gt;int_in_d  1\nstatic_cast&lt;D*&gt;(b2s[1])            0x7fffffffc930\nstatic_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d  3\ndynamic_cast&lt;D*&gt;(b2s[0])           0\ndynamic_cast&lt;D*&gt;(b2s[1])           0x7fffffffc930\ndynamic_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d 3\nreinterpret_cast&lt;D*&gt;(b2s[1])           0x7fffffffc940\nreinterpret_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d 32767\n\nNow, as mentioned at: https://en.wikipedia.org/wiki/Virtual_method_table in order to support the virtual method calls efficiently, supposing that the memory data structures of B1 is of form:\nB1:\n  +0: pointer to virtual method table of B1\n  +4: value of int_in_b1\n\nand B2 is of form:\nB2:\n  +0: pointer to virtual method table of B2\n  +4: value of int_in_b2\n\nthen memory data structure of D has to look something like:\nD:\n  +0: pointer to virtual method table of D (for B1)\n  +4: value of int_in_b1\n  +8: pointer to virtual method table of D (for B2)\n +12: value of int_in_b2\n +16: value of int_in_d\n\nThe key fact is that the memory data structure of D contains inside it memory structure identical to that of B1 and B2, i.e.:\n\n+0 looks exactly like a B1, with the B1 vtable for D followed by int_in_b1\n+8 looks exactly like a B2, with the B2 vtable for D followed by int_in_b2\n\nTherefore we reach the critical conclusion:\n\nan upcast or downcast only needs to shift the pointer value by a value known at compile time\n\nThis way, when D gets passed to the base type array, the type cast actually calculates that offset and points something that looks exactly like a valid B2 in memory, except that this one has the vtable for D instead of B2, and therefore all virtual calls work transparently.\nE.g.:\nb2s[1] = &amp;d;\n\nsimply needs to get the address of d + 8 to reach the corresponding B2-like data structure.\nNow, we can finally get back to type casting and the analysis of our concrete example.\nFrom the stdout output we see:\n&amp;d           0x7fffffffc930\nb2s[1]       0x7fffffffc940\n\nTherefore, the implicit static_cast done there did correctly calculate the offset from the full D data structure at 0x7fffffffc930 to the B2 like one which is at 0x7fffffffc940. We also infer that what lies between 0x7fffffffc930 and 0x7fffffffc940 is likely be the B1 data and vtable.\nThen, on the downcast sections, it is now easy to understand how the invalid ones fail and why:\n\nstatic_cast&lt;D*&gt;(b2s[0])            0x7fffffffc910: the compiler just went up 0x10 at compile time bytes to try and go from a B2 to the containing D\nBut because b2s[0] was not a D, it now points to an undefined memory region.\nThe disassembly is:\n49          dp = static_cast&lt;D*&gt;(b2s[0]);\n   0x0000000000000fc8 &lt;+414&gt;:   48 8b 45 d0     mov    -0x30(%rbp),%rax\n   0x0000000000000fcc &lt;+418&gt;:   48 85 c0        test   %rax,%rax\n   0x0000000000000fcf &lt;+421&gt;:   74 0a   je     0xfdb &lt;main()+433&gt;\n   0x0000000000000fd1 &lt;+423&gt;:   48 8b 45 d0     mov    -0x30(%rbp),%rax\n   0x0000000000000fd5 &lt;+427&gt;:   48 83 e8 10     sub    $0x10,%rax\n   0x0000000000000fd9 &lt;+431&gt;:   eb 05   jmp    0xfe0 &lt;main()+438&gt;\n   0x0000000000000fdb &lt;+433&gt;:   b8 00 00 00 00  mov    $0x0,%eax\n   0x0000000000000fe0 &lt;+438&gt;:   48 89 45 98     mov    %rax,-0x68(%rbp)\n\nso we see that GCC does:\n\ncheck if pointer is NULL, and if yes return NULL\notherwise, subtract 0x10 from it to reach the D which does not exist\n\n\ndynamic_cast&lt;D*&gt;(b2s[0])           0: C++ actually found that the cast was invalid and returned nullptr!\nThere is no way this can be done at compile time, and we will confirm that from the disassembly:\n59          dp = dynamic_cast&lt;D*&gt;(b2s[0]);\n   0x00000000000010ec &lt;+706&gt;:   48 8b 45 d0     mov    -0x30(%rbp),%rax\n   0x00000000000010f0 &lt;+710&gt;:   48 85 c0        test   %rax,%rax\n   0x00000000000010f3 &lt;+713&gt;:   74 1d   je     0x1112 &lt;main()+744&gt;\n   0x00000000000010f5 &lt;+715&gt;:   b9 10 00 00 00  mov    $0x10,%ecx\n   0x00000000000010fa &lt;+720&gt;:   48 8d 15 f7 0b 20 00    lea    0x200bf7(%rip),%rdx        # 0x201cf8 &lt;_ZTI1D&gt;\n   0x0000000000001101 &lt;+727&gt;:   48 8d 35 28 0c 20 00    lea    0x200c28(%rip),%rsi        # 0x201d30 &lt;_ZTI2B2&gt;\n   0x0000000000001108 &lt;+734&gt;:   48 89 c7        mov    %rax,%rdi\n   0x000000000000110b &lt;+737&gt;:   e8 c0 fb ff ff  callq  0xcd0 &lt;__dynamic_cast@plt&gt;\n   0x0000000000001110 &lt;+742&gt;:   eb 05   jmp    0x1117 &lt;main()+749&gt;\n   0x0000000000001112 &lt;+744&gt;:   b8 00 00 00 00  mov    $0x0,%eax\n   0x0000000000001117 &lt;+749&gt;:   48 89 45 98     mov    %rax,-0x68(%rbp)\n\nFirst there is a NULL check, and it returns NULL if th einput is NULL.\nOtherwise, it sets up some arguments in the RDX, RSI and RDI and calls __dynamic_cast.\nI don&apos;t have the patience to analyze this further now, but as others said, the only way for this to work is for __dynamic_cast to access some extra RTTI in-memory data structures that represent the class hierarchy.\nIt must therefore start from the B2 entry for that table, then walk this class hierarchy until it finds that the vtable for a D typecast from b2s[0].\nThis is why dynamic cast is potentially expensive! Here is an example where a one liner patch converting a dynamic_cast to a static_cast in a complex project reduced runtime by 33%!.\n\nreinterpret_cast&lt;D*&gt;(b2s[1])           0x7fffffffc940 this one just believes us blindly: we said there is a D at address b2s[1], and the compiler does no offset calculations.\nBut this is wrong, because D is actually at 0x7fffffffc930, what is at 0x7fffffffc940 is the B2-like structure inside D! So trash gets accessed.\nWe can confirm this from the horrendous -O0 assembly that just moves the value around:\n70          dp = reinterpret_cast&lt;D*&gt;(b2s[1]);\n   0x00000000000011fa &lt;+976&gt;:   48 8b 45 d8     mov    -0x28(%rbp),%rax\n   0x00000000000011fe &lt;+980&gt;:   48 89 45 98     mov    %rax,-0x68(%rbp)\n\n\n\nRelated questions:\n\nWhen should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?\nHow is dynamic_cast implemented\nDowncasting using the &apos;static_cast&apos; in C++\n\nTested on Ubuntu 18.04 amd64, GCC 7.4.0.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"While other answers nicely described all differences between C++ casts, I would like to add a short note why you should not use C-style casts (Type) var and Type(var).\n\nFor C++ beginners C-style casts look like being the superset operation over C++ casts (static_cast&lt;&gt;(), dynamic_cast&lt;&gt;(), const_cast&lt;&gt;(), reinterpret_cast&lt;&gt;()) and someone could prefer them over the C++ casts. In fact C-style cast is the superset and shorter to write.\n\nThe main problem of C-style casts is that they hide developer real intention of the cast. The C-style casts can do virtually all types of casting from normally safe casts done by static_cast&lt;&gt;() and dynamic_cast&lt;&gt;() to potentially dangerous casts like const_cast&lt;&gt;(), where const modifier can be removed so the const variables can be modified and reinterpret_cast&lt;&gt;() that can even reinterpret integer values to pointers.\n\nHere is the sample.\n\nint a=rand(); // Random number.\n\nint* pa1=reinterpret_cast&lt;int*&gt;(a); // OK. Here developer clearly expressed he wanted to do this potentially dangerous operation.\n\nint* pa2=static_cast&lt;int*&gt;(a); // Compiler error.\nint* pa3=dynamic_cast&lt;int*&gt;(a); // Compiler error.\n\nint* pa4=(int*) a; // OK. C-style cast can do such cast. The question is if it was intentional or developer just did some typo.\n\n*pa4=5; // Program crashes.\n\n\nThe main reason why C++ casts were added to the language was to allow a developer to clarify his intentions - why he is going to do that cast. By using C-style casts which are perfectly valid in C++ you are making your code less readable and more error prone especially for other developers who didn&apos;t create your code. So to make your code more readable and explicit you should always prefer C++ casts over C-style casts.\n\nHere is a short quote from Bjarne Stroustrup&apos;s (the author of C++) book The C++ Programming Language 4th edition - page 302.\n\n\n  This C-style cast is far more dangerous than the named conversion operators\n  because the notation is harder to spot in a large program and the kind of conversion intended by the programmer is not explicit.\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"To understand, let&apos;s consider below code snippet:\n\nstruct Foo{};\nstruct Bar{};\n\nint main(int argc, char** argv)\n{\n    Foo* f = new Foo;\n\n    Bar* b1 = f;                              // (1)\n    Bar* b2 = static_cast&lt;Bar*&gt;(f);           // (2)\n    Bar* b3 = dynamic_cast&lt;Bar*&gt;(f);          // (3)\n    Bar* b4 = reinterpret_cast&lt;Bar*&gt;(f);      // (4)\n    Bar* b5 = const_cast&lt;Bar*&gt;(f);            // (5)\n\n    return 0;\n}\n\n\nOnly line (4) compiles without error. Only reinterpret_cast can be used to convert a pointer to an object to a pointer to an any unrelated object type.\n\nOne this to be noted is: The dynamic_cast would fail at run-time, however on most compilers it will also fail to compile because there are no virtual functions in the struct of the pointer being casted, meaning dynamic_cast will work with only polymorphic class pointers.\n\nWhen to use C++ cast:\n\n\nUse static_cast as the equivalent of a C-style cast that does value conversion, or when we need to explicitly up-cast a pointer from a class to its superclass.\nUse const_cast to remove the const qualifier.  \nUse reinterpret_cast to do unsafe conversions of pointer types to and from integer and other pointer types. Use this only if we know what we are doing and we understand the aliasing issues.\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Nice feature of reinterpret_cast, not mentioned in the other answers, is that it allows us to create a sort of void* pointer for function types. Normally, for object types one uses static_cast to retrieve the original type of a pointer stored in void*:\n  int i = 13;\n  void *p = &amp;i;\n  auto *pi = static_cast&lt;int*&gt;(p);\n\nFor functions, we must use reinterpret_cast twice:\n#include&lt;iostream&gt;\n\nusing any_fcn_ptr_t = void(*)();\n\n\nvoid print(int i)\n{\n   std::cout &lt;&lt; i &lt;&lt;std::endl;\n}\n\nint main()\n{     \n  //Create type-erased pointer to function:\n  auto any_ptr = reinterpret_cast&lt;any_fcn_ptr_t&gt;(&amp;print);\n  \n  //Retrieve the original pointer:\n  auto ptr = reinterpret_cast&lt; void(*)(int) &gt;(any_ptr);\n  \n  ptr(7);\n}\n\nWith reinterpret_cast we can even get a similar sort-of-void* pointer for pointers to member functions.\nAs with plain void* and static_cast, C++ guarantees that ptr points to print function (as long as we pass the correct type to reinterpret_cast).\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-260362324a06d105.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_buildManifest.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"><h1>When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>What are the proper uses of:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/static_cast" rel="nofollow noreferrer"><code>static_cast</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/dynamic_cast" rel="nofollow noreferrer"><code>dynamic_cast</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/const_cast" rel="nofollow noreferrer"><code>const_cast</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast" rel="nofollow noreferrer"><code>reinterpret_cast</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/explicit_cast" rel="nofollow noreferrer"><code>(type)value</code></a> (C-style cast)</li>
<li><a href="https://en.cppreference.com/w/cpp/language/explicit_cast" rel="nofollow noreferrer"><code>type(value)</code></a> (function-style cast)</li>
</ul>
<p>How does one decide which to use in which specific cases?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><code>static_cast</code></strong> is the first cast you should attempt to use. It does things like implicit conversions between types (such as <code>int</code> to <code>float</code>, or pointer to <code>void*</code>), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating <code>static_cast</code> isn't necessary, but it's important to note that the <code>T(something)</code> syntax is equivalent to <code>(T)something</code> and should be avoided (more on that later). A <code>T(something, something_else)</code> is safe, however, and guaranteed to call the constructor.</p>

<p><code>static_cast</code> can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn't cast through <code>virtual</code> inheritance. It does not do checking, however, and it is undefined behavior to <code>static_cast</code> down a hierarchy to a type that isn't actually the type of the object.</p>

<hr>

<p><strong><code>const_cast</code></strong> can be used to remove or add <code>const</code> to a variable; no other C++ cast is capable of removing it (not even <code>reinterpret_cast</code>). It is important to note that modifying a formerly <code>const</code> value is only undefined if the original variable is <code>const</code>; if you use it to take the <code>const</code> off a reference to something that wasn't declared with <code>const</code>, it is safe. This can be useful when overloading member functions based on <code>const</code>, for instance. It can also be used to add <code>const</code> to an object, such as to call a member function overload.</p>

<p><code>const_cast</code> also works similarly on <code>volatile</code>, though that's less common.</p>

<hr>

<p><strong><code>dynamic_cast</code></strong> is exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards  you can cast sideways or even up another chain. The <code>dynamic_cast</code> will seek out the desired object and return it if possible. If it can't, it will return <code>nullptr</code> in the case of a pointer, or throw <code>std::bad_cast</code> in the case of a reference.</p>

<p><code>dynamic_cast</code> has some limitations, though. It doesn't work if there are multiple objects of the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using <code>virtual</code> inheritance. It also can only go through public inheritance - it will always fail to travel through <code>protected</code> or <code>private</code> inheritance. This is rarely an issue, however, as such forms of inheritance are rare.</p>

<hr>

<p><strong><code>reinterpret_cast</code></strong> is the most dangerous cast, and should be used very sparingly. It turns one type directly into another  such as casting the value from one pointer to another, or storing a pointer in an <code>int</code>, or all sorts of other nasty things. Largely, the only guarantee you get with <code>reinterpret_cast</code> is that normally if you cast the result back to the original type, you will get the exact same value (but <strong><em>not</em></strong> if the intermediate type is smaller than the original type). There are a number of conversions that <strong><code>reinterpret_cast</code></strong> cannot do, too. It's used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of a pointer to aligned data.</p>

<hr>

<p><strong>C-style cast</strong> and <strong>function-style cast</strong> are casts using <code>(type)object</code> or <code>type(object)</code>, respectively, and are functionally equivalent. They are defined as the first of the following which succeeds:</p>

<ul>
<li><code>const_cast</code></li>
<li><code>static_cast</code> (though ignoring access restrictions)</li>
<li><code>static_cast</code> (see above), then <code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>reinterpret_cast</code>, then <code>const_cast</code></li>
</ul>

<p>It can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a <code>reinterpret_cast</code>, and the latter should be preferred when explicit casting is needed, unless you are sure <code>static_cast</code> will succeed or <code>reinterpret_cast</code> will fail. Even then, consider the longer, more explicit option.</p>

<p>C-style casts also ignore access control when performing a <code>static_cast</code>, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ul>
<li><p>Use <code>dynamic_cast</code> for converting pointers/references within an inheritance hierarchy.</p>
</li>
<li><p>Use <code>static_cast</code> for ordinary type conversions.</p>
</li>
<li><p>Use <code>reinterpret_cast</code> for low-level reinterpreting of bit patterns.  Use with extreme caution.</p>
</li>
<li><p>Use <code>const_cast</code> for casting away <code>const/volatile</code>.  Avoid this unless you are stuck using a const-incorrect API.</p>
</li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>(A lot of theoretical and conceptual explanation has been given above)</em> </p>

<p>Below are some of the <strong>practical examples</strong> when I used <strong>static_cast</strong>, <strong>dynamic_cast</strong>, <strong>const_cast</strong>, <strong>reinterpret_cast</strong>.</p>

<p>(Also referes this to understand the explaination : <a href="http://www.cplusplus.com/doc/tutorial/typecasting/" rel="noreferrer">http://www.cplusplus.com/doc/tutorial/typecasting/</a>)</p>

<p><strong>static_cast :</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">OnEventData</span>(<span class="hljs-type">void</span>* pData)

{
  ......

  <span class="hljs-comment">//  pData is a void* pData, </span>

  <span class="hljs-comment">//  EventData is a structure e.g. </span>
  <span class="hljs-comment">//  typedef struct _EventData {</span>
  <span class="hljs-comment">//  std::string id;</span>
  <span class="hljs-comment">//  std:: string remote_id;</span>
  <span class="hljs-comment">//  } EventData;</span>

  <span class="hljs-comment">// On Some Situation a void pointer *pData</span>
  <span class="hljs-comment">// has been static_casted as </span>
  <span class="hljs-comment">// EventData* pointer </span>

  EventData *evtdata = <span class="hljs-built_in">static_cast</span>&lt;EventData*&gt;(pData);
  .....
}
</code></pre>

<p><strong>dynamic_cast :</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DebugLog::OnMessage</span><span class="hljs-params">(Message *msg)</span>
</span>{
    <span class="hljs-type">static</span> DebugMsgData *debug;
    <span class="hljs-type">static</span> XYZMsgData *xyz;

    <span class="hljs-keyword">if</span>(debug = <span class="hljs-built_in">dynamic_cast</span>&lt;DebugMsgData*&gt;(msg-&gt;pdata)){
        <span class="hljs-comment">// debug message</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(xyz = <span class="hljs-built_in">dynamic_cast</span>&lt;XYZMsgData*&gt;(msg-&gt;pdata)){
        <span class="hljs-comment">// xyz message</span>
    }
    <span class="hljs-keyword">else</span><span class="hljs-comment">/* if( ... )*/</span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>

<p><strong>const_cast :</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// *Passwd declared as a const</span>

<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *Passwd


<span class="hljs-comment">// on some situation it require to remove its constness</span>

<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(Passwd)
</code></pre>

<p><strong>reinterpret_cast :</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uint16;

<span class="hljs-comment">// Read Bytes returns that 2 bytes got read. </span>

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteBuffer::ReadUInt16</span><span class="hljs-params">(uint16&amp; val)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadBytes</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;val), <span class="hljs-number">2</span>);
}
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It might help if you know little bit of internals...</p>
<p><strong>static_cast</strong></p>
<ul>
<li>C++ compiler already knows how to convert between scaler types such as <code>float</code> to <code>int</code>. Use <code>static_cast</code> for them.</li>
<li>When you ask compiler to convert from type <code>A</code> to <code>B</code>, <code>static_cast</code> calls <code>B</code>'s constructor passing <code>A</code> as param. Alternatively, <code>A</code> could have a conversion operator (i.e. <code>A::operator B()</code>).  If <code>B</code> doesn't have such constructor, or <code>A</code> doesn't have a conversion operator, then you get compile time error.</li>
<li>Cast from <code>A*</code> to <code>B*</code> always succeeds if A and B are in inheritance hierarchy (or void) otherwise you get compile error.</li>
<li><strong>Gotcha</strong>: If you cast base pointer to derived pointer but if actual object is not really derived type then you <em>don't</em> get error. You get bad pointer and  very likely a segfault at runtime. Same goes for <code>A&amp;</code> to <code>B&amp;</code>.</li>
<li><strong>Gotcha</strong>: Cast from Derived to Base or viceversa creates <em>new</em> copy! For people coming from C#/Java, this can be a huge surprise because the result is basically a chopped off object created from Derived.</li>
</ul>
<p><strong>dynamic_cast</strong></p>
<ul>
<li>dynamic_cast uses runtime type information to figure out if cast is valid. For example, <code>(Base*)</code> to <code>(Derived*)</code> may fail if pointer is not actually of derived type.</li>
<li>This means, dynamic_cast is very expensive compared to static_cast!</li>
<li>For <code>A*</code> to <code>B*</code>, if cast is invalid then dynamic_cast will return nullptr.</li>
<li>For <code>A&amp;</code> to <code>B&amp;</code> if cast is invalid then dynamic_cast will throw bad_cast exception.</li>
<li>Unlike other casts, there is runtime overhead.</li>
</ul>
<p><strong>const_cast</strong></p>
<ul>
<li>While static_cast can do non-const to const it can't go other way around. The const_cast can do both ways.</li>
<li>One example where this comes handy is iterating through some container like <code>set&lt;T&gt;</code> which only returns its elements as const to make sure you don't change its key. However if your intent is to modify object's non-key members then it should be ok. You can use const_cast to remove constness.</li>
<li>Another example is when you want to implement <code>T&amp; SomeClass::foo()</code> as well as <code>const T&amp; SomeClass::foo() const</code>. To avoid code duplication, you can apply const_cast to return value of one function from another.</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<ul>
<li>This basically says that take these bytes at this memory location and think of it as given object.</li>
<li>For example, you can load 4 bytes of <code>float</code> to 4 bytes of <code>int</code> to see how bits in <code>float</code> looks like.</li>
<li>Obviously, if data is not correct for the type, you may get segfault.</li>
<li>There is no runtime overhead for this cast.</li>
</ul>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Does <a href="http://www.cppreference.com/wiki/keywords/casting_comparison" rel="noreferrer">this</a> answer your question?</p>

<p>I have never used <code>reinterpret_cast</code>, and wonder whether running into a case that needs it isn't a smell of bad design. In the code base I work on <code>dynamic_cast</code> is used a lot. The difference with  <code>static_cast</code> is that a <code>dynamic_cast</code> does runtime checking which may (safer) or may not (more overhead) be what you want (see <a href="http://msdn.microsoft.com/en-us/library/c36yw7x9(VS.80).aspx" rel="noreferrer">msdn</a>).</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In addition to the other answers so far, here is unobvious example where <code>static_cast</code> is not sufficient so that <code>reinterpret_cast</code> is needed. Suppose there is a function which in an output parameter returns pointers to objects of different classes (which do not share a common base class). A real example of such function is <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686615%28v=vs.85%29.aspx" rel="noreferrer"><code>CoCreateInstance()</code></a> (see the last parameter, which is in fact <code>void**</code>). Suppose you request particular class of object from this function, so you know in advance the type for the pointer (which you often do for COM objects). In this case you cannot cast pointer to your pointer into <code>void**</code> with <code>static_cast</code>: you need <code>reinterpret_cast&lt;void**&gt;(&amp;yourPointer)</code>. </p>

<p>In code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netfw.h&gt;</span></span>
.....
INetFwPolicy2* pNetFwPolicy2 = <span class="hljs-literal">nullptr</span>;
HRESULT hr = <span class="hljs-built_in">CoCreateInstance</span>(__uuidof(NetFwPolicy2), <span class="hljs-literal">nullptr</span>,
    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),
    <span class="hljs-comment">//static_cast&lt;void**&gt;(&amp;pNetFwPolicy2) would give a compile error</span>
    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;pNetFwPolicy2) );
</code></pre>

<p>However, <code>static_cast</code> works for simple pointers (not pointers to pointers), so the above code can be rewritten to avoid <code>reinterpret_cast</code> (at a price of an extra variable) in the following way:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netfw.h&gt;</span></span>
.....
INetFwPolicy2* pNetFwPolicy2 = <span class="hljs-literal">nullptr</span>;
<span class="hljs-type">void</span>* tmp = <span class="hljs-literal">nullptr</span>;
HRESULT hr = <span class="hljs-built_in">CoCreateInstance</span>(__uuidof(NetFwPolicy2), <span class="hljs-literal">nullptr</span>,
    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),
    &amp;tmp );
pNetFwPolicy2 = <span class="hljs-built_in">static_cast</span>&lt;INetFwPolicy2*&gt;(tmp);
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><code>static_cast</code> vs <code>dynamic_cast</code> vs <code>reinterpret_cast</code> internals view on a downcast/upcast</strong></p>
<p>In this answer, I want to compare these three mechanisms on a concrete upcast/downcast example and analyze what happens to the underlying pointers/memory/assembly to give a concrete understanding of how they compare.</p>
<p>I believe that this will give a good intuition on how those casts are different:</p>
<ul>
<li><p><code>static_cast</code>: does one address offset at runtime (low runtime impact) and no safety checks that a downcast is correct.</p>
</li>
<li><p><code>dyanamic_cast</code>: does the same address offset at runtime like <code>static_cast</code>, but also and an expensive safety check that a downcast is correct using RTTI.</p>
<p>This safety check allows you to query if a base class pointer is of a given type at runtime by checking a return of <code>nullptr</code> which indicates an invalid downcast.</p>
<p>Therefore, if your code is not able to check for that <code>nullptr</code> and take a valid non-abort action, you should just use <code>static_cast</code> instead of dynamic cast.</p>
<p>If an abort is the only action your code can take, maybe you only want to enable the <code>dynamic_cast</code> in debug builds (<code>-NDEBUG</code>), and use <code>static_cast</code> otherwise, e.g. <a href="https://github.com/gem5/gem5/blob/9fc9c67b4242c03f165951775be5cd0812f2a705/src/base/cast.hh#L40" rel="noreferrer">as done here</a>, to not slow down your fast runs.</p>
</li>
<li><p><code>reinterpret_cast</code>: does nothing at runtime, not even the address offset. The pointer must point exactly to the correct type, not even a base class works. You generally don't want this unless raw byte streams are involved.</p>
</li>
</ul>
<p>Consider the following code example:</p>
<p>main.cpp</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B1</span> {
    <span class="hljs-built_in">B1</span>(<span class="hljs-type">int</span> int_in_b1) : <span class="hljs-built_in">int_in_b1</span>(int_in_b1) {}
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B1</span>() {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
    <span class="hljs-type">int</span> int_in_b1;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B2</span> {
    <span class="hljs-built_in">B2</span>(<span class="hljs-type">int</span> int_in_b2) : <span class="hljs-built_in">int_in_b2</span>(int_in_b2) {}
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B2</span>() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; }
    <span class="hljs-type">int</span> int_in_b2;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B1, <span class="hljs-keyword">public</span> B2 {
    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> int_in_b1, <span class="hljs-type">int</span> int_in_b2, <span class="hljs-type">int</span> int_in_d)
        : <span class="hljs-built_in">B1</span>(int_in_b1), <span class="hljs-built_in">B2</span>(int_in_b2), <span class="hljs-built_in">int_in_d</span>(int_in_d) {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>; }
    <span class="hljs-type">int</span> int_in_d;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    B2 *b2s[<span class="hljs-number">2</span>];
    B2 b2{<span class="hljs-number">11</span>};
    D *dp;
    D d{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};

    <span class="hljs-comment">// The memory layout must support the virtual method call use case.</span>
    b2s[<span class="hljs-number">0</span>] = &amp;b2;
    <span class="hljs-comment">// An upcast is an implicit static_cast&lt;&gt;().</span>
    b2s[<span class="hljs-number">1</span>] = &amp;d;
    std::cout &lt;&lt; <span class="hljs-string">"&amp;d           "</span> &lt;&lt; &amp;d           &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"b2s[0]       "</span> &lt;&lt; b2s[<span class="hljs-number">0</span>]       &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"b2s[1]       "</span> &lt;&lt; b2s[<span class="hljs-number">1</span>]       &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"b2s[0]-&gt;f2() "</span> &lt;&lt; b2s[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">f2</span>() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"b2s[1]-&gt;f2() "</span> &lt;&lt; b2s[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">f2</span>() &lt;&lt; std::endl;

    <span class="hljs-comment">// Now for some downcasts.</span>

    <span class="hljs-comment">// Cannot be done implicitly</span>
    <span class="hljs-comment">// error: invalid conversion from B2* to D* [-fpermissive]</span>
    <span class="hljs-comment">// dp = (b2s[0]);</span>

    <span class="hljs-comment">// Undefined behaviour to an unrelated memory address because this is a B2, not D.</span>
    dp = <span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>]);
    std::cout &lt;&lt; <span class="hljs-string">"static_cast&lt;D*&gt;(b2s[0])            "</span> &lt;&lt; dp           &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"static_cast&lt;D*&gt;(b2s[0])-&gt;int_in_d  "</span> &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;

    <span class="hljs-comment">// OK</span>
    dp = <span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>]);
    std::cout &lt;&lt; <span class="hljs-string">"static_cast&lt;D*&gt;(b2s[1])            "</span> &lt;&lt; dp           &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"static_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d  "</span> &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;

    <span class="hljs-comment">// Segfault because dp is nullptr.</span>
    dp = <span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>]);
    std::cout &lt;&lt; <span class="hljs-string">"dynamic_cast&lt;D*&gt;(b2s[0])           "</span> &lt;&lt; dp           &lt;&lt; std::endl;
    <span class="hljs-comment">//std::cout &lt;&lt; "dynamic_cast&lt;D*&gt;(b2s[0])-&gt;int_in_d " &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;</span>

    <span class="hljs-comment">// OK</span>
    dp = <span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>]);
    std::cout &lt;&lt; <span class="hljs-string">"dynamic_cast&lt;D*&gt;(b2s[1])           "</span> &lt;&lt; dp           &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"dynamic_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d "</span> &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;

    <span class="hljs-comment">// Undefined behaviour to an unrelated memory address because this</span>
    <span class="hljs-comment">// did not calculate the offset to get from B2* to D*.</span>
    dp = <span class="hljs-built_in">reinterpret_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>]);
    std::cout &lt;&lt; <span class="hljs-string">"reinterpret_cast&lt;D*&gt;(b2s[1])           "</span> &lt;&lt; dp           &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"reinterpret_cast&lt;D*&gt;(b2s[1])-&gt;int_in_d "</span> &lt;&lt; dp-&gt;int_in_d &lt;&lt; std::endl;
}

</code></pre>
<p>Compile, run and disassemble with:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">g++ -ggdb3 -O0 -std=c++<span class="hljs-number">11</span> -Wall -Wextra -pedantic -o main.out main.cpp
setarch `uname -m` -R ./main.out
gdb -batch -ex <span class="hljs-string">"disassemble/rs main"</span> main.out
</code></pre>
<p>where <code>setarch</code> is <a href="https://stackoverflow.com/questions/11238457/disable-and-re-enable-address-space-layout-randomization-only-for-myself">used to disable ASLR</a> to make it easier to compare runs.</p>
<p>Possible output:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&amp;d           <span class="hljs-number">0x7fffffffc930</span>
b2s[<span class="hljs-number">0</span>]       <span class="hljs-number">0x7fffffffc920</span>
b2s[<span class="hljs-number">1</span>]       <span class="hljs-number">0x7fffffffc940</span>
b2s[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">f2</span>() <span class="hljs-number">2</span>
b2s[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">f2</span>() <span class="hljs-number">3</span>
<span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>])            <span class="hljs-number">0x7fffffffc910</span>
<span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>])-&gt;int_in_d  <span class="hljs-number">1</span>
<span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])            <span class="hljs-number">0x7fffffffc930</span>
<span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])-&gt;int_in_d  <span class="hljs-number">3</span>
<span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>])           <span class="hljs-number">0</span>
<span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])           <span class="hljs-number">0x7fffffffc930</span>
<span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])-&gt;int_in_d <span class="hljs-number">3</span>
<span class="hljs-built_in">reinterpret_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])           <span class="hljs-number">0x7fffffffc940</span>
<span class="hljs-built_in">reinterpret_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>])-&gt;int_in_d <span class="hljs-number">32767</span>
</code></pre>
<p>Now, as mentioned at: <a href="https://en.wikipedia.org/wiki/Virtual_method_table" rel="noreferrer">https://en.wikipedia.org/wiki/Virtual_method_table</a> in order to support the virtual method calls efficiently, supposing that the memory data structures of B1 is of form:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B1:
  +<span class="hljs-number">0</span>: pointer to <span class="hljs-keyword">virtual</span> method table of B1
  +<span class="hljs-number">4</span>: value of int_in_b1
</code></pre>
<p>and <code>B2</code> is of form:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B2:
  +<span class="hljs-number">0</span>: pointer to <span class="hljs-keyword">virtual</span> method table of B2
  +<span class="hljs-number">4</span>: value of int_in_b2
</code></pre>
<p>then memory data structure of <code>D</code> has to look something like:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">D:
  +<span class="hljs-number">0</span>: <span class="hljs-function">pointer to <span class="hljs-keyword">virtual</span> method table of <span class="hljs-title">D</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> B1)</span>
  +4: value of int_in_b1
  +<span class="hljs-number">8</span>: pointer to virtual method table of D (for B2)
 +<span class="hljs-number">12</span>: value of int_in_b2
 +<span class="hljs-number">16</span>: value of int_in_d
</span></code></pre>
<p>The key fact is that the memory data structure of <code>D</code> contains inside it memory structure identical to that of <code>B1</code> and <code>B2</code>, i.e.:</p>
<ul>
<li>+0 looks exactly like a B1, with the B1 vtable for D followed by <code>int_in_b1</code></li>
<li>+8 looks exactly like a B2, with the B2 vtable for D followed by <code>int_in_b2</code></li>
</ul>
<p>Therefore we reach the critical conclusion:</p>
<blockquote>
<p>an upcast or downcast only needs to shift the pointer value by a value known at compile time</p>
</blockquote>
<p>This way, when <code>D</code> gets passed to the base type array, the type cast actually calculates that offset and points something that looks exactly like a valid <code>B2</code> in memory, except that this one has the vtable for <code>D</code> instead of <code>B2</code>, and therefore all virtual calls work transparently.</p>
<p>E.g.:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">b2s[<span class="hljs-number">1</span>] = &amp;d;
</code></pre>
<p>simply needs to get the address of <code>d</code> + 8 to reach the corresponding B2-like data structure.</p>
<p>Now, we can finally get back to type casting and the analysis of our concrete example.</p>
<p>From the stdout output we see:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&amp;d           <span class="hljs-number">0x7fffffffc930</span>
b2s[<span class="hljs-number">1</span>]       <span class="hljs-number">0x7fffffffc940</span>
</code></pre>
<p>Therefore, the implicit <code>static_cast</code> done there did correctly calculate the offset from the full <code>D</code> data structure at 0x7fffffffc930 to the <code>B2</code> like one which is at 0x7fffffffc940. We also infer that what lies between 0x7fffffffc930 and 0x7fffffffc940 is likely be the <code>B1</code> data and vtable.</p>
<p>Then, on the downcast sections, it is now easy to understand how the invalid ones fail and why:</p>
<ul>
<li><p><code>static_cast&lt;D*&gt;(b2s[0])            0x7fffffffc910</code>: the compiler just went up 0x10 at compile time bytes to try and go from a <code>B2</code> to the containing <code>D</code></p>
<p>But because <code>b2s[0]</code> was not a <code>D</code>, it now points to an undefined memory region.</p>
<p>The disassembly is:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">49</span>          dp = <span class="hljs-built_in">static_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>]);
   <span class="hljs-number">0x0000000000000fc8</span> &lt;+<span class="hljs-number">414</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> d0     mov    <span class="hljs-number">-0x30</span>(%rbp),%rax
   <span class="hljs-number">0x0000000000000fcc</span> &lt;+<span class="hljs-number">418</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">85</span> c0        test   %rax,%rax
   <span class="hljs-number">0x0000000000000fcf</span> &lt;+<span class="hljs-number">421</span>&gt;:   <span class="hljs-number">74</span> <span class="hljs-number">0</span>a   je     <span class="hljs-number">0xfdb</span> &lt;<span class="hljs-built_in">main</span>()+<span class="hljs-number">433</span>&gt;
   <span class="hljs-number">0x0000000000000fd1</span> &lt;+<span class="hljs-number">423</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> d0     mov    <span class="hljs-number">-0x30</span>(%rbp),%rax
   <span class="hljs-number">0x0000000000000fd5</span> &lt;+<span class="hljs-number">427</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> e8 <span class="hljs-number">10</span>     sub    $<span class="hljs-number">0x10</span>,%rax
   <span class="hljs-number">0x0000000000000fd9</span> &lt;+<span class="hljs-number">431</span>&gt;:   eb <span class="hljs-number">05</span>   jmp    <span class="hljs-number">0xfe0</span> &lt;<span class="hljs-built_in">main</span>()+<span class="hljs-number">438</span>&gt;
   <span class="hljs-number">0x0000000000000fdb</span> &lt;+<span class="hljs-number">433</span>&gt;:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  mov    $<span class="hljs-number">0x0</span>,%eax
   <span class="hljs-number">0x0000000000000fe0</span> &lt;+<span class="hljs-number">438</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">98</span>     mov    %rax,<span class="hljs-number">-0x68</span>(%rbp)
</code></pre>
<p>so we see that GCC does:</p>
<ul>
<li>check if pointer is NULL, and if yes return NULL</li>
<li>otherwise, subtract 0x10 from it to reach the <code>D</code> which does not exist</li>
</ul>
</li>
<li><p><code>dynamic_cast&lt;D*&gt;(b2s[0])           0</code>: C++ actually found that the cast was invalid and returned <code>nullptr</code>!</p>
<p>There is no way this can be done at compile time, and we will confirm that from the disassembly:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">59</span>          dp = <span class="hljs-built_in">dynamic_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">0</span>]);
   <span class="hljs-number">0x00000000000010ec</span> &lt;+<span class="hljs-number">706</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> d0     mov    <span class="hljs-number">-0x30</span>(%rbp),%rax
   <span class="hljs-number">0x00000000000010f0</span> &lt;+<span class="hljs-number">710</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">85</span> c0        test   %rax,%rax
   <span class="hljs-number">0x00000000000010f3</span> &lt;+<span class="hljs-number">713</span>&gt;:   <span class="hljs-number">74</span> <span class="hljs-number">1</span>d   je     <span class="hljs-number">0x1112</span> &lt;<span class="hljs-built_in">main</span>()+<span class="hljs-number">744</span>&gt;
   <span class="hljs-number">0x00000000000010f5</span> &lt;+<span class="hljs-number">715</span>&gt;:   b9 <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  mov    $<span class="hljs-number">0x10</span>,%ecx
   <span class="hljs-number">0x00000000000010fa</span> &lt;+<span class="hljs-number">720</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">15</span> f7 <span class="hljs-number">0b</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>    lea    <span class="hljs-number">0x200bf7</span>(%rip),%rdx        # <span class="hljs-number">0x201cf8</span> &lt;_ZTI1D&gt;
   <span class="hljs-number">0x0000000000001101</span> &lt;+<span class="hljs-number">727</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">35</span> <span class="hljs-number">28</span> <span class="hljs-number">0</span>c <span class="hljs-number">20</span> <span class="hljs-number">00</span>    lea    <span class="hljs-number">0x200c28</span>(%rip),%rsi        # <span class="hljs-number">0x201d30</span> &lt;_ZTI2B2&gt;
   <span class="hljs-number">0x0000000000001108</span> &lt;+<span class="hljs-number">734</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7        mov    %rax,%rdi
   <span class="hljs-number">0x000000000000110b</span> &lt;+<span class="hljs-number">737</span>&gt;:   e8 c0 fb ff ff  callq  <span class="hljs-number">0xcd0</span> &lt;__dynamic_cast@plt&gt;
   <span class="hljs-number">0x0000000000001110</span> &lt;+<span class="hljs-number">742</span>&gt;:   eb <span class="hljs-number">05</span>   jmp    <span class="hljs-number">0x1117</span> &lt;<span class="hljs-built_in">main</span>()+<span class="hljs-number">749</span>&gt;
   <span class="hljs-number">0x0000000000001112</span> &lt;+<span class="hljs-number">744</span>&gt;:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  mov    $<span class="hljs-number">0x0</span>,%eax
   <span class="hljs-number">0x0000000000001117</span> &lt;+<span class="hljs-number">749</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">98</span>     mov    %rax,<span class="hljs-number">-0x68</span>(%rbp)
</code></pre>
<p>First there is a NULL check, and it returns NULL if th einput is NULL.</p>
<p>Otherwise, it sets up some arguments in the RDX, RSI and RDI and calls <code>__dynamic_cast</code>.</p>
<p>I don't have the patience to analyze this further now, but as others said, the only way for this to work is for <code>__dynamic_cast</code> to access some extra RTTI in-memory data structures that represent the class hierarchy.</p>
<p>It must therefore start from the <code>B2</code> entry for that table, then walk this class hierarchy until it finds that the vtable for a <code>D</code> typecast from <code>b2s[0]</code>.</p>
<p>This is why dynamic cast is potentially expensive! Here is <a href="https://gem5-review.googlesource.com/c/public/gem5/+/25964" rel="noreferrer">an example where a one liner patch converting a <code>dynamic_cast</code> to a <code>static_cast</code> in a complex project reduced runtime by 33%!</a>.</p>
</li>
<li><p><code>reinterpret_cast&lt;D*&gt;(b2s[1])           0x7fffffffc940</code> this one just believes us blindly: we said there is a <code>D</code> at address <code>b2s[1]</code>, and the compiler does no offset calculations.</p>
<p>But this is wrong, because D is actually at 0x7fffffffc930, what is at 0x7fffffffc940 is the B2-like structure inside D! So trash gets accessed.</p>
<p>We can confirm this from the horrendous <code>-O0</code> assembly that just moves the value around:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">70</span>          dp = <span class="hljs-built_in">reinterpret_cast</span>&lt;D*&gt;(b2s[<span class="hljs-number">1</span>]);
   <span class="hljs-number">0x00000000000011fa</span> &lt;+<span class="hljs-number">976</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> d8     mov    <span class="hljs-number">-0x28</span>(%rbp),%rax
   <span class="hljs-number">0x00000000000011fe</span> &lt;+<span class="hljs-number">980</span>&gt;:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">98</span>     mov    %rax,<span class="hljs-number">-0x68</span>(%rbp)
</code></pre>
</li>
</ul>
<p>Related questions:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
<li><a href="https://stackoverflow.com/questions/18359780/how-is-dynamic-cast-implemented">How is dynamic_cast implemented</a></li>
<li><a href="https://stackoverflow.com/questions/6322949/downcasting-using-the-static-cast-in-c">Downcasting using the 'static_cast' in C++</a></li>
</ul>
<p>Tested on Ubuntu 18.04 amd64, GCC 7.4.0.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While other answers nicely described all differences between C++ casts, I would like to add a short note why you should not use C-style casts <code>(Type) var</code> and <code>Type(var)</code>.</p>

<p>For C++ beginners C-style casts look like being the superset operation over C++ casts (static_cast&lt;&gt;(), dynamic_cast&lt;&gt;(), const_cast&lt;&gt;(), reinterpret_cast&lt;&gt;()) and someone could prefer them over the C++ casts. In fact C-style cast is the superset and shorter to write.</p>

<p>The main problem of C-style casts is that they hide developer real intention of the cast. The C-style casts can do virtually all types of casting from normally safe casts done by static_cast&lt;&gt;() and dynamic_cast&lt;&gt;() to potentially dangerous casts like const_cast&lt;&gt;(), where const modifier can be removed so the const variables can be modified and reinterpret_cast&lt;&gt;() that can even reinterpret integer values to pointers.</p>

<p>Here is the sample.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> a=<span class="hljs-built_in">rand</span>(); <span class="hljs-comment">// Random number.</span>

<span class="hljs-type">int</span>* pa1=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(a); <span class="hljs-comment">// OK. Here developer clearly expressed he wanted to do this potentially dangerous operation.</span>

<span class="hljs-type">int</span>* pa2=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(a); <span class="hljs-comment">// Compiler error.</span>
<span class="hljs-type">int</span>* pa3=<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(a); <span class="hljs-comment">// Compiler error.</span>

<span class="hljs-type">int</span>* pa4=(<span class="hljs-type">int</span>*) a; <span class="hljs-comment">// OK. C-style cast can do such cast. The question is if it was intentional or developer just did some typo.</span>

*pa4=<span class="hljs-number">5</span>; <span class="hljs-comment">// Program crashes.</span>
</code></pre>

<p>The main reason why C++ casts were added to the language was to allow a developer to clarify his intentions - why he is going to do that cast. By using C-style casts which are perfectly valid in C++ you are making your code less readable and more error prone especially for other developers who didn't create your code. So to make your code more readable and explicit you should always prefer C++ casts over C-style casts.</p>

<p>Here is a short quote from Bjarne Stroustrup's (the author of C++) book The C++ Programming Language 4th edition - page 302.</p>

<blockquote>
  <p>This C-style cast is far more dangerous than the named conversion operators
  because the notation is harder to spot in a large program and the kind of conversion intended by the programmer is not explicit.</p>
</blockquote>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To understand, let's consider below code snippet:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>{};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span>{};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>
</span>{
    Foo* f = <span class="hljs-keyword">new</span> Foo;

    Bar* b1 = f;                              <span class="hljs-comment">// (1)</span>
    Bar* b2 = <span class="hljs-built_in">static_cast</span>&lt;Bar*&gt;(f);           <span class="hljs-comment">// (2)</span>
    Bar* b3 = <span class="hljs-built_in">dynamic_cast</span>&lt;Bar*&gt;(f);          <span class="hljs-comment">// (3)</span>
    Bar* b4 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Bar*&gt;(f);      <span class="hljs-comment">// (4)</span>
    Bar* b5 = <span class="hljs-built_in">const_cast</span>&lt;Bar*&gt;(f);            <span class="hljs-comment">// (5)</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Only line (4) compiles without error. Only <strong>reinterpret_cast</strong> can be used to convert a pointer to an object to a pointer to an any unrelated object type.</p>

<p>One this to be noted is: The <strong>dynamic_cast</strong> would fail at run-time, however on most compilers it will also fail to compile because there are no virtual functions in the struct of the pointer being casted, meaning <strong>dynamic_cast</strong> will work with only polymorphic class pointers.</p>

<p><strong>When to use C++ cast</strong>:</p>

<ul>
<li>Use <strong>static_cast</strong> as the equivalent of a C-style cast that does value conversion, or when we need to explicitly up-cast a pointer from a class to its superclass.</li>
<li>Use <strong>const_cast</strong> to remove the const qualifier.  </li>
<li>Use <strong>reinterpret_cast</strong> to do unsafe conversions of pointer types to and from integer and other pointer types. Use this only if we know what we are doing and we understand the aliasing issues.</li>
</ul>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Nice feature of <code>reinterpret_cast</code>, not mentioned in the other answers, is that it allows us to create a sort of <code>void*</code> pointer for function types. Normally, for object types one uses <code>static_cast</code> to retrieve the original type of a pointer stored in <code>void*</code>:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">  <span class="hljs-type">int</span> i = <span class="hljs-number">13</span>;
  <span class="hljs-type">void</span> *p = &amp;i;
  <span class="hljs-keyword">auto</span> *pi = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p);
</code></pre>
<p>For functions, we must use <code>reinterpret_cast</code> twice:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-type">any_fcn_ptr_t</span> = <span class="hljs-built_in">void</span>(*)();


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>
</span>{
   std::cout &lt;&lt; i &lt;&lt;std::endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{     
  <span class="hljs-comment">//Create type-erased pointer to function:</span>
  <span class="hljs-keyword">auto</span> any_ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">any_fcn_ptr_t</span>&gt;(&amp;print);
  
  <span class="hljs-comment">//Retrieve the original pointer:</span>
  <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt; <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>) &gt;(any_ptr);
  
  <span class="hljs-built_in">ptr</span>(<span class="hljs-number">7</span>);
}
</code></pre>
<p>With <code>reinterpret_cast</code> we can even get a similar sort-of-void* pointer for pointers to member functions.</p>
<p>As with plain <code>void*</code> and <code>static_cast</code>, C++ guarantees that <code>ptr</code> points to <code>print</code> function (as long as we pass the correct type to <code>reinterpret_cast</code>).</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-to-lazy-load-images-in-listview-in-android-1657387332835">How to lazy load images in ListView in Android</a><a href="/questions/does-python-have-a-ternary-conditional-operator-1657387555448">Does Python have a ternary conditional operator?</a><a href="/questions/importing-files-from-different-folder-1657388203798">Importing files from different folder</a><a href="/questions/what-is-the-difference-between-%22px%22-%22dip%22-%22dp%22-and-%22sp%22-1657388093250">What is the difference between &quot;px&quot;, &quot;dip&quot;, &quot;dp&quot; and &quot;sp&quot;?</a><a href="/questions/how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964">How do I attach events to dynamic HTML elements with jQuery? [duplicate]</a><a href="/questions/javascript-infamous-loop-issue-duplicate-1657387498530">Javascript infamous Loop issue? [duplicate]</a><a href="/questions/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379">How to print a number with commas as thousands separators in JavaScript</a><a href="/questions/can-i-mix-mysql-apis-in-php-1657384597444">Can I mix MySQL APIs in PHP?</a><a href="/questions/what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159">What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?</a><a href="/questions/what-are-the-rules-for-javascript&#x27;s-automatic-semicolon-insertion-(asi)-1657387472789">What are the rules for JavaScript&#x27;s automatic semicolon insertion (ASI)?</a><a href="/questions/asynctask-android-example-1657388127898">AsyncTask Android example</a><a href="/questions/ways-to-circumvent-the-same-origin-policy-1657384763316">Ways to circumvent the same-origin policy</a><a href="/questions/persist-variables-between-page-loads-1657388558452">Persist variables between page loads</a><a href="/questions/jquery-ajax-post-example-with-php-1657387402634">jQuery Ajax POST example with PHP</a><a href="/questions/submit-same-partial-view-called-multiple-times-data-to-controller-1657387887213">Submit same Partial View called multiple times data to controller?</a><a href="/questions/when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113">When should I use a return statement in ES6 arrow functions</a><a href="/questions/how-does-the-%22this%22-keyword-work-and-when-should-it-be-used-1657384384385">How does the &quot;this&quot; keyword work, and when should it be used?</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a><a href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216">With arrays, why is it the case that a[5] == 5[a]?</a><a href="/questions/how-do-i-expire-a-php-session-after-30-minutes-1657387990658">How do I expire a PHP session after 30 minutes?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; is the first cast you should attempt to use. It does things like implicit conversions between types (such as \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt;, or pointer to \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt;), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; isn\u0026apos;t necessary, but it\u0026apos;s important to note that the \u0026lt;code\u0026gt;T(something)\u0026lt;/code\u0026gt; syntax is equivalent to \u0026lt;code\u0026gt;(T)something\u0026lt;/code\u0026gt; and should be avoided (more on that later). A \u0026lt;code\u0026gt;T(something, something_else)\u0026lt;/code\u0026gt; is safe, however, and guaranteed to call the constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn\u0026apos;t cast through \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; inheritance. It does not do checking, however, and it is undefined behavior to \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; down a hierarchy to a type that isn\u0026apos;t actually the type of the object.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; can be used to remove or add \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; to a variable; no other C++ cast is capable of removing it (not even \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;). It is important to note that modifying a formerly \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; value is only undefined if the original variable is \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;; if you use it to take the \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; off a reference to something that wasn\u0026apos;t declared with \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;, it is safe. This can be useful when overloading member functions based on \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;, for instance. It can also be used to add \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; to an object, such as to call a member function overload.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt; also works similarly on \u0026lt;code\u0026gt;volatile\u0026lt;/code\u0026gt;, though that\u0026apos;s less common.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; is exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards  you can cast sideways or even up another chain. The \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; will seek out the desired object and return it if possible. If it can\u0026apos;t, it will return \u0026lt;code\u0026gt;nullptr\u0026lt;/code\u0026gt; in the case of a pointer, or throw \u0026lt;code\u0026gt;std::bad_cast\u0026lt;/code\u0026gt; in the case of a reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; has some limitations, though. It doesn\u0026apos;t work if there are multiple objects of the same type in the inheritance hierarchy (the so-called \u0026apos;dreaded diamond\u0026apos;) and you aren\u0026apos;t using \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; inheritance. It also can only go through public inheritance - it will always fail to travel through \u0026lt;code\u0026gt;protected\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt; inheritance. This is rarely an issue, however, as such forms of inheritance are rare.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; is the most dangerous cast, and should be used very sparingly. It turns one type directly into another  such as casting the value from one pointer to another, or storing a pointer in an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, or all sorts of other nasty things. Largely, the only guarantee you get with \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; is that normally if you cast the result back to the original type, you will get the exact same value (but \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; if the intermediate type is smaller than the original type). There are a number of conversions that \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; cannot do, too. It\u0026apos;s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of a pointer to aligned data.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C-style cast\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;function-style cast\u0026lt;/strong\u0026gt; are casts using \u0026lt;code\u0026gt;(type)object\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;type(object)\u0026lt;/code\u0026gt;, respectively, and are functionally equivalent. They are defined as the first of the following which succeeds:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; (though ignoring access restrictions)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; (see above), then \u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;It can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;, and the latter should be preferred when explicit casting is needed, unless you are sure \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; will succeed or \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; will fail. Even then, consider the longer, more explicit option.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C-style casts also ignore access control when performing a \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; for converting pointers/references within an inheritance hierarchy.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; for ordinary type conversions.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; for low-level reinterpreting of bit patterns.  Use with extreme caution.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt; for casting away \u0026lt;code\u0026gt;const/volatile\u0026lt;/code\u0026gt;.  Avoid this unless you are stuck using a const-incorrect API.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;(A lot of theoretical and conceptual explanation has been given above)\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Below are some of the \u0026lt;strong\u0026gt;practical examples\u0026lt;/strong\u0026gt; when I used \u0026lt;strong\u0026gt;static_cast\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;dynamic_cast\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;const_cast\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;reinterpret_cast\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Also referes this to understand the explaination : \u0026lt;a href=\u0026quot;http://www.cplusplus.com/doc/tutorial/typecasting/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.cplusplus.com/doc/tutorial/typecasting/\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;static_cast :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;OnEventData\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* pData)\n\n{\n  ......\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  pData is a void* pData, \u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  EventData is a structure e.g. \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  typedef struct _EventData {\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  std::string id;\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  std:: string remote_id;\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  } EventData;\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// On Some Situation a void pointer *pData\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// has been static_casted as \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// EventData* pointer \u0026lt;/span\u0026gt;\n\n  EventData *evtdata = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;EventData*\u0026amp;gt;(pData);\n  .....\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;dynamic_cast :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DebugLog::OnMessage\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Message *msg)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; DebugMsgData *debug;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; XYZMsgData *xyz;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(debug = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;DebugMsgData*\u0026amp;gt;(msg-\u0026amp;gt;pdata)){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// debug message\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(xyz = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;XYZMsgData*\u0026amp;gt;(msg-\u0026amp;gt;pdata)){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// xyz message\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* if( ... )*/\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;const_cast :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *Passwd declared as a const\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *Passwd\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// on some situation it require to remove its constness\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;const_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt;(Passwd)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;reinterpret_cast :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; uint16;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Read Bytes returns that 2 bytes got read. \u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ByteBuffer::ReadUInt16\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(uint16\u0026amp;amp; val)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ReadBytes\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt;(\u0026amp;amp;val), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It might help if you know little bit of internals...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;static_cast\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;C++ compiler already knows how to convert between scaler types such as \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;. Use \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; for them.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When you ask compiler to convert from type \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; calls \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s constructor passing \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; as param. Alternatively, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; could have a conversion operator (i.e. \u0026lt;code\u0026gt;A::operator B()\u0026lt;/code\u0026gt;).  If \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; doesn\u0026apos;t have such constructor, or \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; doesn\u0026apos;t have a conversion operator, then you get compile time error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Cast from \u0026lt;code\u0026gt;A*\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B*\u0026lt;/code\u0026gt; always succeeds if A and B are in inheritance hierarchy (or void) otherwise you get compile error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Gotcha\u0026lt;/strong\u0026gt;: If you cast base pointer to derived pointer but if actual object is not really derived type then you \u0026lt;em\u0026gt;don\u0026apos;t\u0026lt;/em\u0026gt; get error. You get bad pointer and  very likely a segfault at runtime. Same goes for \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B\u0026amp;amp;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Gotcha\u0026lt;/strong\u0026gt;: Cast from Derived to Base or viceversa creates \u0026lt;em\u0026gt;new\u0026lt;/em\u0026gt; copy! For people coming from C#/Java, this can be a huge surprise because the result is basically a chopped off object created from Derived.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;dynamic_cast\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;dynamic_cast uses runtime type information to figure out if cast is valid. For example, \u0026lt;code\u0026gt;(Base*)\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;(Derived*)\u0026lt;/code\u0026gt; may fail if pointer is not actually of derived type.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This means, dynamic_cast is very expensive compared to static_cast!\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For \u0026lt;code\u0026gt;A*\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B*\u0026lt;/code\u0026gt;, if cast is invalid then dynamic_cast will return nullptr.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B\u0026amp;amp;\u0026lt;/code\u0026gt; if cast is invalid then dynamic_cast will throw bad_cast exception.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unlike other casts, there is runtime overhead.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;const_cast\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;While static_cast can do non-const to const it can\u0026apos;t go other way around. The const_cast can do both ways.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;One example where this comes handy is iterating through some container like \u0026lt;code\u0026gt;set\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; which only returns its elements as const to make sure you don\u0026apos;t change its key. However if your intent is to modify object\u0026apos;s non-key members then it should be ok. You can use const_cast to remove constness.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Another example is when you want to implement \u0026lt;code\u0026gt;T\u0026amp;amp; SomeClass::foo()\u0026lt;/code\u0026gt; as well as \u0026lt;code\u0026gt;const T\u0026amp;amp; SomeClass::foo() const\u0026lt;/code\u0026gt;. To avoid code duplication, you can apply const_cast to return value of one function from another.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;reinterpret_cast\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;This basically says that take these bytes at this memory location and think of it as given object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For example, you can load 4 bytes of \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; to 4 bytes of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; to see how bits in \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; looks like.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Obviously, if data is not correct for the type, you may get segfault.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There is no runtime overhead for this cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Does \u0026lt;a href=\u0026quot;http://www.cppreference.com/wiki/keywords/casting_comparison\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; answer your question?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have never used \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;, and wonder whether running into a case that needs it isn\u0026apos;t a smell of bad design. In the code base I work on \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; is used a lot. The difference with  \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; is that a \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; does runtime checking which may (safer) or may not (more overhead) be what you want (see \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/c36yw7x9(VS.80).aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;msdn\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In addition to the other answers so far, here is unobvious example where \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; is not sufficient so that \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; is needed. Suppose there is a function which in an output parameter returns pointers to objects of different classes (which do not share a common base class). A real example of such function is \u0026lt;a href=\u0026quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms686615%28v=vs.85%29.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;CoCreateInstance()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (see the last parameter, which is in fact \u0026lt;code\u0026gt;void**\u0026lt;/code\u0026gt;). Suppose you request particular class of object from this function, so you know in advance the type for the pointer (which you often do for COM objects). In this case you cannot cast pointer to your pointer into \u0026lt;code\u0026gt;void**\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;: you need \u0026lt;code\u0026gt;reinterpret_cast\u0026amp;lt;void**\u0026amp;gt;(\u0026amp;amp;yourPointer)\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;windows.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;netfw.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\nHRESULT hr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CoCreateInstance\u0026lt;/span\u0026gt;(__uuidof(NetFwPolicy2), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//static_cast\u0026amp;lt;void**\u0026amp;gt;(\u0026amp;amp;pNetFwPolicy2) would give a compile error\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;**\u0026amp;gt;(\u0026amp;amp;pNetFwPolicy2) );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; works for simple pointers (not pointers to pointers), so the above code can be rewritten to avoid \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; (at a price of an extra variable) in the following way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;windows.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;netfw.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* tmp = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\nHRESULT hr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CoCreateInstance\u0026lt;/span\u0026gt;(__uuidof(NetFwPolicy2), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    \u0026amp;amp;tmp );\npNetFwPolicy2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;INetFwPolicy2*\u0026amp;gt;(tmp);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; vs \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; vs \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; internals view on a downcast/upcast\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In this answer, I want to compare these three mechanisms on a concrete upcast/downcast example and analyze what happens to the underlying pointers/memory/assembly to give a concrete understanding of how they compare.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I believe that this will give a good intuition on how those casts are different:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;: does one address offset at runtime (low runtime impact) and no safety checks that a downcast is correct.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;dyanamic_cast\u0026lt;/code\u0026gt;: does the same address offset at runtime like \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, but also and an expensive safety check that a downcast is correct using RTTI.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This safety check allows you to query if a base class pointer is of a given type at runtime by checking a return of \u0026lt;code\u0026gt;nullptr\u0026lt;/code\u0026gt; which indicates an invalid downcast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Therefore, if your code is not able to check for that \u0026lt;code\u0026gt;nullptr\u0026lt;/code\u0026gt; and take a valid non-abort action, you should just use \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; instead of dynamic cast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If an abort is the only action your code can take, maybe you only want to enable the \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; in debug builds (\u0026lt;code\u0026gt;-NDEBUG\u0026lt;/code\u0026gt;), and use \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; otherwise, e.g. \u0026lt;a href=\u0026quot;https://github.com/gem5/gem5/blob/9fc9c67b4242c03f165951775be5cd0812f2a705/src/base/cast.hh#L40\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;as done here\u0026lt;/a\u0026gt;, to not slow down your fast runs.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;: does nothing at runtime, not even the address offset. The pointer must point exactly to the correct type, not even a base class works. You generally don\u0026apos;t want this unless raw byte streams are involved.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Consider the following code example:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;main.cpp\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B1\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B1\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b1) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int_in_b1\u0026lt;/span\u0026gt;(int_in_b1) {}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B1\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f0\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b1;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B2\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b2) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int_in_b2\u0026lt;/span\u0026gt;(int_in_b2) {}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B2\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b2;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; B1, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; B2 {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_b2, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_d)\n        : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B1\u0026lt;/span\u0026gt;(int_in_b1), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B2\u0026lt;/span\u0026gt;(int_in_b2), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int_in_d\u0026lt;/span\u0026gt;(int_in_d) {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; int_in_d;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    B2 *b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n    B2 b2{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;};\n    D *dp;\n    D d{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;};\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The memory layout must support the virtual method call use case.\u0026lt;/span\u0026gt;\n    b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026amp;amp;b2;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// An upcast is an implicit static_cast\u0026amp;lt;\u0026amp;gt;().\u0026lt;/span\u0026gt;\n    b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026amp;amp;d;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;amp;d           \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026amp;amp;d           \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b2s[0]       \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]       \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b2s[1]       \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]       \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b2s[0]-\u0026amp;gt;f2() \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b2s[1]-\u0026amp;gt;f2() \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Now for some downcasts.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Cannot be done implicitly\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error: invalid conversion from B2* to D* [-fpermissive]\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dp = (b2s[0]);\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Undefined behaviour to an unrelated memory address because this is a B2, not D.\u0026lt;/span\u0026gt;\n    dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;static_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])            \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp           \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;static_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])-\u0026amp;gt;int_in_d  \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp-\u0026amp;gt;int_in_d \u0026amp;lt;\u0026amp;lt; std::endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;static_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])            \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp           \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;static_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])-\u0026amp;gt;int_in_d  \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp-\u0026amp;gt;int_in_d \u0026amp;lt;\u0026amp;lt; std::endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Segfault because dp is nullptr.\u0026lt;/span\u0026gt;\n    dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dynamic_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])           \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp           \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//std::cout \u0026amp;lt;\u0026amp;lt; \u0026quot;dynamic_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])-\u0026amp;gt;int_in_d \u0026quot; \u0026amp;lt;\u0026amp;lt; dp-\u0026amp;gt;int_in_d \u0026amp;lt;\u0026amp;lt; std::endl;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dynamic_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])           \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp           \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dynamic_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])-\u0026amp;gt;int_in_d \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp-\u0026amp;gt;int_in_d \u0026amp;lt;\u0026amp;lt; std::endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Undefined behaviour to an unrelated memory address because this\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// did not calculate the offset to get from B2* to D*.\u0026lt;/span\u0026gt;\n    dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;reinterpret_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])           \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp           \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;reinterpret_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])-\u0026amp;gt;int_in_d \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; dp-\u0026amp;gt;int_in_d \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Compile, run and disassemble with:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;g++ -ggdb3 -O0 -std=c++\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt; -Wall -Wextra -pedantic -o main.out main.cpp\nsetarch `uname -m` -R ./main.out\ngdb -batch -ex \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;disassemble/rs main\u0026quot;\u0026lt;/span\u0026gt; main.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;where \u0026lt;code\u0026gt;setarch\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/11238457/disable-and-re-enable-address-space-layout-randomization-only-for-myself\u0026quot;\u0026gt;used to disable ASLR\u0026lt;/a\u0026gt; to make it easier to compare runs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Possible output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;amp;d           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc930\u0026lt;/span\u0026gt;\nb2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc920\u0026lt;/span\u0026gt;\nb2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc940\u0026lt;/span\u0026gt;\nb2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\nb2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])            \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc910\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])-\u0026amp;gt;int_in_d  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])            \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc930\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])-\u0026amp;gt;int_in_d  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc930\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])-\u0026amp;gt;int_in_d \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc940\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])-\u0026amp;gt;int_in_d \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32767\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, as mentioned at: \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Virtual_method_table\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Virtual_method_table\u0026lt;/a\u0026gt; in order to support the virtual method calls efficiently, supposing that the memory data structures of B1 is of form:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B1:\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: pointer to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; method table of B1\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: value of int_in_b1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt; is of form:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B2:\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: pointer to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; method table of B2\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: value of int_in_b2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;then memory data structure of \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; has to look something like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;D:\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;pointer to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; method table of \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; B1)\u0026lt;/span\u0026gt;\n  +4: value of int_in_b1\n  +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;: pointer to virtual method table of D (for B2)\n +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;: value of int_in_b2\n +\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt;: value of int_in_d\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The key fact is that the memory data structure of \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; contains inside it memory structure identical to that of \u0026lt;code\u0026gt;B1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt;, i.e.:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;+0 looks exactly like a B1, with the B1 vtable for D followed by \u0026lt;code\u0026gt;int_in_b1\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;+8 looks exactly like a B2, with the B2 vtable for D followed by \u0026lt;code\u0026gt;int_in_b2\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Therefore we reach the critical conclusion:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;an upcast or downcast only needs to shift the pointer value by a value known at compile time\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This way, when \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; gets passed to the base type array, the type cast actually calculates that offset and points something that looks exactly like a valid \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt; in memory, except that this one has the vtable for \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt;, and therefore all virtual calls work transparently.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;E.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026amp;amp;d;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;simply needs to get the address of \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; + 8 to reach the corresponding B2-like data structure.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, we can finally get back to type casting and the analysis of our concrete example.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From the stdout output we see:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;amp;d           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc930\u0026lt;/span\u0026gt;\nb2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fffffffc940\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Therefore, the implicit \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; done there did correctly calculate the offset from the full \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; data structure at 0x7fffffffc930 to the \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt; like one which is at 0x7fffffffc940. We also infer that what lies between 0x7fffffffc930 and 0x7fffffffc940 is likely be the \u0026lt;code\u0026gt;B1\u0026lt;/code\u0026gt; data and vtable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Then, on the downcast sections, it is now easy to understand how the invalid ones fail and why:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])            0x7fffffffc910\u0026lt;/code\u0026gt;: the compiler just went up 0x10 at compile time bytes to try and go from a \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt; to the containing \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But because \u0026lt;code\u0026gt;b2s[0]\u0026lt;/code\u0026gt; was not a \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt;, it now points to an undefined memory region.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The disassembly is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;49\u0026lt;/span\u0026gt;          dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fc8\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;414\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; d0     mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x30\u0026lt;/span\u0026gt;(%rbp),%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fcc\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;418\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;85\u0026lt;/span\u0026gt; c0        test   %rax,%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fcf\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;421\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;74\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;a   je     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xfdb\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;433\u0026lt;/span\u0026gt;\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fd1\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;423\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; d0     mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x30\u0026lt;/span\u0026gt;(%rbp),%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fd5\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;427\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;83\u0026lt;/span\u0026gt; e8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;     sub    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x10\u0026lt;/span\u0026gt;,%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fd9\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;431\u0026lt;/span\u0026gt;\u0026amp;gt;:   eb \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;05\u0026lt;/span\u0026gt;   jmp    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xfe0\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;438\u0026lt;/span\u0026gt;\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fdb\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;433\u0026lt;/span\u0026gt;\u0026amp;gt;:   b8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;  mov    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,%eax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000000fe0\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;438\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;98\u0026lt;/span\u0026gt;     mov    %rax,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x68\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;so we see that GCC does:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;check if pointer is NULL, and if yes return NULL\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;otherwise, subtract 0x10 from it to reach the \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; which does not exist\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;dynamic_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[0])           0\u0026lt;/code\u0026gt;: C++ actually found that the cast was invalid and returned \u0026lt;code\u0026gt;nullptr\u0026lt;/code\u0026gt;!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is no way this can be done at compile time, and we will confirm that from the disassembly:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;59\u0026lt;/span\u0026gt;          dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000010ec\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;706\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; d0     mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x30\u0026lt;/span\u0026gt;(%rbp),%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000010f0\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;710\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;85\u0026lt;/span\u0026gt; c0        test   %rax,%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000010f3\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;713\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;74\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;d   je     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1112\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;744\u0026lt;/span\u0026gt;\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000010f5\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;715\u0026lt;/span\u0026gt;\u0026amp;gt;:   b9 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;  mov    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x10\u0026lt;/span\u0026gt;,%ecx\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000010fa\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;720\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;d \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt; f7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    lea    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x200bf7\u0026lt;/span\u0026gt;(%rip),%rdx        # \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x201cf8\u0026lt;/span\u0026gt; \u0026amp;lt;_ZTI1D\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000001101\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;727\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;d \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;35\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;28\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    lea    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x200c28\u0026lt;/span\u0026gt;(%rip),%rsi        # \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x201d30\u0026lt;/span\u0026gt; \u0026amp;lt;_ZTI2B2\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000001108\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;734\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; c7        mov    %rax,%rdi\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x000000000000110b\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;737\u0026lt;/span\u0026gt;\u0026amp;gt;:   e8 c0 fb ff ff  callq  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xcd0\u0026lt;/span\u0026gt; \u0026amp;lt;__dynamic_cast@plt\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000001110\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;742\u0026lt;/span\u0026gt;\u0026amp;gt;:   eb \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;05\u0026lt;/span\u0026gt;   jmp    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1117\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;749\u0026lt;/span\u0026gt;\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000001112\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;744\u0026lt;/span\u0026gt;\u0026amp;gt;:   b8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;  mov    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,%eax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000000001117\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;749\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;98\u0026lt;/span\u0026gt;     mov    %rax,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x68\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;First there is a NULL check, and it returns NULL if th einput is NULL.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Otherwise, it sets up some arguments in the RDX, RSI and RDI and calls \u0026lt;code\u0026gt;__dynamic_cast\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I don\u0026apos;t have the patience to analyze this further now, but as others said, the only way for this to work is for \u0026lt;code\u0026gt;__dynamic_cast\u0026lt;/code\u0026gt; to access some extra RTTI in-memory data structures that represent the class hierarchy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It must therefore start from the \u0026lt;code\u0026gt;B2\u0026lt;/code\u0026gt; entry for that table, then walk this class hierarchy until it finds that the vtable for a \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; typecast from \u0026lt;code\u0026gt;b2s[0]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is why dynamic cast is potentially expensive! Here is \u0026lt;a href=\u0026quot;https://gem5-review.googlesource.com/c/public/gem5/+/25964\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;an example where a one liner patch converting a \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; in a complex project reduced runtime by 33%!\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026amp;lt;D*\u0026amp;gt;(b2s[1])           0x7fffffffc940\u0026lt;/code\u0026gt; this one just believes us blindly: we said there is a \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; at address \u0026lt;code\u0026gt;b2s[1]\u0026lt;/code\u0026gt;, and the compiler does no offset calculations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But this is wrong, because D is actually at 0x7fffffffc930, what is at 0x7fffffffc940 is the B2-like structure inside D! So trash gets accessed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We can confirm this from the horrendous \u0026lt;code\u0026gt;-O0\u0026lt;/code\u0026gt; assembly that just moves the value around:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;70\u0026lt;/span\u0026gt;          dp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;D*\u0026amp;gt;(b2s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000011fa\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;976\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; d8     mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x28\u0026lt;/span\u0026gt;(%rbp),%rax\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000000011fe\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;980\u0026lt;/span\u0026gt;\u0026amp;gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;98\u0026lt;/span\u0026gt;     mov    %rax,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x68\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Related questions:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used\u0026quot;\u0026gt;When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/18359780/how-is-dynamic-cast-implemented\u0026quot;\u0026gt;How is dynamic_cast implemented\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/6322949/downcasting-using-the-static-cast-in-c\u0026quot;\u0026gt;Downcasting using the \u0026apos;static_cast\u0026apos; in C++\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Tested on Ubuntu 18.04 amd64, GCC 7.4.0.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While other answers nicely described all differences between C++ casts, I would like to add a short note why you should not use C-style casts \u0026lt;code\u0026gt;(Type) var\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Type(var)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For C++ beginners C-style casts look like being the superset operation over C++ casts (static_cast\u0026amp;lt;\u0026amp;gt;(), dynamic_cast\u0026amp;lt;\u0026amp;gt;(), const_cast\u0026amp;lt;\u0026amp;gt;(), reinterpret_cast\u0026amp;lt;\u0026amp;gt;()) and someone could prefer them over the C++ casts. In fact C-style cast is the superset and shorter to write.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main problem of C-style casts is that they hide developer real intention of the cast. The C-style casts can do virtually all types of casting from normally safe casts done by static_cast\u0026amp;lt;\u0026amp;gt;() and dynamic_cast\u0026amp;lt;\u0026amp;gt;() to potentially dangerous casts like const_cast\u0026amp;lt;\u0026amp;gt;(), where const modifier can be removed so the const variables can be modified and reinterpret_cast\u0026amp;lt;\u0026amp;gt;() that can even reinterpret integer values to pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the sample.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;rand\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Random number.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pa1=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK. Here developer clearly expressed he wanted to do this potentially dangerous operation.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pa2=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pa3=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pa4=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*) a; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK. C-style cast can do such cast. The question is if it was intentional or developer just did some typo.\u0026lt;/span\u0026gt;\n\n*pa4=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Program crashes.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The main reason why C++ casts were added to the language was to allow a developer to clarify his intentions - why he is going to do that cast. By using C-style casts which are perfectly valid in C++ you are making your code less readable and more error prone especially for other developers who didn\u0026apos;t create your code. So to make your code more readable and explicit you should always prefer C++ casts over C-style casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a short quote from Bjarne Stroustrup\u0026apos;s (the author of C++) book The C++ Programming Language 4th edition - page 302.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This C-style cast is far more dangerous than the named conversion operators\n  because the notation is harder to spot in a large program and the kind of conversion intended by the programmer is not explicit.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To understand, let\u0026apos;s consider below code snippet:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;{};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;** argv)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Foo* f = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Foo;\n\n    Bar* b1 = f;                              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1)\u0026lt;/span\u0026gt;\n    Bar* b2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;Bar*\u0026amp;gt;(f);           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (2)\u0026lt;/span\u0026gt;\n    Bar* b3 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;Bar*\u0026amp;gt;(f);          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3)\u0026lt;/span\u0026gt;\n    Bar* b4 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;Bar*\u0026amp;gt;(f);      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (4)\u0026lt;/span\u0026gt;\n    Bar* b5 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;const_cast\u0026lt;/span\u0026gt;\u0026amp;lt;Bar*\u0026amp;gt;(f);            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (5)\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Only line (4) compiles without error. Only \u0026lt;strong\u0026gt;reinterpret_cast\u0026lt;/strong\u0026gt; can be used to convert a pointer to an object to a pointer to an any unrelated object type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One this to be noted is: The \u0026lt;strong\u0026gt;dynamic_cast\u0026lt;/strong\u0026gt; would fail at run-time, however on most compilers it will also fail to compile because there are no virtual functions in the struct of the pointer being casted, meaning \u0026lt;strong\u0026gt;dynamic_cast\u0026lt;/strong\u0026gt; will work with only polymorphic class pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When to use C++ cast\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;strong\u0026gt;static_cast\u0026lt;/strong\u0026gt; as the equivalent of a C-style cast that does value conversion, or when we need to explicitly up-cast a pointer from a class to its superclass.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;strong\u0026gt;const_cast\u0026lt;/strong\u0026gt; to remove the const qualifier.  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;strong\u0026gt;reinterpret_cast\u0026lt;/strong\u0026gt; to do unsafe conversions of pointer types to and from integer and other pointer types. Use this only if we know what we are doing and we understand the aliasing issues.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Nice feature of \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;, not mentioned in the other answers, is that it allows us to create a sort of \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; pointer for function types. Normally, for object types one uses \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt; to retrieve the original type of a pointer stored in \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *p = \u0026amp;amp;i;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; *pi = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;(p);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For functions, we must use \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; twice:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;any_fcn_ptr_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(*)();\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   std::cout \u0026amp;lt;\u0026amp;lt; i \u0026amp;lt;\u0026amp;lt;std::endl;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{     \n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create type-erased pointer to function:\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; any_ptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;any_fcn_ptr_t\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026amp;amp;print);\n  \n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Retrieve the original pointer:\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; ptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(*)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) \u0026amp;gt;(any_ptr);\n  \n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;With \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt; we can even get a similar sort-of-void* pointer for pointers to member functions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As with plain \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, C++ guarantees that \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; points to \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; function (as long as we pass the correct type to \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    "],"id":555,"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","content":"\n                \n\u0026lt;p\u0026gt;What are the proper uses of:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/static_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/dynamic_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/const_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/reinterpret_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/explicit_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(type)value\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (C-style cast)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/explicit_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;type(value)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (function-style cast)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;How does one decide which to use in which specific cases?\u0026lt;/p\u0026gt;\n    ","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205","postType":"QUESTION","createdAt":"2022-07-09T17:40:06.000Z","updatedAt":"2022-07-09T17:40:06.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to lazy load images in ListView in Android","slug":"how-to-lazy-load-images-in-listview-in-android-1657387332835"},{"title":"Does Python have a ternary conditional operator?","slug":"does-python-have-a-ternary-conditional-operator-1657387555448"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"What is the difference between \"px\", \"dip\", \"dp\" and \"sp\"?","slug":"what-is-the-difference-between-\"px\"-\"dip\"-\"dp\"-and-\"sp\"-1657388093250"},{"title":"How do I attach events to dynamic HTML elements with jQuery? [duplicate]","slug":"how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964"},{"title":"Javascript infamous Loop issue? [duplicate]","slug":"javascript-infamous-loop-issue-duplicate-1657387498530"},{"title":"How to print a number with commas as thousands separators in JavaScript","slug":"how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379"},{"title":"Can I mix MySQL APIs in PHP?","slug":"can-i-mix-mysql-apis-in-php-1657384597444"},{"title":"What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?","slug":"what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159"},{"title":"What are the rules for JavaScript's automatic semicolon insertion (ASI)?","slug":"what-are-the-rules-for-javascript's-automatic-semicolon-insertion-(asi)-1657387472789"},{"title":"AsyncTask Android example","slug":"asynctask-android-example-1657388127898"},{"title":"Ways to circumvent the same-origin policy","slug":"ways-to-circumvent-the-same-origin-policy-1657384763316"},{"title":"Persist variables between page loads","slug":"persist-variables-between-page-loads-1657388558452"},{"title":"jQuery Ajax POST example with PHP","slug":"jquery-ajax-post-example-with-php-1657387402634"},{"title":"Submit same Partial View called multiple times data to controller?","slug":"submit-same-partial-view-called-multiple-times-data-to-controller-1657387887213"},{"title":"When should I use a return statement in ES6 arrow functions","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113"},{"title":"How does the \"this\" keyword work, and when should it be used?","slug":"how-does-the-\"this\"-keyword-work-and-when-should-it-be-used-1657384384385"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"},{"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"},{"title":"How do I expire a PHP session after 30 minutes?","slug":"how-do-i-expire-a-php-session-after-30-minutes-1657387990658"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"},"buildId":"5tS3Jli5j89_wXapXajXn","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>