{"pageProps":{"data":{"answer":["\n&lt;p&gt;&lt;code&gt;is&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if two variables point to the same object (in memory), &lt;code&gt;==&lt;/code&gt; if the objects referred to by the variables are equal.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = a\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a \n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b == a\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Make a new copy of list `a` via the slice operator, &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# and assign it to variable `b`&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = a[:] \n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b == a\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;**&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; == &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;**&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The same holds true for string literals:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt; * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; x * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; intern(x*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Please see &lt;a href=&quot;https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none&quot;&gt;this question&lt;/a&gt; as well.&lt;/p&gt;\n    ","\n&lt;p&gt;There is a simple rule of thumb to tell you when to use &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;is&lt;/code&gt;.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;==&lt;/code&gt; is for &lt;em&gt;value equality&lt;/em&gt;. Use it when you would like to know if two objects have the same value.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;is&lt;/code&gt; is for &lt;em&gt;reference equality&lt;/em&gt;. Use it when you would like to know if two references refer to the same object.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In general, when you are comparing something to a simple type, you are usually checking for &lt;em&gt;value equality&lt;/em&gt;, so you should use &lt;code&gt;==&lt;/code&gt;. For example, the intention of your example is probably to check whether x has a value equal to 2 (&lt;code&gt;==&lt;/code&gt;), not whether &lt;code&gt;x&lt;/code&gt; is literally referring to the same object as 2.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Something else to note: because of the way the CPython reference implementation works, you&apos;ll get unexpected and inconsistent results if you mistakenly use &lt;code&gt;is&lt;/code&gt; to compare for reference equality on integers:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == b\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That&apos;s pretty much what we expected: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value, but are distinct entities. But what about this?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c == d\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; d\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is inconsistent with the earlier result. What&apos;s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here&apos;s an example demonstrating this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;260&lt;/span&gt;): a = i; &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;%i: %s&quot;&lt;/span&gt; % (i, a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(i)));\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;251&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;252&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;253&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;254&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;257&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;258&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;259&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is another obvious reason not to use &lt;code&gt;is&lt;/code&gt;: the behavior is left up to implementations when you&apos;re erroneously using it for value equality.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;h2&gt;Is there a difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;is&lt;/code&gt; in Python?&lt;/h2&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Yes, they have a very important difference.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;==&lt;/code&gt;&lt;/strong&gt;: check for equality - the semantics are that equivalent objects (that aren&apos;t necessarily the same object) will test as equal. As the &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#value-comparisons&quot; rel=&quot;noreferrer&quot;&gt;documentation says&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The operators &amp;lt;, &amp;gt;, ==, &amp;gt;=, &amp;lt;=, and != compare the values of two objects.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;is&lt;/code&gt;&lt;/strong&gt;: check for identity - the semantics are that the object (as held in memory) &lt;em&gt;is&lt;/em&gt; the object. Again, the &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#is-not&quot; rel=&quot;noreferrer&quot;&gt;documentation says&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The operators &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;is not&lt;/code&gt; test for object identity: &lt;code&gt;x is y&lt;/code&gt; is true\n  if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the same object. Object identity is\n  determined using the &lt;code&gt;id()&lt;/code&gt; function. &lt;code&gt;x is not y&lt;/code&gt; yields the inverse\n  truth value.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is the same as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(a) == &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(b)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;where &lt;code&gt;id&lt;/code&gt; is the builtin function that returns an integer that &quot;is guaranteed to be unique among simultaneously existing objects&quot; (see &lt;code&gt;help(id)&lt;/code&gt;) and where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are any arbitrary objects.&lt;/p&gt;\n\n&lt;h2&gt;Other Usage Directions&lt;/h2&gt;\n\n&lt;p&gt;You should use these comparisons for their semantics. Use &lt;code&gt;is&lt;/code&gt; to check identity and &lt;code&gt;==&lt;/code&gt; to check equality.&lt;/p&gt;\n\n&lt;p&gt;So in general, we use &lt;code&gt;is&lt;/code&gt; to check for identity. This is usually useful when we are checking for an object that should only exist once in memory, referred to as a &quot;singleton&quot; in the documentation.&lt;/p&gt;\n\n&lt;p&gt;Use cases for &lt;code&gt;is&lt;/code&gt; include:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;None&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;enum values (when using Enums from the enum module)&lt;/li&gt;\n&lt;li&gt;usually modules&lt;/li&gt;\n&lt;li&gt;usually class objects resulting from class definitions&lt;/li&gt;\n&lt;li&gt;usually function objects resulting from function definitions&lt;/li&gt;\n&lt;li&gt;anything else that should only exist once in memory (all singletons, generally)&lt;/li&gt;\n&lt;li&gt;a specific object that you want by identity&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Usual use cases for &lt;code&gt;==&lt;/code&gt; include:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;numbers, including integers&lt;/li&gt;\n&lt;li&gt;strings&lt;/li&gt;\n&lt;li&gt;lists&lt;/li&gt;\n&lt;li&gt;sets&lt;/li&gt;\n&lt;li&gt;dictionaries&lt;/li&gt;\n&lt;li&gt;custom mutable objects&lt;/li&gt;\n&lt;li&gt;other builtin immutable objects, in most cases&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The general use case, again, for &lt;code&gt;==&lt;/code&gt;, is the object you want may not be the &lt;em&gt;same&lt;/em&gt; object, instead it may be an &lt;em&gt;equivalent&lt;/em&gt; one&lt;/p&gt;\n\n&lt;h3&gt;PEP 8 directions&lt;/h3&gt;\n\n&lt;p&gt;PEP 8, the official Python style guide for the standard library also mentions &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations&quot; rel=&quot;noreferrer&quot;&gt;two use-cases for &lt;code&gt;is&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Comparisons to singletons like &lt;code&gt;None&lt;/code&gt; should always be done with &lt;code&gt;is&lt;/code&gt; or\n  &lt;code&gt;is not&lt;/code&gt;, never the equality operators.&lt;/p&gt;\n  \n  &lt;p&gt;Also, beware of writing &lt;code&gt;if x&lt;/code&gt; when you really mean &lt;code&gt;if x is not None&lt;/code&gt; --\n  e.g. when testing whether a variable or argument that defaults to &lt;code&gt;None&lt;/code&gt;\n  was set to some other value. The other value might have a type (such\n  as a container) that could be false in a boolean context!&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;Inferring equality from identity&lt;/h2&gt;\n\n&lt;p&gt;If &lt;code&gt;is&lt;/code&gt; is true, equality can &lt;em&gt;usually&lt;/em&gt; be inferred - logically, if an object is itself, then it should test as equivalent to itself. &lt;/p&gt;\n\n&lt;p&gt;In most cases this logic is true, but it relies on the implementation of the &lt;code&gt;__eq__&lt;/code&gt; special method. As the &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#value-comparisons&quot; rel=&quot;noreferrer&quot;&gt;docs&lt;/a&gt; say, &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The default behavior for equality comparison (&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;) is based on\n  the identity of the objects. Hence, equality comparison of instances\n  with the same identity results in equality, and equality comparison of\n  instances with different identities results in inequality. A\n  motivation for this default behavior is the desire that all objects\n  should be reflexive (i.e. x is y implies x == y).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and in the interests of consistency, recommends:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Equality comparison should be reflexive. In other words, identical\n  objects should compare equal:&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;x is y&lt;/code&gt; implies &lt;code&gt;x == y&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;We can see that this is the default behavior for custom objects:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;): &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;obj = Object()\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;obj2 = Object()\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;obj == obj, obj &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; obj\n(&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;obj == obj2, obj &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; obj2\n(&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. &lt;/p&gt;\n\n&lt;p&gt;Since tests for equality can be customized, this inference does not always hold true for all types.&lt;/p&gt;\n\n&lt;h3&gt;An exception&lt;/h3&gt;\n\n&lt;p&gt;A notable exception is &lt;code&gt;nan&lt;/code&gt; - it always tests as not equal to itself:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nan = &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;nan&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nan\nnan\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nan &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; nan\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nan == nan           &lt;span class=&quot;hljs-comment&quot;&gt;# !!!!!&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). &lt;/p&gt;\n\n&lt;p&gt;But it cannot be substituted for equality where you may find more than one object as equivalent.&lt;/p&gt;\n\n&lt;p&gt;Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for &lt;code&gt;nan&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;[nan] == [nan]\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;(nan,) == (nan,)\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;A Cautionary Tale:&lt;/h2&gt;\n\n&lt;p&gt;The question is attempting to use &lt;code&gt;is&lt;/code&gt; to compare integers. You shouldn&apos;t assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.&lt;/p&gt;\n\n&lt;p&gt;A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached.  gwg&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It worked in development. It may have passed some unittests. &lt;/p&gt;\n\n&lt;p&gt;And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. &lt;/p&gt;\n\n&lt;p&gt;This is a production failure that could have been caught in code review or possibly with a style-checker.&lt;/p&gt;\n\n&lt;p&gt;Let me emphasize: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/28864111/541136&quot;&gt;do not use &lt;code&gt;is&lt;/code&gt; to compare integers.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; determines if the values are equal, while &lt;code&gt;is&lt;/code&gt; determines if they are the exact same object.&lt;/p&gt;\n    ","\n&lt;h1&gt;What&apos;s the difference between &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;?&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;is&lt;/code&gt; are different comparison! As others already said:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;==&lt;/code&gt; compares the values of the objects.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;is&lt;/code&gt; compares the references of the objects.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In Python names refer to objects, for example in this case &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; refer to an &lt;code&gt;int&lt;/code&gt; instance storing the value &lt;code&gt;1000&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;value1 = &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;\nvalue2 = value1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/WLzXy.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/WLzXy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Because &lt;code&gt;value2&lt;/code&gt; refers to the same object &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; will give &lt;code&gt;True&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value1 == value2\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value1 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; value2\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the following example the names &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; refer to different &lt;code&gt;int&lt;/code&gt; instances, even if both store the same integer:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value1 = &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value2 = &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/IJgBI.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/IJgBI.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Because the same value (integer) is stored &lt;code&gt;==&lt;/code&gt; will be &lt;code&gt;True&lt;/code&gt;, that&apos;s why it&apos;s often called &quot;value comparison&quot;. However &lt;code&gt;is&lt;/code&gt; will return &lt;code&gt;False&lt;/code&gt; because these are different objects:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value1 == value2\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;value1 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; value2\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;When to use which?&lt;/h2&gt;\n&lt;p&gt;Generally &lt;code&gt;is&lt;/code&gt; is a much faster comparison. That&apos;s why CPython caches (or maybe &lt;em&gt;reuses&lt;/em&gt; would be the better term) certain objects like small integers, some strings, etc. But this should be treated as &lt;em&gt;implementation detail&lt;/em&gt; that could (even if unlikely) change at any point without warning.&lt;/p&gt;\n&lt;p&gt;You should &lt;strong&gt;only use &lt;code&gt;is&lt;/code&gt;&lt;/strong&gt; if you:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;want to check if two objects are really the same object (not just the same &quot;value&quot;). One example can be if &lt;em&gt;you&lt;/em&gt; use a singleton object as constant.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;want to compare a value to a &lt;a href=&quot;https://docs.python.org/library/constants.html&quot; rel=&quot;noreferrer&quot;&gt;Python &lt;em&gt;constant&lt;/em&gt;&lt;/a&gt;. The constants in Python are:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;None&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;True&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;False&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;__debug__&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;classes (for example &lt;code&gt;int is int&lt;/code&gt; or &lt;code&gt;int is float&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;there could be additional constants in built-in modules or 3rd party modules. For example &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.masked&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;np.ma.masked&lt;/code&gt;&lt;/a&gt; from the NumPy module)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In &lt;strong&gt;every other case you should use &lt;code&gt;==&lt;/code&gt;&lt;/strong&gt; to check for equality.&lt;/p&gt;\n&lt;h2&gt;Can I customize the behavior?&lt;/h2&gt;\n&lt;p&gt;There is some aspect to &lt;code&gt;==&lt;/code&gt; that hasn&apos;t been mentioned already in the other answers: It&apos;s part of &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#data-model&quot; rel=&quot;noreferrer&quot;&gt;Pythons &quot;Data model&quot;&lt;/a&gt;. That means its behavior can be customized using the &lt;a href=&quot;https://docs.python.org/reference/datamodel.html#object.__eq__&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;__eq__&lt;/code&gt;&lt;/a&gt; method. For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyClass&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, val&lt;/span&gt;):\n        self._value = val\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__eq__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, other&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;__eq__ method called&apos;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._value == other._value\n        &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; AttributeError:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; TypeError(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cannot compare {0} to objects of type {1}&apos;&lt;/span&gt;\n                            .&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(self), &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(other)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is just an artificial example to illustrate that the method is really called:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;MyClass(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) == MyClass(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)\n__eq__ method called\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that by default (if no other implementation of &lt;code&gt;__eq__&lt;/code&gt; can be found in the class or the superclasses) &lt;code&gt;__eq__&lt;/code&gt; uses &lt;code&gt;is&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;AClass&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, value&lt;/span&gt;):\n        self._value = value\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = AClass(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = AClass(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == b\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So it&apos;s actually important to implement &lt;code&gt;__eq__&lt;/code&gt; if you want &quot;more&quot; than just reference-comparison for custom classes!&lt;/p&gt;\n&lt;p&gt;On the other hand you cannot customize &lt;code&gt;is&lt;/code&gt; checks. It will always compare &lt;em&gt;just&lt;/em&gt; if you have the same reference.&lt;/p&gt;\n&lt;h2&gt;Will these comparisons always return a boolean?&lt;/h2&gt;\n&lt;p&gt;Because &lt;code&gt;__eq__&lt;/code&gt; can be re-implemented or overridden, it&apos;s not limited to return &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. It &lt;em&gt;could&lt;/em&gt; return anything (but in most cases it should return a boolean!).&lt;/p&gt;\n&lt;p&gt;For example with NumPy arrays the &lt;code&gt;==&lt;/code&gt; will return an array:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;np.arange(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) == &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\narray([&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;,  &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;], dtype=&lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But &lt;code&gt;is&lt;/code&gt; checks will always return &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;!&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; As Aaron Hall mentioned in the comments:&lt;/p&gt;\n&lt;p&gt;Generally you shouldn&apos;t do any &lt;code&gt;is True&lt;/code&gt; or &lt;code&gt;is False&lt;/code&gt; checks because one normally uses these &quot;checks&quot; in a context that implicitly converts the &lt;em&gt;condition&lt;/em&gt; to a boolean (for example in an &lt;code&gt;if&lt;/code&gt; statement). So doing the &lt;code&gt;is True&lt;/code&gt; comparison &lt;strong&gt;and&lt;/strong&gt; the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn&apos;t considered pythonic).&lt;/p&gt;\n&lt;p&gt;Like PEP8 mentions:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Don&apos;t compare boolean values to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; using &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;Yes:   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; greeting:\nNo:    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; greeting == &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\nWorse: &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; greeting &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;They are &lt;b&gt;completely different&lt;/b&gt;.  &lt;code&gt;is&lt;/code&gt; checks for object identity, while &lt;code&gt;==&lt;/code&gt; checks for equality (a notion that depends on the two operands&apos; types).&lt;/p&gt;\n\n&lt;p&gt;It is only a lucky coincidence that &quot;&lt;code&gt;is&lt;/code&gt;&quot; seems to work correctly with small integers (e.g. 5 == 4+1).  That is because &lt;a href=&quot;https://docs.python.org/2/c-api/int.html#c.PyInt_FromLong&quot; rel=&quot;noreferrer&quot;&gt;CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons&lt;/a&gt;. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.&lt;/p&gt;\n\n&lt;p&gt;For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;[:] + &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;[:] + &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://docs.python.org/library/stdtypes.html#comparisons&quot; rel=&quot;noreferrer&quot;&gt;https://docs.python.org/library/stdtypes.html#comparisons&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;is&lt;/code&gt; tests for identity\n&lt;code&gt;==&lt;/code&gt; tests for equality&lt;/p&gt;\n\n&lt;p&gt;Each (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though&lt;/p&gt;\n    ","\n&lt;p&gt;Your answer is correct. The &lt;code&gt;is&lt;/code&gt; operator compares the identity of two objects.  The &lt;code&gt;==&lt;/code&gt; operator compares the values of two objects.&lt;/p&gt;\n\n&lt;p&gt;An object&apos;s identity never changes once it has been created; you may think of it as the object&apos;s address in memory.&lt;/p&gt;\n\n&lt;p&gt;You can control comparison behaviour of object values by defining a &lt;code&gt;__cmp__&lt;/code&gt; method or a &lt;a href=&quot;https://docs.python.org/reference/datamodel.html#basic-customization&quot; rel=&quot;nofollow noreferrer&quot;&gt;rich comparison&lt;/a&gt; method like &lt;code&gt;__eq__&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Have a look at Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/306313&quot;&gt;Python&apos;s is operator behaves unexpectedly with integers&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;What it mostly boils down to is that &quot;&lt;code&gt;is&lt;/code&gt;&quot; checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).&lt;/p&gt;\n    ","\n&lt;p&gt;In a nutshell, &lt;code&gt;is&lt;/code&gt; checks whether two references point to the same object or not.&lt;code&gt;==&lt;/code&gt; checks whether two objects have the same value or not.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\nb=a        &lt;span class=&quot;hljs-comment&quot;&gt;#a and b point to the same object&lt;/span&gt;\nc=&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(a)  &lt;span class=&quot;hljs-comment&quot;&gt;#c points to different object &lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; a==b:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#&apos;&lt;/span&gt;)   &lt;span class=&quot;hljs-comment&quot;&gt;#output:#&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;##&apos;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;#output:## &lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; a==c:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;###&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;#output:## &lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; c:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;####&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;#no output as c and a point to different object &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As the other people in this post answer the question in details the difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;is&lt;/code&gt; for comparing Objects or variables, I would &lt;strong&gt;emphasize&lt;/strong&gt; mainly the comparison between &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; &lt;strong&gt;for strings&lt;/strong&gt; which can give different results and I would urge programmers to carefully use them.&lt;/p&gt;\n&lt;p&gt;For string comparison, make sure to use &lt;code&gt;==&lt;/code&gt; instead of &lt;code&gt;is&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&apos;str is hello&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&apos;str == hello&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Out:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; hello\n&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; == hello\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;But&lt;/strong&gt; in the below example &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;is&lt;/code&gt; will get different results:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;str2 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello sam&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str2 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello sam&apos;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&apos;str2 is hello sam&apos;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str2 == &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello sam&apos;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&apos;str2 == hello sam&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Out:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;str2 == hello sam\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Conclusion and Analysis:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Use &lt;code&gt;is&lt;/code&gt; carefully to compare between strings.\nSince &lt;code&gt;is&lt;/code&gt; for comparing objects and since in Python 3+ every variable such as string interpret as an object, let&apos;s see what happened in above paragraphs.&lt;/p&gt;\n&lt;p&gt;In python there is &lt;a href=&quot;https://www.geeksforgeeks.org/id-function-python/#:%7E:text=id()%20is%20an%20inbuilt,the%20same%20id()%20value.&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; function that shows a unique constant of an object during its lifetime. This id is using in back-end of Python interpreter to compare two objects using &lt;code&gt;is&lt;/code&gt; keyword.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;)\n&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;140039832615152&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;)\n&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;140039832615152&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;str2 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello sam&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;hello sam&apos;&lt;/span&gt;)\n&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;140039832615536&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(str2)\n&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;140039832615792&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I&apos;d just like to categorise what you would do the rest of the time:&lt;/p&gt;\n\n&lt;p&gt;There is one and only one instance of NoneType i.e. None is a singleton. Consequently &lt;code&gt;foo == None&lt;/code&gt; and &lt;code&gt;foo is None&lt;/code&gt; mean the same. However the &lt;code&gt;is&lt;/code&gt; test is faster and the Pythonic convention is to use &lt;code&gt;foo is None&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;bar&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;True and False are also (now) singletons, but there is no use-case for &lt;code&gt;foo == True&lt;/code&gt; and no use case for &lt;code&gt;foo is True&lt;/code&gt;. &lt;/p&gt;\n    ","\n&lt;p&gt;Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;== if the objects referred to by the variables are equal&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;from above answers should be read as &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;== if the objects referred to by the variables are equal and objects belonging to the same type/class&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;. I arrived at this conclusion based on the below test:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;list1 = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\ntuple1 = (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(list1)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(tuple1)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(list1))\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(tuple1))\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(list1 == tuple1)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(list1 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; tuple1)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the contents of the list and tuple are same but the type/class are different. &lt;/p&gt;\n    ","\n&lt;p&gt;Python difference between is and equals(==)&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The is operator may seem like the same as the equality operator but\n  they are not same.&lt;/p&gt;\n  \n  &lt;p&gt;The is checks if both the variables point to the same object whereas\n  the == sign checks if the values for the two variables are the same.&lt;/p&gt;\n  \n  &lt;p&gt;So if the is operator returns True then the equality is definitely\n  True, but the opposite may or may not be True.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Here is an example to demonstrate the similarity and the difference.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = b = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == b\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == c\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; c\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == b\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a == b\n&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; b\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;Tip: Avoid using &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; operator &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; immutable types such &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; strings &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; numbers, the result &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; unpredictable.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    "],"id":413,"title":"Is there a difference between \"==\" and \"is\"?","content":"\n                    &lt;div&gt;\n            &lt;aside class=&quot;s-notice s-notice__info post-notice js-post-notice mb16&quot; role=&quot;status&quot;&gt;\n        &lt;div class=&quot;d-flex fd-column fw-nowrap&quot;&gt;\n            &lt;div class=&quot;d-flex fw-nowrap&quot;&gt;\n                    &lt;div class=&quot;flex--item mr8&quot;&gt;\n                        &lt;svg aria-hidden=&quot;true&quot; class=&quot;svg-icon iconLock&quot; width=&quot;18&quot; height=&quot;18&quot; viewBox=&quot;0 0 18 18&quot;&gt;&lt;path d=&quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                    &lt;/div&gt;\n                &lt;div class=&quot;flex--item wmn0 fl1 lh-lg&quot;&gt;\n                    &lt;div class=&quot;flex--item fl1 lh-lg&quot;&gt;\n                        &lt;b&gt;This question&apos;s answers are a &lt;a href=&quot;/help/privileges/edit-community-wiki&quot;&gt;community effort&lt;/a&gt;&lt;/b&gt;. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n&lt;/aside&gt;\n\n    &lt;/div&gt;\n\n&lt;p&gt;My &lt;a href=&quot;https://english.stackexchange.com/questions/19967/what-does-google-fu-mean&quot;&gt;Google-fu&lt;/a&gt; has failed me.&lt;/p&gt;\n\n&lt;p&gt;In Python, are the following two tests for equality equivalent?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;n = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Test one.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay!&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Test two.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay!&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Does this hold true for objects where you would be comparing instances (a &lt;code&gt;list&lt;/code&gt; say)?&lt;/p&gt;\n\n&lt;p&gt;Okay, so this kind of answers my question:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;L = []\nL.append(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; L == [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay!&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Holds true, but...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; L &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay!&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Doesn&apos;t.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So &lt;code&gt;==&lt;/code&gt; tests value where &lt;code&gt;is&lt;/code&gt; tests to see if they are the same object?&lt;/p&gt;\n    ","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231","postType":"QUESTION","createdAt":"2022-07-09T17:31:42.000Z","updatedAt":"2022-07-09T17:31:42.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"Removing trailing newline character from fgets() input","slug":"removing-trailing-newline-character-from-fgets()-input-1657387308069"},{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"Using regular expressions to parse HTML: why not?","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},{"title":".prop() vs .attr()","slug":".prop()-vs-.attr()-1657384898328"},{"title":"Why do we always prefer using parameters in SQL statements?","slug":"why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"Scroll to an element with jQuery","slug":"scroll-to-an-element-with-jquery-1657388523178"},{"title":"How to read a file line-by-line into a list?","slug":"how-to-read-a-file-line-by-line-into-a-list-1657387865894"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"},{"title":"How to add to the PYTHONPATH in Windows, so it finds my modules/packages?","slug":"how-to-add-to-the-pythonpath-in-windows-so-it-finds-my-modulespackages-1657388540360"},{"title":"How can I return pivot table output in MySQL?","slug":"how-can-i-return-pivot-table-output-in-mysql-1657384715043"},{"title":"How do I convert an existing callback API to promises?","slug":"how-do-i-convert-an-existing-callback-api-to-promises-1657384694006"},{"title":"Creating multiline strings in JavaScript","slug":"creating-multiline-strings-in-javascript-1657388025414"},{"title":"What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?","slug":"what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095"},{"title":"How can I deserialize JSON with C#?","slug":"how-can-i-deserialize-json-with-c-1657388102941"}]},"__N_SSG":true}