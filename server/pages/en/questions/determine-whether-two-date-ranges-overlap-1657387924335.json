{"pageProps":{"data":{"answer":["\n&lt;p&gt;&lt;strong&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt;= StartB)&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Proof:&lt;/em&gt;&lt;br&gt;\nLet ConditionA Mean that DateRange A Completely After DateRange B&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;_                        |---- DateRange A ------|\n|---Date Range B -----|                          _\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(True if &lt;code&gt;StartA &amp;gt; EndB&lt;/code&gt;)&lt;/p&gt;\n&lt;p&gt;Let ConditionB Mean that DateRange A is Completely Before DateRange B&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;|---- DateRange A -----|                        _ \n_                          |---Date Range B ----|\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(True if &lt;code&gt;EndA &amp;lt; StartB&lt;/code&gt;)&lt;/p&gt;\n&lt;p&gt;Then Overlap exists if Neither A Nor B is true -&lt;br&gt;\n(If one range is neither completely after the other,&lt;br&gt;\nnor completely before the other,\nthen they must overlap.)&lt;/p&gt;\n&lt;p&gt;Now one of &lt;a href=&quot;https://en.wikipedia.org/wiki/De_Morgan%27s_laws&quot; rel=&quot;noreferrer&quot;&gt;De Morgan&apos;s laws&lt;/a&gt; says that:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Not (A Or B)&lt;/code&gt;  &amp;lt;=&amp;gt;  &lt;code&gt;Not A And Not B&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Which translates to: &lt;code&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt;= StartB)&lt;/code&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;NOTE: This includes conditions where the edges overlap exactly.  If you wish to exclude that,&lt;br&gt;\nchange the &lt;code&gt;&amp;gt;=&lt;/code&gt; operators to &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&lt;/code&gt;  to &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;NOTE2. Thanks to @Baodad, see &lt;a href=&quot;http://baodad.blogspot.com/2014/06/date-range-overlap.html&quot; rel=&quot;noreferrer&quot;&gt;this blog&lt;/a&gt;, the actual overlap is least of:&lt;br&gt;\n{ &lt;code&gt;endA-startA&lt;/code&gt;, &lt;code&gt;endA - startB&lt;/code&gt;, &lt;code&gt;endB-startA&lt;/code&gt;, &lt;code&gt;endB - startB&lt;/code&gt; }&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt;= StartB)&lt;/code&gt;\n&lt;code&gt;(StartA &amp;lt;= EndB)  and  (StartB &amp;lt;= EndA)&lt;/code&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;NOTE3. Thanks to @tomosius, a shorter version reads:&lt;br&gt;\n&lt;code&gt;DateRangesOverlap = max(start1, start2) &amp;lt; min(end1, end2)&lt;/code&gt;&lt;br&gt;\nThis is actually a syntactical shortcut for what is a longer implementation, which includes extra checks to verify that the start dates are on or before the endDates.  Deriving this from above:&lt;/p&gt;\n&lt;p&gt;If start and end dates can be out of order, i.e., if it is possible that &lt;code&gt;startA &amp;gt; endA&lt;/code&gt; or &lt;code&gt;startB &amp;gt; endB&lt;/code&gt;, then you also have to check that they are in order, so that means you have to add two additional validity rules:&lt;br&gt;\n&lt;code&gt;(StartA &amp;lt;= EndB) and (StartB &amp;lt;= EndA) and (StartA &amp;lt;= EndA) and (StartB &amp;lt;= EndB)&lt;/code&gt;\nor:&lt;br&gt;\n&lt;code&gt;(StartA &amp;lt;= EndB) and (StartA &amp;lt;= EndA) and (StartB &amp;lt;= EndA) and (StartB &amp;lt;= EndB)&lt;/code&gt;\nor,&lt;br&gt;\n&lt;code&gt;(StartA &amp;lt;= Min(EndA, EndB) and (StartB &amp;lt;= Min(EndA, EndB))&lt;/code&gt;\nor:&lt;br&gt;\n&lt;code&gt;(Max(StartA, StartB) &amp;lt;= Min(EndA, EndB)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;But to implement &lt;code&gt;Min()&lt;/code&gt; and &lt;code&gt;Max()&lt;/code&gt;, you have to code, (using C ternary for terseness),:&lt;br&gt;\n&lt;code&gt;(StartA &amp;gt; StartB? Start A: StartB) &amp;lt;= (EndA &amp;lt; EndB? EndA: EndB)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;NOTE4.  Thanks to Carl for noticing this, but  &lt;a href=&quot;https://stackoverflow.com/questions/27430253/find-if-given-date-range-inside-another-date-range-in-mysql/27430668#27430668&quot;&gt;another answer&lt;/a&gt; shows an equivalent mathematical expression for this logical expression. Because the product of any two real numbers with opposite sign is negative and with the same sign it is positive, if you convert the datetimes to fractional numbers (and most DBMSs internally use numbers to represent datetimes), the above logical expression can also be evaluated using the following mathematical expression:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;(EndA  - StartA) * (StartB - EndB) &amp;lt;= 0\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I believe that it is sufficient to say that the two ranges overlap if:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;(StartDate1 &amp;lt;= EndDate2) and (StartDate2 &amp;lt;= EndDate1)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This article &lt;a href=&quot;http://www.codeproject.com/KB/datetime/TimePeriod.aspx&quot;&gt;Time Period Library for .NET&lt;/a&gt; describes the relation of two time periods by the enumeration &lt;strong&gt;PeriodRelation&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// ------------------------------------------------------------------------\npublic enum PeriodRelation\n{\n    After,\n    StartTouching,\n    StartInside,\n    InsideStartTouching,\n    EnclosingStartTouching,\n    Enclosing,\n    EnclosingEndTouching,\n    ExactMatch,\n    Inside,\n    InsideEndTouching,\n    EndInside,\n    EndTouching,\n    Before,\n} // enum PeriodRelation\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/0c6q0.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;For reasoning about temporal relations (or any other interval relations, come to that), consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Allen%27s_Interval_Algebra&quot; rel=&quot;noreferrer&quot;&gt;Allen&apos;s Interval Algebra&lt;/a&gt;.  It describes the 13 possible relations that two intervals can have with respect to each other.  You can find other references  &quot;Allen Interval&quot; seems to be an operative search term.  You can also find information about these operations in Snodgrass&apos;s &lt;a href=&quot;http://www.cs.arizona.edu/~rts/publications.html&quot; rel=&quot;noreferrer&quot;&gt;Developing Time-Oriented Applications in SQL&lt;/a&gt; (PDF available online at URL), and in Date, Darwen and Lorentzos &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B005UY0W0E&quot; rel=&quot;noreferrer&quot;&gt;Temporal Data and the Relational Model&lt;/a&gt; (2002) or  &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B00N2SNSUG&quot; rel=&quot;noreferrer&quot;&gt;Time and Relational Theory: Temporal Databases in the Relational Model and SQL&lt;/a&gt; (2014; effectively the second edition of TD&amp;amp;RM).&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The short(ish) answer is: given two date intervals &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; with components &lt;code&gt;.start&lt;/code&gt; and &lt;code&gt;.end&lt;/code&gt; and the constraint &lt;code&gt;.start &amp;lt;= .end&lt;/code&gt;, then two intervals overlap if:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A.end &amp;gt;= B.start AND A.start &amp;lt;= B.end\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can tune the use of &lt;code&gt;&amp;gt;=&lt;/code&gt; vs &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;=&lt;/code&gt; vs &lt;code&gt;&amp;lt;&lt;/code&gt; to meet your requirements for degree of overlap.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;ErikE comments:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;You can only get 13 if you count things funny... I can get &quot;15 possible relations that two intervals can have&quot; when I go crazy with it. By sensible counting, I get only six, and if you throw out caring whether A or B comes first, I get only three (no intersect, partially intersect, one wholly within other). 15 goes like this: [before:before, start, within, end, after], [start:start, within, end, after], [within:within, end, after], [end:end, after], [after:after]. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I think that you cannot count the two entries &apos;before:before&apos; and &apos;after:after&apos;.  I could see 7 entries if you equate some relations with their inverses (see the diagram in the referenced Wikipedia URL; it has 7 entries, 6 of which have a different inverse, with equals not having a distinct inverse).  And whether three is sensible depends on your requirements.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;----------------------|-------A-------|----------------------\n    |----B1----|\n           |----B2----|\n               |----B3----|\n               |----------B4----------|\n               |----------------B5----------------|\n                      |----B6----|\n----------------------|-------A-------|----------------------\n                      |------B7-------|\n                      |----------B8-----------|\n                         |----B9----|\n                         |----B10-----|\n                         |--------B11--------|\n                                      |----B12----|\n                                         |----B13----|\n----------------------|-------A-------|----------------------\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If the overlap itself should be calculated as well, you can use the following formula:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;overlap = max(0, min(EndDate1, EndDate2) - max(StartDate1, StartDate2))\nif (overlap &amp;gt; 0) { \n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;All the solutions that check a multitude of conditions based on where the ranges are in relation to one another can be greatly simplified by &lt;em&gt;&lt;strong&gt;simply ensuring that one range starts before or at the same time as the other.&lt;/strong&gt;&lt;/em&gt; You can do this by swapping the ranges if necessary up front.&lt;/p&gt;\n&lt;p&gt;Then, you can detect overlap if the second range start is either:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;less than or equal to the first range end (if ranges are inclusive, containing both the start and end times); or&lt;/li&gt;\n&lt;li&gt;less than (if ranges are inclusive of start and exclusive of end).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;For example (assuming inclusive at both ends), there&apos;s only four possibilities for range 2of which &lt;em&gt;one&lt;/em&gt; is a non-overlap (the &lt;code&gt;&amp;gt;&lt;/code&gt; at the end of the range means it doesn&apos;t matter where the range ends):&lt;/p&gt;\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;|-----|        range 1, lines below are all range 2.\n|--&amp;gt;  :        overlap.\n |--&amp;gt; :        overlap.\n      |---&amp;gt;    overlap (no overlap in exclusive-of-end case).\n       |---&amp;gt;   no overlap.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;em&gt;endpoint&lt;/em&gt; of the second range doesn&apos;t affect the result at all. So, in pseudo-code, you can do something like (assuming &lt;code&gt;s &amp;lt;= e&lt;/code&gt; within a given range):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;hasOverlap&lt;/span&gt; (r1, r2):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; r1.s &amp;gt; r2.s: swap r1, r2\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r2.s &amp;lt;= r1.e\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If the ranges are &lt;em&gt;exclusive&lt;/em&gt; at the end, you just have to replace &lt;code&gt;&amp;lt;=&lt;/code&gt; with &lt;code&gt;&amp;lt;&lt;/code&gt; in the expression you return.&lt;/p&gt;\n&lt;p&gt;This greatly limits the number of checks you have to make because you remove half of the problem space early by ensuring the first range never starts after the second.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;And, since &quot;code talks&quot;, here is some Python code that shows this in action, with quite a few test cases. First, the &lt;code&gt;InclusiveRange&lt;/code&gt; class:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;InclusiveRange&lt;/span&gt;:\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;InclusiveRange class to represent a lower and upper bound&quot;&quot;&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, start, end&lt;/span&gt;):\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Initialisation ensures start &amp;lt;= end&quot;&quot;&quot;&lt;/span&gt;\n        self.start = &lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(start, end)\n        self.end = &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(start, end)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__repr__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot; Return representation for f-string&quot;&quot;&quot;&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;f&quot;(&lt;span class=&quot;hljs-subst&quot;&gt;{self.start}&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;{self.end}&lt;/span&gt;)&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;overlaps&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, other&lt;/span&gt;):\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;True if range overlaps with another&quot;&quot;&quot;&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# Very limited recursion to ensure start of first range&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# isn&apos;t after start of second.&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.start &amp;gt; other.start:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; other.overlaps(self)\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# Greatly simplified check for overlap.&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; other.start &amp;lt;= self.end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then a test case handler to allow us to nicely present the result of a &lt;em&gt;single&lt;/em&gt; test case:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test_case&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;range1, range2&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Single test case checker&quot;&quot;&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# Get low and high value for &quot;graphic&quot; output.&lt;/span&gt;\n\n    low = &lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(range1.start, range2.start)\n    high = &lt;span class=&quot;hljs-built_in&quot;&gt;max&lt;/span&gt;(range1.end, range2.end)\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# Output ranges and graphic.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot;r1=&lt;span class=&quot;hljs-subst&quot;&gt;{range1}&lt;/span&gt; r2=&lt;span class=&quot;hljs-subst&quot;&gt;{range2}&lt;/span&gt;: &quot;&lt;/span&gt;, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; val &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(low, high + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):\n        is_in_first = range1.start &amp;lt;= val &amp;lt;= range1.end\n        is_in_second = range2.start &amp;lt;= val &amp;lt;= range2.end\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; is_in_first &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; is_in_second:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; is_in_first:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;&quot;&lt;/span&gt;, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; is_in_second:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# Finally, output result of overlap check.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot; - &lt;span class=&quot;hljs-subst&quot;&gt;{range1.overlaps(range2)}&lt;/span&gt;\\n&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then finally, a decent chunk of test cases to which you can add your own if need be:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Various test cases, add others if you doubt the correctness.&lt;/span&gt;\n\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;))\n\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\ntest_case(InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;), InclusiveRange(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Running that produces the output:&lt;/p&gt;\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;r1=(0, 1) r2=(8, 9): &apos;&apos;      ,, - False\nr1=(0, 4) r2=(5, 9): &apos;&apos;&apos;&apos;&apos;,,,,, - False\nr1=(0, 4) r2=(4, 9): &apos;&apos;&apos;&apos;|,,,,, - True\nr1=(0, 7) r2=(2, 9): &apos;&apos;||||||,, - True\nr1=(0, 4) r2=(0, 9): |||||,,,,, - True\nr1=(0, 9) r2=(0, 9): |||||||||| - True\nr1=(0, 9) r2=(4, 5): &apos;&apos;&apos;&apos;||&apos;&apos;&apos;&apos; - True\nr1=(8, 9) r2=(0, 1): ,,      &apos;&apos; - False\nr1=(5, 9) r2=(0, 4): ,,,,,&apos;&apos;&apos;&apos;&apos; - False\nr1=(4, 9) r2=(0, 4): ,,,,|&apos;&apos;&apos;&apos;&apos; - True\nr1=(2, 9) r2=(0, 7): ,,||||||&apos;&apos; - True\nr1=(0, 9) r2=(0, 4): |||||&apos;&apos;&apos;&apos;&apos; - True\nr1=(0, 9) r2=(0, 9): |||||||||| - True\nr1=(4, 5) r2=(0, 9): ,,,,||,,,, - True\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;where each line has:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the two ranges being evaluated;&lt;/li&gt;\n&lt;li&gt;a graphical representation of the &quot;range space&quot; (from lowest start to highest end) where each character is a value in that &quot;range space&quot;: &lt;code&gt;&apos;&lt;/code&gt; indicates a value in the first range only, &lt;code&gt;,&lt;/code&gt; indicates a value in the second range only, &lt;code&gt;|&lt;/code&gt; indicates a value in both ranges, and &lt;code&gt; &lt;/code&gt; indicates a value in neither range.&lt;/li&gt;\n&lt;li&gt;the result of the overlap check.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;You can see quite clearly that you only get true in the overlap check when there is at least one value in &lt;em&gt;both&lt;/em&gt; ranges (i.e., a &lt;code&gt;|&lt;/code&gt; character). Every other case gives false.&lt;/p&gt;\n&lt;p&gt;Feel free to use any other values if you want to add more test cases.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is yet another solution using JavaScript. Specialities of my solution:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Handles null values as infinity&lt;/li&gt;\n&lt;li&gt;Assumes that the lower bound is inclusive and the upper bound exclusive.&lt;/li&gt;\n&lt;li&gt;Comes with a bunch of tests&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The tests are based on integers but since date objects in JavaScript are comparable you can just throw in two date objects as well. Or you could throw in the millisecond timestamp.&lt;/p&gt;\n\n&lt;h1&gt;Code:&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-javascript s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/**\n * Compares to comparable objects to find out whether they overlap.\n * It is assumed that the interval is in the format [from,to) (read: from is inclusive, to is exclusive).\n * A null value is interpreted as infinity\n */&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;intervalsOverlap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;from1, to1, from2, to2&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (to2 === &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || from1 &amp;lt; to2) &amp;amp;&amp;amp; (to1 === &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || to1 &amp;gt; from2);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Tests:&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-javascript s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title function_&quot;&gt;describe&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;firstRange, secondRange, expected&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;it&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;stringify&lt;/span&gt;(firstRange) + &lt;span class=&quot;hljs-string&quot;&gt;&apos; and &apos;&lt;/span&gt; + &lt;span class=&quot;hljs-title class_&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;stringify&lt;/span&gt;(secondRange), &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n            &lt;span class=&quot;hljs-title function_&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;intervalsOverlap&lt;/span&gt;(firstRange[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], firstRange[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], secondRange[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], secondRange[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])).&lt;span class=&quot;hljs-title function_&quot;&gt;toBe&lt;/span&gt;(expected);\n        });\n    }\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;describe&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;no overlap (touching ends)&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], [&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n    });\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;describe&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;do overlap (one end overlaps)&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n    });\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;describe&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;do overlap (one range included in other range)&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;], [&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n    });\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;describe&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;do overlap (both ranges equal)&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], [&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n        &lt;span class=&quot;hljs-title function_&quot;&gt;generateTest&lt;/span&gt;([&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], [&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);\n    });\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Result when run with karma&amp;amp;jasmine&amp;amp;PhantomJS:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;PhantomJS 1.9.8 (Linux): Executed 20 of 20 SUCCESS (0.003 secs / 0.004 secs)&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/bDVe1.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/bDVe1.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Here is the code that does the magic:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; var isOverlapping =  ((A == null || D == null || A &amp;lt;= D) \n            &amp;amp;&amp;amp; (C == null || B == null || C &amp;lt;= B)\n            &amp;amp;&amp;amp; (A == null || B == null || A &amp;lt;= B)\n            &amp;amp;&amp;amp; (C == null || D == null || C &amp;lt;= D));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Where.. &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;A -&amp;gt; 1Start&lt;/li&gt;\n&lt;li&gt;B -&amp;gt; 1End &lt;/li&gt;\n&lt;li&gt;C -&amp;gt; 2Start &lt;/li&gt;\n&lt;li&gt;D -&amp;gt; 2End&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Proof? Check out this test &lt;a href=&quot;https://gist.github.com/sandeeptalabathula/3b469065251eb1992dd92b168fea0b61&quot; rel=&quot;noreferrer&quot;&gt;console code gist&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;An easy way to remember the solution would be&lt;br&gt;\n&lt;code&gt;min(ends)&amp;gt;max(starts)&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s my solution in &lt;em&gt;Java&lt;/em&gt;, which works on unbounded intervals too&lt;/p&gt;\n\n\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Boolean &lt;span class=&quot;hljs-title function_&quot;&gt;overlap&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(Timestamp startA, Timestamp endA,\n                         Timestamp startB, Timestamp endB)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (endB == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || startA == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || !startA.after(endB))\n        &amp;amp;&amp;amp; (endA == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || startB == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; || !endA.before(startB));\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I would do &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;StartDate1.IsBetween(StartDate2, EndDate2) || EndDate1.IsBetween(StartDate2, EndDate2)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Where &lt;code&gt;IsBetween&lt;/code&gt; is something like &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    public static bool IsBetween(this DateTime value, DateTime left, DateTime right) {\n        return (value &amp;gt; left &amp;amp;&amp;amp; value &amp;lt; right) || (value &amp;lt; left &amp;amp;&amp;amp; value &amp;gt; right);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The solution posted here did not work for all overlapping ranges... &lt;/p&gt;\n\n&lt;pre&gt;----------------------|-------A-------|----------------------\n    |----B1----|\n           |----B2----|\n               |----B3----|\n               |----------B4----------|\n               |----------------B5----------------|\n                      |----B6----|\n----------------------|-------A-------|----------------------\n                      |------B7-------|\n                      |----------B8-----------|\n                         |----B9----|\n                         |----B10-----|\n                         |--------B11--------|\n                                      |----B12----|\n                                         |----B13----|\n----------------------|-------A-------|----------------------&lt;/pre&gt;\n\n&lt;p&gt;my working solution was:&lt;/p&gt;\n\n&lt;pre&gt;AND (\n  (&apos;start_date&apos; BETWEEN STARTDATE AND ENDDATE) -- caters for inner and end date outer\n  OR\n  (&apos;end_date&apos; BETWEEN STARTDATE AND ENDDATE) -- caters for inner and start date outer\n  OR\n  (STARTDATE BETWEEN &apos;start_date&apos; AND &apos;end_date&apos;) -- only one needed for outer range where dates are inside.\n) \n&lt;/pre&gt;\n    ","\n&lt;p&gt;As there have been several answers for different languages and environments, here is one for standard ANSI SQL.&lt;/p&gt;\n&lt;p&gt;In standard SQL it is as as simple as&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;(StartDate1, EndDate1) overlaps (StartDate2, EndDate2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;assuming all four columns are &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt; columns. It returns true if both ranges have at least one day in common (assuming &lt;code&gt;DATE&lt;/code&gt; values)&lt;/p&gt;\n&lt;p&gt;(However not all DBMS products support that)&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;In PostgreSQL it&apos;s also easy to test for &lt;em&gt;inclusion&lt;/em&gt; by using &lt;a href=&quot;https://www.postgresql.org/docs/current/rangetypes.html&quot; rel=&quot;noreferrer&quot;&gt;date ranges&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;daterange(StartDate1, EndDate1) @&amp;gt; daterange(StartDate2, EndDate2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the above returns true if the second range is completely included in the first (which is different to &quot;overlaps&quot;)&lt;/p&gt;\n    ","\n&lt;p&gt;This was my javascript solution with moment.js:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Current row dates\nvar dateStart = moment(&quot;2014-08-01&quot;, &quot;YYYY-MM-DD&quot;);\nvar dateEnd = moment(&quot;2014-08-30&quot;, &quot;YYYY-MM-DD&quot;);\n\n// Check with dates above\nvar rangeUsedStart = moment(&quot;2014-08-02&quot;, &quot;YYYY-MM-DD&quot;);\nvar rangeUsedEnd = moment(&quot;2014-08-015&quot;, &quot;YYYY-MM-DD&quot;);\n\n// Range covers other ?\nif((dateStart &amp;lt;= rangeUsedStart) &amp;amp;&amp;amp; (rangeUsedEnd &amp;lt;= dateEnd)) {\n    return false;\n}\n// Range intersects with other start ?\nif((dateStart &amp;lt;= rangeUsedStart) &amp;amp;&amp;amp; (rangeUsedStart &amp;lt;= dateEnd)) {\n    return false;\n}\n// Range intersects with other end ?\nif((dateStart &amp;lt;= rangeUsedEnd) &amp;amp;&amp;amp; (rangeUsedEnd &amp;lt;= dateEnd)) {\n    return false;\n}\n\n// All good\nreturn true;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Short answer using momentjs&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function isOverlapping(startDate1, endDate1, startDate2, endDate2){ \n    return moment(startDate1).isSameOrBefore(endDate2) &amp;amp;&amp;amp; \n    moment(startDate2).isSameOrBefore(endDate1);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the answer is based on above answers, but its shortened.&lt;/p&gt;\n    ","\n&lt;p&gt;In Microsoft SQL SERVER  - SQL Function   &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;CREATE FUNCTION IsOverlapDates \n(\n    @startDate1 as datetime,\n    @endDate1 as datetime,\n    @startDate2 as datetime,\n    @endDate2 as datetime\n)\nRETURNS int\nAS\nBEGIN\nDECLARE @Overlap as int\nSET @Overlap = (SELECT CASE WHEN  (\n        (@startDate1 BETWEEN @startDate2 AND @endDate2) -- caters for inner and end date outer\n        OR\n        (@endDate1 BETWEEN @startDate2 AND @endDate2) -- caters for inner and start date outer\n        OR\n        (@startDate2 BETWEEN @startDate1 AND @endDate1) -- only one needed for outer range where dates are inside.\n        ) THEN 1 ELSE 0 END\n    )\n    RETURN @Overlap\n\nEND\nGO\n\n--Execution of the above code\nDECLARE @startDate1 as datetime\nDECLARE @endDate1 as datetime\nDECLARE @startDate2 as datetime\nDECLARE @endDate2 as datetime\nDECLARE @Overlap as int\nSET @startDate1 = &apos;2014-06-01 01:00:00&apos; \nSET @endDate1 =   &apos;2014-06-01 02:00:00&apos;\nSET @startDate2 = &apos;2014-06-01 01:00:00&apos; \nSET @endDate2 =   &apos;2014-06-01 01:30:00&apos;\n\nSET @Overlap = [dbo].[IsOverlapDates]  (@startDate1, @endDate1, @startDate2, @endDate2)\n\nSELECT Overlap = @Overlap\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;the simplest&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The simplest way is to use a well-engineered dedicated library for date-time work.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;someInterval.overlaps( anotherInterval )\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;java.time &amp;amp; ThreeTen-Extra&lt;/h1&gt;\n\n&lt;p&gt;The best in the business is the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;java.time&lt;/code&gt;&lt;/a&gt; framework built into Java 8 and later. Add to that the &lt;a href=&quot;http://www.threeten.org/threeten-extra/&quot; rel=&quot;nofollow noreferrer&quot;&gt;ThreeTen-Extra&lt;/a&gt; project that supplements java.time with additional classes, specifically the &lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; class we need here.&lt;/p&gt;\n\n&lt;p&gt;As for the &lt;code&gt;language-agnostic&lt;/code&gt; tag on this Question, the source code for both projects is available for use in other languages (mind their licenses). &lt;/p&gt;\n\n&lt;h2&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/h2&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;org.threeten.extra.Interval&lt;/code&gt;&lt;/a&gt; class is handy, but requires date-time moments (&lt;code&gt;java.time.Instant&lt;/code&gt; objects) rather than date-only values. So we proceed by using the first moment of the day in UTC to represent the date.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Instant&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Instant.parse( &lt;span class=&quot;hljs-string&quot;&gt;&quot;2016-01-01T00:00:00Z&quot;&lt;/span&gt; );\n&lt;span class=&quot;hljs-type&quot;&gt;Instant&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Instant.parse( &lt;span class=&quot;hljs-string&quot;&gt;&quot;2016-02-01T00:00:00Z&quot;&lt;/span&gt; );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Create an &lt;code&gt;Interval&lt;/code&gt; to represent that span of time.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Interval&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;interval_A&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Interval.of( start , stop );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We can also define an &lt;code&gt;Interval&lt;/code&gt; with a starting moment plus a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/time/Duration.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Instant&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;start_B&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Instant.parse( &lt;span class=&quot;hljs-string&quot;&gt;&quot;2016-01-03T00:00:00Z&quot;&lt;/span&gt; );\n&lt;span class=&quot;hljs-type&quot;&gt;Interval&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;interval_B&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Interval.of( start_B , Duration.of( &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; , ChronoUnit.DAYS ) );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Comparing to test for overlaps is easy.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;overlaps&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; interval_A.overlaps( interval_B );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can compare an &lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; against another &lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#abuts-org.threeten.extra.Interval-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;abuts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#contains-java.time.Instant-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#encloses-org.threeten.extra.Interval-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;encloses&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#equals-java.lang.Object-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#isAfter-org.threeten.extra.Interval-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;isAfter&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#isBefore-org.threeten.extra.Interval-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;isBefore&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#overlaps-org.threeten.extra.Interval-&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;overlaps&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;All of these use the &lt;code&gt;Half-Open&lt;/code&gt; approach to defining a span of time where the beginning is &lt;em&gt;inclusive&lt;/em&gt; and the ending is &lt;em&gt;exclusive&lt;/em&gt;. &lt;/p&gt;\n    ","\n&lt;p&gt;I had a situation where we had dates instead of datetimes, and the dates could overlap only on start/end. Example below:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/qzRBx.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/qzRBx.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;(Green is the current interval, blue blocks are valid intervals, red ones are overlapping intervals).&lt;/p&gt;\n\n&lt;p&gt;I adapted Ian Nelson&apos;s answer to the following solution:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   (startB &amp;lt;= startA &amp;amp;&amp;amp; endB &amp;gt; startA)\n|| (startB &amp;gt;= startA &amp;amp;&amp;amp; startB &amp;lt; endA)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This matches all overlap cases but ignores the allowed overlap ones.&lt;/p&gt;\n    ","\n&lt;p&gt;The mathematical solution given by @Bretana is good but neglects two specific details:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;aspect of closed or half-open intervals&lt;/li&gt;\n&lt;li&gt;empty intervals&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;About the closed or open state of interval boundaries, the solution of @Bretana valid &lt;strong&gt;for closed intervals&lt;/strong&gt; &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt;= StartB)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;can be rewritten &lt;strong&gt;for half-open intervals&lt;/strong&gt; to:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;(StartA &amp;lt; EndB) and (EndA &amp;gt; StartB)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This correction is necessary because an open interval boundary does not belong to the value range of an interval by definition.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;And about &lt;strong&gt;empty intervals&lt;/strong&gt;, well, here the relationship shown above does NOT hold. Empty intervals which do not contain any valid value by definition must be handled as special case. I demonstrate it by my Java time library &lt;a href=&quot;https://github.com/MenoData/Time4J&quot; rel=&quot;nofollow noreferrer&quot;&gt;Time4J&lt;/a&gt; via this example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;MomentInterval a = MomentInterval.between(Instant.now(), Instant.now().plusSeconds(2));\nMomentInterval b = a.collapse(); // make b an empty interval out of a\n\nSystem.out.println(a); // [2017-04-10T05:28:11,909000000Z/2017-04-10T05:28:13,909000000Z)\nSystem.out.println(b); // [2017-04-10T05:28:11,909000000Z/2017-04-10T05:28:11,909000000Z)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The leading square bracket &quot;[&quot; indicates a closed start while the last bracket &quot;)&quot; indicates an open end.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;System.out.println(\n      &quot;startA &amp;lt; endB: &quot; + a.getStartAsInstant().isBefore(b.getEndAsInstant())); // false\nSystem.out.println(\n      &quot;endA &amp;gt; startB: &quot; + a.getEndAsInstant().isAfter(b.getStartAsInstant())); // true\n\nSystem.out.println(&quot;a overlaps b: &quot; + a.intersects(b)); // a overlaps b: false\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As shown above, empty intervals violate the overlap condition above (especially startA &amp;lt; endB), so Time4J (and other libraries, too) has to handle it as special edge case in order to guarantee that the overlap of any arbitrary interval with an empty interval does not exist. Of course, date intervals (which are closed by default in Time4J but can be half-open, too, like empty date intervals) are handled in a similar way.&lt;/p&gt;\n    ","\n&lt;p&gt;This is an extension to the &lt;a href=&quot;https://stackoverflow.com/a/325964/2314737&quot;&gt;excellent answer&lt;/a&gt; by @charles-bretana.&lt;/p&gt;\n\n&lt;p&gt;The answer however does not make a distinction among open, closed, and half-open (or half-closed) intervals.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Case 1&lt;/strong&gt;: A, B are closed intervals&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A = [StartA, EndA]\nB = [StartB, EndB]\n\n                         [---- DateRange A ------]   (True if StartA &amp;gt; EndB)\n[--- Date Range B -----]                           \n\n\n[---- DateRange A -----]                             (True if EndA &amp;lt; StartB)\n                         [--- Date Range B ----]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Overlap iff: &lt;code&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt;= StartB)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Case 2&lt;/strong&gt;: A, B are open intervals&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A = (StartA, EndA)\nB = (StartB, EndB)\n\n                         (---- DateRange A ------)   (True if StartA &amp;gt;= EndB)\n(--- Date Range B -----)                           \n\n(---- DateRange A -----)                             (True if EndA &amp;lt;= StartB)\n                         (--- Date Range B ----)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Overlap iff: &lt;code&gt;(StartA &amp;lt; EndB)  and  (EndA &amp;gt; StartB)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Case 3&lt;/strong&gt;: A, B right open &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A = [StartA, EndA)\nB = [StartB, EndB)\n\n                         [---- DateRange A ------)   (True if StartA &amp;gt;= EndB) \n[--- Date Range B -----)                           \n\n[---- DateRange A -----)                             (True if EndA &amp;lt;= StartB)\n                         [--- Date Range B ----)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Overlap condition: &lt;code&gt;(StartA &amp;lt; EndB)  and  (EndA &amp;gt; StartB)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Case 4&lt;/strong&gt;: A, B left open&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A = (StartA, EndA]\nB = (StartB, EndB]\n\n                         (---- DateRange A ------]   (True if StartA &amp;gt;= EndB)\n(--- Date Range B -----]                           \n\n(---- DateRange A -----]                             (True if EndA &amp;lt;= StartB)\n                         (--- Date Range B ----]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Overlap condition: &lt;code&gt;(StartA &amp;lt; EndB)  and  (EndA &amp;gt; StartB)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Case 5&lt;/strong&gt;: A right open, B closed&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;A = [StartA, EndA)\nB = [StartB, EndB]\n\n                         [---- DateRange A ------)    (True if StartA &amp;gt; EndB)\n[--- Date Range B -----]                           \n\n\n[---- DateRange A -----)                              (True if EndA &amp;lt;= StartB)  \n                         [--- Date Range B ----]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Overlap condition: &lt;code&gt;(StartA &amp;lt;= EndB)  and  (EndA &amp;gt; StartB)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;etc...&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Finally, the general condition for two intervals to overlap is &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;(StartA &amp;lt; EndB)  and  (EndA &amp;gt; StartB)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;where  turns a strict inequality into a non-strict one whenever the comparison is made between two included endpoint.&lt;/p&gt;\n    ","\n&lt;p&gt;In case you&apos;re using a date range that has not ended yet (still on going) e.g. not set \nendDate = &apos;0000-00-00&apos; you can not use BETWEEN because 0000-00-00 is not a valid date!&lt;/p&gt;\n\n&lt;p&gt;I used this solution:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;(Startdate BETWEEN &apos;&quot;.$startdate2.&quot;&apos; AND &apos;&quot;.$enddate2.&quot;&apos;)  //overlap: starts between start2/end2\nOR (Startdate &amp;lt; &apos;&quot;.$startdate2.&quot;&apos; \n  AND (enddate = &apos;0000-00-00&apos; OR enddate &amp;gt;= &apos;&quot;.$startdate2.&quot;&apos;)\n) //overlap: starts before start2 and enddate not set 0000-00-00 (still on going) or if enddate is set but higher then startdate2\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If startdate2 is higher then enddate there is no overlap!&lt;/p&gt;\n    ","\n&lt;p&gt;The answer is too simple for me so I have created a more generic dynamic SQL statement which checks to see if a person has any overlapping dates.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;SELECT DISTINCT T1.EmpID\nFROM Table1 T1\nINNER JOIN Table2 T2 ON T1.EmpID = T2.EmpID \n    AND T1.JobID &amp;lt;&amp;gt; T2.JobID\n    AND (\n        (T1.DateFrom &amp;gt;= T2.DateFrom AND T1.dateFrom &amp;lt;= T2.DateTo) \n        OR (T1.DateTo &amp;gt;= T2.DateFrom AND T1.DateTo &amp;lt;= T2.DateTo)\n        OR (T1.DateFrom &amp;lt; T2.DateFrom AND T1.DateTo IS NULL)\n    )\n    AND NOT (T1.DateFrom = T2.DateFrom)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Using Java util.Date, here what I did.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    public static boolean checkTimeOverlaps(Date startDate1, Date endDate1, Date startDate2, Date endDate2)\n    {\n        if (startDate1 == null || endDate1 == null || startDate2 == null || endDate2 == null)\n           return false;\n\n        if ((startDate1.getTime() &amp;lt;= endDate2.getTime()) &amp;amp;&amp;amp; (startDate2.getTime() &amp;lt;= endDate1.getTime()))\n           return true;\n\n        return false;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For ruby I also found this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Interval &amp;lt; ActiveRecord::Base\n\n  validates_presence_of :start_date, :end_date\n\n  # Check if a given interval overlaps this interval    \n  def overlaps?(other)\n    (start_date - other.end_date) * (other.start_date - end_date) &amp;gt;= 0\n  end\n\n  # Return a scope for all interval overlapping the given interval, including the given interval itself\n  named_scope :overlapping, lambda { |interval| {\n    :conditions =&amp;gt; [&quot;id &amp;lt;&amp;gt; ? AND (DATEDIFF(start_date, ?) * DATEDIFF(?, end_date)) &amp;gt;= 0&quot;, interval.id, interval.end_date, interval.start_date]\n  }}\n\nend\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Found it here with nice explaination -&amp;gt;\n&lt;a href=&quot;http://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-rails&quot; rel=&quot;nofollow&quot;&gt;http://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-rails&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;The easiest way to do it in my opinion would be to compare if either EndDate1 is before StartDate2 and EndDate2 is before StartDate1.&lt;/p&gt;\n\n&lt;p&gt;That of course if you are considering intervals where StartDate is always before EndDate.&lt;/p&gt;\n    ","\n&lt;p&gt;If you provide a date range as input and want to find out if it overlaps with the existing date range in database, the following conditions can successfully meet your demand&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Assume you provide a &lt;code&gt;@StartDate&lt;/code&gt; and &lt;code&gt;@EndDate&lt;/code&gt; from your form input.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;conditions are :&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If &lt;code&gt;@StartDate&lt;/code&gt; is ahead of &lt;code&gt;existingStartDate&lt;/code&gt; and behind &lt;code&gt;existingEndDate&lt;/code&gt; then we can say &lt;code&gt;@StartDate&lt;/code&gt; is in the middle of a existing date range, thus we can conclude it will overlap&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@StartDate &amp;gt;=existing.StartDate And @StartDate &amp;lt;= existing.EndDate) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If &lt;code&gt;@StartDate&lt;/code&gt; is behind &lt;code&gt;existingStartDate&lt;/code&gt; but &lt;code&gt;@EndDate&lt;/code&gt; is ahead of &lt;code&gt;existingStartDate&lt;/code&gt; we can say that it will overlap&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; (@StartDate &amp;lt;= existing.StartDate And @EndDate &amp;gt;= existing.StartDate)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If &lt;code&gt;@StartDate&lt;/code&gt; is behind &lt;code&gt;existingStartDate&lt;/code&gt; And &lt;code&gt;@EndDate&lt;/code&gt; is ahead of &lt;code&gt;existingEndDate&lt;/code&gt; we can conclude that the provided date range devours a existing date range , thus overlaps&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; (@StartDate &amp;lt;= existing.StartDate And @EndDate &amp;gt;= existing.EndDate))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If any of the condition stands true, your provided date range overlaps with existing ones in the database.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Split the problem into cases then handle each case&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;The situation &apos;two date ranges intersect&apos; is covered by two cases - the first date range starts within the second, or the second date range starts within the first.&lt;/p&gt;\n    ","\n&lt;p&gt;You can try this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;//custom date for example\n$d1 = new DateTime(&quot;2012-07-08&quot;);\n$d2 = new DateTime(&quot;2012-07-11&quot;);\n$d3 = new DateTime(&quot;2012-07-08&quot;);\n$d4 = new DateTime(&quot;2012-07-15&quot;);\n\n//create a date period object\n$interval = new DateInterval(&apos;P1D&apos;);\n$daterange = iterator_to_array(new DatePeriod($d1, $interval, $d2));\n$daterange1 = iterator_to_array(new DatePeriod($d3, $interval, $d4));\narray_map(function($v) use ($daterange1) { if(in_array($v, $daterange1)) print &quot;Bingo!&quot;;}, $daterange);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;public static class NumberExtensionMethods\n    {\n        public static Boolean IsBetween(this Int64 value, Int64 Min, Int64 Max)\n        {\n            if (value &amp;gt;= Min &amp;amp;&amp;amp; value &amp;lt;= Max) return true;\n            else return false;\n        }\n\n        public static Boolean IsBetween(this DateTime value, DateTime Min, DateTime Max)\n        {\n            Int64 numricValue = value.Ticks;\n            Int64 numericStartDate = Min.Ticks;\n            Int64 numericEndDate = Max.Ticks;\n\n            if (numricValue.IsBetween(numericStartDate, numericEndDate) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n    }\n\npublic static Boolean IsOverlap(DateTime startDate1, DateTime endDate1, DateTime startDate2, DateTime endDate2)\n        {\n            Int64 numericStartDate1 = startDate1.Ticks;\n            Int64 numericEndDate1 = endDate1.Ticks;\n            Int64 numericStartDate2 = startDate2.Ticks;\n            Int64 numericEndDate2 = endDate2.Ticks;\n\n            if (numericStartDate2.IsBetween(numericStartDate1, numericEndDate1) ||\n                numericEndDate2.IsBetween(numericStartDate1, numericEndDate1) ||\n                numericStartDate1.IsBetween(numericStartDate2, numericEndDate2) ||\n                numericEndDate1.IsBetween(numericStartDate2, numericEndDate2))\n            {\n                return true;\n            }\n\n            return false;\n        } \n\n\nif (IsOverlap(startdate1, enddate1, startdate2, enddate2))\n            {\n                Console.WriteLine(&quot;IsOverlap&quot;);\n            }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This was my solution, it returns true when the values don&apos;t overlap:&lt;/p&gt;\n\n&lt;p&gt;X START 1\nY END 1&lt;/p&gt;\n\n&lt;p&gt;A START 2\nB END 2&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;TEST1: (X &amp;lt;= A || X &amp;gt;= B)\n        &amp;amp;&amp;amp;\nTEST2: (Y &amp;gt;= B || Y &amp;lt;= A) \n        &amp;amp;&amp;amp; \nTEST3: (X &amp;gt;= B || Y &amp;lt;= A)\n\n\nX-------------Y\n    A-----B\n\nTEST1:  TRUE\nTEST2:  TRUE\nTEST3:  FALSE\nRESULT: FALSE\n\n---------------------------------------\n\nX---Y\n      A---B\n\nTEST1:  TRUE\nTEST2:  TRUE\nTEST3:  TRUE\nRESULT: TRUE\n\n---------------------------------------\n\n      X---Y\nA---B\n\nTEST1:  TRUE\nTEST2:  TRUE\nTEST3:  TRUE\nRESULT: TRUE\n\n---------------------------------------\n\n     X----Y\nA---------------B\n\nTEST1:  FALSE\nTEST2:  FALSE\nTEST3:  FALSE\nRESULT: FALSE\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":419,"title":"Determine Whether Two Date Ranges Overlap","content":"\n                \n&lt;p&gt;Given two date ranges, what is the simplest or most efficient way to determine whether the two date ranges overlap?&lt;/p&gt;\n\n&lt;p&gt;As an example, suppose we have ranges denoted by DateTime variables &lt;code&gt;StartDate1&lt;/code&gt; to &lt;code&gt;EndDate1&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;StartDate2&lt;/code&gt; to &lt;code&gt;EndDate2&lt;/code&gt;.&lt;/p&gt;\n    ","slug":"determine-whether-two-date-ranges-overlap-1657387924335","postType":"QUESTION","createdAt":"2022-07-09T17:32:04.000Z","updatedAt":"2022-07-09T17:32:04.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to remove the space between inline/inline-block elements?","slug":"how-to-remove-the-space-between-inlineinline-block-elements-1657384532273"},{"title":"The definitive guide to form-based website authentication [closed]","slug":"the-definitive-guide-to-form-based-website-authentication-closed-1657388456475"},{"title":"What is the difference between \"px\", \"dip\", \"dp\" and \"sp\"?","slug":"what-is-the-difference-between-\"px\"-\"dip\"-\"dp\"-and-\"sp\"-1657388093250"},{"title":"Generating random whole numbers in JavaScript in a specific range","slug":"generating-random-whole-numbers-in-javascript-in-a-specific-range-1657388112728"},{"title":"How do I split a delimited string so I can access individual items?","slug":"how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385"},{"title":"Is it possible for flex items to align tightly to the items above them?","slug":"is-it-possible-for-flex-items-to-align-tightly-to-the-items-above-them-1657388511179"},{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"What is the most efficient way to deep clone an object in JavaScript?","slug":"what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript-1657384601026"},{"title":"Retrieve only the queried element in an object array in MongoDB collection","slug":"retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"Ways to deal with #document under iframe","slug":"ways-to-deal-with-document-under-iframe-1657388403345"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"How to horizontally center an element","slug":"how-to-horizontally-center-an-element-1657384634147"},{"title":"How to iterate over rows in a DataFrame in Pandas","slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115"},{"title":"Resolve build errors due to circular dependency amongst classes","slug":"resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"}]},"__N_SSG":true}