<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="precision,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-are-floating-point-numbers-inaccurate-1657387346111","name":"Questions"}}]}</script><title>Why are floating point numbers inaccurate? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Why do some numbers lose accuracy when stored as floating point numbers?

For example, the decimal number 9.2 can be expressed exactly as a ratio of two decimal integers (92/10), both of which can be expressed exactly in binary (0b1011100/0b1010). However, the same ratio stored as a floating point number is never exactly equal to 9.2:

32-bit &quot;single precision&quot; float: 9.19999980926513671875
64-bit &quot;double precision&quot; float: 9.199999999999999289457264239899814128875732421875


How can such an apparently simple number be &quot;too big&quot; to express in 64 bits of memory?
    "/><meta property="og:title" content="Why are floating point numbers inaccurate? | Solution Checker"/><meta property="og:description" content="Why do some numbers lose accuracy when stored as floating point numbers?

For example, the decimal number 9.2 can be expressed exactly as a ratio of two decimal integers (92/10), both of which can be expressed exactly in binary (0b1011100/0b1010). However, the same ratio stored as a floating point number is never exactly equal to 9.2:

32-bit &quot;single precision&quot; float: 9.19999980926513671875
64-bit &quot;double precision&quot; float: 9.199999999999999289457264239899814128875732421875


How can such an apparently simple number be &quot;too big&quot; to express in 64 bits of memory?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why are floating point numbers inaccurate?","text":"Why do some numbers lose accuracy when stored as floating point numbers?\n\nFor example, the decimal number 9.2 can be expressed exactly as a ratio of two decimal integers (92/10), both of which can be expressed exactly in binary (0b1011100/0b1010). However, the same ratio stored as a floating point number is never exactly equal to 9.2:\n\n32-bit &quot;single precision&quot; float: 9.19999980926513671875\n64-bit &quot;double precision&quot; float: 9.199999999999999289457264239899814128875732421875\n\n\nHow can such an apparently simple number be &quot;too big&quot; to express in 64 bits of memory?\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"In most programming languages, floating point numbers are represented a lot like scientific notation: with an exponent and a mantissa (also called the significand). A very simple number, say 9.2, is actually this fraction:\n\n\n  5179139571476070 * 2 -49\n\n\nWhere the exponent is -49 and the mantissa is 5179139571476070. The reason it is impossible to represent some decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an integer multiplied by an integer power of 2. \n\n9.2 may be simply 92/10, but 10 cannot be expressed as 2n if n is limited to integer values.\n\n\n\nSeeing the Data\n\nFirst, a few functions to see the components that make a 32- and 64-bit float. Gloss over these if you only care about the output (example in Python):\n\ndef float_to_bin_parts(number, bits=64):\n    if bits == 32:          # single precision\n        int_pack      = &apos;I&apos;\n        float_pack    = &apos;f&apos;\n        exponent_bits = 8\n        mantissa_bits = 23\n        exponent_bias = 127\n    elif bits == 64:        # double precision. all python floats are this\n        int_pack      = &apos;Q&apos;\n        float_pack    = &apos;d&apos;\n        exponent_bits = 11\n        mantissa_bits = 52\n        exponent_bias = 1023\n    else:\n        raise ValueError, &apos;bits argument must be 32 or 64&apos;\n    bin_iter = iter(bin(struct.unpack(int_pack, struct.pack(float_pack, number))[0])[2:].rjust(bits, &apos;0&apos;))\n    return [&apos;&apos;.join(islice(bin_iter, x)) for x in (1, exponent_bits, mantissa_bits)]\n\n\nThere&apos;s a lot of complexity behind that function, and it&apos;d be quite the tangent to explain, but if you&apos;re interested, the important resource for our purposes is the struct module.\n\nPython&apos;s float is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type double, which is often implemented as 64 bits.\n\nWhen we call that function with our example, 9.2, here&apos;s what we get:\n\n&gt;&gt;&gt; float_to_bin_parts(9.2)\n[&apos;0&apos;, &apos;10000000010&apos;, &apos;0010011001100110011001100110011001100110011001100110&apos;]\n\n\n\n\nInterpreting the Data\n\nYou&apos;ll see I&apos;ve split the return value into three components. These components are:\n\n\nSign\nExponent\nMantissa (also called Significand, or Fraction)\n\n\nSign\n\nThe sign is stored in the first component as a single bit. It&apos;s easy to explain: 0 means the float is a positive number; 1 means it&apos;s negative. Because 9.2 is positive, our sign value is 0.\n\nExponent\n\nThe exponent is stored in the middle component as 11 bits. In our case, 0b10000000010. In decimal, that represents the value 1026. A quirk of this component is that you must subtract a number equal to 2(# of bits) - 1 - 1 to get the true exponent; in our case, that means subtracting  0b1111111111 (decimal number 1023) to get the true exponent, 0b00000000011 (decimal number 3).\n\nMantissa\n\nThe mantissa is stored in the third component as 52 bits. However, there&apos;s a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:\n\n\n  6.0221413x1023\n\n\nThe mantissa would be the 6.0221413. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: 0 and 1. So the binary mantissa always starts with 1! When a float is stored, the 1 at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the true mantissa:\n\n\n  1.0010011001100110011001100110011001100110011001100110\n\n\nThis involves more than just a simple addition, because the bits stored in our third component actually represent the fractional part of the mantissa, to the right of the radix point. \n\nWhen dealing with decimal numbers, we &quot;move the decimal point&quot; by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by 252 to move it 52 places to the right:\n\n\n  0.0010011001100110011001100110011001100110011001100110\n\n\nIn decimal notation, that&apos;s the same as dividing 675539944105574 by 4503599627370496 to get 0.1499999999999999. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: 675539944105574 / 4503599627370496.)\n\nNow that we&apos;ve transformed the third component into a fractional number, adding 1 gives the true mantissa.\n\nRecapping the Components\n\n\nSign (first component): 0 for positive, 1 for negative\nExponent (middle component): Subtract 2(# of bits) - 1 - 1 to get the true exponent\nMantissa (last component): Divide by 2(# of bits) and add 1 to get the true mantissa\n\n\n\n\nCalculating the Number\n\nPutting all three parts together, we&apos;re given this binary number:\n\n\n  1.0010011001100110011001100110011001100110011001100110 x 1011\n\n\nWhich we can then convert from binary to decimal:\n\n\n  1.1499999999999999 x 23 (inexact!)\n\n\nAnd multiply to reveal the final representation of the number we started with (9.2) after being stored as a floating point value:\n\n\n  9.1999999999999993\n\n\n\n\nRepresenting as a Fraction\n\n9.2\n\nNow that we&apos;ve built the number, it&apos;s possible to reconstruct it into a simple fraction:\n\n\n  1.0010011001100110011001100110011001100110011001100110 x 1011\n\n\nShift mantissa to a whole number:\n\n\n  10010011001100110011001100110011001100110011001100110 x 1011-110100\n\n\nConvert to decimal:\n\n\n  5179139571476070 x 23-52\n\n\nSubtract the exponent:\n\n\n  5179139571476070 x 2-49\n\n\nTurn negative exponent into division:\n\n\n  5179139571476070 / 249\n\n\nMultiply exponent:\n\n\n  5179139571476070 / 562949953421312\n\n\nWhich equals:\n\n\n  9.1999999999999993\n\n\n9.5\n\n&gt;&gt;&gt; float_to_bin_parts(9.5)\n[&apos;0&apos;, &apos;10000000010&apos;, &apos;0011000000000000000000000000000000000000000000000000&apos;]\n\n\nAlready you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let&apos;s go through the paces.\n\nAssemble the binary scientific notation:\n\n\n  1.0011 x 1011\n\n\nShift the decimal point:\n\n\n  10011 x 1011-100  \n\n\nSubtract the exponent:\n\n\n  10011 x 10-1  \n\n\nBinary to decimal:\n\n\n  19 x 2-1  \n\n\nNegative exponent to division:\n\n\n  19 / 21\n\n\nMultiply exponent:\n\n\n  19 / 2\n\n\nEquals:\n\n\n  9.5\n\n\n\n\n\n\nFurther reading\n\n\nThe Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up? (floating-point-gui.de)\nWhat Every Computer Scientist Should Know About Floating-Point Arithmetic (Goldberg 1991)\nIEEE Double-precision floating-point format (Wikipedia)\nFloating Point Arithmetic: Issues and Limitations (docs.python.org)\nFloating Point Binary\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"This isn&apos;t a full answer (mhlester already covered a lot of good ground I won&apos;t duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.\nConsider the fraction 2/3\nIn good-ol&apos; base 10, we typically write it out as something like\n\n0.666...\n0.666\n0.667\n\nWhen we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn&apos;t even rounded correctly! Nevertheless, we don&apos;t have a problem with 0.666 as an approximation of the number 2/3, so we shouldn&apos;t really have a problem with how 9.2 is approximated in most programs. (Yes, in some programs it matters.)\nNumber bases\nSo here&apos;s where number bases are crucial. If we were trying to represent 2/3 in base 3, then\n\n(2/3)10 = 0.23\n\nIn other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, all rational numbers have exact finite representations in some bases but not in others.\nTo drive this point home, let&apos;s look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.\n\n(1/2)10 = 0.510 = 0.12 = 0.1111...3\n\nWhy are floating point numbers inaccurate?\nBecause often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in any base.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"While all of the other answers are good there is still one thing missing:\n\nIt is impossible to represent irrational numbers (e.g. π, sqrt(2), log(3), etc.) precisely!\n\nAnd that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only symbolic arithmetic is able to preserve their precision.\n\nAlthough if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers a and b to hold the number represented by the fraction a/b. All your arithmetic would have to be done on fractions just like in highschool math (e.g. a/b * c/d = ac/bd).\n\nBut of course you would still run into the same kind of trouble when pi, sqrt, log, sin, etc. are involved.\n\nTL;DR\n\nFor hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"There are infinitely many real numbers (so many that you can&apos;t enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).\n\nThe floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.\n\n\n\nYou might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.\n\n\n\nAlso note that double-precision floating-points numbers are extremely accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"\n  Why can we not represent 9.2 in binary floating point?\n\n\nFloating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.\n\nA fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it&apos;s lowest terms) are factors of the base.\n\nThe prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2b5c). \n\nOn the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2b)\n\n\n  Why do computers use this representation?\n\n\nBecause it&apos;s a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use &quot;scientific notation&quot; and round their results to a reasonable number of digits at each step.\n\nIt would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. \n\nHowever the big problem is that such a format is a pain to do calculations on. For two reasons.\n\n\nIf you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it&apos;s lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.\nIf after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.\n\n\nSome Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it&apos;s own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.\n\nSome languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don&apos;t offer hardware support for them.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111"><h1>Why are floating point numbers inaccurate?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/precision">precision</a></div></div><div class="question-content mt-5">
                
<p>Why do some numbers lose accuracy when stored as floating point numbers?</p>

<p>For example, the decimal number <code>9.2</code> can be expressed exactly as a ratio of two decimal integers (<code>92/10</code>), both of which can be expressed exactly in binary (<code>0b1011100/0b1010</code>). However, the same ratio stored as a floating point number is never exactly equal to <code>9.2</code>:</p>

<pre><code>32-bit "single precision" float: 9.19999980926513671875
64-bit "double precision" float: 9.199999999999999289457264239899814128875732421875
</code></pre>

<p>How can such an apparently simple number be "too big" to express in <strong>64 bits</strong> of memory?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/precision">precision</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In most programming languages, floating point numbers are represented a lot like <a href="http://en.wikipedia.org/wiki/Scientific_notation" rel="noreferrer">scientific notation</a>: with an exponent and a mantissa (also called the significand). A very simple number, say <code>9.2</code>, is actually this fraction:</p>

<blockquote>
  <p>5179139571476070 * 2<sup> -49</sup></p>
</blockquote>

<p>Where the exponent is <code>-49</code> and the mantissa is <code>5179139571476070</code>. The reason it is impossible to represent <em>some</em> decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an <em>integer</em> multiplied by an <em>integer power of 2</em>. </p>

<p><code>9.2</code> may be simply <code>92/10</code>, but <strong>10</strong> cannot be expressed as <strong>2<sup>n</sup></strong> if <strong>n</strong> is limited to integer values.</p>

<hr>

<h1>Seeing the Data</h1>

<p>First, a few functions to <em>see</em> the components that make a 32- and 64-bit <code>float</code>. Gloss over these if you only care about the output (example in Python):</p>

<pre class="lang-python s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">float_to_bin_parts</span>(<span class="hljs-params">number, bits=<span class="hljs-number">64</span></span>):
    <span class="hljs-keyword">if</span> bits == <span class="hljs-number">32</span>:          <span class="hljs-comment"># single precision</span>
        int_pack      = <span class="hljs-string">'I'</span>
        float_pack    = <span class="hljs-string">'f'</span>
        exponent_bits = <span class="hljs-number">8</span>
        mantissa_bits = <span class="hljs-number">23</span>
        exponent_bias = <span class="hljs-number">127</span>
    <span class="hljs-keyword">elif</span> bits == <span class="hljs-number">64</span>:        <span class="hljs-comment"># double precision. all python floats are this</span>
        int_pack      = <span class="hljs-string">'Q'</span>
        float_pack    = <span class="hljs-string">'d'</span>
        exponent_bits = <span class="hljs-number">11</span>
        mantissa_bits = <span class="hljs-number">52</span>
        exponent_bias = <span class="hljs-number">1023</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> ValueError, <span class="hljs-string">'bits argument must be 32 or 64'</span>
    bin_iter = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">bin</span>(struct.unpack(int_pack, struct.pack(float_pack, number))[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].rjust(bits, <span class="hljs-string">'0'</span>))
    <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>.join(islice(bin_iter, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, exponent_bits, mantissa_bits)]
</code></pre>

<p>There's a lot of complexity behind that function, and it'd be quite the tangent to explain, but if you're interested, the important resource for our purposes is the <a href="http://docs.python.org/2/library/struct.html" rel="noreferrer">struct</a> module.</p>

<p>Python's <code>float</code> is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type <code>double</code>, which is often implemented as 64 bits.</p>

<p>When we call that function with our example, <code>9.2</code>, here's what we get:</p>

<pre><code>&gt;&gt;&gt; float_to_bin_parts(9.2)
['0', '10000000010', '0010011001100110011001100110011001100110011001100110']
</code></pre>

<hr>

<h1>Interpreting the Data</h1>

<p>You'll see I've split the return value into three components. These components are:</p>

<ul>
<li>Sign</li>
<li>Exponent</li>
<li>Mantissa (also called Significand, or Fraction)</li>
</ul>

<h2>Sign</h2>

<p>The sign is stored in the first component as a single bit. It's easy to explain: <code>0</code> means the float is a positive number; <code>1</code> means it's negative. Because <code>9.2</code> is positive, our sign value is <code>0</code>.</p>

<h2>Exponent</h2>

<p>The exponent is stored in the middle component as 11 bits. In our case, <code>0b10000000010</code>. In decimal, that represents the value <code>1026</code>. A quirk of this component is that you must subtract a number equal to <strong>2<sup>(# of bits) - 1</sup> - 1</strong> to get the true exponent; in our case, that means subtracting  <code>0b1111111111</code> (decimal number <code>1023</code>) to get the true exponent, <code>0b00000000011</code> (decimal number 3).</p>

<h2>Mantissa</h2>

<p>The mantissa is stored in the third component as 52 bits. However, there's a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:</p>

<blockquote>
  <p>6.0221413x10<sup>23</sup></p>
</blockquote>

<p>The mantissa would be the <code>6.0221413</code>. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: <code>0</code> and <code>1</code>. So the binary mantissa <em>always</em> starts with <code>1</code>! When a float is stored, the <code>1</code> at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the <em>true</em> mantissa:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110</p>
</blockquote>

<p>This involves more than just a simple addition, because the bits stored in our third component actually represent the <em>fractional</em> part of the mantissa, to the right of the <a href="http://en.wiktionary.org/wiki/radix_point" rel="noreferrer">radix point</a>. </p>

<p>When dealing with decimal numbers, we "move the decimal point" by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by <strong>2<sup>52</sup></strong> to move it 52 places to the right:</p>

<blockquote>
  <p>0.0010011001100110011001100110011001100110011001100110</p>
</blockquote>

<p>In decimal notation, that's the same as dividing <code>675539944105574</code> by <code>4503599627370496</code> to get <code>0.1499999999999999</code>. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: <a href="http://www.wolframalpha.com/input/?i=675539944105574+%2F+4503599627370496" rel="noreferrer">675539944105574 / 4503599627370496</a>.)</p>

<p>Now that we've transformed the third component into a fractional number, adding <code>1</code> gives the true mantissa.</p>

<h2>Recapping the Components</h2>

<ul>
<li>Sign (first component): <code>0</code> for positive, <code>1</code> for negative</li>
<li>Exponent (middle component): Subtract <strong>2<sup>(# of bits) - 1</sup> - 1</strong> to get the true exponent</li>
<li>Mantissa (last component): Divide by <strong>2<sup>(# of bits)</sup></strong> and add <code>1</code> to get the true mantissa</li>
</ul>

<hr>

<h1>Calculating the Number</h1>

<p>Putting all three parts together, we're given this binary number:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110 x 10<sup>11</sup></p>
</blockquote>

<p>Which we can then convert from binary to decimal:</p>

<blockquote>
  <p>1.1499999999999999 x 2<sup>3</sup> (inexact!)</p>
</blockquote>

<p>And multiply to reveal the final representation of the number we started with (<code>9.2</code>) after being stored as a floating point value:</p>

<blockquote>
  <p>9.1999999999999993</p>
</blockquote>

<hr>

<h1>Representing as a Fraction</h1>

<h2>9.2</h2>

<p>Now that we've built the number, it's possible to reconstruct it into a simple fraction:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110 x 10<sup>11</sup></p>
</blockquote>

<p>Shift mantissa to a whole number:</p>

<blockquote>
  <p>10010011001100110011001100110011001100110011001100110 x 10<sup>11-110100</sup></p>
</blockquote>

<p>Convert to decimal:</p>

<blockquote>
  <p>5179139571476070 x 2<sup>3-52</sup></p>
</blockquote>

<p>Subtract the exponent:</p>

<blockquote>
  <p>5179139571476070 x 2<sup>-49</sup></p>
</blockquote>

<p>Turn negative exponent into division:</p>

<blockquote>
  <p>5179139571476070 / 2<sup>49</sup></p>
</blockquote>

<p>Multiply exponent:</p>

<blockquote>
  <p>5179139571476070 / 562949953421312</p>
</blockquote>

<p>Which equals:</p>

<blockquote>
  <p>9.1999999999999993</p>
</blockquote>

<h2>9.5</h2>

<pre><code>&gt;&gt;&gt; float_to_bin_parts(9.5)
['0', '10000000010', '0011000000000000000000000000000000000000000000000000']
</code></pre>

<p>Already you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let's go through the paces.</p>

<p>Assemble the binary scientific notation:</p>

<blockquote>
  <p>1.0011 x 10<sup>11</sup></p>
</blockquote>

<p>Shift the decimal point:</p>

<blockquote>
  <p>10011 x 10<sup>11-100</sup>  </p>
</blockquote>

<p>Subtract the exponent:</p>

<blockquote>
  <p>10011 x 10<sup>-1</sup>  </p>
</blockquote>

<p>Binary to decimal:</p>

<blockquote>
  <p>19 x 2<sup>-1</sup>  </p>
</blockquote>

<p>Negative exponent to division:</p>

<blockquote>
  <p>19 / 2<sup>1</sup></p>
</blockquote>

<p>Multiply exponent:</p>

<blockquote>
  <p>19 / 2</p>
</blockquote>

<p>Equals:</p>

<blockquote>
  <p>9.5</p>
</blockquote>

<hr>

<hr>

<h1>Further reading</h1>

<ul>
<li><a href="http://floating-point-gui.de/" rel="noreferrer">The Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up?</a> (floating-point-gui.de)</li>
<li><a href="http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noreferrer">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> (Goldberg 1991)</li>
<li><a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer">IEEE Double-precision floating-point format</a> (Wikipedia)</li>
<li><a href="http://docs.python.org/3.4/tutorial/floatingpoint.html" rel="noreferrer">Floating Point Arithmetic: Issues and Limitations</a> (docs.python.org)</li>
<li><a href="http://kipirvine.com/asm/workbook/floating_tut.htm" rel="noreferrer">Floating Point Binary</a></li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/precision">precision</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This isn't a full answer (<a href="https://stackoverflow.com/a/21895757/1072468">mhlester</a> already covered a lot of good ground I won't duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.</p>
<h2>Consider the fraction 2/3</h2>
<p>In good-ol' base 10, we typically write it out as something like</p>
<ul>
<li>0.666...</li>
<li>0.666</li>
<li>0.667</li>
</ul>
<p>When we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn't even rounded correctly! <em>Nevertheless, we don't have a problem with 0.666 as an approximation of the number 2/3, <strong>so we shouldn't really have a problem with how 9.2 is approximated in most programs</strong>.</em> (Yes, in some programs it matters.)</p>
<h2>Number bases</h2>
<p>So here's where number bases are crucial. If we were trying to represent 2/3 in base 3, then</p>
<blockquote>
<p>(2/3)<sub>10</sub> = 0.2<sub>3</sub></p>
</blockquote>
<p>In other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, <em>all rational numbers have exact finite representations in some bases but not in others</em>.</p>
<p>To drive this point home, let's look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.</p>
<blockquote>
<p>(1/2)<sub>10</sub> = 0.5<sub>10</sub> = 0.1<sub>2</sub> = 0.1111...<sub>3</sub></p>
</blockquote>
<h2>Why are floating point numbers inaccurate?</h2>
<p>Because often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in <em>any</em> base.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/precision">precision</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While all of the other answers are good there is still one thing missing:</p>

<p><strong>It is impossible to represent irrational numbers (e.g. π, <code>sqrt(2)</code>, <code>log(3)</code>, etc.) precisely!</strong></p>

<p>And that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only <em>symbolic</em> arithmetic is able to preserve their precision.</p>

<p>Although if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers <code>a</code> and <code>b</code> to hold the number represented by the fraction <code>a/b</code>. All your arithmetic would have to be done on fractions just like in highschool math (e.g. <code>a/b * c/d = ac/bd</code>).</p>

<p>But of course you would still run into the same kind of trouble when <code>pi</code>, <code>sqrt</code>, <code>log</code>, <code>sin</code>, etc. are involved.</p>

<p><strong>TL;DR</strong></p>

<p>For hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/precision">precision</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are infinitely many real numbers (so many that you can't enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).</p>

<p>The floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.</p>

<hr>

<p>You might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.</p>

<hr>

<p>Also note that double-precision floating-points numbers are <em>extremely</em> accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/precision">precision</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Why can we not represent 9.2 in binary floating point?</p>
</blockquote>

<p>Floating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.</p>

<p>A fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it's lowest terms) are factors of the base.</p>

<p>The prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2<sup>b</sup>5<sup>c</sup>). </p>

<p>On the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2<sup>b</sup>)</p>

<blockquote>
  <p>Why do computers use this representation?</p>
</blockquote>

<p>Because it's a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use "scientific notation" and round their results to a reasonable number of digits at each step.</p>

<p>It would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. </p>

<p>However the big problem is that such a format is a pain to do calculations on. For two reasons.</p>

<ol>
<li>If you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it's lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.</li>
<li>If after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.</li>
</ol>

<p>Some Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it's own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.</p>

<p>Some languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don't offer hardware support for them.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-import-a-module-given-the-full-path-1657388139965">How do I import a module given the full path?</a><a href="/questions/what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197">What are the rules about using an underscore in a C++ identifier?</a><a href="/questions/what-are-the-rules-for-javascript&#x27;s-automatic-semicolon-insertion-(asi)-1657387472789">What are the rules for JavaScript&#x27;s automatic semicolon insertion (ASI)?</a><a href="/questions/are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951">Are global variables thread-safe in Flask? How do I share data between requests?</a><a href="/questions/why-is-%22using-namespace-std%22-considered-bad-practice-1657384296377">Why is &quot;using namespace std;&quot; considered bad practice?</a><a href="/questions/how-can-i-save-an-activity-state-using-the-save-instance-state-1657387429981">How can I save an activity state using the save instance state?</a><a href="/questions/example-images-for-code-and-mark-up-qandas-closed-1657387690222">Example images for code and mark-up Q&amp;As [closed]</a><a href="/questions/getcontactsfromfirebase()-method-return-an-empty-list-1657388433928">getContactsFromFirebase() method return an empty list</a><a href="/questions/where-should-i-put-lessscriptgreater-tags-in-html-markup-1657388350798">Where should I put &lt;script&gt; tags in HTML markup?</a><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329">What is the copy-and-swap idiom?</a><a href="/questions/can-i-bind-an-array-to-an-in()-condition-in-a-pdo-query-1657388382858">Can I bind an array to an IN() condition in a PDO query?</a><a href="/questions/dollar(document).ready-equivalent-without-jquery-1657388504115">$(document).ready equivalent without jQuery</a><a href="/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067">What are the nuances of scope prototypal / prototypical inheritance in AngularJS?</a><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a><a href="/questions/learning-regular-expressions-closed-1657384719460">Learning Regular Expressions [closed]</a><a href="/questions/how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717">How do I revert a Git repository to a previous commit?</a><a href="/questions/how-do-function-pointers-in-c-work-1657388332074">How do function pointers in C work?</a><a href="/questions/how-can-i-iterate-through-two-lists-in-parallel-1657387278930">How can I iterate through two lists in parallel?</a><a href="/questions/how-does-the-java-&#x27;for-each&#x27;-loop-work-1657388423749">How does the Java &#x27;for each&#x27; loop work?</a><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In most programming languages, floating point numbers are represented a lot like \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Scientific_notation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scientific notation\u0026lt;/a\u0026gt;: with an exponent and a mantissa (also called the significand). A very simple number, say \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;, is actually this fraction:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 * 2\u0026lt;sup\u0026gt; -49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Where the exponent is \u0026lt;code\u0026gt;-49\u0026lt;/code\u0026gt; and the mantissa is \u0026lt;code\u0026gt;5179139571476070\u0026lt;/code\u0026gt;. The reason it is impossible to represent \u0026lt;em\u0026gt;some\u0026lt;/em\u0026gt; decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an \u0026lt;em\u0026gt;integer\u0026lt;/em\u0026gt; multiplied by an \u0026lt;em\u0026gt;integer power of 2\u0026lt;/em\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; may be simply \u0026lt;code\u0026gt;92/10\u0026lt;/code\u0026gt;, but \u0026lt;strong\u0026gt;10\u0026lt;/strong\u0026gt; cannot be expressed as \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; if \u0026lt;strong\u0026gt;n\u0026lt;/strong\u0026gt; is limited to integer values.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Seeing the Data\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;First, a few functions to \u0026lt;em\u0026gt;see\u0026lt;/em\u0026gt; the components that make a 32- and 64-bit \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt;. Gloss over these if you only care about the output (example in Python):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-python s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;float_to_bin_parts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;number, bits=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;64\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; bits == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;:          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# single precision\u0026lt;/span\u0026gt;\n        int_pack      = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;I\u0026apos;\u0026lt;/span\u0026gt;\n        float_pack    = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;f\u0026apos;\u0026lt;/span\u0026gt;\n        exponent_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;\n        mantissa_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;\n        exponent_bias = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;127\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; bits == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;64\u0026lt;/span\u0026gt;:        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# double precision. all python floats are this\u0026lt;/span\u0026gt;\n        int_pack      = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Q\u0026apos;\u0026lt;/span\u0026gt;\n        float_pack    = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;\n        exponent_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;\n        mantissa_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;52\u0026lt;/span\u0026gt;\n        exponent_bias = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1023\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bits argument must be 32 or 64\u0026apos;\u0026lt;/span\u0026gt;\n    bin_iter = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bin\u0026lt;/span\u0026gt;(struct.unpack(int_pack, struct.pack(float_pack, number))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;:].rjust(bits, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;.join(islice(bin_iter, x)) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, exponent_bits, mantissa_bits)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a lot of complexity behind that function, and it\u0026apos;d be quite the tangent to explain, but if you\u0026apos;re interested, the important resource for our purposes is the \u0026lt;a href=\u0026quot;http://docs.python.org/2/library/struct.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;struct\u0026lt;/a\u0026gt; module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Python\u0026apos;s \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt;, which is often implemented as 64 bits.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When we call that function with our example, \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;, here\u0026apos;s what we get:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; float_to_bin_parts(9.2)\n[\u0026apos;0\u0026apos;, \u0026apos;10000000010\u0026apos;, \u0026apos;0010011001100110011001100110011001100110011001100110\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Interpreting the Data\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll see I\u0026apos;ve split the return value into three components. These components are:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Sign\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Exponent\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mantissa (also called Significand, or Fraction)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Sign\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The sign is stored in the first component as a single bit. It\u0026apos;s easy to explain: \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; means the float is a positive number; \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; means it\u0026apos;s negative. Because \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; is positive, our sign value is \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Exponent\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The exponent is stored in the middle component as 11 bits. In our case, \u0026lt;code\u0026gt;0b10000000010\u0026lt;/code\u0026gt;. In decimal, that represents the value \u0026lt;code\u0026gt;1026\u0026lt;/code\u0026gt;. A quirk of this component is that you must subtract a number equal to \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits) - 1\u0026lt;/sup\u0026gt; - 1\u0026lt;/strong\u0026gt; to get the true exponent; in our case, that means subtracting  \u0026lt;code\u0026gt;0b1111111111\u0026lt;/code\u0026gt; (decimal number \u0026lt;code\u0026gt;1023\u0026lt;/code\u0026gt;) to get the true exponent, \u0026lt;code\u0026gt;0b00000000011\u0026lt;/code\u0026gt; (decimal number 3).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Mantissa\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The mantissa is stored in the third component as 52 bits. However, there\u0026apos;s a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;6.0221413x10\u0026lt;sup\u0026gt;23\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The mantissa would be the \u0026lt;code\u0026gt;6.0221413\u0026lt;/code\u0026gt;. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;. So the binary mantissa \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; starts with \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;! When a float is stored, the \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the \u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; mantissa:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This involves more than just a simple addition, because the bits stored in our third component actually represent the \u0026lt;em\u0026gt;fractional\u0026lt;/em\u0026gt; part of the mantissa, to the right of the \u0026lt;a href=\u0026quot;http://en.wiktionary.org/wiki/radix_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;radix point\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When dealing with decimal numbers, we \u0026quot;move the decimal point\u0026quot; by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;52\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; to move it 52 places to the right:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;0.0010011001100110011001100110011001100110011001100110\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In decimal notation, that\u0026apos;s the same as dividing \u0026lt;code\u0026gt;675539944105574\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;4503599627370496\u0026lt;/code\u0026gt; to get \u0026lt;code\u0026gt;0.1499999999999999\u0026lt;/code\u0026gt;. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: \u0026lt;a href=\u0026quot;http://www.wolframalpha.com/input/?i=675539944105574+%2F+4503599627370496\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;675539944105574 / 4503599627370496\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now that we\u0026apos;ve transformed the third component into a fractional number, adding \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; gives the true mantissa.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Recapping the Components\u0026lt;/h2\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Sign (first component): \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; for positive, \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; for negative\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Exponent (middle component): Subtract \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits) - 1\u0026lt;/sup\u0026gt; - 1\u0026lt;/strong\u0026gt; to get the true exponent\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mantissa (last component): Divide by \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits)\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; and add \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; to get the true mantissa\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Calculating the Number\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Putting all three parts together, we\u0026apos;re given this binary number:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which we can then convert from binary to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.1499999999999999 x 2\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt; (inexact!)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And multiply to reveal the final representation of the number we started with (\u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;) after being stored as a floating point value:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.1999999999999993\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Representing as a Fraction\u0026lt;/h1\u0026gt;\n\n\u0026lt;h2\u0026gt;9.2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now that we\u0026apos;ve built the number, it\u0026apos;s possible to reconstruct it into a simple fraction:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Shift mantissa to a whole number:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11-110100\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Convert to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 x 2\u0026lt;sup\u0026gt;3-52\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Subtract the exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 x 2\u0026lt;sup\u0026gt;-49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Turn negative exponent into division:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 / 2\u0026lt;sup\u0026gt;49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Multiply exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 / 562949953421312\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.1999999999999993\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;9.5\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; float_to_bin_parts(9.5)\n[\u0026apos;0\u0026apos;, \u0026apos;10000000010\u0026apos;, \u0026apos;0011000000000000000000000000000000000000000000000000\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Already you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let\u0026apos;s go through the paces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assemble the binary scientific notation:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0011 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Shift the decimal point:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10011 x 10\u0026lt;sup\u0026gt;11-100\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Subtract the exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10011 x 10\u0026lt;sup\u0026gt;-1\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Binary to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 x 2\u0026lt;sup\u0026gt;-1\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Negative exponent to division:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 / 2\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Multiply exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 / 2\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.5\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Further reading\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://floating-point-gui.de/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up?\u0026lt;/a\u0026gt; (floating-point-gui.de)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic\u0026lt;/a\u0026gt; (Goldberg 1991)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Double-precision_floating-point_format\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IEEE Double-precision floating-point format\u0026lt;/a\u0026gt; (Wikipedia)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://docs.python.org/3.4/tutorial/floatingpoint.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Floating Point Arithmetic: Issues and Limitations\u0026lt;/a\u0026gt; (docs.python.org)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://kipirvine.com/asm/workbook/floating_tut.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Floating Point Binary\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This isn\u0026apos;t a full answer (\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/21895757/1072468\u0026quot;\u0026gt;mhlester\u0026lt;/a\u0026gt; already covered a lot of good ground I won\u0026apos;t duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Consider the fraction 2/3\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In good-ol\u0026apos; base 10, we typically write it out as something like\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;0.666...\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;0.666\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;0.667\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;When we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn\u0026apos;t even rounded correctly! \u0026lt;em\u0026gt;Nevertheless, we don\u0026apos;t have a problem with 0.666 as an approximation of the number 2/3, \u0026lt;strong\u0026gt;so we shouldn\u0026apos;t really have a problem with how 9.2 is approximated in most programs\u0026lt;/strong\u0026gt;.\u0026lt;/em\u0026gt; (Yes, in some programs it matters.)\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Number bases\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;So here\u0026apos;s where number bases are crucial. If we were trying to represent 2/3 in base 3, then\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(2/3)\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.2\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, \u0026lt;em\u0026gt;all rational numbers have exact finite representations in some bases but not in others\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To drive this point home, let\u0026apos;s look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(1/2)\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.5\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.1\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; = 0.1111...\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Why are floating point numbers inaccurate?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Because often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; base.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While all of the other answers are good there is still one thing missing:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It is impossible to represent irrational numbers (e.g. π, \u0026lt;code\u0026gt;sqrt(2)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;log(3)\u0026lt;/code\u0026gt;, etc.) precisely!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only \u0026lt;em\u0026gt;symbolic\u0026lt;/em\u0026gt; arithmetic is able to preserve their precision.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; to hold the number represented by the fraction \u0026lt;code\u0026gt;a/b\u0026lt;/code\u0026gt;. All your arithmetic would have to be done on fractions just like in highschool math (e.g. \u0026lt;code\u0026gt;a/b * c/d = ac/bd\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But of course you would still run into the same kind of trouble when \u0026lt;code\u0026gt;pi\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sqrt\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;log\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sin\u0026lt;/code\u0026gt;, etc. are involved.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TL;DR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are infinitely many real numbers (so many that you can\u0026apos;t enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Also note that double-precision floating-points numbers are \u0026lt;em\u0026gt;extremely\u0026lt;/em\u0026gt; accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why can we not represent 9.2 in binary floating point?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Floating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it\u0026apos;s lowest terms) are factors of the base.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2\u0026lt;sup\u0026gt;b\u0026lt;/sup\u0026gt;5\u0026lt;sup\u0026gt;c\u0026lt;/sup\u0026gt;). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2\u0026lt;sup\u0026gt;b\u0026lt;/sup\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why do computers use this representation?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Because it\u0026apos;s a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use \u0026quot;scientific notation\u0026quot; and round their results to a reasonable number of digits at each step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However the big problem is that such a format is a pain to do calculations on. For two reasons.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it\u0026apos;s lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Some Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it\u0026apos;s own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don\u0026apos;t offer hardware support for them.\u0026lt;/p\u0026gt;\n    "],"id":230,"title":"Why are floating point numbers inaccurate?","content":"\n                \n\u0026lt;p\u0026gt;Why do some numbers lose accuracy when stored as floating point numbers?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, the decimal number \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; can be expressed exactly as a ratio of two decimal integers (\u0026lt;code\u0026gt;92/10\u0026lt;/code\u0026gt;), both of which can be expressed exactly in binary (\u0026lt;code\u0026gt;0b1011100/0b1010\u0026lt;/code\u0026gt;). However, the same ratio stored as a floating point number is never exactly equal to \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;32-bit \u0026quot;single precision\u0026quot; float: 9.19999980926513671875\n64-bit \u0026quot;double precision\u0026quot; float: 9.199999999999999289457264239899814128875732421875\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;How can such an apparently simple number be \u0026quot;too big\u0026quot; to express in \u0026lt;strong\u0026gt;64 bits\u0026lt;/strong\u0026gt; of memory?\u0026lt;/p\u0026gt;\n    ","slug":"why-are-floating-point-numbers-inaccurate-1657387346111","postType":"QUESTION","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","tags":[{"id":1552,"name":"precision","slug":"precision","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","Questions_Tags":{"questionId":230,"tagId":1552}}],"relatedQuestions":[{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111","tags":[{"name":"precision","Questions_Tags":{"questionId":230,"tagId":1552}}]}]},"randomQuestions":[{"title":"How do I import a module given the full path?","slug":"how-do-i-import-a-module-given-the-full-path-1657388139965"},{"title":"What are the rules about using an underscore in a C++ identifier?","slug":"what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197"},{"title":"What are the rules for JavaScript's automatic semicolon insertion (ASI)?","slug":"what-are-the-rules-for-javascript's-automatic-semicolon-insertion-(asi)-1657387472789"},{"title":"Are global variables thread-safe in Flask? How do I share data between requests?","slug":"are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"How can I save an activity state using the save instance state?","slug":"how-can-i-save-an-activity-state-using-the-save-instance-state-1657387429981"},{"title":"Example images for code and mark-up Q\u0026As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"getContactsFromFirebase() method return an empty list","slug":"getcontactsfromfirebase()-method-return-an-empty-list-1657388433928"},{"title":"Where should I put \u003cscript\u003e tags in HTML markup?","slug":"where-should-i-put-lessscriptgreater-tags-in-html-markup-1657388350798"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"Can I bind an array to an IN() condition in a PDO query?","slug":"can-i-bind-an-array-to-an-in()-condition-in-a-pdo-query-1657388382858"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"Learning Regular Expressions [closed]","slug":"learning-regular-expressions-closed-1657384719460"},{"title":"How do I revert a Git repository to a previous commit?","slug":"how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717"},{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074"},{"title":"How can I iterate through two lists in parallel?","slug":"how-can-i-iterate-through-two-lists-in-parallel-1657387278930"},{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>