<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is a lambda expression in C++11? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn&#x27;t possible prior to their introduction?

A few examples, and use cases would be useful. 
    "/><meta property="og:title" content="What is a lambda expression in C++11? | Solutions Checker"/><meta property="og:description" content="What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn&#x27;t possible prior to their introduction?

A few examples, and use cases would be useful. 
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is a lambda expression in C++11?","text":"What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn&apos;t possible prior to their introduction?\n\nA few examples, and use cases would be useful. \n    ","answerCount":10,"upVoteCount":500,"suggestedAnswer":[{"text":"The problem\nC++ includes useful generic functions like std::for_each and std::transform, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the functor you would like to apply is unique to the particular function.\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nnamespace {\n  struct f {\n    void operator()(int) {\n      // do something\n    }\n  };\n}\n\nvoid func(std::vector&lt;int&gt;&amp; v) {\n  f f;\n  std::for_each(v.begin(), v.end(), f);\n}\n\nIf you only use f once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.\nIn C++03 you might be tempted to write something like the following, to keep the functor local:\nvoid func2(std::vector&lt;int&gt;&amp; v) {\n  struct {\n    void operator()(int) {\n       // do something\n    }\n  } f;\n  std::for_each(v.begin(), v.end(), f);\n}\n\nhowever this is not allowed, f cannot be passed to a template function in C++03.\nThe new solution\nC++11 introduces lambdas allow you to write an inline, anonymous functor to replace the struct f. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:\nvoid func3(std::vector&lt;int&gt;&amp; v) {\n  std::for_each(v.begin(), v.end(), [](int) { /* do something here*/ });\n}\n\nLambda functions are just syntactic sugar for anonymous functors.\nReturn types\nIn simple cases the return type of the lambda is deduced for you, e.g.:\nvoid func4(std::vector&lt;double&gt;&amp; v) {\n  std::transform(v.begin(), v.end(), v.begin(),\n                 [](double d) { return d &lt; 0.00001 ? 0 : d; }\n                 );\n}\n\nhowever when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:\nvoid func4(std::vector&lt;double&gt;&amp; v) {\n    std::transform(v.begin(), v.end(), v.begin(),\n        [](double d) {\n            if (d &lt; 0.0001) {\n                return 0;\n            } else {\n                return d;\n            }\n        });\n}\n\nTo resolve this you are allowed to explicitly specify a return type for a lambda function, using -&gt; T:\nvoid func4(std::vector&lt;double&gt;&amp; v) {\n    std::transform(v.begin(), v.end(), v.begin(),\n        [](double d) -&gt; double {\n            if (d &lt; 0.0001) {\n                return 0;\n            } else {\n                return d;\n            }\n        });\n}\n\n&quot;Capturing&quot; variables\nSo far we&apos;ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the [] of the expression), which has so far been unused in these examples, e.g.:\nvoid func5(std::vector&lt;double&gt;&amp; v, const double&amp; epsilon) {\n    std::transform(v.begin(), v.end(), v.begin(),\n        [epsilon](double d) -&gt; double {\n            if (d &lt; epsilon) {\n                return 0;\n            } else {\n                return d;\n            }\n        });\n}\n\nYou can capture by both reference and value, which you can specify using &amp; and = respectively:\n\n[&amp;epsilon, zeta] captures epsilon by reference and zeta by value\n[&amp;] captures all variables used in the lambda by reference\n[=] captures all variables used in the lambda by value\n[&amp;, epsilon] captures all variables used in the lambda by reference but captures epsilon by value\n[=, &amp;epsilon] captures all variables used in the lambda by value but captures epsilon by reference\n\nThe generated operator() is const by default, with the implication that captures will be const when you access them by default. This has the effect that each call with the same input would produce the same result, however you can mark the lambda as mutable to request that the operator() that is produced is not const.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"What is a lambda function?\n\nThe C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.\n\nIn C++ a lambda function is defined like this\n\n[]() { } // barebone lambda\n\n\nor in all its glory\n\n[]() mutable -&gt; T { } // T is the return type, still lacking throw()\n\n\n[] is the capture list, () the argument list and {} the function body.\n\nThe capture list\n\nThe capture list defines what from the outside of the lambda should be available inside the function body and how.\nIt can be either:\n\n\na value: [x]\na reference [&amp;x]\nany variable currently in scope by reference [&amp;]\nsame as 3, but by value [=]\n\n\nYou can mix any of the above in a comma separated list [x, &amp;y].\n\nThe argument list\n\nThe argument list is the same as in any other C++ function. \n\nThe function body\n\nThe code that will be executed when the lambda is actually called.\n\nReturn type deduction\n\nIf a lambda has only one return statement, the return type can be omitted and has the implicit type of decltype(return_statement).\n\nMutable\n\nIf a lambda is marked mutable (e.g. []() mutable { }) it is allowed to mutate the values that have been captured by value.\n\nUse cases\n\nThe library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don&apos;t have to clutter their code with small functors in some accessible scope.\n\nC++14\n\nIn C++14 lambdas have been extended by various proposals.\n\nInitialized Lambda Captures\n\nAn element of the capture list can now be initialized with =. This allows renaming of variables and to capture by moving. An example taken from the standard:\n\nint x = 4;\nauto y = [&amp;r = x, x = x+1]()-&gt;int {\n            r += 2;\n            return x+2;\n         }();  // Updates ::x to 6, and initializes y to 7.\n\n\nand one taken from Wikipedia showing how to capture with std::move:\n\nauto ptr = std::make_unique&lt;int&gt;(10); // See below for std::make_unique\nauto lambda = [ptr = std::move(ptr)] {return *ptr;};\n\n\nGeneric Lambdas\n\nLambdas can now be generic (auto would be equivalent to T here if\nT were a type template argument somewhere in the surrounding scope):\n\nauto lambda = [](auto x, auto y) {return x + y;};\n\n\nImproved Return Type Deduction\n\nC++14 allows deduced return types for every function and does not restrict it to functions of the form return expression;. This is also extended to lambdas.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, it is possible to execute a lambda immediately upon definition:\n\n[&amp;](){ ...your code... }(); // immediately executed lambda expression\n\n\nis functionally equivalent to\n\n{ ...your code... } // simple code block\n\n\nThis makes lambda expressions a powerful tool for refactoring complex functions.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the &amp;), you can move the code to an external location and make it a normal function.\n\nSimilarly, you can use lambda expressions to initialize variables based on the result of an algorithm...\n\nint a = []( int b ){ int r=1; while (b&gt;0) r*=b--; return r; }(5); // 5!\n\n\nAs a way of partitioning your program logic, you might even find it useful to pass a lambda expression as an argument to another lambda expression...\n\n[&amp;]( std::function&lt;void()&gt; algorithm ) // wrapper section\n   {\n   ...your wrapper code...\n   algorithm();\n   ...your wrapper code...\n   }\n([&amp;]() // algorithm section\n   {\n   ...your algorithm code...\n   });\n\n\nLambda expressions also let you create named nested functions, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  Note: don&apos;t forget the semicolon after the closing curly brace.\n\nauto algorithm = [&amp;]( double x, double m, double b ) -&gt; double\n   {\n   return m*x+b;\n   };\n\nint a=algorithm(1,2,3), b=algorithm(4,5,6);\n\n\nIf subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Answers\n\nQ: What is a lambda expression in C++11?\n\nA: Under the hood, it is the object of an autogenerated class with overloading operator() const. Such object is called closure and created by compiler.\nThis &apos;closure&apos; concept is near with the bind concept from C++11. \nBut lambdas typically generate better code. And calls through closures allow full inlining.\n\nQ: When would I use one?\n\nA: To define &quot;simple and small logic&quot; and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.\n\nQ: What class of problem do they solve that wasn&apos;t possible prior to their introduction?\n\nA: It is some kind of syntax sugar like operators overloading instead of functions for custom add, subrtact operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I&apos;m also think so)\n\nExample of usage\n\nauto x = [=](int arg1){printf(&quot;%i&quot;, arg1); };\nvoid(*f)(int) = x;\nf(1);\nx(1);\n\n\n\n\nExtras about lambdas, not covered by question. Ignore this section if you&apos;re not interest\n\n1. Captured values. What you can to capture\n\n1.1. You can reference to a variable with static storage duration in lambdas. They all are captured.\n\n1.2. You can use lambda for capture values &quot;by value&quot;. In such case captured vars will be copied to the function object (closure).\n\n[captureVar1,captureVar2](int arg1){}\n\n\n1.3. You can capture be reference. &amp; -- in this context mean reference, not pointers.\n\n   [&amp;captureVar1,&amp;captureVar2](int arg1){}\n\n\n1.4. It exists notation to capture all non-static vars by value, or by reference\n\n  [=](int arg1){} // capture all not-static vars by value\n\n  [&amp;](int arg1){} // capture all not-static vars by reference\n\n\n1.5.  It exists notation to capture all non-static vars by value, or by reference and specify smth. more.\nExamples:\nCapture all not-static vars by value, but by reference capture Param2\n\n[=,&amp;Param2](int arg1){} \n\n\nCapture all not-static vars by reference, but by value capture Param2\n\n[&amp;,Param2](int arg1){} \n\n\n2. Return type deduction\n\n2.1. Lambda return type can be deduced if lambda is one expression. Or you can explicitly specify it.\n\n[=](int arg1)-&gt;trailing_return_type{return trailing_return_type();}\n\n\nIf lambda has more then one expression, then return type must be specified via trailing return type. \n  Also, similar syntax can be applied to auto functions and member-functions\n\n3. Captured values. What you can not capture\n\n3.1. You can capture only local vars, not member variable of the object.\n\n4. Сonversions\n\n4.1 !! Lambda is not a function pointer and it is not an anonymous function, but capture-less lambdas can be implicitly converted to a function pointer.\n\np.s. \n\n\nMore about lambda grammar information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88\nIn C++14 the extra feature which has named as &quot;init capture&quot; have been added. It allow to perform arbitarily declaration of closure data members:\n\nauto toFloat = [](int value) { return float(value);};\nauto interpolate = [min = toFloat(0), max = toFloat(255)](int value)-&gt;float { return (value - min) / (max - min);};\n\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. http://www.stroustrup.com/C++11FAQ.html#lambda) but there are some limitations. For example, if there&apos;s a callback interface like this, \n\nvoid apply(void (*f)(int)) {\n    f(10);\n    f(20);\n    f(30);\n}\n\n\nyou can write a function on the spot to use it like the one passed to apply below:\n\nint col=0;\nvoid output() {\n    apply([](int data) {\n        cout &lt;&lt; data &lt;&lt; ((++col % 10) ? &apos; &apos; : &apos;\\n&apos;);\n    });\n}\n\n\nBut you can&apos;t do this:\n\nvoid output(int n) {\n    int col=0;\n    apply([&amp;col,n](int data) {\n        cout &lt;&lt; data &lt;&lt; ((++col % 10) ? &apos; &apos; : &apos;\\n&apos;);\n    });\n}\n\n\nbecause of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and \n\n#include &lt;functional&gt; \n\n\n(or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:\n\n#include &lt;functional&gt;\nvoid apply(std::function&lt;void(int)&gt; f) {\n    f(10);\n    f(20);\n    f(30);\n}\nvoid output(int width) {\n    int col;\n    apply([width,&amp;col](int data) {\n        cout &lt;&lt; data &lt;&lt; ((++col % width) ? &apos; &apos; : &apos;\\n&apos;);\n    });\n}\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"One of the best explanation of lambda expression is given from author of C++ Bjarne Stroustrup in his book ***The C++ Programming Language*** chapter 11 (ISBN-13: 978-0321563842):\n\nWhat is a lambda expression? \n\n\n  A lambda expression, sometimes also referred to as a lambda\n  function or (strictly speaking incorrectly, but colloquially) as a\n  lambda, is a simplified notation for defining and using an anonymous function object. Instead of defining a named class with an operator(), later making an object of that class, and finally\n  invoking it, we can use a shorthand.\n\n\nWhen would I use one?\n\n\n  This is particularly useful when we want to pass an operation as an\n  argument to an algorithm. In the context of graphical user interfaces\n  (and elsewhere), such operations are often referred to as callbacks.\n\n\nWhat class of problem do they solve that wasn&apos;t possible prior to their introduction?\n\nHere i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :\n\n\n  effective ways of optimizing\n\n\nSome examples\n\nvia lambda expression\n\nvoid print_modulo(const vector&lt;int&gt;&amp; v, ostream&amp; os, int m) // output v[i] to os if v[i]%m==0\n{\n    for_each(begin(v),end(v),\n        [&amp;os,m](int x) { \n           if (x%m==0) os &lt;&lt; x &lt;&lt; &apos;\\n&apos;;\n         });\n}\n\n\nor via function\n\nclass Modulo_print {\n         ostream&amp; os; // members to hold the capture list int m;\n     public:\n         Modulo_print(ostream&amp; s, int mm) :os(s), m(mm) {} \n         void operator()(int x) const\n           { \n             if (x%m==0) os &lt;&lt; x &lt;&lt; &apos;\\n&apos;; \n           }\n};\n\n\nor even\n\nvoid print_modulo(const vector&lt;int&gt;&amp; v, ostream&amp; os, int m) \n     // output v[i] to os if v[i]%m==0\n{\n    class Modulo_print {\n        ostream&amp; os; // members to hold the capture list\n        int m; \n        public:\n           Modulo_print (ostream&amp; s, int mm) :os(s), m(mm) {}\n           void operator()(int x) const\n           { \n               if (x%m==0) os &lt;&lt; x &lt;&lt; &apos;\\n&apos;;\n           }\n     };\n     for_each(begin(v),end(v),Modulo_print{os,m}); \n}\n\n\nif u need u can name lambda expression like below:\n\nvoid print_modulo(const vector&lt;int&gt;&amp; v, ostream&amp; os, int m)\n    // output v[i] to os if v[i]%m==0\n{\n      auto Modulo_print = [&amp;os,m] (int x) { if (x%m==0) os &lt;&lt; x &lt;&lt; &apos;\\n&apos;; };\n      for_each(begin(v),end(v),Modulo_print);\n }\n\n\nOr assume another simple sample\n\nvoid TestFunctions::simpleLambda() {\n    bool sensitive = true;\n    std::vector&lt;int&gt; v = std::vector&lt;int&gt;({1,33,3,4,5,6,7});\n\n    sort(v.begin(),v.end(),\n         [sensitive](int x, int y) {\n             printf(&quot;\\n%i\\n&quot;,  x &lt; y);\n             return sensitive ? x &lt; y : abs(x) &lt; abs(y);\n         });\n\n\n    printf(&quot;sorted&quot;);\n    for_each(v.begin(), v.end(),\n             [](int x) {\n                 printf(&quot;x - %i;&quot;, x);\n             }\n             );\n}\n\n\nwill generate next\n\n\n  0\n  \n  1\n  \n  0\n  \n  1\n  \n  0\n  \n  1\n  \n  0\n  \n  1\n  \n  0\n  \n  1\n  \n  0 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;\n\n\n[] - this is capture list or lambda introducer: if lambdas require no access to their local environment we can use it.\n\nQuote from book:\n\n\n  The first character of a lambda expression is always [. A lambda\n  introducer can take various forms:\n  \n   []: an empty capture list. This\n  implies that no local names from the surrounding context can be used\n  in the lambda body. For such lambda expressions, data is obtained from\n  arguments or from nonlocal variables. \n  \n   [&amp;]: implicitly capture by\n  reference. All local names can be used. All local variables are\n  accessed by reference.\n  \n   [=]: implicitly capture by value. All local\n  names can be used. All names refer to copies of the local variables\n  taken at the point of call of the lambda expression.\n  \n   [capture-list]:  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by &amp; are captured by\n  reference. Other variables are captured by value. A capture list can\n  also contain this and names followed by ... as elements. \n  \n   [&amp;,  capture-list]: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by &amp;. Variables named in the\n  capture list are captured by value. \n  \n   [=, capture-list]: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by &amp;. Vari- ables named in the capture list are captured by  reference. \n  \n  Note that a local name preceded by &amp; is always captured by\n  reference and a local name not pre- ceded by &amp; is always captured by\n  value. Only capture by reference allows modification of variables in\n  the calling environment.\n\n\nAdditional\n\nLambda expression format\n\n\n\nAdditional references:\n\n\nWiki\nopen-std.org, chapter 5.1.2\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"The lambda&apos;s in c++ are treated as &quot;on the go available function&quot;.\nyes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone.\n\nc++ introduced it in c++ 11 and everyone started using it like at every possible place.\nthe example and what is lambda can be find here https://en.cppreference.com/w/cpp/language/lambda\n\ni will describe which is not there but essential to know for every c++ programmer \n\nLambda is not meant to use everywhere and every function cannot be replaced with lambda. It&apos;s also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.\n\nit will surely help in reducing number of lines in some cases.\nit can be basically used for the section of code, which is getting called in same function one or more time and that piece of code is not needed anywhere else so that you can create standalone function for it.\n\nBelow is the basic example of lambda and what happens in background.\n\nUser code:\n\nint main()\n{\n  // Lambda &amp; auto\n  int member=10;\n  auto endGame = [=](int a, int b){ return a+b+member;};\n\n  endGame(4,5);\n\n  return 0;\n\n}\n\n\nHow compile expands it:\n\nint main()\n{\n  int member = 10;\n\n  class __lambda_6_18\n  {\n    int member;\n    public: \n    inline /*constexpr */ int operator()(int a, int b) const\n    {\n      return a + b + member;\n    }\n\n    public: __lambda_6_18(int _member)\n    : member{_member}\n    {}\n\n  };\n\n  __lambda_6_18 endGame = __lambda_6_18{member};\n  endGame.operator()(4, 5);\n\n  return 0;\n}\n\n\nso as you can see, what kind of overhead it adds when you use it.\nso its not good idea to use them everywhere.\nit can be used at places where they are applicable.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Well, one practical use I&apos;ve found out is reducing boiler plate code. For example:\n\nvoid process_z_vec(vector&lt;int&gt;&amp; vec)\n{\n  auto print_2d = [](const vector&lt;int&gt;&amp; board, int bsize)\n  {\n    for(int i = 0; i&lt;bsize; i++)\n    {\n      for(int j=0; j&lt;bsize; j++)\n      {\n        cout &lt;&lt; board[bsize*i+j] &lt;&lt; &quot; &quot;;\n      }\n      cout &lt;&lt; &quot;\\n&quot;;\n    }\n  };\n  // Do sth with the vec.\n  print_2d(vec,x_size);\n  // Do sth else with the vec.\n  print_2d(vec,y_size);\n  //... \n}\n\n\nWithout lambda, you may need to do something for different bsize cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"C++ 11 introduced lambda expression to allow us write an inline function which can be used for short snippets of code\n[ capture clause ] (parameters) -&gt; return-type\n{\n   definition of method\n}\n\nGenerally return-type in lambda expression are evaluated by compiler itself and we dont need to specify that explicitly and -&gt; return-type part can be ignored but in some complex case as in conditional statement, compiler cant make out the return type and we need to specify that.\n// C++ program to demonstrate lambda expression in C++\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to print vector\nvoid printVector(vector&lt;int&gt; v)\n{\n    // lambda expression to print vector\n    for_each(v.begin(), v.end(), [](int i)\n    {\n        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    });\n    cout &lt;&lt; endl;\n}\n\nint main()\n{\n    vector&lt;int&gt; v {4, 1, 3, 5, 2, 3, 1, 7};\n\n    printVector(v);\n\n    // below snippet find first number greater than 4\n    // find_if searches for an element for which\n    // function(third argument) returns true\n    vector&lt;int&gt;:: iterator p = find_if(v.begin(), v.end(), [](int i)\n    {\n        return i &gt; 4;\n    });\n    cout &lt;&lt; &quot;First number greater than 4 is : &quot; &lt;&lt; *p &lt;&lt; endl;\n\n\n    // function to sort vector, lambda expression is for sorting in\n    // non-decreasing order Compiler can make out return type as\n    // bool, but shown here just for explanation\n    sort(v.begin(), v.end(), [](const int&amp; a, const int&amp; b) -&gt; bool\n    {\n        return a &gt; b;\n    });\n\n    printVector(v);\n\n    // function to count numbers greater than or equal to 5\n    int count_5 = count_if(v.begin(), v.end(), [](int a)\n    {\n        return (a &gt;= 5);\n    });\n    cout &lt;&lt; &quot;The number of elements greater than or equal to 5 is : &quot;\n        &lt;&lt; count_5 &lt;&lt; endl;\n\n    // function for removing duplicate element (after sorting all\n    // duplicate comes together)\n    p = unique(v.begin(), v.end(), [](int a, int b)\n    {\n        return a == b;\n    });\n\n    // resizing vector to make size equal to total different number\n    v.resize(distance(v.begin(), p));\n    printVector(v);\n\n    // accumulate function accumulate the container on the basis of\n    // function provided as third argument\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int f = accumulate(arr, arr + 10, 1, [](int i, int j)\n    {\n        return i * j;\n    });\n\n    cout &lt;&lt; &quot;Factorial of 10 is : &quot; &lt;&lt; f &lt;&lt; endl;\n\n    //   We can also access function by storing this into variable\n    auto square = [](int i)\n    {\n        return i * i;\n    };\n\n    cout &lt;&lt; &quot;Square of 5 is : &quot; &lt;&lt; square(5) &lt;&lt; endl;\n}\n\nOutput\n4 1 3 5 2 3 1 7\nFirst number greater than 4 is : 5\n7 5 4 3 3 2 1 1\nThe number of elements greater than or equal to 5 is : 2\n7 5 4 3 2 1\nFactorial of 10 is : 3628800\nSquare of 5 is : 25\n\nA lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from enclosing scope by three ways :\n\nCapture by reference\nCapture by value\nCapture by both (mixed capture)\n\nThe syntax used for capturing variables :\n\n[&amp;] : capture all external variable by reference\n[=] : capture all external variable by value\n[a, &amp;b] : capture a by value and b by reference\nA lambda with empty capture clause [ ] can access only those variable which are local to it.\n\n    #include &lt;bits/stdc++.h&gt;\n    using namespace std;\n    \n    int main()\n    {\n        vector&lt;int&gt; v1 = {3, 1, 7, 9};\n        vector&lt;int&gt; v2 = {10, 2, 7, 16, 9};\n    \n        // access v1 and v2 by reference\n        auto pushinto = [&amp;] (int m)\n        {\n            v1.push_back(m);\n            v2.push_back(m);\n        };\n    \n        // it pushes 20 in both v1 and v2\n        pushinto(20);\n    \n        // access v1 by copy\n        [v1]()\n        {\n            for (auto p = v1.begin(); p != v1.end(); p++)\n            {\n                cout &lt;&lt; *p &lt;&lt; &quot; &quot;;\n            }\n        };\n    \n        int N = 5;\n    \n        // below snippet find first number greater than N\n        // [N] denotes, can access only N by value\n        vector&lt;int&gt;:: iterator p = find_if(v1.begin(), v1.end(), [N](int i)\n        {\n            return i &gt; N;\n        });\n    \n        cout &lt;&lt; &quot;First number greater than 5 is : &quot; &lt;&lt; *p &lt;&lt; endl;\n    \n        // function to count numbers greater than or equal to N\n        // [=] denotes, can access all variable\n        int count_N = count_if(v1.begin(), v1.end(), [=](int a)\n        {\n            return (a &gt;= N);\n        });\n    \n        cout &lt;&lt; &quot;The number of elements greater than or equal to 5 is : &quot;\n            &lt;&lt; count_N &lt;&lt; endl;\n    }\n\nOutput:\n   First number greater than 5 is : 7\n   The number of elements greater than or equal to 5 is : 3\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"One problem it solves: Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const member\n\nYou can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-a-lambda-expression-in-c++11-1657387999252#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-a-lambda-expression-in-c++11-1657387999252"><h1>What is a lambda expression in C++11?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/lambda">lambda</a></div></div><div class="question-content mt-5">
                
<p>What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn't possible prior to their introduction?</p>

<p>A few examples, and use cases would be useful. </p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>The problem</h1>
<p>C++ includes useful generic functions like <code>std::for_each</code> and <code>std::transform</code>, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the <a href="https://stackoverflow.com/questions/356950/c-functors-and-their-uses">functor</a> you would like to apply is unique to the particular function.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">namespace</span> {
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">f</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>{
      <span class="hljs-comment">// do something</span>
    }
  };
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{
  f f;
  std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), f);
}
</code></pre>
<p>If you only use <code>f</code> once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.</p>
<p>In C++03 you might be tempted to write something like the following, to keep the functor local:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{
  <span class="hljs-keyword">struct</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>{
       <span class="hljs-comment">// do something</span>
    }
  } f;
  std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), f);
}
</code></pre>
<p>however this is not allowed, <code>f</code> cannot be passed to a <a href="https://en.cppreference.com/w/cpp/language/function_template" rel="noreferrer">template</a> function in C++03.</p>
<h1>The new solution</h1>
<p>C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the <code>struct f</code>. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{
  std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span>) { <span class="hljs-comment">/* do something here*/</span> });
}
</code></pre>
<p>Lambda functions are just syntactic sugar for anonymous functors.</p>
<h2>Return types</h2>
<p>In simple cases the return type of the lambda is deduced for you, e.g.:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; v)</span> </span>{
  std::<span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>(),
                 [](<span class="hljs-type">double</span> d) { <span class="hljs-keyword">return</span> d &lt; <span class="hljs-number">0.00001</span> ? <span class="hljs-number">0</span> : d; }
                 );
}
</code></pre>
<p>however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; v)</span> </span>{
    std::<span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>(),
        [](<span class="hljs-type">double</span> d) {
            <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.0001</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> d;
            }
        });
}
</code></pre>
<p>To resolve this you are allowed to explicitly specify a return type for a lambda function, using <code>-&gt; T</code>:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; v)</span> </span>{
    std::<span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>(),
        [](<span class="hljs-type">double</span> d) -&gt; <span class="hljs-type">double</span> {
            <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.0001</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> d;
            }
        });
}
</code></pre>
<h2>"Capturing" variables</h2>
<p>So far we've not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the <code>[]</code> of the expression), which has so far been unused in these examples, e.g.:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func5</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; v, <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; epsilon)</span> </span>{
    std::<span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>(),
        [epsilon](<span class="hljs-type">double</span> d) -&gt; <span class="hljs-type">double</span> {
            <span class="hljs-keyword">if</span> (d &lt; epsilon) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> d;
            }
        });
}
</code></pre>
<p>You can capture by both reference and value, which you can specify using <code>&amp;</code> and <code>=</code> respectively:</p>
<ul>
<li><code>[&amp;epsilon, zeta]</code> captures epsilon by reference and zeta by value</li>
<li><code>[&amp;]</code> captures all variables used in the lambda by reference</li>
<li><code>[=]</code> captures all variables used in the lambda by value</li>
<li><code>[&amp;, epsilon]</code> captures all variables used in the lambda by reference but captures epsilon by value</li>
<li><code>[=, &amp;epsilon]</code> captures all variables used in the lambda by value but captures epsilon by reference</li>
</ul>
<p>The generated <code>operator()</code> is <code>const</code> by default, with the implication that captures will be <code>const</code> when you access them by default. This has the effect that each call with the same input would produce the same result, however you can <a href="https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul">mark the lambda as <code>mutable</code></a> to request that the <code>operator()</code> that is produced is not <code>const</code>.</p>

    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>What is a lambda function?</h1>

<p>The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.</p>

<p>In C++ a lambda function is defined like this</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[]() { } <span class="hljs-comment">// barebone lambda</span>
</code></pre>

<p>or in all its glory</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[]() <span class="hljs-keyword">mutable</span> -&gt; T { } <span class="hljs-comment">// T is the return type, still lacking throw()</span>
</code></pre>

<p><code>[]</code> is the capture list, <code>()</code> the argument list and <code>{}</code> the function body.</p>

<h2>The capture list</h2>

<p>The capture list defines what from the outside of the lambda should be available inside the function body and how.
It can be either:</p>

<ol>
<li>a value: [x]</li>
<li>a reference [&amp;x]</li>
<li>any variable currently in scope by reference [&amp;]</li>
<li>same as 3, but by value [=]</li>
</ol>

<p>You can mix any of the above in a comma separated list <code>[x, &amp;y]</code>.</p>

<h2>The argument list</h2>

<p>The argument list is the same as in any other C++ function. </p>

<h2>The function body</h2>

<p>The code that will be executed when the lambda is actually called.</p>

<h2>Return type deduction</h2>

<p>If a lambda has only one return statement, the return type can be omitted and has the implicit type of <code>decltype(return_statement)</code>.</p>

<h2>Mutable</h2>

<p>If a lambda is marked mutable (e.g. <code>[]() mutable { }</code>) it is allowed to mutate the values that have been captured by value.</p>

<h1>Use cases</h1>

<p>The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don't have to clutter their code with small functors in some accessible scope.</p>

<h1>C++14</h1>

<p>In C++14 lambdas have been extended by various proposals.</p>

<h2>Initialized Lambda Captures</h2>

<p>An element of the capture list can now be initialized with <code>=</code>. This allows renaming of variables and to capture by moving. An example taken from the standard:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">4</span>;
<span class="hljs-keyword">auto</span> y = [&amp;r = x, x = x+<span class="hljs-number">1</span>]()-&gt;<span class="hljs-type">int</span> {
            r += <span class="hljs-number">2</span>;
            <span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>;
         }();  <span class="hljs-comment">// Updates ::x to 6, and initializes y to 7.</span>
</code></pre>

<p>and one taken from Wikipedia showing how to capture with <code>std::move</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>); <span class="hljs-comment">// See below for std::make_unique</span>
<span class="hljs-keyword">auto</span> lambda = [ptr = std::<span class="hljs-built_in">move</span>(ptr)] {<span class="hljs-keyword">return</span> *ptr;};
</code></pre>

<h2>Generic Lambdas</h2>

<p>Lambdas can now be generic (<code>auto</code> would be equivalent to <code>T</code> here if
<code>T</code> were a type template argument somewhere in the surrounding scope):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) {<span class="hljs-keyword">return</span> x + y;};
</code></pre>

<h2>Improved Return Type Deduction</h2>

<p>C++14 allows deduced return types for every function and does not restrict it to functions of the form <code>return expression;</code>. This is also extended to lambdas.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, <strong>it is possible to execute a lambda immediately upon definition</strong>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[&amp;](){ ...your code... }(); <span class="hljs-comment">// immediately executed lambda expression</span>
</code></pre>

<p>is functionally equivalent to</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">{ ...your code... } <span class="hljs-comment">// simple code block</span>
</code></pre>

<p>This makes lambda expressions <strong>a powerful tool for refactoring complex functions</strong>.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the <code>&amp;</code>), you can move the code to an external location and make it a normal function.</p>

<p>Similarly, you can use lambda expressions to <strong>initialize variables based on the result of an algorithm</strong>...</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> a = []( <span class="hljs-type">int</span> b ){ <span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; <span class="hljs-keyword">while</span> (b&gt;<span class="hljs-number">0</span>) r*=b--; <span class="hljs-keyword">return</span> r; }(<span class="hljs-number">5</span>); <span class="hljs-comment">// 5!</span>
</code></pre>

<p>As <strong>a way of partitioning your program logic</strong>, you might even find it useful to pass a lambda expression as an argument to another lambda expression...</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[&amp;]( std::function&lt;<span class="hljs-built_in">void</span>()&gt; algorithm ) <span class="hljs-comment">// wrapper section</span>
   {
   ...your wrapper code...
   <span class="hljs-built_in">algorithm</span>();
   ...your wrapper code...
   }
([&amp;]() <span class="hljs-comment">// algorithm section</span>
   {
   ...your algorithm code...
   });
</code></pre>

<p>Lambda expressions also let you create named <a href="http://en.wikipedia.org/wiki/Nested_function" rel="noreferrer"><strong>nested functions</strong></a>, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  <em>Note: don't forget the semicolon after the closing curly brace.</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> algorithm = [&amp;]( <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> m, <span class="hljs-type">double</span> b ) -&gt; <span class="hljs-type">double</span>
   {
   <span class="hljs-keyword">return</span> m*x+b;
   };

<span class="hljs-type">int</span> a=<span class="hljs-built_in">algorithm</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), b=<span class="hljs-built_in">algorithm</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);
</code></pre>

<p>If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Answers</strong></p>

<p>Q: What is a lambda expression in C++11?</p>

<p>A: Under the hood, it is the object of an autogenerated class with overloading <strong>operator() const</strong>. Such object is called <em>closure</em> and created by compiler.
This 'closure' concept is near with the bind concept from C++11. 
But lambdas typically generate better code. And calls through closures allow full inlining.</p>

<p>Q: When would I use one?</p>

<p>A: To define "simple and small logic" and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.</p>

<p>Q: What class of problem do they solve that wasn't possible prior to their introduction?</p>

<p>A: It is some kind of syntax sugar like operators overloading instead of functions for custom <em>add, subrtact</em> operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I'm also think so)</p>

<p><strong>Example of usage</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> x = [=](<span class="hljs-type">int</span> arg1){<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i"</span>, arg1); };
<span class="hljs-built_in">void</span>(*f)(<span class="hljs-type">int</span>) = x;
<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);
<span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>);
</code></pre>

<hr>

<p><strong>Extras about lambdas, not covered by question. Ignore this section if you're not interest</strong></p>

<p><em>1. Captured values. What you can to capture</em></p>

<p>1.1. You can reference to a variable with static storage duration in lambdas. They all are captured.</p>

<p>1.2. You can use lambda for capture values "by value". In such case captured vars will be copied to the function object (closure).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[captureVar1,captureVar2](<span class="hljs-type">int</span> arg1){}
</code></pre>

<p>1.3. You can capture be reference. &amp; -- in this context mean reference, not pointers.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   [&amp;captureVar1,&amp;captureVar2](<span class="hljs-type">int</span> arg1){}
</code></pre>

<p>1.4. It exists notation to capture all non-static vars by value, or by reference</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">  [=](<span class="hljs-type">int</span> arg1){} <span class="hljs-comment">// capture all not-static vars by value</span>

  [&amp;](<span class="hljs-type">int</span> arg1){} <span class="hljs-comment">// capture all not-static vars by reference</span>
</code></pre>

<p>1.5.  It exists notation to capture all non-static vars by value, or by reference and specify smth. more.
Examples:
Capture all not-static vars by value, but by reference capture Param2</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[=,&amp;Param2](<span class="hljs-type">int</span> arg1){} 
</code></pre>

<p>Capture all not-static vars by reference, but by value capture Param2</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[&amp;,Param2](<span class="hljs-type">int</span> arg1){} 
</code></pre>

<p><em>2. Return type deduction</em></p>

<p>2.1. Lambda return type can be deduced if lambda is one expression. Or you can explicitly specify it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[=](<span class="hljs-type">int</span> arg1)-&gt;trailing_return_type{<span class="hljs-keyword">return</span> <span class="hljs-built_in">trailing_return_type</span>();}
</code></pre>

<p>If lambda has more then one expression, then return type must be specified via trailing return type. 
  Also, similar syntax can be applied to auto functions and member-functions</p>

<p><em>3. Captured values. What you can not capture</em></p>

<p>3.1. You can capture only local vars, not member variable of the object.</p>

<p><em>4. Сonversions</em></p>

<p>4.1 !! Lambda is not a function pointer and it is not an anonymous function, but <strong>capture-less</strong> lambdas can be implicitly converted to a function pointer.</p>

<p><strong>p.s.</strong> </p>

<ol>
<li><p>More about lambda grammar information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88</p></li>
<li><p>In C++14 the extra feature which has named as "init capture" have been added. It allow to perform arbitarily declaration of closure data members:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> toFloat = [](<span class="hljs-type">int</span> value) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(value);};
<span class="hljs-keyword">auto</span> interpolate = [min = <span class="hljs-built_in">toFloat</span>(<span class="hljs-number">0</span>), max = <span class="hljs-built_in">toFloat</span>(<span class="hljs-number">255</span>)](<span class="hljs-type">int</span> value)-&gt;<span class="hljs-type">float</span> { <span class="hljs-built_in">return</span> (value - min) / (max - min);};
</code></pre></li>
</ol>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. <a href="http://www.stroustrup.com/C++11FAQ.html#lambda">http://www.stroustrup.com/C++11FAQ.html#lambda</a>) but there are some limitations. For example, if there's a callback interface like this, </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">void</span> (*f)(<span class="hljs-type">int</span>))</span> </span>{
    <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);
    <span class="hljs-built_in">f</span>(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">f</span>(<span class="hljs-number">30</span>);
}
</code></pre>

<p>you can write a function on the spot to use it like the one passed to apply below:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">apply</span>([](<span class="hljs-type">int</span> data) {
        cout &lt;&lt; data &lt;&lt; ((++col % <span class="hljs-number">10</span>) ? <span class="hljs-string">' '</span> : <span class="hljs-string">'\n'</span>);
    });
}
</code></pre>

<p>But you can't do this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">apply</span>([&amp;col,n](<span class="hljs-type">int</span> data) {
        cout &lt;&lt; data &lt;&lt; ((++col % <span class="hljs-number">10</span>) ? <span class="hljs-string">' '</span> : <span class="hljs-string">'\n'</span>);
    });
}
</code></pre>

<p>because of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> </span>
</code></pre>

<p>(or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f)</span> </span>{
    <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);
    <span class="hljs-built_in">f</span>(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">f</span>(<span class="hljs-number">30</span>);
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> width)</span> </span>{
    <span class="hljs-type">int</span> col;
    <span class="hljs-built_in">apply</span>([width,&amp;col](<span class="hljs-type">int</span> data) {
        cout &lt;&lt; data &lt;&lt; ((++col % width) ? <span class="hljs-string">' '</span> : <span class="hljs-string">'\n'</span>);
    });
}
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One of the best explanation of <code>lambda expression</code> is given from author of C++ <strong>Bjarne Stroustrup</strong> in his book <code>***The C++ Programming Language***</code> chapter 11 (<a href="https://rads.stackoverflow.com/amzn/click/com/0321563840" rel="noreferrer">ISBN-13: 978-0321563842</a>):</p>

<p><strong><code>What is a lambda expression?</code></strong> </p>

<blockquote>
  <p>A <em>lambda expression</em>, sometimes also referred to as a <em>lambda</em>
  function or (strictly speaking incorrectly, but colloquially) as a
  <em>lambda</em>, is a simplified notation for defining and using an <strong>anonymous function object</strong>. Instead of defining a named class with an operator(), later making an object of that class, and finally
  invoking it, we can use a shorthand.</p>
</blockquote>

<p><strong><code>When would I use one?</code></strong></p>

<blockquote>
  <p>This is particularly useful when we want to pass an operation as an
  argument to an algorithm. In the context of graphical user interfaces
  (and elsewhere), such operations are often referred to as <em>callbacks</em>.</p>
</blockquote>

<p><strong><code>What class of problem do they solve that wasn't possible prior to their introduction?</code></strong></p>

<p>Here i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :</p>

<blockquote>
  <p>effective ways of optimizing</p>
</blockquote>

<p><strong><code>Some examples</code></strong></p>

<p>via lambda expression</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_modulo</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, ostream&amp; os, <span class="hljs-type">int</span> m)</span> <span class="hljs-comment">// output v[i] to os if v[i]%m==0</span>
</span>{
    for_each(<span class="hljs-built_in">begin</span>(v),<span class="hljs-built_in">end</span>(v),
        [&amp;os,m](<span class="hljs-type">int</span> x) { 
           <span class="hljs-keyword">if</span> (x%m==<span class="hljs-number">0</span>) os &lt;&lt; x &lt;&lt; <span class="hljs-string">'\n'</span>;
         });
}
</code></pre>

<p>or via function</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modulo_print</span> {
         ostream&amp; os; <span class="hljs-comment">// members to hold the capture list int m;</span>
     <span class="hljs-keyword">public</span>:
         <span class="hljs-built_in">Modulo_print</span>(ostream&amp; s, <span class="hljs-type">int</span> mm) :<span class="hljs-built_in">os</span>(s), <span class="hljs-built_in">m</span>(mm) {} 
         <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span>
           </span>{ 
             <span class="hljs-keyword">if</span> (x%m==<span class="hljs-number">0</span>) os &lt;&lt; x &lt;&lt; <span class="hljs-string">'\n'</span>; 
           }
};
</code></pre>

<p>or even</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_modulo</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, ostream&amp; os, <span class="hljs-type">int</span> m)</span> 
     <span class="hljs-comment">// output v[i] to os if v[i]%m==0</span>
</span>{
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Modulo_print</span> {
        ostream&amp; os; <span class="hljs-comment">// members to hold the capture list</span>
        <span class="hljs-type">int</span> m; 
        <span class="hljs-keyword">public</span>:
           <span class="hljs-built_in">Modulo_print</span> (ostream&amp; s, <span class="hljs-type">int</span> mm) :<span class="hljs-built_in">os</span>(s), <span class="hljs-built_in">m</span>(mm) {}
           <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span>
           </span>{ 
               <span class="hljs-keyword">if</span> (x%m==<span class="hljs-number">0</span>) os &lt;&lt; x &lt;&lt; <span class="hljs-string">'\n'</span>;
           }
     };
     for_each(<span class="hljs-built_in">begin</span>(v),<span class="hljs-built_in">end</span>(v),Modulo_print{os,m}); 
}
</code></pre>

<p>if u need u can name <code>lambda expression</code> like below:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_modulo</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, ostream&amp; os, <span class="hljs-type">int</span> m)</span>
    <span class="hljs-comment">// output v[i] to os if v[i]%m==0</span>
</span>{
      <span class="hljs-keyword">auto</span> Modulo_print = [&amp;os,m] (<span class="hljs-type">int</span> x) { <span class="hljs-keyword">if</span> (x%m==<span class="hljs-number">0</span>) os &lt;&lt; x &lt;&lt; <span class="hljs-string">'\n'</span>; };
      for_each(<span class="hljs-built_in">begin</span>(v),<span class="hljs-built_in">end</span>(v),Modulo_print);
 }
</code></pre>

<p>Or assume another simple sample</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestFunctions::simpleLambda</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">bool</span> sensitive = <span class="hljs-literal">true</span>;
    std::vector&lt;<span class="hljs-type">int</span>&gt; v = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;({<span class="hljs-number">1</span>,<span class="hljs-number">33</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>});

    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),
         [sensitive](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%i\n"</span>,  x &lt; y);
             <span class="hljs-keyword">return</span> sensitive ? x &lt; y : <span class="hljs-built_in">abs</span>(x) &lt; <span class="hljs-built_in">abs</span>(y);
         });


    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sorted"</span>);
    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),
             [](<span class="hljs-type">int</span> x) {
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x - %i;"</span>, x);
             }
             );
}
</code></pre>

<p>will generate next</p>

<blockquote>
  <p>0</p>
  
  <p>1</p>
  
  <p>0</p>
  
  <p>1</p>
  
  <p>0</p>
  
  <p>1</p>
  
  <p>0</p>
  
  <p>1</p>
  
  <p>0</p>
  
  <p>1</p>
  
  <p>0 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;</p>
</blockquote>

<p><code>[]</code> - this is capture list or <code>lambda introducer</code>: if <code>lambdas</code> require no access to their local environment we can use it.</p>

<p>Quote from book:</p>

<blockquote>
  <p>The first character of a lambda expression is always <strong>[</strong>. A lambda
  introducer can take various forms:</p>
  
  <p> <strong>[]</strong>: an empty capture list. This
  implies that no local names from the surrounding context can be used
  in the lambda body. For such lambda expressions, data is obtained from
  arguments or from nonlocal variables. </p>
  
  <p> <strong>[&amp;]</strong>: implicitly capture by
  reference. All local names can be used. All local variables are
  accessed by reference.</p>
  
  <p> <strong>[=]</strong>: implicitly capture by value. All local
  names can be used. All names refer to copies of the local variables
  taken at the point of call of the lambda expression.</p>
  
  <p> <strong>[capture-list]:</strong>  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by &amp; are captured by
  reference. Other variables are captured by value. A capture list can
  also contain this and names followed by ... as elements. </p>
  
  <p> <strong>[&amp;,  capture-list]</strong>: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by &amp;. Variables named in the
  capture list are captured by value. </p>
  
  <p> <strong>[=, capture-list]</strong>: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by &amp;. Vari- ables named in the capture list are captured by  reference. </p>
  
  <p>Note that a local name preceded by &amp; is always captured by
  reference and a local name not pre- ceded by &amp; is always captured by
  value. Only capture by reference allows modification of variables in
  the calling environment.</p>
</blockquote>

<p><strong><code>Additional</code></strong></p>

<p><code>Lambda expression</code> format</p>

<p><a href="https://i.stack.imgur.com/03yye.png" rel="noreferrer"><img src="https://i.stack.imgur.com/03yye.png" alt="enter image description here"></a></p>

<p>Additional references:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29" rel="noreferrer">Wiki</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" rel="noreferrer">open-std.org</a>, chapter 5.1.2</li>
</ul>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The lambda's in c++ are treated as "on the go available function".
yes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone.</p>

<p>c++ introduced it in c++ 11 and everyone started using it like at every possible place.
the example and what is lambda can be find here <a href="https://en.cppreference.com/w/cpp/language/lambda" rel="noreferrer">https://en.cppreference.com/w/cpp/language/lambda</a></p>

<p><strong><em>i will describe which is not there but essential to know for every c++ programmer</em></strong> </p>

<p>Lambda is not meant to use everywhere and every function cannot be replaced with lambda. It's also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.</p>

<p>it will surely help in reducing number of lines in some cases.
it can be basically used for the section of code, which is getting called in same function one or more time and that piece of code is not needed anywhere else so that you can create standalone function for it.</p>

<p>Below is the basic example of lambda and what happens in background.</p>

<p><strong>User code:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// Lambda &amp; auto</span>
  <span class="hljs-type">int</span> member=<span class="hljs-number">10</span>;
  <span class="hljs-keyword">auto</span> endGame = [=](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b){ <span class="hljs-keyword">return</span> a+b+member;};

  <span class="hljs-built_in">endGame</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}
</code></pre>

<p><strong>How compile expands it:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">int</span> member = <span class="hljs-number">10</span>;

  <span class="hljs-keyword">class</span> <span class="hljs-title class_">__lambda_6_18</span>
  {
    <span class="hljs-type">int</span> member;
    <span class="hljs-keyword">public</span>: 
    <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span>
    </span>{
      <span class="hljs-keyword">return</span> a + b + member;
    }

    <span class="hljs-keyword">public</span>: __lambda_6_18(<span class="hljs-type">int</span> _member)
    : member{_member}
    {}

  };

  __lambda_6_18 endGame = __lambda_6_18{member};
  endGame.<span class="hljs-built_in">operator</span>()(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>so as you can see, what kind of overhead it adds when you use it.
so its not good idea to use them everywhere.
it can be used at places where they are applicable.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, one practical use I've found out is reducing boiler plate code. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_z_vec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span>
</span>{
  <span class="hljs-keyword">auto</span> print_2d = [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; board, <span class="hljs-type">int</span> bsize)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;bsize; i++)
    {
      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;bsize; j++)
      {
        cout &lt;&lt; board[bsize*i+j] &lt;&lt; <span class="hljs-string">" "</span>;
      }
      cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
  };
  <span class="hljs-comment">// Do sth with the vec.</span>
  <span class="hljs-built_in">print_2d</span>(vec,x_size);
  <span class="hljs-comment">// Do sth else with the vec.</span>
  <span class="hljs-built_in">print_2d</span>(vec,y_size);
  <span class="hljs-comment">//... </span>
}
</code></pre>

<p>Without lambda, you may need to do something for different <code>bsize</code> cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++ 11 introduced lambda expression to allow us write an inline function which can be used for short snippets of code</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[ capture clause ] (parameters) -&gt; <span class="hljs-keyword">return</span>-type
{
   definition of method
}
</code></pre>
<p>Generally return-type in lambda expression are evaluated by compiler itself and we dont need to specify that explicitly and -&gt; return-type part can be ignored but in some complex case as in conditional statement, compiler cant make out the return type and we need to specify that.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// C++ program to demonstrate lambda expression in C++</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// Function to print vector</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span>
</span>{
    <span class="hljs-comment">// lambda expression to print vector</span>
    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> i)
    {
        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;
    });
    cout &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    vector&lt;<span class="hljs-type">int</span>&gt; v {<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>};

    <span class="hljs-built_in">printVector</span>(v);

    <span class="hljs-comment">// below snippet find first number greater than 4</span>
    <span class="hljs-comment">// find_if searches for an element for which</span>
    <span class="hljs-comment">// function(third argument) returns true</span>
    vector&lt;<span class="hljs-type">int</span>&gt;:: iterator p = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> i)
    {
        <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">4</span>;
    });
    cout &lt;&lt; <span class="hljs-string">"First number greater than 4 is : "</span> &lt;&lt; *p &lt;&lt; endl;


    <span class="hljs-comment">// function to sort vector, lambda expression is for sorting in</span>
    <span class="hljs-comment">// non-decreasing order Compiler can make out return type as</span>
    <span class="hljs-comment">// bool, but shown here just for explanation</span>
    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b) -&gt; <span class="hljs-type">bool</span>
    {
        <span class="hljs-keyword">return</span> a &gt; b;
    });

    <span class="hljs-built_in">printVector</span>(v);

    <span class="hljs-comment">// function to count numbers greater than or equal to 5</span>
    <span class="hljs-type">int</span> count_5 = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a)
    {
        <span class="hljs-built_in">return</span> (a &gt;= <span class="hljs-number">5</span>);
    });
    cout &lt;&lt; <span class="hljs-string">"The number of elements greater than or equal to 5 is : "</span>
        &lt;&lt; count_5 &lt;&lt; endl;

    <span class="hljs-comment">// function for removing duplicate element (after sorting all</span>
    <span class="hljs-comment">// duplicate comes together)</span>
    p = <span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)
    {
        <span class="hljs-keyword">return</span> a == b;
    });

    <span class="hljs-comment">// resizing vector to make size equal to total different number</span>
    v.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">distance</span>(v.<span class="hljs-built_in">begin</span>(), p));
    <span class="hljs-built_in">printVector</span>(v);

    <span class="hljs-comment">// accumulate function accumulate the container on the basis of</span>
    <span class="hljs-comment">// function provided as third argument</span>
    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>};
    <span class="hljs-type">int</span> f = <span class="hljs-built_in">accumulate</span>(arr, arr + <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)
    {
        <span class="hljs-keyword">return</span> i * j;
    });

    cout &lt;&lt; <span class="hljs-string">"Factorial of 10 is : "</span> &lt;&lt; f &lt;&lt; endl;

    <span class="hljs-comment">//   We can also access function by storing this into variable</span>
    <span class="hljs-keyword">auto</span> square = [](<span class="hljs-type">int</span> i)
    {
        <span class="hljs-keyword">return</span> i * i;
    };

    cout &lt;&lt; <span class="hljs-string">"Square of 5 is : "</span> &lt;&lt; <span class="hljs-built_in">square</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;
}
</code></pre>
<p>Output</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span>
First number greater than <span class="hljs-number">4</span> is : <span class="hljs-number">5</span>
<span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>
The number of elements greater than <span class="hljs-keyword">or</span> equal to <span class="hljs-number">5</span> is : <span class="hljs-number">2</span>
<span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>
Factorial of <span class="hljs-number">10</span> is : <span class="hljs-number">3628800</span>
Square of <span class="hljs-number">5</span> is : <span class="hljs-number">25</span>
</code></pre>
<p>A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from enclosing scope by three ways :</p>
<ul>
<li>Capture by reference</li>
<li>Capture by value</li>
<li>Capture by both (mixed capture)</li>
</ul>
<p>The syntax used for capturing variables :</p>
<ul>
<li>[&amp;] : capture all external variable by reference</li>
<li>[=] : capture all external variable by value</li>
<li>[a, &amp;b] : capture a by value and b by reference
A lambda with empty capture clause [ ] can access only those variable which are local to it.</li>
</ul>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
    </span>{
        vector&lt;<span class="hljs-type">int</span>&gt; v1 = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>};
        vector&lt;<span class="hljs-type">int</span>&gt; v2 = {<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">16</span>, <span class="hljs-number">9</span>};
    
        <span class="hljs-comment">// access v1 and v2 by reference</span>
        <span class="hljs-keyword">auto</span> pushinto = [&amp;] (<span class="hljs-type">int</span> m)
        {
            v1.<span class="hljs-built_in">push_back</span>(m);
            v2.<span class="hljs-built_in">push_back</span>(m);
        };
    
        <span class="hljs-comment">// it pushes 20 in both v1 and v2</span>
        <span class="hljs-built_in">pushinto</span>(<span class="hljs-number">20</span>);
    
        <span class="hljs-comment">// access v1 by copy</span>
        [v1]()
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = v1.<span class="hljs-built_in">begin</span>(); p != v1.<span class="hljs-built_in">end</span>(); p++)
            {
                cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">" "</span>;
            }
        };
    
        <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;
    
        <span class="hljs-comment">// below snippet find first number greater than N</span>
        <span class="hljs-comment">// [N] denotes, can access only N by value</span>
        vector&lt;<span class="hljs-type">int</span>&gt;:: iterator p = <span class="hljs-built_in">find_if</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), [N](<span class="hljs-type">int</span> i)
        {
            <span class="hljs-keyword">return</span> i &gt; N;
        });
    
        cout &lt;&lt; <span class="hljs-string">"First number greater than 5 is : "</span> &lt;&lt; *p &lt;&lt; endl;
    
        <span class="hljs-comment">// function to count numbers greater than or equal to N</span>
        <span class="hljs-comment">// [=] denotes, can access all variable</span>
        <span class="hljs-type">int</span> count_N = <span class="hljs-built_in">count_if</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), [=](<span class="hljs-type">int</span> a)
        {
            <span class="hljs-built_in">return</span> (a &gt;= N);
        });
    
        cout &lt;&lt; <span class="hljs-string">"The number of elements greater than or equal to 5 is : "</span>
            &lt;&lt; count_N &lt;&lt; endl;
    }
</code></pre>
<p>Output:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   First number greater than <span class="hljs-number">5</span> is : <span class="hljs-number">7</span>
   The number of elements greater than <span class="hljs-keyword">or</span> equal to <span class="hljs-number">5</span> is : <span class="hljs-number">3</span>
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lambda">lambda</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One problem it solves: <a href="https://stackoverflow.com/questions/31078201/code-simpler-than-lambda-for-a-call-in-constructor-that-uses-an-output-parameter">Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const member</a></p>

<p>You can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118">Why does std::getline() skip input after a formatted extraction?</a><a href="/questions/how-to-append-text-to-an-existing-file-in-java-1657388492377">How to append text to an existing file in Java?</a><a href="/questions/read-file-line-by-line-using-ifstream-in-c++-1657388236966">Read file line by line using ifstream in C++</a><a href="/questions/what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749">What are drawbacks or disadvantages of singleton pattern? [closed]</a><a href="/questions/is-there-a-%22previous-sibling%22-selector-1657384771067">Is there a &quot;previous sibling&quot; selector?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474">What is an efficient way to implement a singleton pattern in Java? [closed]</a><a href="/questions/test-for-existence-of-nested-javascript-object-key-1657387935411">Test for existence of nested JavaScript object key</a><a href="/questions/can-i-bind-an-array-to-an-in()-condition-in-a-pdo-query-1657388382858">Can I bind an array to an IN() condition in a PDO query?</a><a href="/questions/how-do-i-use-reflection-to-call-a-generic-method-1657387256751">How do I use reflection to call a generic method?</a><a href="/questions/how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190">How to remove all duplicates from an array of objects?</a><a href="/questions/how-do-function-pointers-in-c-work-1657388332074">How do function pointers in C work?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/where-can-i-find-documentation-on-formatting-a-date-in-javascript-1657384878157">Where can I find documentation on formatting a date in JavaScript?</a><a href="/questions/random-number-generator-only-generating-one-random-number-1657385468315">Random number generator only generating one random number</a><a href="/questions/returning-data-from-async-call-in-swift-function-1657387469218">Returning data from async call in Swift function</a><a href="/questions/daylight-saving-time-and-time-zone-best-practices-closed-1657387973687">Daylight saving time and time zone best practices [closed]</a><a href="/questions/how-do-i-sort-a-dictionary-by-value-1657385485049">How do I sort a dictionary by value?</a><a href="/questions/actual-meaning-of-&#x27;shelltrue&#x27;-in-subprocess-1657388470341">Actual meaning of &#x27;shell=True&#x27; in subprocess</a><a href="/questions/what-is-the-self-parameter-in-class-methods-1657387518448">What is the `self` parameter in class methods?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;The problem\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;C++ includes useful generic functions like \u0026lt;code\u0026gt;std::for_each\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;std::transform\u0026lt;/code\u0026gt;, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/356950/c-functors-and-their-uses\u0026quot;\u0026gt;functor\u0026lt;/a\u0026gt; you would like to apply is unique to the particular function.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do something\u0026lt;/span\u0026gt;\n    }\n  };\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  f f;\n  std::for_each(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), f);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you only use \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C++03 you might be tempted to write something like the following, to keep the functor local:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do something\u0026lt;/span\u0026gt;\n    }\n  } f;\n  std::for_each(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), f);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;however this is not allowed, \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; cannot be passed to a \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/function_template\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;template\u0026lt;/a\u0026gt; function in C++03.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The new solution\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the \u0026lt;code\u0026gt;struct f\u0026lt;/code\u0026gt;. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  std::for_each(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do something here*/\u0026lt;/span\u0026gt; });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Lambda functions are just syntactic sugar for anonymous functors.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Return types\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In simple cases the return type of the lambda is deduced for you, e.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),\n                 [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.00001\u0026lt;/span\u0026gt; ? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; : d; }\n                 );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),\n        [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (d \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0001\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d;\n            }\n        });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To resolve this you are allowed to explicitly specify a return type for a lambda function, using \u0026lt;code\u0026gt;-\u0026amp;gt; T\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),\n        [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (d \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0001\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d;\n            }\n        });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026quot;Capturing\u0026quot; variables\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;So far we\u0026apos;ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; of the expression), which has so far been unused in these examples, e.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func5\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;amp; epsilon)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),\n        [epsilon](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (d \u0026amp;lt; epsilon) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d;\n            }\n        });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can capture by both reference and value, which you can specify using \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; respectively:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[\u0026amp;amp;epsilon, zeta]\u0026lt;/code\u0026gt; captures epsilon by reference and zeta by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[\u0026amp;amp;]\u0026lt;/code\u0026gt; captures all variables used in the lambda by reference\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[=]\u0026lt;/code\u0026gt; captures all variables used in the lambda by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[\u0026amp;amp;, epsilon]\u0026lt;/code\u0026gt; captures all variables used in the lambda by reference but captures epsilon by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[=, \u0026amp;amp;epsilon]\u0026lt;/code\u0026gt; captures all variables used in the lambda by value but captures epsilon by reference\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The generated \u0026lt;code\u0026gt;operator()\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; by default, with the implication that captures will be \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; when you access them by default. This has the effect that each call with the same input would produce the same result, however you can \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul\u0026quot;\u0026gt;mark the lambda as \u0026lt;code\u0026gt;mutable\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; to request that the \u0026lt;code\u0026gt;operator()\u0026lt;/code\u0026gt; that is produced is not \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n    ","\n\u0026lt;h1\u0026gt;What is a lambda function?\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C++ a lambda function is defined like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[]() { } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// barebone lambda\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or in all its glory\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[]() \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mutable\u0026lt;/span\u0026gt; -\u0026amp;gt; T { } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// T is the return type, still lacking throw()\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; is the capture list, \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; the argument list and \u0026lt;code\u0026gt;{}\u0026lt;/code\u0026gt; the function body.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The capture list\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The capture list defines what from the outside of the lambda should be available inside the function body and how.\nIt can be either:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;a value: [x]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a reference [\u0026amp;amp;x]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;any variable currently in scope by reference [\u0026amp;amp;]\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;same as 3, but by value [=]\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;You can mix any of the above in a comma separated list \u0026lt;code\u0026gt;[x, \u0026amp;amp;y]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The argument list\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The argument list is the same as in any other C++ function. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The function body\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The code that will be executed when the lambda is actually called.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Return type deduction\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If a lambda has only one return statement, the return type can be omitted and has the implicit type of \u0026lt;code\u0026gt;decltype(return_statement)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Mutable\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If a lambda is marked mutable (e.g. \u0026lt;code\u0026gt;[]() mutable { }\u0026lt;/code\u0026gt;) it is allowed to mutate the values that have been captured by value.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Use cases\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don\u0026apos;t have to clutter their code with small functors in some accessible scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;C++14\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;In C++14 lambdas have been extended by various proposals.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Initialized Lambda Captures\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;An element of the capture list can now be initialized with \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;. This allows renaming of variables and to capture by moving. An example taken from the standard:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; y = [\u0026amp;amp;r = x, x = x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; {\n            r += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n         }();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Updates ::x to 6, and initializes y to 7.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and one taken from Wikipedia showing how to capture with \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; ptr = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_unique\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// See below for std::make_unique\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; lambda = [ptr = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(ptr)] {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *ptr;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Generic Lambdas\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Lambdas can now be generic (\u0026lt;code\u0026gt;auto\u0026lt;/code\u0026gt; would be equivalent to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; here if\n\u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; were a type template argument somewhere in the surrounding scope):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; lambda = [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; y) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x + y;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Improved Return Type Deduction\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;C++14 allows deduced return types for every function and does not restrict it to functions of the form \u0026lt;code\u0026gt;return expression;\u0026lt;/code\u0026gt;. This is also extended to lambdas.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, \u0026lt;strong\u0026gt;it is possible to execute a lambda immediately upon definition\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[\u0026amp;amp;](){ ...your code... }(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// immediately executed lambda expression\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is functionally equivalent to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;{ ...your code... } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// simple code block\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This makes lambda expressions \u0026lt;strong\u0026gt;a powerful tool for refactoring complex functions\u0026lt;/strong\u0026gt;.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;), you can move the code to an external location and make it a normal function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, you can use lambda expressions to \u0026lt;strong\u0026gt;initialize variables based on the result of an algorithm\u0026lt;/strong\u0026gt;...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = []( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b ){ \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; r=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (b\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) r*=b--; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; r; }(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As \u0026lt;strong\u0026gt;a way of partitioning your program logic\u0026lt;/strong\u0026gt;, you might even find it useful to pass a lambda expression as an argument to another lambda expression...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[\u0026amp;amp;]( std::function\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;()\u0026amp;gt; algorithm ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// wrapper section\u0026lt;/span\u0026gt;\n   {\n   ...your wrapper code...\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;algorithm\u0026lt;/span\u0026gt;();\n   ...your wrapper code...\n   }\n([\u0026amp;amp;]() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// algorithm section\u0026lt;/span\u0026gt;\n   {\n   ...your algorithm code...\n   });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Lambda expressions also let you create named \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Nested_function\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;nested functions\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  \u0026lt;em\u0026gt;Note: don\u0026apos;t forget the semicolon after the closing curly brace.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; algorithm = [\u0026amp;amp;]( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; m, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; b ) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\n   {\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m*x+b;\n   };\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;algorithm\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;), b=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;algorithm\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Answers\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Q: What is a lambda expression in C++11?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A: Under the hood, it is the object of an autogenerated class with overloading \u0026lt;strong\u0026gt;operator() const\u0026lt;/strong\u0026gt;. Such object is called \u0026lt;em\u0026gt;closure\u0026lt;/em\u0026gt; and created by compiler.\nThis \u0026apos;closure\u0026apos; concept is near with the bind concept from C++11. \nBut lambdas typically generate better code. And calls through closures allow full inlining.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Q: When would I use one?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A: To define \u0026quot;simple and small logic\u0026quot; and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Q: What class of problem do they solve that wasn\u0026apos;t possible prior to their introduction?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A: It is some kind of syntax sugar like operators overloading instead of functions for custom \u0026lt;em\u0026gt;add, subrtact\u0026lt;/em\u0026gt; operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I\u0026apos;m also think so)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example of usage\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; x = [=](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\u0026quot;\u0026lt;/span\u0026gt;, arg1); };\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(*f)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) = x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Extras about lambdas, not covered by question. Ignore this section if you\u0026apos;re not interest\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;1. Captured values. What you can to capture\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1.1. You can reference to a variable with static storage duration in lambdas. They all are captured.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1.2. You can use lambda for capture values \u0026quot;by value\u0026quot;. In such case captured vars will be copied to the function object (closure).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[captureVar1,captureVar2](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;1.3. You can capture be reference. \u0026amp;amp; -- in this context mean reference, not pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   [\u0026amp;amp;captureVar1,\u0026amp;amp;captureVar2](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;1.4. It exists notation to capture all non-static vars by value, or by reference\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  [=](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// capture all not-static vars by value\u0026lt;/span\u0026gt;\n\n  [\u0026amp;amp;](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// capture all not-static vars by reference\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;1.5.  It exists notation to capture all non-static vars by value, or by reference and specify smth. more.\nExamples:\nCapture all not-static vars by value, but by reference capture Param2\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[=,\u0026amp;amp;Param2](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Capture all not-static vars by reference, but by value capture Param2\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[\u0026amp;amp;,Param2](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1){} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;2. Return type deduction\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2.1. Lambda return type can be deduced if lambda is one expression. Or you can explicitly specify it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[=](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arg1)-\u0026amp;gt;trailing_return_type{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trailing_return_type\u0026lt;/span\u0026gt;();}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If lambda has more then one expression, then return type must be specified via trailing return type. \n  Also, similar syntax can be applied to auto functions and member-functions\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;3. Captured values. What you can not capture\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3.1. You can capture only local vars, not member variable of the object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;4. Сonversions\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;4.1 !! Lambda is not a function pointer and it is not an anonymous function, but \u0026lt;strong\u0026gt;capture-less\u0026lt;/strong\u0026gt; lambdas can be implicitly converted to a function pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;p.s.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;More about lambda grammar information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In C++14 the extra feature which has named as \u0026quot;init capture\u0026quot; have been added. It allow to perform arbitarily declaration of closure data members:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; toFloat = [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; value) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;(value);};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; interpolate = [min = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toFloat\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;), max = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toFloat\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;)](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; value)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (value - min) / (max - min);};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. \u0026lt;a href=\u0026quot;http://www.stroustrup.com/C++11FAQ.html#lambda\u0026quot;\u0026gt;http://www.stroustrup.com/C++11FAQ.html#lambda\u0026lt;/a\u0026gt;) but there are some limitations. For example, if there\u0026apos;s a callback interface like this, \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (*f)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;))\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you can write a function on the spot to use it like the one passed to apply below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; col=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data) {\n        cout \u0026amp;lt;\u0026amp;lt; data \u0026amp;lt;\u0026amp;lt; ((++col % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;) ? \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But you can\u0026apos;t do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; col=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;([\u0026amp;amp;col,n](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data) {\n        cout \u0026amp;lt;\u0026amp;lt; data \u0026amp;lt;\u0026amp;lt; ((++col % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;) ? \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;because of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;functional\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;functional\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::function\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt; f)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;);\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; width)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; col;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;([width,\u0026amp;amp;col](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data) {\n        cout \u0026amp;lt;\u0026amp;lt; data \u0026amp;lt;\u0026amp;lt; ((++col % width) ? \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One of the best explanation of \u0026lt;code\u0026gt;lambda expression\u0026lt;/code\u0026gt; is given from author of C++ \u0026lt;strong\u0026gt;Bjarne Stroustrup\u0026lt;/strong\u0026gt; in his book \u0026lt;code\u0026gt;***The C++ Programming Language***\u0026lt;/code\u0026gt; chapter 11 (\u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0321563840\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ISBN-13: 978-0321563842\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;What is a lambda expression?\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;lambda expression\u0026lt;/em\u0026gt;, sometimes also referred to as a \u0026lt;em\u0026gt;lambda\u0026lt;/em\u0026gt;\n  function or (strictly speaking incorrectly, but colloquially) as a\n  \u0026lt;em\u0026gt;lambda\u0026lt;/em\u0026gt;, is a simplified notation for defining and using an \u0026lt;strong\u0026gt;anonymous function object\u0026lt;/strong\u0026gt;. Instead of defining a named class with an operator(), later making an object of that class, and finally\n  invoking it, we can use a shorthand.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;When would I use one?\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This is particularly useful when we want to pass an operation as an\n  argument to an algorithm. In the context of graphical user interfaces\n  (and elsewhere), such operations are often referred to as \u0026lt;em\u0026gt;callbacks\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;What class of problem do they solve that wasn\u0026apos;t possible prior to their introduction?\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;effective ways of optimizing\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;Some examples\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;via lambda expression\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;print_modulo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v, ostream\u0026amp;amp; os, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// output v[i] to os if v[i]%m==0\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    for_each(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(v),\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(v),\n        [\u0026amp;amp;os,m](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x) { \n           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (x%m==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) os \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;;\n         });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or via function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Modulo_print\u0026lt;/span\u0026gt; {\n         ostream\u0026amp;amp; os; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// members to hold the capture list int m;\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Modulo_print\u0026lt;/span\u0026gt;(ostream\u0026amp;amp; s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; mm) :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;os\u0026lt;/span\u0026gt;(s), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m\u0026lt;/span\u0026gt;(mm) {} \n         \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n           \u0026lt;/span\u0026gt;{ \n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (x%m==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) os \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;; \n           }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or even\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;print_modulo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v, ostream\u0026amp;amp; os, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt; \n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// output v[i] to os if v[i]%m==0\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Modulo_print\u0026lt;/span\u0026gt; {\n        ostream\u0026amp;amp; os; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// members to hold the capture list\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m; \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n           \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Modulo_print\u0026lt;/span\u0026gt; (ostream\u0026amp;amp; s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; mm) :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;os\u0026lt;/span\u0026gt;(s), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m\u0026lt;/span\u0026gt;(mm) {}\n           \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n           \u0026lt;/span\u0026gt;{ \n               \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (x%m==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) os \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;;\n           }\n     };\n     for_each(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(v),\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(v),Modulo_print{os,m}); \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;if u need u can name \u0026lt;code\u0026gt;lambda expression\u0026lt;/code\u0026gt; like below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;print_modulo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; v, ostream\u0026amp;amp; os, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// output v[i] to os if v[i]%m==0\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; Modulo_print = [\u0026amp;amp;os,m] (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (x%m==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) os \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;; };\n      for_each(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(v),\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(v),Modulo_print);\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or assume another simple sample\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;TestFunctions::simpleLambda\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; sensitive = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n    std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; v = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;({\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;});\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(),\n         [sensitive](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y) {\n             \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n%i\\n\u0026quot;\u0026lt;/span\u0026gt;,  x \u0026amp;lt; y);\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sensitive ? x \u0026amp;lt; y : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abs\u0026lt;/span\u0026gt;(x) \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abs\u0026lt;/span\u0026gt;(y);\n         });\n\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sorted\u0026quot;\u0026lt;/span\u0026gt;);\n    for_each(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(),\n             [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x) {\n                 \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x - %i;\u0026quot;\u0026lt;/span\u0026gt;, x);\n             }\n             );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will generate next\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;0\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;0\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;0\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;0\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;0\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;0 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; - this is capture list or \u0026lt;code\u0026gt;lambda introducer\u0026lt;/code\u0026gt;: if \u0026lt;code\u0026gt;lambdas\u0026lt;/code\u0026gt; require no access to their local environment we can use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quote from book:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The first character of a lambda expression is always \u0026lt;strong\u0026gt;[\u0026lt;/strong\u0026gt;. A lambda\n  introducer can take various forms:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[]\u0026lt;/strong\u0026gt;: an empty capture list. This\n  implies that no local names from the surrounding context can be used\n  in the lambda body. For such lambda expressions, data is obtained from\n  arguments or from nonlocal variables. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[\u0026amp;amp;]\u0026lt;/strong\u0026gt;: implicitly capture by\n  reference. All local names can be used. All local variables are\n  accessed by reference.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[=]\u0026lt;/strong\u0026gt;: implicitly capture by value. All local\n  names can be used. All names refer to copies of the local variables\n  taken at the point of call of the lambda expression.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[capture-list]:\u0026lt;/strong\u0026gt;  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by \u0026amp;amp; are captured by\n  reference. Other variables are captured by value. A capture list can\n  also contain this and names followed by ... as elements. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[\u0026amp;amp;,  capture-list]\u0026lt;/strong\u0026gt;: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by \u0026amp;amp;. Variables named in the\n  capture list are captured by value. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;[=, capture-list]\u0026lt;/strong\u0026gt;: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by \u0026amp;amp;. Vari- ables named in the capture list are captured by  reference. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Note that a local name preceded by \u0026amp;amp; is always captured by\n  reference and a local name not pre- ceded by \u0026amp;amp; is always captured by\n  value. Only capture by reference allows modification of variables in\n  the calling environment.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;Additional\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Lambda expression\u0026lt;/code\u0026gt; format\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/03yye.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/03yye.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additional references:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wiki\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;open-std.org\u0026lt;/a\u0026gt;, chapter 5.1.2\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The lambda\u0026apos;s in c++ are treated as \u0026quot;on the go available function\u0026quot;.\nyes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;c++ introduced it in c++ 11 and everyone started using it like at every possible place.\nthe example and what is lambda can be find here \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/lambda\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.cppreference.com/w/cpp/language/lambda\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;i will describe which is not there but essential to know for every c++ programmer\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lambda is not meant to use everywhere and every function cannot be replaced with lambda. It\u0026apos;s also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;it will surely help in reducing number of lines in some cases.\nit can be basically used for the section of code, which is getting called in same function one or more time and that piece of code is not needed anywhere else so that you can create standalone function for it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Below is the basic example of lambda and what happens in background.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;User code:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Lambda \u0026amp;amp; auto\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; member=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; endGame = [=](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b){ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a+b+member;};\n\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;endGame\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How compile expands it:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; member = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;__lambda_6_18\u0026lt;/span\u0026gt;\n  {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; member;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*constexpr */\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b + member;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: __lambda_6_18(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _member)\n    : member{_member}\n    {}\n\n  };\n\n  __lambda_6_18 endGame = __lambda_6_18{member};\n  endGame.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;()(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so as you can see, what kind of overhead it adds when you use it.\nso its not good idea to use them everywhere.\nit can be used at places where they are applicable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, one practical use I\u0026apos;ve found out is reducing boiler plate code. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;process_z_vec\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; vec)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; print_2d = [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; board, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bsize)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;bsize; i++)\n    {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;bsize; j++)\n      {\n        cout \u0026amp;lt;\u0026amp;lt; board[bsize*i+j] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n      }\n      cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n  };\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do sth with the vec.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print_2d\u0026lt;/span\u0026gt;(vec,x_size);\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do sth else with the vec.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print_2d\u0026lt;/span\u0026gt;(vec,y_size);\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//... \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Without lambda, you may need to do something for different \u0026lt;code\u0026gt;bsize\u0026lt;/code\u0026gt; cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++ 11 introduced lambda expression to allow us write an inline function which can be used for short snippets of code\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[ capture clause ] (parameters) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;-type\n{\n   definition of method\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Generally return-type in lambda expression are evaluated by compiler itself and we dont need to specify that explicitly and -\u0026amp;gt; return-type part can be ignored but in some complex case as in conditional statement, compiler cant make out the return type and we need to specify that.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C++ program to demonstrate lambda expression in C++\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bits/stdc++.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Function to print vector\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;printVector\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; v)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// lambda expression to print vector\u0026lt;/span\u0026gt;\n    for_each(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; i \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n    });\n    cout \u0026amp;lt;\u0026amp;lt; endl;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; v {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;};\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printVector\u0026lt;/span\u0026gt;(v);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// below snippet find first number greater than 4\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// find_if searches for an element for which\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function(third argument) returns true\u0026lt;/span\u0026gt;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;:: iterator p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_if\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n    });\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;First number greater than 4 is : \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; *p \u0026amp;lt;\u0026amp;lt; endl;\n\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function to sort vector, lambda expression is for sorting in\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-decreasing order Compiler can make out return type as\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// bool, but shown here just for explanation\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;amp; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;amp; b) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a \u0026amp;gt; b;\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printVector\u0026lt;/span\u0026gt;(v);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function to count numbers greater than or equal to 5\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count_5 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;count_if\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (a \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n    });\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The number of elements greater than or equal to 5 is : \u0026quot;\u0026lt;/span\u0026gt;\n        \u0026amp;lt;\u0026amp;lt; count_5 \u0026amp;lt;\u0026amp;lt; endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function for removing duplicate element (after sorting all\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// duplicate comes together)\u0026lt;/span\u0026gt;\n    p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;unique\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a == b;\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// resizing vector to make size equal to total different number\u0026lt;/span\u0026gt;\n    v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;resize\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), p));\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printVector\u0026lt;/span\u0026gt;(v);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// accumulate function accumulate the container on the basis of\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function provided as third argument\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(arr, arr + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i * j;\n    });\n\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Factorial of 10 is : \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; f \u0026amp;lt;\u0026amp;lt; endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   We can also access function by storing this into variable\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; square = [](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i * i;\n    };\n\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Square of 5 is : \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;square\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;\nFirst number greater than \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nThe number of elements greater than \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; equal to \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nFactorial of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3628800\u0026lt;/span\u0026gt;\nSquare of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;25\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from enclosing scope by three ways :\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Capture by reference\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Capture by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Capture by both (mixed capture)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The syntax used for capturing variables :\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;[\u0026amp;amp;] : capture all external variable by reference\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[=] : capture all external variable by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[a, \u0026amp;amp;b] : capture a by value and b by reference\nA lambda with empty capture clause [ ] can access only those variable which are local to it.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bits/stdc++.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    \n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; v1 = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;};\n        vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; v2 = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;};\n    \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// access v1 and v2 by reference\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; pushinto = [\u0026amp;amp;] (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\n        {\n            v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(m);\n            v2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(m);\n        };\n    \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// it pushes 20 in both v1 and v2\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pushinto\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;);\n    \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// access v1 by copy\u0026lt;/span\u0026gt;\n        [v1]()\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; p = v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(); p != v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(); p++)\n            {\n                cout \u0026amp;lt;\u0026amp;lt; *p \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n            }\n        };\n    \n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; N = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// below snippet find first number greater than N\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [N] denotes, can access only N by value\u0026lt;/span\u0026gt;\n        vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;:: iterator p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_if\u0026lt;/span\u0026gt;(v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [N](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i \u0026amp;gt; N;\n        });\n    \n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;First number greater than 5 is : \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; *p \u0026amp;lt;\u0026amp;lt; endl;\n    \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function to count numbers greater than or equal to N\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [=] denotes, can access all variable\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count_N = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;count_if\u0026lt;/span\u0026gt;(v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), v1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), [=](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (a \u0026amp;gt;= N);\n        });\n    \n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The number of elements greater than or equal to 5 is : \u0026quot;\u0026lt;/span\u0026gt;\n            \u0026amp;lt;\u0026amp;lt; count_N \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   First number greater than \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;\n   The number of elements greater than \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; equal to \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; is : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One problem it solves: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/31078201/code-simpler-than-lambda-for-a-call-in-constructor-that-uses-an-output-parameter\u0026quot;\u0026gt;Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const member\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.\u0026lt;/p\u0026gt;\n    "],"id":445,"title":"What is a lambda expression in C++11?","content":"\n                \n\u0026lt;p\u0026gt;What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn\u0026apos;t possible prior to their introduction?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A few examples, and use cases would be useful. \u0026lt;/p\u0026gt;\n    ","slug":"what-is-a-lambda-expression-in-c++11-1657387999252","postType":"QUESTION","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","tags":[{"id":2306,"name":"lambda","slug":"lambda","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","Questions_Tags":{"questionId":445,"tagId":2306}}],"relatedQuestions":[{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252","tags":[{"name":"lambda","Questions_Tags":{"questionId":445,"tagId":2306}}]}]},"randomQuestions":[{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},{"title":"How to append text to an existing file in Java?","slug":"how-to-append-text-to-an-existing-file-in-java-1657388492377"},{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"What are drawbacks or disadvantages of singleton pattern? [closed]","slug":"what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749"},{"title":"Is there a \"previous sibling\" selector?","slug":"is-there-a-\"previous-sibling\"-selector-1657384771067"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"What is an efficient way to implement a singleton pattern in Java? [closed]","slug":"what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474"},{"title":"Test for existence of nested JavaScript object key","slug":"test-for-existence-of-nested-javascript-object-key-1657387935411"},{"title":"Can I bind an array to an IN() condition in a PDO query?","slug":"can-i-bind-an-array-to-an-in()-condition-in-a-pdo-query-1657388382858"},{"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751"},{"title":"How to remove all duplicates from an array of objects?","slug":"how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190"},{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"Where can I find documentation on formatting a date in JavaScript?","slug":"where-can-i-find-documentation-on-formatting-a-date-in-javascript-1657384878157"},{"title":"Random number generator only generating one random number","slug":"random-number-generator-only-generating-one-random-number-1657385468315"},{"title":"Returning data from async call in Swift function","slug":"returning-data-from-async-call-in-swift-function-1657387469218"},{"title":"Daylight saving time and time zone best practices [closed]","slug":"daylight-saving-time-and-time-zone-best-practices-closed-1657387973687"},{"title":"How do I sort a dictionary by value?","slug":"how-do-i-sort-a-dictionary-by-value-1657385485049"},{"title":"Actual meaning of 'shell=True' in subprocess","slug":"actual-meaning-of-'shelltrue'-in-subprocess-1657388470341"},{"title":"What is the `self` parameter in class methods?","slug":"what-is-the-self-parameter-in-class-methods-1657387518448"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>