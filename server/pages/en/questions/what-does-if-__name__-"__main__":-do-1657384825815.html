<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="python-module,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-does-if-__name__-&quot;__main__&quot;:-do-1657384825815","name":"Questions"}}]}</script><title>What does if __name__ == &quot;__main__&quot;: do? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What does this do, and why should one include the if statement?
if __name__ == &quot;__main__&quot;:
    print(&quot;Hello, World!&quot;)

    "/><meta property="og:title" content="What does if __name__ == &quot;__main__&quot;: do? | Solution Checker"/><meta property="og:description" content="What does this do, and why should one include the if statement?
if __name__ == &quot;__main__&quot;:
    print(&quot;Hello, World!&quot;)

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What does if __name__ == &quot;__main__&quot;: do?","text":"What does this do, and why should one include the if statement?\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Hello, World!&quot;)\n\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Short Answer\nIt&apos;s boilerplate code that protects users from accidentally invoking the script when they didn&apos;t intend to. Here are some common problems when the guard is omitted from a script:\n\nIf you import the guardless script in another script (e.g. import my_script_without_a_name_eq_main_guard), then the latter script will trigger the former to run at import time and using the second script&apos;s command line arguments. This is almost always a mistake.\n\nIf you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.\n\n\nLong Answer\nTo better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.\nWhenever the Python interpreter reads a source file, it does two things:\n\nit sets a few special variables like __name__, and then\n\nit executes all of the code found in the file.\n\n\nLet&apos;s see how this works and how it relates to your question about the __name__ checks we always see in Python scripts.\nCode Sample\nLet&apos;s use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called foo.py.\n# Suppose this is foo.py.\n\nprint(&quot;before import&quot;)\nimport math\n\nprint(&quot;before function_a&quot;)\ndef function_a():\n    print(&quot;Function A&quot;)\n\nprint(&quot;before function_b&quot;)\ndef function_b():\n    print(&quot;Function B {}&quot;.format(math.sqrt(100)))\n\nprint(&quot;before __name__ guard&quot;)\nif __name__ == &apos;__main__&apos;:\n    function_a()\n    function_b()\nprint(&quot;after __name__ guard&quot;)\n\nSpecial Variables\nWhen the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the __name__ variable.\nWhen Your Module Is the Main Program\nIf you are running your module (the source file) as the main program, e.g.\npython foo.py\n\nthe interpreter will assign the hard-coded string &quot;__main__&quot; to the __name__ variable, i.e.\n# It&apos;s as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = &quot;__main__&quot; \n\nWhen Your Module Is Imported By Another\nOn the other hand, suppose some other module is the main program and it imports your module. This means there&apos;s a statement like this in the main program, or in some other module the main program imports:\n# Suppose this is in some other main program.\nimport foo\n\nThe interpreter will search for your foo.py file (along with searching for a few other variants), and prior to executing that module, it will assign the name &quot;foo&quot; from the import statement to the __name__ variable, i.e.\n# It&apos;s as if the interpreter inserts this at the top\n# of your module when it&apos;s imported from another module.\n__name__ = &quot;foo&quot;\n\nExecuting the Module&apos;s Code\nAfter the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.\nAlways\n\nIt prints the string &quot;before import&quot; (without quotes).\n\nIt loads the math module and assigns it to a variable called math. This is equivalent to replacing import math with the following (note that __import__ is a low-level function in Python that takes a string and triggers the actual import):\n\n\n# Find and load a module given its string name, &quot;math&quot;,\n# then assign it to a local variable called math.\nmath = __import__(&quot;math&quot;)\n\n\nIt prints the string &quot;before function_a&quot;.\n\nIt executes the def block, creating a function object, then assigning that function object to a variable called function_a.\n\nIt prints the string &quot;before function_b&quot;.\n\nIt executes the second def block, creating another function object, then assigning it to a variable called function_b.\n\nIt prints the string &quot;before __name__ guard&quot;.\n\n\nOnly When Your Module Is the Main Program\n\nIf your module is the main program, then it will see that __name__ was indeed set to &quot;__main__&quot; and it calls the two functions, printing the strings &quot;Function A&quot; and &quot;Function B 10.0&quot;.\n\nOnly When Your Module Is Imported by Another\n\n(instead) If your module is not the main program but was imported by another one, then __name__ will be &quot;foo&quot;, not &quot;__main__&quot;, and it&apos;ll skip the body of the if statement.\n\nAlways\n\nIt will print the string &quot;after __name__ guard&quot; in both situations.\n\nSummary\nIn summary, here&apos;s what&apos;d be printed in the two cases:\n# What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n\n# What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n\nWhy Does It Work This Way?\nYou might naturally wonder why anybody would want this.  Well, sometimes you want to write a .py file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:\n\nYour module is a library, but you want to have a script mode where it runs some unit tests or a demo.\n\nYour module is only used as a main program, but it has some unit tests, and the testing framework works by importing .py files like your script and running special test functions. You don&apos;t want it to try running the script just because it&apos;s importing the module.\n\nYour module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.\n\n\nBeyond those examples, it&apos;s elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script&apos;s module.\nFood for Thought\n\nQuestion: Can I have multiple __name__ checking blocks?  Answer: it&apos;s strange to do so, but the language won&apos;t stop you.\n\nSuppose the following is in foo2.py.  What happens if you say python foo2.py on the command-line? Why?\n\n\n# Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo2 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nif __name__ == &quot;__main__&quot;:\n    print(&quot;m1&quot;)\n    function_a()\n    print(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n      \n\n\nNow, figure out what will happen if you remove the __name__ check in foo3.py:\n\n# Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo3 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nprint(&quot;m1&quot;)\nfunction_a()\nprint(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n\n\nWhat will this do when used as a script?  When imported as a module?\n\n# Suppose this is in foo4.py\n__name__ = &quot;__main__&quot;\n\ndef bar():\n    print(&quot;bar&quot;)\n    \nprint(&quot;before __name__ guard&quot;)\nif __name__ == &quot;__main__&quot;:\n    bar()\nprint(&quot;after __name__ guard&quot;)\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"When your script is run by passing it as a command to the Python interpreter,\n\npython myscript.py\n\n\nall of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there&apos;s no main() function that gets run automatically - the main() function is implicitly all the code at the top level.\n\nIn this case, the top-level code is an if block.  __name__ is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in myscript.py above), then __name__ instead is set to the string &quot;__main__&quot;.  Thus, you can test whether your script is being run directly or being imported by something else by testing\n\nif __name__ == &quot;__main__&quot;:\n    ...\n\n\nIf your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the if clause above won&apos;t get run as the condition is not met. As a basic example, consider the following two scripts:\n\n# file one.py\ndef func():\n    print(&quot;func() in one.py&quot;)\n\nprint(&quot;top-level in one.py&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;one.py is being run directly&quot;)\nelse:\n    print(&quot;one.py is being imported into another module&quot;)\n\n\n\n\n# file two.py\nimport one\n\nprint(&quot;top-level in two.py&quot;)\none.func()\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;two.py is being run directly&quot;)\nelse:\n    print(&quot;two.py is being imported into another module&quot;)\n\n\nNow, if you invoke the interpreter as\n\npython one.py\n\n\nThe output will be\n\ntop-level in one.py\none.py is being run directly\n\n\nIf you run two.py instead:\n\npython two.py\n\n\nYou get\n\ntop-level in one.py\none.py is being imported into another module\ntop-level in two.py\nfunc() in one.py\ntwo.py is being run directly\n\n\nThus, when module one gets loaded, its __name__ equals &quot;one&quot; instead of &quot;__main__&quot;.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Create the following two files:\n# a.py\n\nimport b\n\n# b.py\n\nprint(&quot;__name__ equals &quot; + __name__)\n\nif __name__ == &apos;__main__&apos;:\n    print(&quot;if-statement was executed&quot;)\n\nNow run each file individually.\n\nRunning python a.py:\n$ python a.py\n__name__ equals b\n\nWhen a.py is executed, it imports the module b. This causes all the code inside b to run. Python sets globals()[&apos;__name__&apos;] in the b module to the module&apos;s name, b.\n  \nRunning python b.py:\n$ python b.py\n__name__ equals __main__\nif-statement was executed\n\nWhen only the file b.py is executed, Python sets globals()[&apos;__name__&apos;] in this file to &quot;__main__&quot;. Therefore, the if statement evaluates to True this time.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"\n  What does the if __name__ == &quot;__main__&quot;: do?\n\n\nTo outline the basics:\n\n\nThe global variable, __name__, in the module that is the entry point to your program, is &apos;__main__&apos;. Otherwise, it&apos;s the name you import the module by.\nSo, code under the if block will only run if the module is the entry point to your program.\nIt allows the code in the module to be importable by other modules, without executing the code block beneath on import.\n\n\n\n\nWhy do we need this?\n\nDeveloping and Testing Your Code\n\nSay you&apos;re writing a Python script designed to be used as a module:\n\ndef do_important():\n    &quot;&quot;&quot;This function does something very important&quot;&quot;&quot;\n\n\nYou could test the module by adding this call of the function to the bottom:\n\ndo_important()\n\n\nand running it (on a command prompt) with something like:\n\n~$ python important.py\n\n\nThe Problem\n\nHowever, if you want to import the module to another script:\n\nimport important\n\n\nOn import, the do_important function would be called, so you&apos;d probably comment out your function call, do_important(), at the bottom. \n\n# do_important() # I must remember to uncomment to execute this!\n\n\nAnd then you&apos;ll have to remember whether or not you&apos;ve commented out your test function call. And this extra complexity would mean you&apos;re likely to forget, making your development process more troublesome.\n\nA Better Way\n\nThe __name__ variable points to the namespace wherever the Python interpreter happens to be at the moment. \n\nInside an imported module, it&apos;s the name of that module. \n\nBut inside the primary module (or an interactive Python session, i.e. the interpreter&apos;s Read, Eval, Print Loop, or REPL) you are running everything from its &quot;__main__&quot;.\n\nSo if you check before executing:\n\nif __name__ == &quot;__main__&quot;:\n    do_important()\n\n\nWith the above, your code will only execute when you&apos;re running it as the primary module (or intentionally call it from another script). \n\nAn Even Better Way\n\nThere&apos;s a Pythonic way to improve on this, though. \n\nWhat if we want to run this business process from outside the module?\n\nIf we put the code we want to exercise as we develop and test in a function like this and then do our check for &apos;__main__&apos; immediately after:\n\ndef main():\n    &quot;&quot;&quot;business logic for when running this module as the primary one!&quot;&quot;&quot;\n    setup()\n    foo = do_important()\n    bar = do_even_more_important(foo)\n    for baz in bar:\n        do_super_important(baz)\n    teardown()\n\n# Here&apos;s our payoff idiom!\nif __name__ == &apos;__main__&apos;:\n    main()\n\n\nWe now have a final function for the end of our module that will run if we run the module as the primary module. \n\nIt will allow the module and its functions and classes to be imported into other scripts without running the main function, and will also allow the module (and its functions and classes) to be called when running from a different &apos;__main__&apos; module, i.e.\n\nimport important\nimportant.main()\n\n\nThis idiom can also be found in the Python documentation in an explanation of the __main__ module. That text states:\n\n\n  This module represents the (otherwise anonymous) scope in which the\n  interpreters main program executes  commands read either from\n  standard input, from a script file, or from an interactive prompt. It\n  is this environment in which the idiomatic conditional script stanza\n  causes a script to run:\n\nif __name__ == &apos;__main__&apos;:\n    main()\n\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"if __name__ == &quot;__main__&quot; is the part that runs when the script is run from (say) the command line using a command like python myscript.py.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"\nWhat does if __name__ == &quot;__main__&quot;: do?\n\n__name__ is a global variable (in Python, global actually means on the module level) that exists in all namespaces. It is typically the module&apos;s name (as a str type).\nAs the only special case, however, in whatever Python process you run, as in mycode.py:\npython mycode.py\n\nthe otherwise anonymous global namespace is assigned the value of &apos;__main__&apos; to its __name__.\nThus, including the final lines\nif __name__ == &apos;__main__&apos;:\n    main()\n\n\nat the end of your mycode.py script,\nwhen it is the primary, entry-point module that is run by a Python process,\n\nwill cause your script&apos;s uniquely defined main function to run.\nAnother benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:\nimport mycode\n# ... any amount of other code\nmycode.main()\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"There are lots of different takes here on the mechanics of the code in question, the &quot;How&quot;, but for me none of it made sense until I understood the &quot;Why&quot;. This should be especially helpful for new programmers.\n\nTake file &quot;ab.py&quot;:\n\ndef a():\n    print(&apos;A function in ab file&apos;);\na()\n\n\nAnd a second file &quot;xy.py&quot;:\n\nimport ab\ndef main():\n    print(&apos;main function: this is where the action is&apos;)\ndef x():\n    print (&apos;peripheral task: might be useful in other projects&apos;)\nx()\nif __name__ == &quot;__main__&quot;:\n    main()\n\n\n\n  What is this code actually doing?\n\n\nWhen you execute xy.py, you import ab. The import statement runs the module immediately on import, so ab&apos;s operations get executed before the remainder of xy&apos;s. Once finished with ab, it continues with xy.\n\nThe interpreter keeps track of which scripts are running with __name__. When you run a script - no matter what you&apos;ve named it - the interpreter calls it &quot;__main__&quot;, making it the master or &apos;home&apos; script that gets returned to after running an external script.\n\nAny other script that&apos;s called from this &quot;__main__&quot; script is assigned its filename as its __name__ (e.g., __name__ == &quot;ab.py&quot;). Hence, the line if __name__ == &quot;__main__&quot;: is the interpreter&apos;s test to determine if it&apos;s interpreting/parsing the &apos;home&apos; script that was initially executed, or if it&apos;s temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it&apos;s executed directly vs. called externally.\n\nLet&apos;s step through the above code to understand what&apos;s happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or def - blocks don&apos;t do anything by themselves until they&apos;re called. What the interpreter might say if mumbled to itself:\n\n\nOpen xy.py as the &apos;home&apos; file; call it &quot;__main__&quot; in the __name__ variable.\nImport and open file with the __name__ == &quot;ab.py&quot;.\nOh, a function. I&apos;ll remember that.\nOk, function a(); I just learned that. Printing &apos;A function in ab file&apos;.\nEnd of file; back to &quot;__main__&quot;!\nOh, a function. I&apos;ll remember that.\nAnother one.\nFunction x(); ok, printing &apos;peripheral task: might be useful in other projects&apos;.\nWhat&apos;s this? An if statement. Well, the condition has been met (the variable __name__ has been set to &quot;__main__&quot;), so I&apos;ll enter the main() function and print &apos;main function: this is where the action is&apos;.\n\n\nThe bottom two lines mean: &quot;If this is the &quot;__main__&quot; or &apos;home&apos; script, execute the function called main()&quot;. That&apos;s why you&apos;ll see a def main(): block up top, which contains the main flow of the script&apos;s functionality.\n\n\n  Why implement this?\n\n\nRemember what I said earlier about import statements? When you import a module it doesn&apos;t just &apos;recognize&apos; it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the main() function effectively quarantines it, putting it in isolation so that it won&apos;t immediately run when imported by another script.\n\nAgain, there will be exceptions, but common practice is that main() doesn&apos;t usually get called externally. So you may be wondering one more thing: if we&apos;re not calling main(), why are we calling the script at all? It&apos;s because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They&apos;re then later called somewhere else in the body of the script. Which brings me to this:\n\n\n  But the code works without it\n\n\nYes, that&apos;s right. These separate functions can be called from an in-line script that&apos;s not contained inside a main() function. If you&apos;re accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you&apos;ll try to figure it out again if you ever need that operation again ... well, you&apos;re not used to this kind of internal structure to your code, because it&apos;s more complicated to build and it&apos;s not as intuitive to read.\n\nBut that&apos;s a script that probably can&apos;t have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you&apos;re trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.\n\nIn splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, &quot;example.py&quot; might import &quot;xy.py&quot; and call x(), making use of the &apos;x&apos; function from &quot;xy.py&quot;. (Maybe it&apos;s capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)\n\n(As an aside, this question contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it&apos;s been marked as a duplicate of this one, which I think is a mistake.)\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The code under if __name__ == &apos;__main__&apos;: will only be executed if the module is invoked as a script.\nAs an example, consider the following module my_test_module.py:\n# my_test_module.py\n\nprint(&apos;This is going to be printed out, no matter what&apos;)\n\nif __name__ == &apos;__main__&apos;:\n    print(&apos;This is going to be printed out, only if user invokes the module as a script&apos;)\n\n\nFirst possibility: Import my_test_module.py in another module\n# main.py\n\nimport my_test_module\n\nif __name__ == &apos;__main__&apos;:\n    print(&apos;Hello from main.py&apos;)\n\nNow if you invoke main.py:\npython main.py\n\n&gt;&gt; &apos;This is going to be printed out, no matter what&apos;\n&gt;&gt; &apos;Hello from main.py&apos;\n\nNote that only the top-level print() statement in my_test_module is executed.\n\nSecond possibility: Invoke my_test_module.py as a script\nNow if you run my_test_module.py as a Python script, both print() statements will be executed:\npython my_test_module.py\n\n&gt;&gt;&gt; &apos;This is going to be printed out, no matter what&apos;\n&gt;&gt;&gt; &apos;This is going to be printed out, only if user invokes the module as a script&apos;\n\n\nFor a more comprehensive explanation, you can read What does if __name__ == &apos;__main__&apos; do in Python.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"When there are certain statements in our module (M.py) we want to be executed when it&apos;ll be running as main (not imported), we can place those statements (test-cases, print statements) under this if block.\n\nAs by default (when module running as main, not imported) the __name__ variable is set to &quot;__main__&quot;, and when it&apos;ll be imported the __name__ variable will get a different value, most probably the name of the module (&apos;M&apos;).\nThis is helpful in running different variants of a modules together, and separating their specific input &amp; output statements and also if there are any test-cases.\n\nIn short, use this &apos;if __name__ == &quot;main&quot; &apos; block to prevent (certain) code from being run when the module is imported.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Put simply, __name__ is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.\n\nSo if we have two scripts;\n\n#script1.py\nprint &quot;Script 1&apos;s name: {}&quot;.format(__name__)\n\n\nand\n\n#script2.py\nimport script1\nprint &quot;Script 2&apos;s name: {}&quot;.format(__name__)\n\n\nThe output from executing script1 is\n\nScript 1&apos;s name: __main__\n\n\nAnd the output from executing script2 is:\n\nScript1&apos;s name is script1\nScript 2&apos;s name: __main__\n\n\nAs you can see, __name__ tells us which code is the &apos;main&apos; module.\nThis is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a &apos;main&apos; function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.\n\nSay you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  if __name__ == &quot;__main__&quot;: context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;\n\n\n\nThe arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:\n\n\n\nYou write a module, and if someone wants to use your code they just import it and the __name__ variable can help to separate the executable portion of the program from the library part.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Let&apos;s look at the answer in a more abstract way:\n\nSuppose we have this code in x.py:\n\n...\n&lt;Block A&gt;\nif __name__ == &apos;__main__&apos;:\n    &lt;Block B&gt;\n...\n\n\nBlocks A and B are run when we are running x.py.\n\nBut just block A (and not B) is run when we are running another module, y.py for example, in which x.py is imported and the code is run from there (like when a function in x.py is called from y.py).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"To be short, you need to know several points:\n\nimport a action actually runs all that can be run in a.py, meaning each line in a.py\n\nBecause of point 1, you may not want everything to be run in a.py when importing it\n\nTo solve the problem in point 2, Python allows you to use a condition check\n\n__name__ is an implicit variable in all .py modules:\n\n\n\nwhen a.py is imported, the value of __name__ of a.py module is set to its file name &quot;a&quot;\nwhen a.py is run directly using &quot;python a.py&quot;, the value of __name__ is set to a string __main__\n\n\nBased on the mechanism how Python sets the variable __name__ for each module, do you know how to achieve point 3? The answer is fairly easy, right? Use an if condition: if __name__ == &quot;__main__&quot;: // do A\n\n\nthen python a.py will run the part // do A\nand import a will skip the part // do A\n\n\nYou can even put if __name__ == &quot;a&quot; depending on your functional need, but rarely do\n\nThe important thing that Python is special at is point 4! The rest is just basic logic.\nI&apos;ve been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"When you run Python interactively the local __name__ variable is assigned a value of __main__. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its __name__ attribute is assigned a value of __main__, rather than the actual name of the module. In this way, modules can look at their own __name__ value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:\n\nif __name__ == &apos;__main__&apos;:\n    # Do something appropriate here, like calling a\n    # main() function defined elsewhere in this module.\n    main()\nelse:\n    # Do nothing. This module has been imported by another\n    # module that wants to make use of the functions,\n    # classes and other useful bits it has defined.\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Consider:\nif __name__ == &quot;__main__&quot;:\n    main()\n\nIt checks if the __name__ attribute of the Python script is &quot;__main__&quot;. In other words, if the program itself is executed, the attribute will be __main__, so the program will be executed (in this case the main() function).\nHowever, if your Python script is used by a module, any code outside of the if statement will be executed, so if __name__ == &quot;__main__&quot; is used just to check if the program is used as a module or not, and therefore decides whether to run the code.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Before explaining anything about if __name__ == &apos;__main__&apos; it is important to understand what __name__ is and what it does.\nWhat is __name__?\n__name__ is a DunderAlias - can be thought of as a global variable (accessible from modules) and works in a similar way to global.\nIt is a string (global as mentioned above) as indicated by type(__name__) (yielding &lt;class &apos;str&apos;&gt;), and is an inbuilt standard for both Python 3 and Python 2 versions.\nWhere\nIt can not only be used in scripts but can also be found in both the interpreter and modules/packages.\nInterpreter:\n&gt;&gt;&gt; print(__name__)\n__main__\n&gt;&gt;&gt;\n\nScript:\ntest_file.py:\nprint(__name__)\n\nResulting in __main__\nModule or package:\nsomefile.py:\ndef somefunction():\n    print(__name__)\n\ntest_file.py:\nimport somefile\nsomefile.somefunction()\n\nResulting in somefile\nNotice that when used in a package or module, __name__ takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias __file__, that allows for this.\nYou should see that, where __name__, where it is the main file (or program) will always return __main__, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.\nPractice\nBeing a variable means that it&apos;s value can be overwritten (&quot;can&quot; does not mean &quot;should&quot;), overwriting the value of __name__ will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.\nIt is always assumed that the value of __name__ to be __main__ or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.\nExample:\n&gt;&gt;&gt; __name__ = &apos;Horrify&apos; # Change default from __main__\n&gt;&gt;&gt; if __name__ == &apos;Horrify&apos;: print(__name__)\n...\n&gt;&gt;&gt; else: print(&apos;Not Horrify&apos;)\n...\nHorrify\n&gt;&gt;&gt;\n\nIt is considered good practice in general to include the if __name__ == &apos;__main__&apos; in scripts.\nNow to answer if __name__ == &apos;__main__&apos;:\nNow we know the behaviour of __name__ things become clearer:\nAn if is a flow control statement that contains the block of code will execute if the value given is true. We have seen that __name__ can take either\n__main__ or the file name it has been imported from.\nThis means that if __name__ is equal to __main__ then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.\nIf indeed __name__ does take the value of __main__ then whatever is in that block of code will execute.\nThis tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be __main__.\nModules\n__name__ can also be used in modules to define the name of a module\nVariants\nIt is also possible to do other, less common but useful things with __name__, some I will show here:\nExecuting only if the file is a module or package\nif __name__ != &apos;__main__&apos;:\n    # Do some useful things \n\nRunning one condition if the file is the main one and another if it is not\nif __name__ == &apos;__main__&apos;:\n    # Execute something\nelse:\n    # Do some useful things\n\nYou can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.\nIt also allows modules to be run from the command line as main scripts, which can be also very useful.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"I think it&apos;s best to break the answer in depth and in simple words:\n\n__name__: Every module in Python has a special attribute called __name__.\nIt is a built-in variable that returns the name of the module.\n\n__main__: Like other programming languages, Python too has an execution entry point, i.e., main. &apos;__main__&apos; is the name of the scope in which top-level code executes. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its __name__ is set to __main__.\n\nThus, the value of the __name__ attribute is set to __main__ when the module is run as the main program. Otherwise the value of __name__  is set to contain the name of the module.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"It is a special for when a Python file is called from the command line. This is typically used to call a &quot;main()&quot; function or execute other appropriate startup code, like commandline arguments handling for instance.\nIt could be written in several ways. Another is:\ndef some_function_for_instance_main():\n    dosomething()\n\n\n__name__ == &apos;__main__&apos; and some_function_for_instance_main()\n\nI am not saying you should use this in production code, but it serves to illustrate that there is nothing &quot;magical&quot; about if __name__ == &apos;__main__&apos;.\nIt just a convention for invoking a main function in Python files.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the __name__ variable/attribute:\n\nWhen Python loads a source code file, it executes all of the code found in it. (Note that it doesn&apos;t call all of the methods and functions defined in the file, but it does define them.)\n\nBefore the interpreter executes the source code file though, it defines a few special variables for that file; __name__ is one of those special variables that Python automatically defines for each source code file.\n\nIf Python is loading this source code file as the main program (i.e. the file you run), then it sets the special __name__ variable for this file to have a value &quot;__main__&quot;.\n\nIf this is being imported from another module, __name__ will be set to that module&apos;s name.\n\nSo, in your example in part:\n\nif __name__ == &quot;__main__&quot;:\n   lock = thread.allocate_lock()\n   thread.start_new_thread(myfunction, (&quot;Thread #: 1&quot;, 2, lock))\n   thread.start_new_thread(myfunction, (&quot;Thread #: 2&quot;, 2, lock))\n\n\nmeans that the code block:\n\nlock = thread.allocate_lock()\nthread.start_new_thread(myfunction, (&quot;Thread #: 1&quot;, 2, lock))\nthread.start_new_thread(myfunction, (&quot;Thread #: 2&quot;, 2, lock))\n\n\nwill be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of __name__ will not equal to &quot;main&quot; in that particular instance.\n\nHope this helps out.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"if __name__ == &quot;__main__&quot;: is basically the top-level script environment, and it specifies the interpreter that (&apos;I have the highest priority to be executed first&apos;).\n\n&apos;__main__&apos; is the name of the scope in which top-level code executes. A modules __name__ is set equal to &apos;__main__&apos; when read from standard input, a script, or from an interactive prompt.\n\nif __name__ == &quot;__main__&quot;:\n    # Execute only if run as a script\n    main()\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Consider:\n\nprint __name__\n\n\nThe output for the above is __main__.\n\nif __name__ == &quot;__main__&quot;:\n  print &quot;direct method&quot;\n\n\nThe above statement is true and prints &quot;direct method&quot;. Suppose if they imported this class in another class it doesn&apos;t print &quot;direct method&quot; because, while importing, it will set __name__ equal to &quot;first model name&quot;.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"\n  You can make the file usable as a script as well as an importable module.\n\n\nfibo.py (a module named fibo)\n\n# Other modules can IMPORT this MODULE to use the function fib\ndef fib(n):    # write Fibonacci series up to n\n    a, b = 0, 1\n    while b &lt; n:\n        print(b, end=&apos; &apos;)\n        a, b = b, a+b\n    print()\n\n# This allows the file to be used as a SCRIPT\nif __name__ == &quot;__main__&quot;:\n    import sys\n    fib(int(sys.argv[1]))\n\n\nReference: https://docs.python.org/3.5/tutorial/modules.html\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"The reason for\n\nif __name__ == &quot;__main__&quot;:\n    main()\n\n\nis primarily to avoid the import lock problems that would arise from having code directly imported. You want main() to run if your file was directly invoked (that&apos;s the __name__ == &quot;__main__&quot; case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.\n\nA side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using main() as the entry point, but you don&apos;t have to. While setup.py expects main(), other tools use alternate entry points. For example, to run your file as a gunicorn process, you define an app() function instead of a main(). Just as with setup.py, gunicorn imports your code so you don&apos;t want it do do anything while it&apos;s being imported (because of the import lock issue).\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Every module in Python has an attribute called __name__. The value of __name__  attribute is  __main__ when the module is run directly, like python my_module.py. Otherwise (like when you say import my_module) the value of __name__  is the name of the module.\nSmall example to explain in short.\nScript test.py\napple = 42\n\ndef hello_world():\n    print(&quot;I am inside hello_world&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Value of __name__ is: &quot;, __name__)\n    print(&quot;Going to call hello_world&quot;)\n    hello_world()\n\nWe can execute this directly as\npython test.py\n\nOutput\nValue of __name__ is: __main__\nGoing to call hello_world\nI am inside hello_world\n\nNow suppose we call the above script from another script:\nScript external_calling.py\nimport test\n\nprint(test.apple)\ntest.hello_world()\n\nprint(test.__name__)\n\nWhen you execute this,\npython external_calling.py\n\nOutput\n42\nI am inside hello_world\ntest\n\nSo, the above is self-explanatory that when you call test from another script, if loop __name__ in test.py will not execute.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"If you are a beginner, probably the only answer you need right now is that this code is unnecessary for a simple script. It is only useful if you want to be able to import your script (or unpickle etc; see the other answers here for some other non-beginner scenarios).\nIn slightly different words, the if __name__ guard is a mechanism for hiding code from other code. If you don&apos;t have a specific reason to hide something, don&apos;t: If you don&apos;t need to hide some code from import, don&apos;t put it behind this guard, and if you do, hide as little as possible.\nIn slightly more detail, let&apos;s say you have a simple script fib.py (adapted from this answer):\n# XXX FIXME: useless (see below)\nif __name__ == &quot;__main__&quot;:\n    n = int(input(&apos;Write a number: &apos;))\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    print(&apos;Fibonacci number %i: %i&apos; % (n, b))\n\nNow, if you simply run python fib.py it works fine. But __name__ will always be &quot;__main__&quot; in this scenario, so the condition is actually unnecessary. The script could be simplified to just\nn = int(input(&apos;Write a number: &apos;))\na, b = 0, 1\nwhile b &lt; n:\n    a, b = b, a+b\nprint(&apos;Fibonacci number %i: %i&apos; % (n, b))\n\nNow, you can&apos;t import fib with the new version, but if you didn&apos;t plan to do that in the first place, this version is actually better, because it&apos;s simpler and clearer.\nIf you do want to be able to import fib, the first version is useless, too, because the useful code is in a section which will not run when you import this file (in which case __name__ will not be &quot;__main__&quot;). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have imported it.\ndef main():\n    n = int(input(&apos;Write a number: &apos;))\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    print(&apos;Fibonacci number %i: %i&apos; % (n, b))\n\nif __name__ == &quot;__main__&quot;:\n    main()\n\nNow, if you import fib, the call to main() will not be executed; but when you run python fib.py, it will.\nActually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:\ndef fibn(n: int) -&gt; int:\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    return b\n\ndef main() -&gt; None:\n    n = int(input(&apos;Write a number: &apos;))\n    print(&apos;Fibonacci number %i: %i&apos; % (n, fibn(n)))\n\nif __name__ == &quot;__main__&quot;:\n    main()\n\nNow, you can from fib import fibn and call the fibn() function from the code which performs this import.\n(I called the function fibn() just to make it clearer what is what in this example. In real life, you might call it fib() and do from fib import fib.)\nSimilarly, you could import and call the main function if you wanted to reuse it.\nReturning to the code in the question, I would similarly move the code from the if into a function as well, so that callers can invoke that function if they want to.\ndef main():\n    lock = thread.allocate_lock()\n    thread.start_new_thread(myfunction, (&quot;Thread #: 1&quot;, 2, lock))\n    thread.start_new_thread(myfunction, (&quot;Thread #: 2&quot;, 2, lock))\n\nif __name__ == &quot;__main__&quot;:\n    main()\n\nThis changes the scope of the lock variable; if the surrounding code needs access to it, you will need to make it global (or, perhaps, better, refactor main to return lock, and have the caller capture the value in a local variable of its own).\n(Unlike in languages like C, the name main has no specific meaning to Python; but it&apos;s a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like main(), unlike in C.)\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"This answer is for Java programmers learning Python.\nEvery Java file typically contains one public class. You can use that class in two ways: \n\n\nCall the class from other files. You just have to import it in the calling program.\nRun the class stand alone, for testing purposes. \n\n\nFor the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label &apos;__main__&apos;.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"If the Python interpreter is running a particular module then the __name__ global variable will have the value &quot;__main__&quot;:\n  def a():\n      print(&quot;a&quot;)\n\n  def b():\n      print(&quot;b&quot;)\n\n  if __name__ == &quot;__main__&quot;:\n\n          print (&quot;you can see me&quot;)\n          a()\n  else:\n\n          print (&quot;You can&apos;t see me&quot;)\n          b()\n\nWhen you run this script, it prints you can see me.\na\nIf you import this file, say A to file B, and execute the file B then if __name__ == &quot;__main__&quot; in file A becomes false, so it prints  You can&apos;t see me.\nb\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"In simple words:\nThe code you see under if __name__ == &quot;__main__&quot;: will only get called upon when your Python file is executed as &quot;python example1.py&quot;.\nHowever, if you wish to import your Python file &apos;example1.py&apos; as a module to work with another Python file, say &apos;example2.py&apos;, the code under if __name__ == &quot;__main__&quot;: will not run or take any effect.\nIn simple words:\nThe code you see under if __name__ == &quot;__main__&quot;: will only get called upon when your Python file is executed as &quot;python example1.py&quot;.\nHowever, if you wish to import your Python file &apos;example1.py&apos; as a module to work with another Python file, say &apos;example2.py&apos;, the code under if __name__ == &quot;__main__&quot;: will not run or take any effect.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"If this .py file are imported by other .py files, the code under the if statement will not be executed.\nIf this .py are run by python this_py.py under shell, or double clicked in Windows. the code under the if statement will be executed.\nIt is usually written for testing.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"We see if __name__ == &apos;__main__&apos;: quite often.\nIt checks if a module is being imported or not.\nIn other words, the code within the if block will be executed only when the code runs directly. Here directly means not imported.\nLet&apos;s see what it does using a simple code that prints the name of the module:\n# test.py\ndef test():\n   print(&apos;test module name=%s&apos; %(__name__))\n\nif __name__ == &apos;__main__&apos;:\n   print(&apos;call test()&apos;)\n   test()\n\nIf we run the code directly via python test.py, the module name is __main__:\ncall test()\ntest module name=__main__\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"Create a file, a.py:\n\nprint(__name__) # It will print out __main__\n\n\n__name__ is always equal to __main__ whenever that file is run directly showing that this is the main file.\n\nCreate another file, b.py, in the same directory:\n\nimport a  # Prints a\n\n\nRun it. It will print a, i.e., the name of the file which is imported.\n\nSo, to show two different behavior of the same file, this is a commonly used trick:\n\n# Code to be run when imported into another python file\n\nif __name__ == &apos;__main__&apos;:\n    # Code to be run only when run directly\n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-does-if-__name__-%22__main__%22:-do-1657384825815#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-does-if-__name__-%22__main__%22:-do-1657384825815"><h1>What does if __name__ == &quot;__main__&quot;: do?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/python-module">python-module</a></div></div><div class="question-content mt-5">
                
<p>What does this do, and why should one include the <code>if</code> statement?</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, World!"</span>)
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Short Answer</h1>
<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>
<ul>
<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p>
</li>
<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p>
</li>
</ul>
<h1>Long Answer</h1>
<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>
<p>Whenever the Python interpreter reads a source file, it does two things:</p>
<ul>
<li><p>it sets a few special variables like <code>__name__</code>, and then</p>
</li>
<li><p>it executes all of the code found in the file.</p>
</li>
</ul>
<p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>
<h2>Code Sample</h2>
<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py</code>.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Suppose this is foo.py.</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"before import"</span>)
<span class="hljs-keyword">import</span> math

<span class="hljs-built_in">print</span>(<span class="hljs-string">"before function_a"</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_a</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Function A"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"before function_b"</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_b</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Function B {}"</span>.<span class="hljs-built_in">format</span>(math.sqrt(<span class="hljs-number">100</span>)))

<span class="hljs-built_in">print</span>(<span class="hljs-string">"before __name__ guard"</span>)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    function_a()
    function_b()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"after __name__ guard"</span>)
</code></pre>
<h2>Special Variables</h2>
<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>
<p><strong>When Your Module Is the Main Program</strong></p>
<p>If you are running your module (the source file) as the main program, e.g.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">python foo.py
</code></pre>
<p>the interpreter will assign the hard-coded string <code>"__main__"</code> to the <code>__name__</code> variable, i.e.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># It's as if the interpreter inserts this at the top</span>
<span class="hljs-comment"># of your module when run as the main program.</span>
__name__ = <span class="hljs-string">"__main__"</span> 
</code></pre>
<p><strong>When Your Module Is Imported By Another</strong></p>
<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Suppose this is in some other main program.</span>
<span class="hljs-keyword">import</span> foo
</code></pre>
<p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>"foo"</code> from the import statement to the <code>__name__</code> variable, i.e.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># It's as if the interpreter inserts this at the top</span>
<span class="hljs-comment"># of your module when it's imported from another module.</span>
__name__ = <span class="hljs-string">"foo"</span>
</code></pre>
<h2>Executing the Module's Code</h2>
<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>
<p><strong>Always</strong></p>
<ol>
<li><p>It prints the string <code>"before import"</code> (without quotes).</p>
</li>
<li><p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p>
</li>
</ol>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Find and load a module given its string name, "math",</span>
<span class="hljs-comment"># then assign it to a local variable called math.</span>
math = <span class="hljs-built_in">__import__</span>(<span class="hljs-string">"math"</span>)
</code></pre>
<ol start="3">
<li><p>It prints the string <code>"before function_a"</code>.</p>
</li>
<li><p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p>
</li>
<li><p>It prints the string <code>"before function_b"</code>.</p>
</li>
<li><p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p>
</li>
<li><p>It prints the string <code>"before __name__ guard"</code>.</p>
</li>
</ol>
<p><strong>Only When Your Module Is the Main Program</strong></p>
<ol start="8">
<li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>"__main__"</code> and it calls the two functions, printing the strings <code>"Function A"</code> and <code>"Function B 10.0"</code>.</li>
</ol>
<p><strong>Only When Your Module Is Imported by Another</strong></p>
<ol start="8">
<li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>"foo"</code>, not <code>"__main__"</code>, and it'll skip the body of the <code>if</code> statement.</li>
</ol>
<p><strong>Always</strong></p>
<ol start="9">
<li>It will print the string <code>"after __name__ guard"</code> in both situations.</li>
</ol>
<p><em><strong>Summary</strong></em></p>
<p>In summary, here's what'd be printed in the two cases:</p>
<pre class="lang-none s-code-block"><code># What gets printed if foo is the main program
before import
before function_a
before function_b
before __name__ guard
Function A
Function B 10.0
after __name__ guard
</code></pre>
<pre class="lang-none s-code-block"><code># What gets printed if foo is imported as a regular module
before import
before function_a
before function_b
before __name__ guard
after __name__ guard
</code></pre>
<h2>Why Does It Work This Way?</h2>
<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</p>
<ul>
<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p>
</li>
<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p>
</li>
<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p>
</li>
</ul>
<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. "Running" the script is a side effect of importing the script's module.</p>
<h2>Food for Thought</h2>
<ul>
<li><p>Question: Can I have multiple <code>__name__</code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.</p>
</li>
<li><p>Suppose the following is in <code>foo2.py</code>.  What happens if you say <code>python foo2.py</code> on the command-line? Why?</p>
</li>
</ul>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Suppose this is foo2.py.</span>
<span class="hljs-keyword">import</span> os, sys; sys.path.insert(<span class="hljs-number">0</span>, os.path.dirname(__file__)) <span class="hljs-comment"># needed for some interpreters</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_a</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a1"</span>)
    <span class="hljs-keyword">from</span> foo2 <span class="hljs-keyword">import</span> function_b
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a2"</span>)
    function_b()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a3"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_b</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"b"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"t1"</span>)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"m1"</span>)
    function_a()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"m2"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"t2"</span>)
      
</code></pre>
<ul>
<li>Now, figure out what will happen if you remove the <code>__name__</code> check in <code>foo3.py</code>:</li>
</ul>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Suppose this is foo3.py.</span>
<span class="hljs-keyword">import</span> os, sys; sys.path.insert(<span class="hljs-number">0</span>, os.path.dirname(__file__)) <span class="hljs-comment"># needed for some interpreters</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_a</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a1"</span>)
    <span class="hljs-keyword">from</span> foo3 <span class="hljs-keyword">import</span> function_b
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a2"</span>)
    function_b()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a3"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">function_b</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"b"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"t1"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"m1"</span>)
function_a()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"m2"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"t2"</span>)
</code></pre>
<ul>
<li>What will this do when used as a script?  When imported as a module?</li>
</ul>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Suppose this is in foo4.py</span>
__name__ = <span class="hljs-string">"__main__"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"bar"</span>)
    
<span class="hljs-built_in">print</span>(<span class="hljs-string">"before __name__ guard"</span>)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    bar()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"after __name__ guard"</span>)
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When your script is run by passing it as a command to the Python interpreter,</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">python myscript.py
</code></pre>

<p>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no <code>main()</code> function that gets run automatically - the <code>main()</code> function is implicitly all the code at the top level.</p>

<p>In this case, the top-level code is an <code>if</code> block.  <code>__name__</code> is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in <code>myscript.py</code> above), then <code>__name__</code> instead is set to the string <code>"__main__"</code>.  Thus, you can test whether your script is being run directly or being imported by something else by testing</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    ...
</code></pre>

<p>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the <code>if</code> clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># file one.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"func() in one.py"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"top-level in one.py"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"one.py is being run directly"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"one.py is being imported into another module"</span>)
</code></pre>



<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># file two.py</span>
<span class="hljs-keyword">import</span> one

<span class="hljs-built_in">print</span>(<span class="hljs-string">"top-level in two.py"</span>)
one.func()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"two.py is being run directly"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"two.py is being imported into another module"</span>)
</code></pre>

<p>Now, if you invoke the interpreter as</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">python one.py
</code></pre>

<p>The output will be</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">top-level <span class="hljs-keyword">in</span> one.py
one.py <span class="hljs-keyword">is</span> being run directly
</code></pre>

<p>If you run <code>two.py</code> instead:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">python two.py
</code></pre>

<p>You get</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">top-level <span class="hljs-keyword">in</span> one.py
one.py <span class="hljs-keyword">is</span> being imported into another module
top-level <span class="hljs-keyword">in</span> two.py
func() <span class="hljs-keyword">in</span> one.py
two.py <span class="hljs-keyword">is</span> being run directly
</code></pre>

<p>Thus, when module <code>one</code> gets loaded, its <code>__name__</code> equals <code>"one"</code> instead of <code>"__main__"</code>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Create the following two files:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># a.py</span>

<span class="hljs-keyword">import</span> b
</code></pre>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># b.py</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"__name__ equals "</span> + __name__)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"if-statement was executed"</span>)
</code></pre>
<p>Now run each file individually.</p>
<hr>
<p><strong>Running <code>python a.py</code>:</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python a.py
__name__ equals b
</code></pre>
<p>When <code>a.py</code> is executed, it imports the module <code>b</code>. This causes all the code inside <code>b</code> to run. Python sets <code>globals()['__name__']</code> in the <code>b</code> module to the module's name, <code>b</code>.</p>
  <br>
<p><strong>Running <code>python b.py</code>:</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python b.py
__name__ equals __main__
<span class="hljs-keyword">if</span>-statement was executed
</code></pre>
<p>When only the file <code>b.py</code> is executed, Python sets <code>globals()['__name__']</code> in this file to <code>"__main__"</code>. Therefore, the <code>if</code> statement evaluates to <code>True</code> this time.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <h2>What does the <code>if __name__ == "__main__":</code> do?</h2>
</blockquote>

<p>To outline the basics:</p>

<ul>
<li><p>The global variable, <code>__name__</code>, in the module that is the entry point to your program, is <code>'__main__'</code>. Otherwise, it's the name you import the module by.</p></li>
<li><p>So, code under the <code>if</code> block will only run if the module is the entry point to your program.</p></li>
<li><p>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</p></li>
</ul>

<hr>

<p>Why do we need this?</p>

<h2>Developing and Testing Your Code</h2>

<p>Say you're writing a Python script designed to be used as a module:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_important</span>():
    <span class="hljs-string">"""This function does something very important"""</span>
</code></pre>

<p>You <em>could</em> test the module by adding this call of the function to the bottom:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">do_important()
</code></pre>

<p>and running it (on a command prompt) with something like:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">~$ python important.py
</code></pre>

<h2>The Problem</h2>

<p>However, if you want to import the module to another script:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> important
</code></pre>

<p>On import, the <code>do_important</code> function would be called, so you'd probably comment out your function call, <code>do_important()</code>, at the bottom. </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># do_important() # I must remember to uncomment to execute this!</span>
</code></pre>

<p>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</p>

<h2>A Better Way</h2>

<p>The <code>__name__</code> variable points to the namespace wherever the Python interpreter happens to be at the moment. </p>

<p>Inside an imported module, it's the name of that module. </p>

<p>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its <code>"__main__"</code>.</p>

<p>So if you check before executing:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    do_important()
</code></pre>

<p>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script). </p>

<h2>An Even Better Way</h2>

<p>There's a Pythonic way to improve on this, though. </p>

<p>What if we want to run this business process from outside the module?</p>

<p>If we put the code we want to exercise as we develop and test in a function like this and then do our check for <code>'__main__'</code> immediately after:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-string">"""business logic for when running this module as the primary one!"""</span>
    setup()
    foo = do_important()
    bar = do_even_more_important(foo)
    <span class="hljs-keyword">for</span> baz <span class="hljs-keyword">in</span> bar:
        do_super_important(baz)
    teardown()

<span class="hljs-comment"># Here's our payoff idiom!</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>

<p>We now have a final function for the end of our module that will run if we run the module as the primary module. </p>

<p>It will allow the module and its functions and classes to be imported into other scripts without running the <code>main</code> function, and will also allow the module (and its functions and classes) to be called when running from a different <code>'__main__'</code> module, i.e.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> important
important.main()
</code></pre>

<p><a href="https://docs.python.org/2/library/__main__.html" rel="noreferrer">This idiom can also be found in the Python documentation in an explanation of the <code>__main__</code> module.</a> That text states:</p>

<blockquote>
  <p>This module represents the (otherwise anonymous) scope in which the
  interpreters main program executes  commands read either from
  standard input, from a script file, or from an interactive prompt. It
  is this environment in which the idiomatic conditional script stanza
  causes a script to run:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>if __name__ == "__main__"</code> is the part that runs when the script is run from (say) the command line using a command like <code>python myscript.py</code>.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
<h2>What does <code>if __name__ == "__main__":</code> do?</h2>
</blockquote>
<p><code>__name__</code> is a global variable (in Python, global actually means on the <a href="https://docs.python.org/tutorial/modules.html#modules" rel="nofollow noreferrer">module level</a>) that exists in all namespaces. It is typically the module's name (as a <code>str</code> type).</p>
<p>As the only special case, however, in whatever Python process you run, as in mycode.py:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">python mycode.py
</code></pre>
<p>the otherwise anonymous global namespace is assigned the value of <code>'__main__'</code> to its <code>__name__</code>.</p>
<p>Thus, including <a href="https://docs.python.org/library/__main__.html" rel="nofollow noreferrer">the final lines</a></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>
<ul>
<li>at the end of your mycode.py script,</li>
<li>when it is the primary, entry-point module that is run by a Python process,</li>
</ul>
<p>will cause your script's uniquely defined <code>main</code> function to run.</p>
<p>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> mycode
<span class="hljs-comment"># ... any amount of other code</span>
mycode.main()
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are lots of different takes here on the mechanics of the code in question, the "How", but for me none of it made sense until I understood the "Why". This should be especially helpful for new programmers.</p>

<p>Take file "ab.py":</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'A function in ab file'</span>);
a()
</code></pre>

<p>And a second file "xy.py":</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> ab
<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'main function: this is where the action is'</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>():
    <span class="hljs-built_in">print</span> (<span class="hljs-string">'peripheral task: might be useful in other projects'</span>)
x()
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<blockquote>
  <p>What is this code actually doing?</p>
</blockquote>

<p>When you execute <code>xy.py</code>, you <code>import ab</code>. The import statement runs the module immediately on import, so <code>ab</code>'s operations get executed before the remainder of <code>xy</code>'s. Once finished with <code>ab</code>, it continues with <code>xy</code>.</p>

<p>The interpreter keeps track of which scripts are running with <code>__name__</code>. When you run a script - no matter what you've named it - the interpreter calls it <code>"__main__"</code>, making it the master or 'home' script that gets returned to after running an external script.</p>

<p>Any other script that's called from this <code>"__main__"</code> script is assigned its filename as its <code>__name__</code> (e.g., <code>__name__ == "ab.py"</code>). Hence, the line <code>if __name__ == "__main__":</code> is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</p>

<p>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or <code>def</code> - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</p>

<ul>
<li>Open xy.py as the 'home' file; call it <code>"__main__"</code> in the <code>__name__</code> variable.</li>
<li>Import and open file with the <code>__name__ == "ab.py"</code>.</li>
<li>Oh, a function. I'll remember that.</li>
<li>Ok, function <code>a()</code>; I just learned that. Printing '<em>A function in ab file</em>'.</li>
<li>End of file; back to <code>"__main__"</code>!</li>
<li>Oh, a function. I'll remember that.</li>
<li>Another one.</li>
<li>Function <code>x()</code>; ok, printing '<em>peripheral task: might be useful in other projects</em>'.</li>
<li>What's this? An <code>if</code> statement. Well, the condition has been met (the variable <code>__name__</code> has been set to <code>"__main__"</code>), so I'll enter the <code>main()</code> function and print '<em>main function: this is where the action is</em>'.</li>
</ul>

<p>The bottom two lines mean: "If this is the <code>"__main__"</code> or 'home' script, execute the function called <code>main()</code>". That's why you'll see a <code>def main():</code> block up top, which contains the main flow of the script's functionality.</p>

<blockquote>
  <p>Why implement this?</p>
</blockquote>

<p>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the <code>main()</code> function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</p>

<p>Again, there will be exceptions, but common practice is that <code>main()</code> doesn't usually get called externally. So you may be wondering one more thing: if we're not calling <code>main()</code>, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</p>

<blockquote>
  <p>But the code works without it</p>
</blockquote>

<p>Yes, that's right. These separate functions <strong>can</strong> be called from an in-line script that's not contained inside a <code>main()</code> function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</p>

<p>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</p>

<p>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, "example.py" might import "xy.py" and call <code>x()</code>, making use of the 'x' function from "xy.py". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</p>

<p>(As an aside, <a href="https://stackoverflow.com/questions/23000075/purpose-of-if-name-main">this question</a> contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of <a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do">this one</a>, which I think is a mistake.)</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The code under <code>if __name__ == '__main__':</code> will <em>only</em> be executed if the module is invoked as a script.</p>
<p>As an example, consider the following module <code>my_test_module.py</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># my_test_module.py</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">'This is going to be printed out, no matter what'</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'This is going to be printed out, only if user invokes the module as a script'</span>)
</code></pre>
<hr>
<p><strong>First possibility: Import <code>my_test_module.py</code> in another module</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># main.py</span>

<span class="hljs-keyword">import</span> my_test_module

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Hello from main.py'</span>)
</code></pre>
<p>Now if you invoke <code>main.py</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">python main.py

&gt;&gt; <span class="hljs-string">'This is going to be printed out, no matter what'</span>
&gt;&gt; <span class="hljs-string">'Hello from main.py'</span>
</code></pre>
<p>Note that only the top-level <code>print()</code> statement in <code>my_test_module</code> is executed.</p>
<hr>
<p><strong>Second possibility: Invoke <code>my_test_module.py</code> as a script</strong></p>
<p>Now if you run <code>my_test_module.py</code> as a Python script, both <code>print()</code> statements will be executed:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">python my_test_module.py

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'This is going to be printed out, no matter what'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'This is going to be printed out, only if user invokes the module as a script'</span>
</code></pre>
<hr>
<p>For a more comprehensive explanation, you can read <em><a href="https://towardsdatascience.com/what-does-if-name-main-do-e357dd61be1a" rel="nofollow noreferrer">What does <code>if __name__ == '__main__'</code> do in Python</a></em>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When there are certain statements in our module (<code>M.py</code>) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this <code>if</code> block.</p>

<p>As by default (when module running as main, not imported) the <code>__name__</code> variable is set to <code>"__main__"</code>, and when it'll be imported the <code>__name__</code> variable will get a different value, most probably the name of the module (<code>'M'</code>).
This is helpful in running different variants of a modules together, and separating their specific input &amp; output statements and also if there are any test-cases.</p>

<p><strong>In short</strong>, use this '<code>if __name__ == "main"</code> ' block to prevent (certain) code from being run when the module is imported.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Put simply, <code>__name__</code> is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</p>

<p>So if we have two scripts;</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment">#script1.py</span>
<span class="hljs-built_in">print</span> <span class="hljs-string">"Script 1's name: {}"</span>.<span class="hljs-built_in">format</span>(__name__)
</code></pre>

<p>and</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment">#script2.py</span>
<span class="hljs-keyword">import</span> script1
<span class="hljs-built_in">print</span> <span class="hljs-string">"Script 2's name: {}"</span>.<span class="hljs-built_in">format</span>(__name__)
</code></pre>

<p>The output from executing script1 is</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">Script <span class="hljs-number">1</span><span class="hljs-string">'s name: __main__
</span></code></pre>

<p>And the output from executing script2 is:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">Script1<span class="hljs-string">'s name is script1
Script 2'</span>s name: __main__
</code></pre>

<p>As you can see, <code>__name__</code> tells us which code is the 'main' module.
This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</p>

<p>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  <code>if __name__ == "__main__":</code> context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</p>

<p><a href="https://i.stack.imgur.com/hWLqr.png" rel="noreferrer"><img src="https://i.stack.imgur.com/hWLqr.png" alt="Complicated importing in C"></a></p>

<p>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</p>

<p><a href="https://i.stack.imgur.com/Eql0u.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Eql0u.png" alt="Elegant importing in Python"></a></p>

<p>You write a module, and if someone wants to use your code they just import it and the <code>__name__</code> variable can help to separate the executable portion of the program from the library part.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let's look at the answer in a more abstract way:</p>

<p>Suppose we have this code in <code>x.py</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">...
&lt;Block A&gt;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    &lt;Block B&gt;
...
</code></pre>

<p>Blocks A and B are run when we are running <code>x.py</code>.</p>

<p>But just block A (and not B) is run when we are running another module, <code>y.py</code> for example, in which <code>x.py</code> is imported and the code is run from there (like when a function in <code>x.py</code> is called from <code>y.py</code>).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To be short, you need to know several points:</p>
<ol>
<li><p><code>import a</code> action actually runs all that can be run in <code>a.py</code>, meaning each line in <code>a.py</code></p>
</li>
<li><p>Because of point 1, you may not want everything to be run in <code>a.py</code> when importing it</p>
</li>
<li><p>To solve the problem in point 2, Python allows you to use a condition check</p>
</li>
<li><p><code>__name__</code> is an implicit variable in all <code>.py</code> modules:</p>
</li>
</ol>
<ul>
<li>when <code>a.py</code> is <code>import</code>ed, the value of <code>__name__</code> of <code>a.py</code> module is set to its file name "<code>a</code>"</li>
<li>when <code>a.py</code> is run directly using "<code>python a.py</code>", the value of <code>__name__</code> is set to a string <code>__main__</code></li>
</ul>
<ol start="5">
<li>Based on the mechanism how Python sets the variable <code>__name__</code> for each module, do you know how to achieve point 3? The answer is fairly easy, right? Use an <em>if</em> condition: <code>if __name__ == "__main__": // do A</code></li>
</ol>
<ul>
<li>then <code>python a.py</code> will run the part <code>// do A</code></li>
<li>and <code>import a</code> will skip the part <code>// do A</code></li>
</ul>
<ol start="6">
<li>You can even put if <code>__name__ == "a"</code> depending on your functional need, but rarely do</li>
</ol>
<p>The important thing that Python is special at is point 4! The rest is just basic logic.</p>
<p><sub>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</sub></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you run Python interactively the local <code>__name__</code> variable is assigned a value of <code>__main__</code>. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its <code>__name__</code> attribute is assigned a value of <code>__main__</code>, rather than the actual name of the module. In this way, modules can look at their own <code>__name__</code> value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Do something appropriate here, like calling a</span>
    <span class="hljs-comment"># main() function defined elsewhere in this module.</span>
    main()
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Do nothing. This module has been imported by another</span>
    <span class="hljs-comment"># module that wants to make use of the functions,</span>
    <span class="hljs-comment"># classes and other useful bits it has defined.</span>
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<p>It checks if the <code>__name__</code> attribute of the Python script is <code>"__main__"</code>. In other words, if the program itself is executed, the attribute will be <code>__main__</code>, so the program will be executed (in this case the <code>main()</code> function).</p>
<p>However, if your Python script is used by a module, any code outside of the <code>if</code> statement will be executed, so <code>if __name__ == "__main__"</code> is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>Before explaining anything about <code>if __name__ == '__main__'</code> it is important to understand what <code>__name__</code> is and what it does.</em></p>
<h2>What is <code>__name__</code>?</h2>
<p><code>__name__</code> is a <a href="https://wiki.python.org/moin/DunderAlias" rel="nofollow noreferrer">DunderAlias</a> - can be thought of as a global variable (accessible from modules) and works in a similar way to <a href="https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement"><code>global</code></a>.</p>
<p>It is a string (global as mentioned above) as indicated by <code>type(__name__)</code> (yielding <code>&lt;class 'str'&gt;</code>), and is an inbuilt standard for both <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">Python 3</a> and <a href="https://docs.python.org/2/library/__main__.html" rel="nofollow noreferrer">Python 2</a> versions.</p>
<h2>Where</h2>
<p>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</p>
<h3>Interpreter:</h3>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(__name__)
__main__
&gt;&gt;&gt;
</code></pre>
<h3>Script:</h3>
<p><em>test_file.py</em>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(__name__)
</code></pre>
<p>Resulting in <code>__main__</code></p>
<h3>Module or package:</h3>
<p><em>somefile.py:</em></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">somefunction</span>():
    <span class="hljs-built_in">print</span>(__name__)
</code></pre>
<p><em>test_file.py:</em></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> somefile
somefile.somefunction()
</code></pre>
<p>Resulting in <code>somefile</code></p>
<p>Notice that when used in a package or module, <code>__name__</code> takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias <code>__file__</code>, that allows for this.</p>
<p>You should see that, where <code>__name__</code>, where it is the main file (or program) will <em>always</em> return <code>__main__</code>, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</p>
<h2>Practice</h2>
<p>Being a variable means that it's value <em>can</em> be overwritten ("can" does not mean "should"), overwriting the value of <code>__name__</code> will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.</p>
<p>It is always assumed that the value of <code>__name__</code> to be <code>__main__</code> or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</p>
<h3>Example:</h3>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>__name__ = <span class="hljs-string">'Horrify'</span> <span class="hljs-comment"># Change default from __main__</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'Horrify'</span>: <span class="hljs-built_in">print</span>(__name__)
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">else</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">'Not Horrify'</span>)
...
Horrify
&gt;&gt;&gt;
</code></pre>
<p>It is considered good practice in general to include the <code>if __name__ == '__main__'</code> in scripts.</p>
<h2>Now to answer <code>if __name__ == '__main__'</code>:</h2>
<p><em>Now we know the behaviour of <code>__name__</code> things become clearer:</em></p>
<p>An <a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements" rel="nofollow noreferrer"><code>if</code></a> is a flow control statement that contains the block of code will execute if the value given is true. We have seen that <code>__name__</code> can take either
<code>__main__</code> or the file name it has been imported from.</p>
<p>This means that if <code>__name__</code> is equal to <code>__main__</code> then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</p>
<p>If indeed <code>__name__</code> does take the value of <code>__main__</code> then whatever is in that block of code will execute.</p>
<p>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be <code>__main__</code>.</p>
<h3>Modules</h3>
<p><code>__name__</code> can also be used in modules to define the name of a module</p>
<h3>Variants</h3>
<p>It is also possible to do other, less common but useful things with <code>__name__</code>, some I will show here:</p>
<h3>Executing only if the file is a module or package</h3>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ != <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Do some useful things </span>
</code></pre>
<h3>Running one condition if the file is the main one and another if it is not</h3>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Execute something</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Do some useful things</span>
</code></pre>
<p>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</p>
<p>It also allows modules to be run from the command line as main scripts, which can be also very useful.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think it's best to break the answer in depth and in simple words:</p>

<p><code>__name__</code>: Every module in Python has a special attribute called <code>__name__</code>.
It is a built-in variable that returns the name of the module.</p>

<p><code>__main__</code>: Like other programming languages, Python too has an execution entry point, i.e., main. <code>'__main__'</code> <em>is the name of the scope in which top-level code executes</em>. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its <code>__name__</code> is set to <code>__main__</code>.</p>

<p>Thus, the value of the <code>__name__</code> attribute is set to <code>__main__</code> when the module is run as the main program. Otherwise the value of <code>__name__</code>  is set to contain the name of the module.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is a special for when a Python file is called from the command line. This is typically used to call a "main()" function or execute other appropriate startup code, like commandline arguments handling for instance.</p>
<p>It could be written in several ways. Another is:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">some_function_for_instance_main</span>():
    dosomething()


__name__ == <span class="hljs-string">'__main__'</span> <span class="hljs-keyword">and</span> some_function_for_instance_main()
</code></pre>
<p>I am not saying you should use this in production code, but it serves to illustrate that there is nothing "magical" about <code>if __name__ == '__main__'</code>.</p>
<p>It just a convention for invoking a main function in Python files.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the <strong>__name__</strong> variable/attribute:</p>

<p>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</p>

<p>Before the interpreter executes the source code file though, it defines a few special variables for that file; <strong>__name__</strong> is one of those special variables that Python automatically defines for each source code file.</p>

<p>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special <strong>__name__</strong> variable for this file to have a value <strong>"__main__"</strong>.</p>

<p>If this is being imported from another module, <strong>__name__</strong> will be set to that module's name.</p>

<p>So, in your example in part:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
   lock = thread.allocate_lock()
   thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 1"</span>, <span class="hljs-number">2</span>, lock))
   thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 2"</span>, <span class="hljs-number">2</span>, lock))
</code></pre>

<p>means that the code block:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">lock = thread.allocate_lock()
thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 1"</span>, <span class="hljs-number">2</span>, lock))
thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 2"</span>, <span class="hljs-number">2</span>, lock))
</code></pre>

<p>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of <strong>__name__</strong> will not equal to "<strong>main</strong>" in that particular instance.</p>

<p>Hope this helps out.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>if __name__ == "__main__":</code> is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</p>

<p><code>'__main__'</code> is the name of the scope in which top-level code executes. A modules <code>__name__</code> is set equal to <code>'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># Execute only if run as a script</span>
    main()
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span> __name__
</code></pre>

<p>The output for the above is <code>__main__</code>.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
  <span class="hljs-built_in">print</span> <span class="hljs-string">"direct method"</span>
</code></pre>

<p>The above statement is true and prints <em>"direct method"</em>. Suppose if they imported this class in another class it doesn't print <em>"direct method"</em> because, while importing, it will set <code>__name__ equal to "first model name"</code>.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>You can make the file usable as a <strong>script</strong> as well as an <strong>importable module</strong>.</p>
</blockquote>

<p><strong>fibo.py (a module named <code>fibo</code>)</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Other modules can IMPORT this MODULE to use the function fib</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):    <span class="hljs-comment"># write Fibonacci series up to n</span>
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> b &lt; n:
        <span class="hljs-built_in">print</span>(b, end=<span class="hljs-string">' '</span>)
        a, b = b, a+b
    <span class="hljs-built_in">print</span>()

<span class="hljs-comment"># This allows the file to be used as a SCRIPT</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">import</span> sys
    fib(<span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>]))
</code></pre>

<p>Reference: <a href="https://docs.python.org/3.5/tutorial/modules.html" rel="noreferrer">https://docs.python.org/3.5/tutorial/modules.html</a></p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason for</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<p>is primarily to avoid the <a href="https://docs.python.org/2/library/threading.html#importing-in-threaded-code" rel="noreferrer">import lock</a> problems that would arise from <a href="https://stackoverflow.com/questions/46326059/">having code directly imported</a>. You want <code>main()</code> to run if your file was directly invoked (that's the <code>__name__ == "__main__"</code> case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</p>

<p>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using <code>main()</code> as the entry point, <em>but you don't have to</em>. While <code>setup.py</code> expects <code>main()</code>, other tools use alternate entry points. For example, to run your file as a <code>gunicorn</code> process, you define an <code>app()</code> function instead of a <code>main()</code>. Just as with <code>setup.py</code>, <code>gunicorn</code> imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every module in Python has an attribute called <code>__name__</code>. The value of <code>__name__</code>  attribute is  <code>__main__</code> when the module is run directly, like <code>python my_module.py</code>. Otherwise (like when you say <code>import my_module</code>) the value of <code>__name__</code>  is the name of the module.</p>
<p>Small example to explain in short.</p>
<h3>Script <em>test.py</em></h3>
<pre class="lang-py s-code-block"><code class="hljs language-python">apple = <span class="hljs-number">42</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I am inside hello_world"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Value of __name__ is: "</span>, __name__)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Going to call hello_world"</span>)
    hello_world()
</code></pre>
<p>We can execute this directly as</p>
<pre class="lang-none s-code-block"><code>python test.py
</code></pre>
<p>Output</p>
<pre class="lang-none s-code-block"><code>Value of __name__ is: __main__
Going to call hello_world
I am inside hello_world
</code></pre>
<p>Now suppose we call the above script from another script:</p>
<h3>Script <em>external_calling.py</em></h3>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> test

<span class="hljs-built_in">print</span>(test.apple)
test.hello_world()

<span class="hljs-built_in">print</span>(test.__name__)
</code></pre>
<p>When you execute this,</p>
<pre class="lang-none s-code-block"><code>python external_calling.py
</code></pre>
<p>Output</p>
<pre class="lang-none s-code-block"><code>42
I am inside hello_world
test
</code></pre>
<p>So, the above is self-explanatory that when you call <em>test</em> from another script, if loop <code>__name__</code> in <code>test.py</code> will not execute.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are a beginner, probably the only answer you need right now is that <em>this code is unnecessary</em> for a simple script. It is only useful if you want to be able to <code>import</code> your script (or <code>unpickle</code> etc; see the other answers here for some other non-beginner scenarios).</p>
<p>In slightly different words, the <code>if __name__</code> guard is a mechanism for hiding code from other code. If you don't have a specific reason to hide something, don't: If you don't need to hide some code from <code>import</code>, don't put it behind this guard, and if you do, hide as little as possible.</p>
<p>In slightly more detail, let's say you have a simple script <code>fib.py</code> (adapted from <a href="https://stackoverflow.com/a/42773985/874188">this answer</a>):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># XXX <span class="hljs-doctag">FIXME:</span> useless (see below)</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Write a number: '</span>))
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> b &lt; n:
        a, b = b, a+b
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Fibonacci number %i: %i'</span> % (n, b))
</code></pre>
<p>Now, if you simply run <code>python fib.py</code> it works fine. But <code>__name__</code> will always be <code>"__main__"</code> in this scenario, so the condition is actually unnecessary. The script could be simplified to just</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Write a number: '</span>))
a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> b &lt; n:
    a, b = b, a+b
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Fibonacci number %i: %i'</span> % (n, b))
</code></pre>
<p>Now, you can't <code>import fib</code> with the new version, but if you didn't plan to do that in the first place, this version is actually better, because it's simpler and clearer.</p>
<p>If you <em>do</em> want to be able to <code>import fib</code>, the first version is useless, too, because the useful code is in a section which will not run when you <code>import</code> this file (in which case <code>__name__</code> will not be <code>"__main__"</code>). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have <code>import</code>ed it.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Write a number: '</span>))
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> b &lt; n:
        a, b = b, a+b
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Fibonacci number %i: %i'</span> % (n, b))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<p>Now, if you <code>import fib</code>, the call to <code>main()</code> will not be executed; but when you run <code>python fib.py</code>, it will.</p>
<p>Actually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibn</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> b &lt; n:
        a, b = b, a+b
    <span class="hljs-keyword">return</span> b

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>() -&gt; <span class="hljs-literal">None</span>:
    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Write a number: '</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Fibonacci number %i: %i'</span> % (n, fibn(n)))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<p>Now, you can <code>from fib import fibn</code> and call the <code>fibn()</code> function from the code which performs this <code>import</code>.</p>
<p>(I called the function <code>fibn()</code> just to make it clearer what is what in this example. In real life, you might call it <code>fib()</code> and do <code>from fib import fib</code>.)</p>
<p>Similarly, you could <code>import</code> and call the <code>main</code> function if you wanted to reuse it.</p>
<p>Returning to the code in the question, I would similarly move the code from the <code>if</code> into a function as well, so that callers can invoke that function if they want to.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    lock = thread.allocate_lock()
    thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 1"</span>, <span class="hljs-number">2</span>, lock))
    thread.start_new_thread(myfunction, (<span class="hljs-string">"Thread #: 2"</span>, <span class="hljs-number">2</span>, lock))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<p>This changes the scope of the <code>lock</code> variable; if the surrounding code needs access to it, you will need to make it <code>global</code> (or, perhaps, better, refactor <code>main</code> to <code>return lock</code>, and have the caller capture the value in a local variable of its own).</p>
<p>(Unlike in languages like C, the name <code>main</code> has no specific meaning to Python; but it's a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like <code>main()</code>, unlike in C.)</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This answer is for Java programmers learning Python.
Every Java file typically contains one public class. You can use that class in two ways: </p>

<ol>
<li><p>Call the class from other files. You just have to import it in the calling program.</p></li>
<li><p>Run the class stand alone, for testing purposes. </p></li>
</ol>

<p>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label <code>'__main__'</code>.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If the Python interpreter is running a particular module then the <code>__name__</code> global variable will have the value <code>"__main__"</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"a"</span>)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>():
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"b"</span>)

  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:

          <span class="hljs-built_in">print</span> (<span class="hljs-string">"you can see me"</span>)
          a()
  <span class="hljs-keyword">else</span>:

          <span class="hljs-built_in">print</span> (<span class="hljs-string">"You can't see me"</span>)
          b()
</code></pre>
<p>When you run this script, it prints <strong>you can see me</strong>.</p>
<p><strong>a</strong></p>
<p>If you import this file, say A to file B, and execute the file B then <code>if __name__ == "__main__"</code> in file A becomes false, so it prints  <strong>You can't see me</strong>.</p>
<p><strong>b</strong></p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In simple words:</p>
<p>The code you see under <code>if __name__ == "__main__":</code> will only get called upon when your Python file is executed as "python example1.py".</p>
<p>However, if you wish to import your Python file 'example1.py' as a module to work with another Python file, say 'example2.py', the code under <code>if __name__ == "__main__":</code> will not run or take any effect.</p>
<p>In simple words:</p>
<p>The code you see under <code>if __name__ == "__main__":</code> will only get called upon when your Python file is executed as "python example1.py".</p>
<p>However, if you wish to import your Python file 'example1.py' as a module to work with another Python file, say 'example2.py', the code under <code>if __name__ == "__main__":</code> will not run or take any effect.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If this .py file are imported by other .py files, the code under the <code>if</code> statement will not be executed.</p>
<p>If this .py are run by <code>python this_py.py</code> under shell, or double clicked in Windows. the code under the <code>if</code> statement will be executed.</p>
<p>It is usually written for testing.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We see if <code>__name__ == '__main__':</code> quite often.</p>
<p>It checks if a module is being imported or not.</p>
<p>In other words, the code within the <code>if</code> block will be executed only when the code runs directly. Here <code>directly</code> means <code>not imported</code>.</p>
<p>Let's see what it does using a simple code that prints the name of the module:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># test.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
   <span class="hljs-built_in">print</span>(<span class="hljs-string">'test module name=%s'</span> %(__name__))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
   <span class="hljs-built_in">print</span>(<span class="hljs-string">'call test()'</span>)
   test()
</code></pre>
<p>If we run the code directly via <code>python test.py</code>, the module name is <code>__main__</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">call test()
test module name=__main__
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-module">python-module</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Create a file, <strong>a.py</strong>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(__name__) <span class="hljs-comment"># It will print out __main__</span>
</code></pre>

<p><code>__name__</code> is always equal to <code>__main__</code> whenever that file is <strong>run directly</strong> showing that this is the main file.</p>

<p>Create another file, <strong>b.py</strong>, in the same directory:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> a  <span class="hljs-comment"># Prints a</span>
</code></pre>

<p>Run it. It will print <strong>a</strong>, i.e., the name of the file which <strong>is imported</strong>.</p>

<p>So, to show <strong>two different behavior of the same file</strong>, this is a commonly used trick:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Code to be run when imported into another python file</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Code to be run only when run directly</span>
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-upload-files-asynchronously-with-jquery-1657384815389">How can I upload files asynchronously with jQuery?</a><a href="/questions/how-to-sort-a-multi-dimensional-array-by-value-1657387746110">How to Sort a Multi-dimensional Array by Value</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a><a href="/questions/why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484">Why should I not #include &lt;bits/stdc++.h&gt;?</a><a href="/questions/what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570">What are good ways to prevent SQL injection? [duplicate]</a><a href="/questions/why-are-mutable-structs-%22evil%22-1657388508974">Why are mutable structs evil?</a><a href="/questions/php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896">PHP - Failed to open stream : No such file or directory</a><a href="/questions/how-can-i-avoid-java-code-in-jsp-files-using-jsp-2-1657384618866">How can I avoid Java code in JSP files, using JSP 2?</a><a href="/questions/when-to-use-virtual-destructors-1657388152135">When to use virtual destructors?</a><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118">How do I use arrays in C++?</a><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/how-can-i-do-a-full-outer-join-in-mysql-1657388175444">How can I do a FULL OUTER JOIN in MySQL?</a><a href="/questions/using-limit-within-group-by-to-get-n-results-per-group-1657388324167">Using LIMIT within GROUP BY to get N results per group?</a><a href="/questions/is-there-a-difference-between-%22%22-and-%22is%22-1657387902231">Is there a difference between &quot;==&quot; and &quot;is&quot;?</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/how-do-i-use-shell-variables-in-an-awk-script-1657387754261">How do I use shell variables in an awk script?</a><a href="/questions/how-do-i-set-clear-and-toggle-a-single-bit-1657388227052">How do I set, clear, and toggle a single bit?</a><a href="/questions/how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093">How to remove/delete a large file from commit history in the Git repository?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Short Answer\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s boilerplate code that protects users from accidentally invoking the script when they didn\u0026apos;t intend to. Here are some common problems when the guard is omitted from a script:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you import the guardless script in another script (e.g. \u0026lt;code\u0026gt;import my_script_without_a_name_eq_main_guard\u0026lt;/code\u0026gt;), then the latter script will trigger the former to run \u0026lt;em\u0026gt;at import time\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;using the second script\u0026apos;s command line arguments\u0026lt;/em\u0026gt;. This is almost always a mistake.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h1\u0026gt;Long Answer\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Whenever the Python interpreter reads a source file, it does two things:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;it sets a few special variables like \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;, and then\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;it executes all of the code found in the file.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s see how this works and how it relates to your question about the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; checks we always see in Python scripts.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Code Sample\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called \u0026lt;code\u0026gt;foo.py\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Suppose this is foo.py.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before import\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; math\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before function_a\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_a\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Function A\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before function_b\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_b\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Function B {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(math.sqrt(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;)))\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before __name__ guard\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    function_a()\n    function_b()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;after __name__ guard\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Special Variables\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When Your Module Is the Main Program\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you are running your module (the source file) as the main program, e.g.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python foo.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;the interpreter will assign the hard-coded string \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; to the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable, i.e.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# It\u0026apos;s as if the interpreter inserts this at the top\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# of your module when run as the main program.\u0026lt;/span\u0026gt;\n__name__ = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When Your Module Is Imported By Another\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On the other hand, suppose some other module is the main program and it imports your module. This means there\u0026apos;s a statement like this in the main program, or in some other module the main program imports:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Suppose this is in some other main program.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The interpreter will search for your \u0026lt;code\u0026gt;foo.py\u0026lt;/code\u0026gt; file (along with searching for a few other variants), and prior to executing that module, it will assign the name \u0026lt;code\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/code\u0026gt; from the import statement to the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable, i.e.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# It\u0026apos;s as if the interpreter inserts this at the top\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# of your module when it\u0026apos;s imported from another module.\u0026lt;/span\u0026gt;\n__name__ = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Executing the Module\u0026apos;s Code\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Always\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It prints the string \u0026lt;code\u0026gt;\u0026quot;before import\u0026quot;\u0026lt;/code\u0026gt; (without quotes).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It loads the \u0026lt;code\u0026gt;math\u0026lt;/code\u0026gt; module and assigns it to a variable called \u0026lt;code\u0026gt;math\u0026lt;/code\u0026gt;. This is equivalent to replacing \u0026lt;code\u0026gt;import math\u0026lt;/code\u0026gt; with the following (note that \u0026lt;code\u0026gt;__import__\u0026lt;/code\u0026gt; is a low-level function in Python that takes a string and triggers the actual import):\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Find and load a module given its string name, \u0026quot;math\u0026quot;,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# then assign it to a local variable called math.\u0026lt;/span\u0026gt;\nmath = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;__import__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;math\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It prints the string \u0026lt;code\u0026gt;\u0026quot;before function_a\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It executes the \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; block, creating a function object, then assigning that function object to a variable called \u0026lt;code\u0026gt;function_a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It prints the string \u0026lt;code\u0026gt;\u0026quot;before function_b\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It executes the second \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; block, creating another function object, then assigning it to a variable called \u0026lt;code\u0026gt;function_b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It prints the string \u0026lt;code\u0026gt;\u0026quot;before __name__ guard\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Only When Your Module Is the Main Program\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;8\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;If your module is the main program, then it will see that \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; was indeed set to \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; and it calls the two functions, printing the strings \u0026lt;code\u0026gt;\u0026quot;Function A\u0026quot;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026quot;Function B 10.0\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Only When Your Module Is Imported by Another\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;8\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;(\u0026lt;strong\u0026gt;instead\u0026lt;/strong\u0026gt;) If your module is not the main program but was imported by another one, then \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will be \u0026lt;code\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/code\u0026gt;, not \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;, and it\u0026apos;ll skip the body of the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Always\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;9\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;It will print the string \u0026lt;code\u0026gt;\u0026quot;after __name__ guard\u0026quot;\u0026lt;/code\u0026gt; in both situations.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Summary\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In summary, here\u0026apos;s what\u0026apos;d be printed in the two cases:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;# What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;# What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Why Does It Work This Way?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;You might naturally wonder why anybody would want this.  Well, sometimes you want to write a \u0026lt;code\u0026gt;.py\u0026lt;/code\u0026gt; file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing \u0026lt;code\u0026gt;.py\u0026lt;/code\u0026gt; files like your script and running special test functions. You don\u0026apos;t want it to try running the script just because it\u0026apos;s importing the module.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Beyond those examples, it\u0026apos;s elegant that running a script in Python is just setting up a few magic variables and importing the script. \u0026quot;Running\u0026quot; the script is a side effect of importing the script\u0026apos;s module.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Food for Thought\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Question: Can I have multiple \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; checking blocks?  Answer: it\u0026apos;s strange to do so, but the language won\u0026apos;t stop you.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Suppose the following is in \u0026lt;code\u0026gt;foo2.py\u0026lt;/code\u0026gt;.  What happens if you say \u0026lt;code\u0026gt;python foo2.py\u0026lt;/code\u0026gt; on the command-line? Why?\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Suppose this is foo2.py.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os, sys; sys.path.insert(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, os.path.dirname(__file__)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# needed for some interpreters\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_a\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a1\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; foo2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; function_b\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a2\u0026quot;\u0026lt;/span\u0026gt;)\n    function_b()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a3\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_b\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;t1\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;m1\u0026quot;\u0026lt;/span\u0026gt;)\n    function_a()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;m2\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;t2\u0026quot;\u0026lt;/span\u0026gt;)\n      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Now, figure out what will happen if you remove the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; check in \u0026lt;code\u0026gt;foo3.py\u0026lt;/code\u0026gt;:\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Suppose this is foo3.py.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os, sys; sys.path.insert(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, os.path.dirname(__file__)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# needed for some interpreters\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_a\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a1\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; foo3 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; function_b\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a2\u0026quot;\u0026lt;/span\u0026gt;)\n    function_b()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a3\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;function_b\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;t1\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;m1\u0026quot;\u0026lt;/span\u0026gt;)\nfunction_a()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;m2\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;t2\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;What will this do when used as a script?  When imported as a module?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Suppose this is in foo4.py\u0026lt;/span\u0026gt;\n__name__ = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;)\n    \n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before __name__ guard\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    bar()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;after __name__ guard\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When your script is run by passing it as a command to the Python interpreter,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python myscript.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there\u0026apos;s no \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function that gets run automatically - the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function is implicitly all the code at the top level.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, the top-level code is an \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; block.  \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in \u0026lt;code\u0026gt;myscript.py\u0026lt;/code\u0026gt; above), then \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; instead is set to the string \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;.  Thus, you can test whether your script is being run directly or being imported by something else by testing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; clause above won\u0026apos;t get run as the condition is not met. As a basic example, consider the following two scripts:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# file one.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;func() in one.py\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;top-level in one.py\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one.py is being run directly\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one.py is being imported into another module\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# file two.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; one\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;top-level in two.py\u0026quot;\u0026lt;/span\u0026gt;)\none.func()\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;two.py is being run directly\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;two.py is being imported into another module\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, if you invoke the interpreter as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python one.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output will be\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;top-level \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; one.py\none.py \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; being run directly\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you run \u0026lt;code\u0026gt;two.py\u0026lt;/code\u0026gt; instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python two.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You get\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;top-level \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; one.py\none.py \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; being imported into another module\ntop-level \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; two.py\nfunc() \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; one.py\ntwo.py \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; being run directly\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thus, when module \u0026lt;code\u0026gt;one\u0026lt;/code\u0026gt; gets loaded, its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; equals \u0026lt;code\u0026gt;\u0026quot;one\u0026quot;\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Create the following two files:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a.py\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# b.py\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__name__ equals \u0026quot;\u0026lt;/span\u0026gt; + __name__)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;if-statement was executed\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now run each file individually.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Running \u0026lt;code\u0026gt;python a.py\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python a.py\n__name__ equals b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt; is executed, it imports the module \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;. This causes all the code inside \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; to run. Python sets \u0026lt;code\u0026gt;globals()[\u0026apos;__name__\u0026apos;]\u0026lt;/code\u0026gt; in the \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; module to the module\u0026apos;s name, \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n  \u0026lt;br\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Running \u0026lt;code\u0026gt;python b.py\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python b.py\n__name__ equals __main__\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;-statement was executed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When only the file \u0026lt;code\u0026gt;b.py\u0026lt;/code\u0026gt; is executed, Python sets \u0026lt;code\u0026gt;globals()[\u0026apos;__name__\u0026apos;]\u0026lt;/code\u0026gt; in this file to \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;. Therefore, the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement evaluates to \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; this time.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h2\u0026gt;What does the \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; do?\u0026lt;/h2\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;To outline the basics:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The global variable, \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;, in the module that is the entry point to your program, is \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt;. Otherwise, it\u0026apos;s the name you import the module by.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;So, code under the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; block will only run if the module is the entry point to your program.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It allows the code in the module to be importable by other modules, without executing the code block beneath on import.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Why do we need this?\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Developing and Testing Your Code\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Say you\u0026apos;re writing a Python script designed to be used as a module:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;do_important\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;This function does something very important\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You \u0026lt;em\u0026gt;could\u0026lt;/em\u0026gt; test the module by adding this call of the function to the bottom:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;do_important()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and running it (on a command prompt) with something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;~$ python important.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;The Problem\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want to import the module to another script:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; important\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;On import, the \u0026lt;code\u0026gt;do_important\u0026lt;/code\u0026gt; function would be called, so you\u0026apos;d probably comment out your function call, \u0026lt;code\u0026gt;do_important()\u0026lt;/code\u0026gt;, at the bottom. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# do_important() # I must remember to uncomment to execute this!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And then you\u0026apos;ll have to remember whether or not you\u0026apos;ve commented out your test function call. And this extra complexity would mean you\u0026apos;re likely to forget, making your development process more troublesome.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;A Better Way\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable points to the namespace wherever the Python interpreter happens to be at the moment. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inside an imported module, it\u0026apos;s the name of that module. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But inside the primary module (or an interactive Python session, i.e. the interpreter\u0026apos;s Read, Eval, Print Loop, or REPL) you are running everything from its \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if you check before executing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    do_important()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With the above, your code will only execute when you\u0026apos;re running it as the primary module (or intentionally call it from another script). \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;An Even Better Way\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a Pythonic way to improve on this, though. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What if we want to run this business process from outside the module?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we put the code we want to exercise as we develop and test in a function like this and then do our check for \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; immediately after:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;business logic for when running this module as the primary one!\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    setup()\n    foo = do_important()\n    bar = do_even_more_important(foo)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; baz \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; bar:\n        do_super_important(baz)\n    teardown()\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Here\u0026apos;s our payoff idiom!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We now have a final function for the end of our module that will run if we run the module as the primary module. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It will allow the module and its functions and classes to be imported into other scripts without running the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function, and will also allow the module (and its functions and classes) to be called when running from a different \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; module, i.e.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; important\nimportant.main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.python.org/2/library/__main__.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;This idiom can also be found in the Python documentation in an explanation of the \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; module.\u0026lt;/a\u0026gt; That text states:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This module represents the (otherwise anonymous) scope in which the\n  interpreters main program executes  commands read either from\n  standard input, from a script file, or from an interactive prompt. It\n  is this environment in which the idiomatic conditional script stanza\n  causes a script to run:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; is the part that runs when the script is run from (say) the command line using a command like \u0026lt;code\u0026gt;python myscript.py\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n\u0026lt;h2\u0026gt;What does \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; do?\u0026lt;/h2\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is a global variable (in Python, global actually means on the \u0026lt;a href=\u0026quot;https://docs.python.org/tutorial/modules.html#modules\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;module level\u0026lt;/a\u0026gt;) that exists in all namespaces. It is typically the module\u0026apos;s name (as a \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; type).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As the only special case, however, in whatever Python process you run, as in mycode.py:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python mycode.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;the otherwise anonymous global namespace is assigned the value of \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; to its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Thus, including \u0026lt;a href=\u0026quot;https://docs.python.org/library/__main__.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;the final lines\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;at the end of your mycode.py script,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when it is the primary, entry-point module that is run by a Python process,\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;will cause your script\u0026apos;s uniquely defined \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function to run.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; mycode\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# ... any amount of other code\u0026lt;/span\u0026gt;\nmycode.main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are lots of different takes here on the mechanics of the code in question, the \u0026quot;How\u0026quot;, but for me none of it made sense until I understood the \u0026quot;Why\u0026quot;. This should be especially helpful for new programmers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take file \u0026quot;ab.py\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A function in ab file\u0026apos;\u0026lt;/span\u0026gt;);\na()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And a second file \u0026quot;xy.py\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ab\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;main function: this is where the action is\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;peripheral task: might be useful in other projects\u0026apos;\u0026lt;/span\u0026gt;)\nx()\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What is this code actually doing?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When you execute \u0026lt;code\u0026gt;xy.py\u0026lt;/code\u0026gt;, you \u0026lt;code\u0026gt;import ab\u0026lt;/code\u0026gt;. The import statement runs the module immediately on import, so \u0026lt;code\u0026gt;ab\u0026lt;/code\u0026gt;\u0026apos;s operations get executed before the remainder of \u0026lt;code\u0026gt;xy\u0026lt;/code\u0026gt;\u0026apos;s. Once finished with \u0026lt;code\u0026gt;ab\u0026lt;/code\u0026gt;, it continues with \u0026lt;code\u0026gt;xy\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The interpreter keeps track of which scripts are running with \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;. When you run a script - no matter what you\u0026apos;ve named it - the interpreter calls it \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;, making it the master or \u0026apos;home\u0026apos; script that gets returned to after running an external script.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Any other script that\u0026apos;s called from this \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; script is assigned its filename as its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; (e.g., \u0026lt;code\u0026gt;__name__ == \u0026quot;ab.py\u0026quot;\u0026lt;/code\u0026gt;). Hence, the line \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; is the interpreter\u0026apos;s test to determine if it\u0026apos;s interpreting/parsing the \u0026apos;home\u0026apos; script that was initially executed, or if it\u0026apos;s temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it\u0026apos;s executed directly vs. called externally.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s step through the above code to understand what\u0026apos;s happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; - blocks don\u0026apos;t do anything by themselves until they\u0026apos;re called. What the interpreter might say if mumbled to itself:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Open xy.py as the \u0026apos;home\u0026apos; file; call it \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; in the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Import and open file with the \u0026lt;code\u0026gt;__name__ == \u0026quot;ab.py\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Oh, a function. I\u0026apos;ll remember that.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Ok, function \u0026lt;code\u0026gt;a()\u0026lt;/code\u0026gt;; I just learned that. Printing \u0026apos;\u0026lt;em\u0026gt;A function in ab file\u0026lt;/em\u0026gt;\u0026apos;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;End of file; back to \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;!\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Oh, a function. I\u0026apos;ll remember that.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Another one.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function \u0026lt;code\u0026gt;x()\u0026lt;/code\u0026gt;; ok, printing \u0026apos;\u0026lt;em\u0026gt;peripheral task: might be useful in other projects\u0026lt;/em\u0026gt;\u0026apos;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What\u0026apos;s this? An \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement. Well, the condition has been met (the variable \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; has been set to \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;), so I\u0026apos;ll enter the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function and print \u0026apos;\u0026lt;em\u0026gt;main function: this is where the action is\u0026lt;/em\u0026gt;\u0026apos;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The bottom two lines mean: \u0026quot;If this is the \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; or \u0026apos;home\u0026apos; script, execute the function called \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;\u0026quot;. That\u0026apos;s why you\u0026apos;ll see a \u0026lt;code\u0026gt;def main():\u0026lt;/code\u0026gt; block up top, which contains the main flow of the script\u0026apos;s functionality.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why implement this?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Remember what I said earlier about import statements? When you import a module it doesn\u0026apos;t just \u0026apos;recognize\u0026apos; it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function effectively quarantines it, putting it in isolation so that it won\u0026apos;t immediately run when imported by another script.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Again, there will be exceptions, but common practice is that \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; doesn\u0026apos;t usually get called externally. So you may be wondering one more thing: if we\u0026apos;re not calling \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;, why are we calling the script at all? It\u0026apos;s because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They\u0026apos;re then later called somewhere else in the body of the script. Which brings me to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;But the code works without it\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, that\u0026apos;s right. These separate functions \u0026lt;strong\u0026gt;can\u0026lt;/strong\u0026gt; be called from an in-line script that\u0026apos;s not contained inside a \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function. If you\u0026apos;re accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you\u0026apos;ll try to figure it out again if you ever need that operation again ... well, you\u0026apos;re not used to this kind of internal structure to your code, because it\u0026apos;s more complicated to build and it\u0026apos;s not as intuitive to read.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But that\u0026apos;s a script that probably can\u0026apos;t have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you\u0026apos;re trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, \u0026quot;example.py\u0026quot; might import \u0026quot;xy.py\u0026quot; and call \u0026lt;code\u0026gt;x()\u0026lt;/code\u0026gt;, making use of the \u0026apos;x\u0026apos; function from \u0026quot;xy.py\u0026quot;. (Maybe it\u0026apos;s capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(As an aside, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt; contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it\u0026apos;s been marked as a duplicate of \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do\u0026quot;\u0026gt;this one\u0026lt;/a\u0026gt;, which I think is a mistake.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The code under \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;:\u0026lt;/code\u0026gt; will \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; be executed if the module is invoked as a script.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an example, consider the following module \u0026lt;code\u0026gt;my_test_module.py\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# my_test_module.py\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;This is going to be printed out, no matter what\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;This is going to be printed out, only if user invokes the module as a script\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;First possibility: Import \u0026lt;code\u0026gt;my_test_module.py\u0026lt;/code\u0026gt; in another module\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# main.py\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; my_test_module\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello from main.py\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now if you invoke \u0026lt;code\u0026gt;main.py\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python main.py\n\n\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;This is going to be printed out, no matter what\u0026apos;\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello from main.py\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that only the top-level \u0026lt;code\u0026gt;print()\u0026lt;/code\u0026gt; statement in \u0026lt;code\u0026gt;my_test_module\u0026lt;/code\u0026gt; is executed.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Second possibility: Invoke \u0026lt;code\u0026gt;my_test_module.py\u0026lt;/code\u0026gt; as a script\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now if you run \u0026lt;code\u0026gt;my_test_module.py\u0026lt;/code\u0026gt; as a Python script, both \u0026lt;code\u0026gt;print()\u0026lt;/code\u0026gt; statements will be executed:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;python my_test_module.py\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;This is going to be printed out, no matter what\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;This is going to be printed out, only if user invokes the module as a script\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;For a more comprehensive explanation, you can read \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://towardsdatascience.com/what-does-if-name-main-do-e357dd61be1a\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;What does \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; do in Python\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When there are certain statements in our module (\u0026lt;code\u0026gt;M.py\u0026lt;/code\u0026gt;) we want to be executed when it\u0026apos;ll be running as main (not imported), we can place those statements (test-cases, print statements) under this \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; block.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As by default (when module running as main, not imported) the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable is set to \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;, and when it\u0026apos;ll be imported the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable will get a different value, most probably the name of the module (\u0026lt;code\u0026gt;\u0026apos;M\u0026apos;\u0026lt;/code\u0026gt;).\nThis is helpful in running different variants of a modules together, and separating their specific input \u0026amp;amp; output statements and also if there are any test-cases.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In short\u0026lt;/strong\u0026gt;, use this \u0026apos;\u0026lt;code\u0026gt;if __name__ == \u0026quot;main\u0026quot;\u0026lt;/code\u0026gt; \u0026apos; block to prevent (certain) code from being run when the module is imported.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Put simply, \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if we have two scripts;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#script1.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Script 1\u0026apos;s name: {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(__name__)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#script2.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; script1\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Script 2\u0026apos;s name: {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(__name__)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output from executing script1 is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Script \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s name: __main__\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And the output from executing script2 is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Script1\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s name is script1\nScript 2\u0026apos;\u0026lt;/span\u0026gt;s name: __main__\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see, \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; tells us which code is the \u0026apos;main\u0026apos; module.\nThis is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a \u0026apos;main\u0026apos; function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/hWLqr.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/hWLqr.png\u0026quot; alt=\u0026quot;Complicated importing in C\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Eql0u.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Eql0u.png\u0026quot; alt=\u0026quot;Elegant importing in Python\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You write a module, and if someone wants to use your code they just import it and the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable can help to separate the executable portion of the program from the library part.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let\u0026apos;s look at the answer in a more abstract way:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we have this code in \u0026lt;code\u0026gt;x.py\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;...\n\u0026amp;lt;Block A\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026amp;lt;Block B\u0026amp;gt;\n...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Blocks A and B are run when we are running \u0026lt;code\u0026gt;x.py\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But just block A (and not B) is run when we are running another module, \u0026lt;code\u0026gt;y.py\u0026lt;/code\u0026gt; for example, in which \u0026lt;code\u0026gt;x.py\u0026lt;/code\u0026gt; is imported and the code is run from there (like when a function in \u0026lt;code\u0026gt;x.py\u0026lt;/code\u0026gt; is called from \u0026lt;code\u0026gt;y.py\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To be short, you need to know several points:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;import a\u0026lt;/code\u0026gt; action actually runs all that can be run in \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt;, meaning each line in \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Because of point 1, you may not want everything to be run in \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt; when importing it\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;To solve the problem in point 2, Python allows you to use a condition check\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is an implicit variable in all \u0026lt;code\u0026gt;.py\u0026lt;/code\u0026gt; modules:\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;when \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt;ed, the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt; module is set to its file name \u0026quot;\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when \u0026lt;code\u0026gt;a.py\u0026lt;/code\u0026gt; is run directly using \u0026quot;\u0026lt;code\u0026gt;python a.py\u0026lt;/code\u0026gt;\u0026quot;, the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is set to a string \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;ol start=\u0026quot;5\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;Based on the mechanism how Python sets the variable \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; for each module, do you know how to achieve point 3? The answer is fairly easy, right? Use an \u0026lt;em\u0026gt;if\u0026lt;/em\u0026gt; condition: \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;: // do A\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;then \u0026lt;code\u0026gt;python a.py\u0026lt;/code\u0026gt; will run the part \u0026lt;code\u0026gt;// do A\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;and \u0026lt;code\u0026gt;import a\u0026lt;/code\u0026gt; will skip the part \u0026lt;code\u0026gt;// do A\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;ol start=\u0026quot;6\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;You can even put if \u0026lt;code\u0026gt;__name__ == \u0026quot;a\u0026quot;\u0026lt;/code\u0026gt; depending on your functional need, but rarely do\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;The important thing that Python is special at is point 4! The rest is just basic logic.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;I\u0026apos;ve been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you run Python interactively the local \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; variable is assigned a value of \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; attribute is assigned a value of \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, rather than the actual name of the module. In this way, modules can look at their own \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Do something appropriate here, like calling a\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# main() function defined elsewhere in this module.\u0026lt;/span\u0026gt;\n    main()\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Do nothing. This module has been imported by another\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# module that wants to make use of the functions,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# classes and other useful bits it has defined.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It checks if the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; attribute of the Python script is \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;. In other words, if the program itself is executed, the attribute will be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, so the program will be executed (in this case the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, if your Python script is used by a module, any code outside of the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement will be executed, so \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; is used just to check if the program is used as a module or not, and therefore decides whether to run the code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Before explaining anything about \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; it is important to understand what \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is and what it does.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;What is \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is a \u0026lt;a href=\u0026quot;https://wiki.python.org/moin/DunderAlias\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DunderAlias\u0026lt;/a\u0026gt; - can be thought of as a global variable (accessible from modules) and works in a similar way to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement\u0026quot;\u0026gt;\u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is a string (global as mentioned above) as indicated by \u0026lt;code\u0026gt;type(__name__)\u0026lt;/code\u0026gt; (yielding \u0026lt;code\u0026gt;\u0026amp;lt;class \u0026apos;str\u0026apos;\u0026amp;gt;\u0026lt;/code\u0026gt;), and is an inbuilt standard for both \u0026lt;a href=\u0026quot;https://docs.python.org/3/library/__main__.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Python 3\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/__main__.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Python 2\u0026lt;/a\u0026gt; versions.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Where\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;It can not only be used in scripts but can also be found in both the interpreter and modules/packages.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Interpreter:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(__name__)\n__main__\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Script:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;test_file.py\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(__name__)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Resulting in \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Module or package:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;somefile.py:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;somefunction\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(__name__)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;test_file.py:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; somefile\nsomefile.somefunction()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Resulting in \u0026lt;code\u0026gt;somefile\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Notice that when used in a package or module, \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias \u0026lt;code\u0026gt;__file__\u0026lt;/code\u0026gt;, that allows for this.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You should see that, where \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;, where it is the main file (or program) will \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; return \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Practice\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Being a variable means that it\u0026apos;s value \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; be overwritten (\u0026quot;can\u0026quot; does not mean \u0026quot;should\u0026quot;), overwriting the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is always assumed that the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; to be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Example:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;__name__ = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Horrify\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Change default from __main__\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Horrify\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(__name__)\n...\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Not Horrify\u0026apos;\u0026lt;/span\u0026gt;)\n...\nHorrify\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It is considered good practice in general to include the \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; in scripts.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Now to answer \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt;:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Now we know the behaviour of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; things become clearer:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;a href=\u0026quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is a flow control statement that contains the block of code will execute if the value given is true. We have seen that \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; can take either\n\u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; or the file name it has been imported from.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This means that if \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is equal to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If indeed \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; does take the value of \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; then whatever is in that block of code will execute.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Modules\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; can also be used in modules to define the name of a module\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Variants\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;It is also possible to do other, less common but useful things with \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;, some I will show here:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Executing only if the file is a module or package\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Do some useful things \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Running one condition if the file is the main one and another if it is not\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Execute something\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Do some useful things\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It also allows modules to be run from the command line as main scripts, which can be also very useful.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think it\u0026apos;s best to break the answer in depth and in simple words:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;: Every module in Python has a special attribute called \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;.\nIt is a built-in variable that returns the name of the module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;: Like other programming languages, Python too has an execution entry point, i.e., main. \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is the name of the scope in which top-level code executes\u0026lt;/em\u0026gt;. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is set to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Thus, the value of the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; attribute is set to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; when the module is run as the main program. Otherwise the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;  is set to contain the name of the module.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is a special for when a Python file is called from the command line. This is typically used to call a \u0026quot;main()\u0026quot; function or execute other appropriate startup code, like commandline arguments handling for instance.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It could be written in several ways. Another is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;some_function_for_instance_main\u0026lt;/span\u0026gt;():\n    dosomething()\n\n\n__name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; some_function_for_instance_main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I am not saying you should use this in production code, but it serves to illustrate that there is nothing \u0026quot;magical\u0026quot; about \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It just a convention for invoking a main function in Python files.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the \u0026lt;strong\u0026gt;__name__\u0026lt;/strong\u0026gt; variable/attribute:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When Python loads a source code file, it executes all of the code found in it. (Note that it doesn\u0026apos;t call all of the methods and functions defined in the file, but it does define them.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Before the interpreter executes the source code file though, it defines a few special variables for that file; \u0026lt;strong\u0026gt;__name__\u0026lt;/strong\u0026gt; is one of those special variables that Python automatically defines for each source code file.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special \u0026lt;strong\u0026gt;__name__\u0026lt;/strong\u0026gt; variable for this file to have a value \u0026lt;strong\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If this is being imported from another module, \u0026lt;strong\u0026gt;__name__\u0026lt;/strong\u0026gt; will be set to that module\u0026apos;s name.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, in your example in part:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n   lock = thread.allocate_lock()\n   thread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 1\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\n   thread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 2\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;means that the code block:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;lock = thread.allocate_lock()\nthread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 1\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\nthread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 2\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of \u0026lt;strong\u0026gt;__name__\u0026lt;/strong\u0026gt; will not equal to \u0026quot;\u0026lt;strong\u0026gt;main\u0026lt;/strong\u0026gt;\u0026quot; in that particular instance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hope this helps out.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; is basically the top-level script environment, and it specifies the interpreter that (\u0026apos;I have the highest priority to be executed first\u0026apos;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; is the name of the scope in which top-level code executes. A modules \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is set equal to \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; when read from standard input, a script, or from an interactive prompt.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Execute only if run as a script\u0026lt;/span\u0026gt;\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; __name__\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output for the above is \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;direct method\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above statement is true and prints \u0026lt;em\u0026gt;\u0026quot;direct method\u0026quot;\u0026lt;/em\u0026gt;. Suppose if they imported this class in another class it doesn\u0026apos;t print \u0026lt;em\u0026gt;\u0026quot;direct method\u0026quot;\u0026lt;/em\u0026gt; because, while importing, it will set \u0026lt;code\u0026gt;__name__ equal to \u0026quot;first model name\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;You can make the file usable as a \u0026lt;strong\u0026gt;script\u0026lt;/strong\u0026gt; as well as an \u0026lt;strong\u0026gt;importable module\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;fibo.py (a module named \u0026lt;code\u0026gt;fibo\u0026lt;/code\u0026gt;)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Other modules can IMPORT this MODULE to use the function fib\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fib\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n\u0026lt;/span\u0026gt;):    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# write Fibonacci series up to n\u0026lt;/span\u0026gt;\n    a, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; b \u0026amp;lt; n:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(b, end=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;)\n        a, b = b, a+b\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;()\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This allows the file to be used as a SCRIPT\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys\n    fib(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(sys.argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference: \u0026lt;a href=\u0026quot;https://docs.python.org/3.5/tutorial/modules.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://docs.python.org/3.5/tutorial/modules.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason for\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is primarily to avoid the \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;import lock\u0026lt;/a\u0026gt; problems that would arise from \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/46326059/\u0026quot;\u0026gt;having code directly imported\u0026lt;/a\u0026gt;. You want \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; to run if your file was directly invoked (that\u0026apos;s the \u0026lt;code\u0026gt;__name__ == \u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; as the entry point, \u0026lt;em\u0026gt;but you don\u0026apos;t have to\u0026lt;/em\u0026gt;. While \u0026lt;code\u0026gt;setup.py\u0026lt;/code\u0026gt; expects \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;, other tools use alternate entry points. For example, to run your file as a \u0026lt;code\u0026gt;gunicorn\u0026lt;/code\u0026gt; process, you define an \u0026lt;code\u0026gt;app()\u0026lt;/code\u0026gt; function instead of a \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;. Just as with \u0026lt;code\u0026gt;setup.py\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gunicorn\u0026lt;/code\u0026gt; imports your code so you don\u0026apos;t want it do do anything while it\u0026apos;s being imported (because of the import lock issue).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every module in Python has an attribute called \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;. The value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;  attribute is  \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; when the module is run directly, like \u0026lt;code\u0026gt;python my_module.py\u0026lt;/code\u0026gt;. Otherwise (like when you say \u0026lt;code\u0026gt;import my_module\u0026lt;/code\u0026gt;) the value of \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt;  is the name of the module.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Small example to explain in short.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Script \u0026lt;em\u0026gt;test.py\u0026lt;/em\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;apple = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hello_world\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am inside hello_world\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Value of __name__ is: \u0026quot;\u0026lt;/span\u0026gt;, __name__)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Going to call hello_world\u0026quot;\u0026lt;/span\u0026gt;)\n    hello_world()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We can execute this directly as\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;python test.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Value of __name__ is: __main__\nGoing to call hello_world\nI am inside hello_world\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now suppose we call the above script from another script:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Script \u0026lt;em\u0026gt;external_calling.py\u0026lt;/em\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; test\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(test.apple)\ntest.hello_world()\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(test.__name__)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When you execute this,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;python external_calling.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;42\nI am inside hello_world\ntest\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So, the above is self-explanatory that when you call \u0026lt;em\u0026gt;test\u0026lt;/em\u0026gt; from another script, if loop \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;test.py\u0026lt;/code\u0026gt; will not execute.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are a beginner, probably the only answer you need right now is that \u0026lt;em\u0026gt;this code is unnecessary\u0026lt;/em\u0026gt; for a simple script. It is only useful if you want to be able to \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; your script (or \u0026lt;code\u0026gt;unpickle\u0026lt;/code\u0026gt; etc; see the other answers here for some other non-beginner scenarios).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In slightly different words, the \u0026lt;code\u0026gt;if __name__\u0026lt;/code\u0026gt; guard is a mechanism for hiding code from other code. If you don\u0026apos;t have a specific reason to hide something, don\u0026apos;t: If you don\u0026apos;t need to hide some code from \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt;, don\u0026apos;t put it behind this guard, and if you do, hide as little as possible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In slightly more detail, let\u0026apos;s say you have a simple script \u0026lt;code\u0026gt;fib.py\u0026lt;/code\u0026gt; (adapted from \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/42773985/874188\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# XXX \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;FIXME:\u0026lt;/span\u0026gt; useless (see below)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Write a number: \u0026apos;\u0026lt;/span\u0026gt;))\n    a, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; b \u0026amp;lt; n:\n        a, b = b, a+b\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fibonacci number %i: %i\u0026apos;\u0026lt;/span\u0026gt; % (n, b))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, if you simply run \u0026lt;code\u0026gt;python fib.py\u0026lt;/code\u0026gt; it works fine. But \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will always be \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; in this scenario, so the condition is actually unnecessary. The script could be simplified to just\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Write a number: \u0026apos;\u0026lt;/span\u0026gt;))\na, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; b \u0026amp;lt; n:\n    a, b = b, a+b\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fibonacci number %i: %i\u0026apos;\u0026lt;/span\u0026gt; % (n, b))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, you can\u0026apos;t \u0026lt;code\u0026gt;import fib\u0026lt;/code\u0026gt; with the new version, but if you didn\u0026apos;t plan to do that in the first place, this version is actually better, because it\u0026apos;s simpler and clearer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; want to be able to \u0026lt;code\u0026gt;import fib\u0026lt;/code\u0026gt;, the first version is useless, too, because the useful code is in a section which will not run when you \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; this file (in which case \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will not be \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt;ed it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Write a number: \u0026apos;\u0026lt;/span\u0026gt;))\n    a, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; b \u0026amp;lt; n:\n        a, b = b, a+b\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fibonacci number %i: %i\u0026apos;\u0026lt;/span\u0026gt; % (n, b))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, if you \u0026lt;code\u0026gt;import fib\u0026lt;/code\u0026gt;, the call to \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; will not be executed; but when you run \u0026lt;code\u0026gt;python fib.py\u0026lt;/code\u0026gt;, it will.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Actually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fibn\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;:\n    a, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; b \u0026amp;lt; n:\n        a, b = b, a+b\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; b\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n    n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Write a number: \u0026apos;\u0026lt;/span\u0026gt;))\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fibonacci number %i: %i\u0026apos;\u0026lt;/span\u0026gt; % (n, fibn(n)))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, you can \u0026lt;code\u0026gt;from fib import fibn\u0026lt;/code\u0026gt; and call the \u0026lt;code\u0026gt;fibn()\u0026lt;/code\u0026gt; function from the code which performs this \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(I called the function \u0026lt;code\u0026gt;fibn()\u0026lt;/code\u0026gt; just to make it clearer what is what in this example. In real life, you might call it \u0026lt;code\u0026gt;fib()\u0026lt;/code\u0026gt; and do \u0026lt;code\u0026gt;from fib import fib\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Similarly, you could \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; and call the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function if you wanted to reuse it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Returning to the code in the question, I would similarly move the code from the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; into a function as well, so that callers can invoke that function if they want to.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    lock = thread.allocate_lock()\n    thread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 1\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\n    thread.start_new_thread(myfunction, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread #: 2\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, lock))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This changes the scope of the \u0026lt;code\u0026gt;lock\u0026lt;/code\u0026gt; variable; if the surrounding code needs access to it, you will need to make it \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; (or, perhaps, better, refactor \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;return lock\u0026lt;/code\u0026gt;, and have the caller capture the value in a local variable of its own).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Unlike in languages like C, the name \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; has no specific meaning to Python; but it\u0026apos;s a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;, unlike in C.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This answer is for Java programmers learning Python.\nEvery Java file typically contains one public class. You can use that class in two ways: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Call the class from other files. You just have to import it in the calling program.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Run the class stand alone, for testing purposes. \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label \u0026lt;code\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If the Python interpreter is running a particular module then the \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; global variable will have the value \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;():\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;)\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;():\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;)\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n\n          \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;you can see me\u0026quot;\u0026lt;/span\u0026gt;)\n          a()\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n\n          \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;You can\u0026apos;t see me\u0026quot;\u0026lt;/span\u0026gt;)\n          b()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When you run this script, it prints \u0026lt;strong\u0026gt;you can see me\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;a\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you import this file, say A to file B, and execute the file B then \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt; in file A becomes false, so it prints  \u0026lt;strong\u0026gt;You can\u0026apos;t see me\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;b\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In simple words:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code you see under \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; will only get called upon when your Python file is executed as \u0026quot;python example1.py\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, if you wish to import your Python file \u0026apos;example1.py\u0026apos; as a module to work with another Python file, say \u0026apos;example2.py\u0026apos;, the code under \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; will not run or take any effect.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In simple words:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code you see under \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; will only get called upon when your Python file is executed as \u0026quot;python example1.py\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, if you wish to import your Python file \u0026apos;example1.py\u0026apos; as a module to work with another Python file, say \u0026apos;example2.py\u0026apos;, the code under \u0026lt;code\u0026gt;if __name__ == \u0026quot;__main__\u0026quot;:\u0026lt;/code\u0026gt; will not run or take any effect.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If this .py file are imported by other .py files, the code under the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement will not be executed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If this .py are run by \u0026lt;code\u0026gt;python this_py.py\u0026lt;/code\u0026gt; under shell, or double clicked in Windows. the code under the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement will be executed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is usually written for testing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We see if \u0026lt;code\u0026gt;__name__ == \u0026apos;__main__\u0026apos;:\u0026lt;/code\u0026gt; quite often.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It checks if a module is being imported or not.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other words, the code within the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; block will be executed only when the code runs directly. Here \u0026lt;code\u0026gt;directly\u0026lt;/code\u0026gt; means \u0026lt;code\u0026gt;not imported\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s see what it does using a simple code that prints the name of the module:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# test.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;():\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test module name=%s\u0026apos;\u0026lt;/span\u0026gt; %(__name__))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;call test()\u0026apos;\u0026lt;/span\u0026gt;)\n   test()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If we run the code directly via \u0026lt;code\u0026gt;python test.py\u0026lt;/code\u0026gt;, the module name is \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;call test()\ntest module name=__main__\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Create a file, \u0026lt;strong\u0026gt;a.py\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(__name__) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# It will print out __main__\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is always equal to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; whenever that file is \u0026lt;strong\u0026gt;run directly\u0026lt;/strong\u0026gt; showing that this is the main file.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Create another file, \u0026lt;strong\u0026gt;b.py\u0026lt;/strong\u0026gt;, in the same directory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; a  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Prints a\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Run it. It will print \u0026lt;strong\u0026gt;a\u0026lt;/strong\u0026gt;, i.e., the name of the file which \u0026lt;strong\u0026gt;is imported\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, to show \u0026lt;strong\u0026gt;two different behavior of the same file\u0026lt;/strong\u0026gt;, this is a commonly used trick:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Code to be run when imported into another python file\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Code to be run only when run directly\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":162,"title":"What does if __name__ == \"__main__\": do?","content":"\n                \n\u0026lt;p\u0026gt;What does this do, and why should one include the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello, World!\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815","postType":"QUESTION","createdAt":"2022-07-09T16:40:25.000Z","updatedAt":"2022-07-09T16:40:25.000Z","tags":[{"id":594,"name":"python-module","slug":"python-module","createdAt":"2022-07-09T16:40:25.000Z","updatedAt":"2022-07-09T16:40:25.000Z","Questions_Tags":{"questionId":162,"tagId":594}}],"relatedQuestions":[{"title":"What does if __name__ == \"__main__\": do?","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815","tags":[{"name":"python-module","Questions_Tags":{"questionId":162,"tagId":594}}]}]},"randomQuestions":[{"title":"How can I upload files asynchronously with jQuery?","slug":"how-can-i-upload-files-asynchronously-with-jquery-1657384815389"},{"title":"How to Sort a Multi-dimensional Array by Value","slug":"how-to-sort-a-multi-dimensional-array-by-value-1657387746110"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"Why should I not #include \u003cbits/stdc++.h\u003e?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"What are good ways to prevent SQL injection? [duplicate]","slug":"what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570"},{"title":"Why are mutable structs evil?","slug":"why-are-mutable-structs-\"evil\"-1657388508974"},{"title":"PHP - Failed to open stream : No such file or directory","slug":"php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896"},{"title":"How can I avoid Java code in JSP files, using JSP 2?","slug":"how-can-i-avoid-java-code-in-jsp-files-using-jsp-2-1657384618866"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"How can I do a FULL OUTER JOIN in MySQL?","slug":"how-can-i-do-a-full-outer-join-in-mysql-1657388175444"},{"title":"Using LIMIT within GROUP BY to get N results per group?","slug":"using-limit-within-group-by-to-get-n-results-per-group-1657388324167"},{"title":"Is there a difference between \"==\" and \"is\"?","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"How to remove/delete a large file from commit history in the Git repository?","slug":"how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-does-if-__name__-\"__main__\":-do-1657384825815"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>