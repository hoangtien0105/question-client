<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/is-an-array-name-a-pointer-1657387874827","name":"Questions"}}]}</script><title>Is an array name a pointer? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Is an array&#x27;s name a pointer in C?
If not, what is the difference between an array&#x27;s name and a pointer variable?
    "/><meta property="og:title" content="Is an array name a pointer? | Solution Checker"/><meta property="og:description" content="Is an array&#x27;s name a pointer in C?
If not, what is the difference between an array&#x27;s name and a pointer variable?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is an array name a pointer?","text":"Is an array&apos;s name a pointer in C?\nIf not, what is the difference between an array&apos;s name and a pointer variable?\n    ","answerCount":9,"upVoteCount":500,"suggestedAnswer":[{"text":"An array is an array and a pointer is a pointer, but in most cases array names are converted to pointers. A term often used is that they decay to pointers.\n\nHere is an array:\n\nint a[7];\n\n\na contains space for seven integers, and you can put a value in one of them with an assignment, like this:\n\na[3] = 9;\n\n\nHere is a pointer:\n\nint *p;\n\n\np doesn&apos;t contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array a, such as the first one:\n\np = &amp;a[0];\n\n\nWhat can be confusing is that you can also write this:\n\np = a;\n\n\nThis does not copy the contents of the array a into the pointer p (whatever that would mean). Instead, the array name a is converted to a pointer to its first element. So that assignment does the same as the previous one.\n\nNow you can use p in a similar way to an array:\n\np[3] = 17;\n\n\nThe reason that this works is that the array dereferencing operator in C, [ ], is defined in terms of pointers. x[y] means: start with the pointer x, step y elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, x[y] can also be written as *(x+y).\n\nFor this to work with a normal array, such as our a, the name a in a[3] must first be converted to a pointer (to the first element in a). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)\n\nSo, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the sizeof operator on an array. If a was converted to a pointer in this context, sizeof a would give the size of a pointer and not of the actual array, which would be rather useless, so in that case a means the array itself.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"When an array is used as a value, its name represents the address of the first element.\nWhen an array is not used as a value its name represents the whole array.\n\nint arr[7];\n\n/* arr used as value */\nfoo(arr);\nint x = *(arr + 1); /* same as arr[1] */\n\n/* arr not used as value */\nsize_t bytes = sizeof arr;\nvoid *q = &amp;arr; /* void pointers are compatible with pointers to any object */\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"If an expression of array type (such as the array name) appears in a larger expression and it isn&apos;t the operand of either the &amp; or sizeof operators, then the type of the array expression is converted from &quot;N-element array of T&quot; to &quot;pointer to T&quot;, and the value of the expression is the address of the first element in the array.  \n\nIn short, the array name is not a pointer, but in most contexts it is treated as though it were a pointer.  \n\nEdit\n\nAnswering the question in the comment:\n\n\n  If I use sizeof, do i count the size of only the elements of the array? Then the array head also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?\n\n\nWhen you create an array, the only space that&apos;s allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given\n\nchar a[10];\n\n\nwhat you get in memory is\n\n   +---+\na: |   | a[0]\n   +---+ \n   |   | a[1]\n   +---+\n   |   | a[2]\n   +---+\n    ...\n   +---+\n   |   | a[9]\n   +---+\n\n\nThe expression a refers to the entire array, but there&apos;s no object a separate from the array elements themselves.  Thus, sizeof a gives you the size (in bytes) of the entire array.  The expression &amp;a gives you the address of the array, which is the same as the address of the first element.  The difference between &amp;a and &amp;a[0] is the type of the result1 - char (*)[10] in the first case and char * in the second.  \n\nWhere things get weird is when you want to access individual elements - the expression a[i] is defined as the result of *(a + i) - given an address value a, offset i elements (not bytes) from that address and dereference the result.\n\nThe problem is that a isn&apos;t a pointer or an address - it&apos;s the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as a, which has type char [10]) and that expression isn&apos;t the operand of the sizeof or unary &amp; operators, the type of that expression is converted (&quot;decays&quot;) to a pointer type (char *), and the value of the expression is the address of the first element of the array.  Therefore, the expression a has the same type and value as the expression &amp;a[0] (and by extension, the expression *a has the same type and value as the expression a[0]).  \n\nC was derived from an earlier language called B, and in B a was a separate pointer object from the array elements a[0], a[1], etc.  Ritchie wanted to keep B&apos;s array semantics, but he didn&apos;t want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.  \n\nRemember that I said arrays don&apos;t store any metadata about their size.  As soon as that array expression &quot;decays&quot; to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There&apos;s no way to know based on the pointer itself.  \n\nWhen you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the gets function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.  \n\n\n\n\nWhich *may* affect how the address value is interpreted - depends on the machine.\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"An array declared like this\n\nint a[10];\n\n\nallocates memory for 10 ints. You can&apos;t modify a but you can do pointer arithmetic with a.\n\nA pointer like this allocates memory for just the pointer p:\n\nint *p;\n\n\nIt doesn&apos;t allocate any ints. You can modify it:\n\np = a;\n\n\nand use array subscripts as you can with a:\n\np[2] = 5;\na[2] = 5;    // same\n*(p+2) = 5;  // same effect\n*(a+2) = 5;  // same effect\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The array name by itself yields a memory location, so you can treat the array name like a pointer:\n\nint a[7];\n\na[0] = 1976;\na[1] = 1984;\n\nprintf(&quot;memory location of a: %p&quot;, a);\n\nprintf(&quot;value at memory location %p is %d&quot;, a, *a);\n\n\nAnd other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:\n\nprintf(&quot;value at memory location %p is %d&quot;, a + 1, *(a + 1));\n\n\nLanguage-wise, if C didn&apos;t expose the array as just some sort of &quot;pointer&quot;(pedantically it&apos;s just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:\n\nprintf(&quot;value at memory location %p is %d&quot;, &amp;a[1], a[1]);\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I think this example sheds some light on the issue:\n\n#include &lt;stdio.h&gt;\nint main()\n{\n        int a[3] = {9, 10, 11};\n        int **b = &amp;a;\n\n        printf(&quot;a == &amp;a: %d\\n&quot;, a == b);\n        return 0;\n}\n\n\nIt compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:\n\na == &amp;a: 1\n\n\noops :-)\n\nSo, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the &amp; operator. But - oops - that operator does not work :-)), either way, you&apos;ve been warned:\n\np.c: In function main:\npp.c:6:12: warning: initialization from incompatible pointer type\n  int **b = &amp;a;\n            ^\np.c:8:28: warning: comparison of distinct pointer types lacks a cast\n  printf(&quot;a == &amp;a: %d\\n&quot;, a == b);\n\n\nC++ refuses any such attempts with errors in compile-time.\n\nEdit:\n\nThis is what I meant to demonstrate:\n\n#include &lt;stdio.h&gt;\nint main()\n{\n    int a[3] = {9, 10, 11};\n    void *c = a;\n\n    void *b = &amp;a;\n    void *d = &amp;c;\n\n    printf(&quot;a == &amp;a: %d\\n&quot;, a == b);\n    printf(&quot;c == &amp;c: %d\\n&quot;, c == d);\n    return 0;\n}\n\n\nEven though c and a &quot;point&quot; to the same memory, you can obtain address of the c pointer, but you cannot obtain the address of the a pointer.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"The following example provides a concrete difference between an array name and a pointer. Let say that you want to represent a 1D line with some given maximum dimension, you could do it either with an array or a pointer:\ntypedef struct {\n   int length;\n   int line_as_array[1000];\n   int* line_as_pointer;\n} Line;\n\nNow let&apos;s look at the behavior of the following code:\n\nvoid do_something_with_line(Line line) {\n   line.line_as_pointer[0] = 0;\n   line.line_as_array[0] = 0;\n}\n\nvoid main() {\n   Line my_line;\n   my_line.length = 20;\n   my_line.line_as_pointer = (int*) calloc(my_line.length, sizeof(int));\n\n   my_line.line_as_pointer[0] = 10;\n   my_line.line_as_array[0] = 10;\n\n   do_something_with_line(my_line);\n\n   printf(&quot;%d %d\\n&quot;, my_line.line_as_pointer[0], my_line.line_as_array[0]);\n};\n\n\nThis code will output:\n0 10\n\nThat is because in the function call to do_something_with_line the object was copied so:\n\nThe pointer line_as_pointer still contains the same address it was pointing to\nThe array line_as_array was copied to a new address which does not outlive the scope of the function\n\nSo while arrays are not given by values when you directly input them to functions, when you encapsulate them in structs they are given by value (i.e. copied) which outlines here a major difference in behavior compared to the implementation using pointers.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The array name behaves like a pointer and points to the first element of the array. Example:\n\nint a[]={1,2,3};\nprintf(&quot;%p\\n&quot;,a);     //result is similar to 0x7fff6fe40bc0\nprintf(&quot;%p\\n&quot;,&amp;a[0]); //result is similar to 0x7fff6fe40bc0\n\n\nBoth the print statements will give exactly same output for a machine. In my system it gave: \n\n0x7fff6fe40bc0\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Array name is the address of 1st element of an array. So yes array name is a const pointer.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-an-array-name-a-pointer-1657387874827#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-an-array-name-a-pointer-1657387874827"><h1>Is an array name a pointer?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Is an array's name a pointer in C?
If not, what is the difference between an array's name and a pointer variable?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An array is an array and a pointer is a pointer, but in most cases array names are <em>converted</em> to pointers. A term often used is that they <em>decay</em> to pointers.</p>

<p>Here is an array:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[<span class="hljs-number">7</span>];
</code></pre>

<p><code>a</code> contains space for seven integers, and you can put a value in one of them with an assignment, like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">a[<span class="hljs-number">3</span>] = <span class="hljs-number">9</span>;
</code></pre>

<p>Here is a pointer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *p;
</code></pre>

<p><code>p</code> doesn't contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array <code>a</code>, such as the first one:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p = &amp;a[<span class="hljs-number">0</span>];
</code></pre>

<p>What can be confusing is that you can also write this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p = a;
</code></pre>

<p>This does <em>not</em> copy the contents of the array <code>a</code> into the pointer <code>p</code> (whatever that would mean). Instead, the array name <code>a</code> is converted to a pointer to its first element. So that assignment does the same as the previous one.</p>

<p>Now you can use <code>p</code> in a similar way to an array:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p[<span class="hljs-number">3</span>] = <span class="hljs-number">17</span>;
</code></pre>

<p>The reason that this works is that the array dereferencing operator in C, <code>[ ]</code>, is defined in terms of pointers. <code>x[y]</code> means: start with the pointer <code>x</code>, step <code>y</code> elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, <code>x[y]</code> can also be written as <code>*(x+y)</code>.</p>

<p>For this to work with a normal array, such as our <code>a</code>, the name <code>a</code> in <code>a[3]</code> must first be converted to a pointer (to the first element in <code>a</code>). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)</p>

<p>So, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the <code>sizeof</code> operator on an array. If <code>a</code> was converted to a pointer in this context, <code>sizeof a</code> would give the size of a pointer and not of the actual array, which would be rather useless, so in that case <code>a</code> means the array itself.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When an array is used as a value, its name represents the address of the first element.<br>
When an array is not used as a value its name represents the whole array.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> arr[<span class="hljs-number">7</span>];

<span class="hljs-comment">/* arr used as value */</span>
foo(arr);
<span class="hljs-type">int</span> x = *(arr + <span class="hljs-number">1</span>); <span class="hljs-comment">/* same as arr[1] */</span>

<span class="hljs-comment">/* arr not used as value */</span>
<span class="hljs-type">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> arr;
<span class="hljs-type">void</span> *q = &amp;arr; <span class="hljs-comment">/* void pointers are compatible with pointers to any object */</span>
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If an expression of array type (such as the array name) appears in a larger expression and it isn't the operand of either the <code>&amp;</code> or <code>sizeof</code> operators, then the type of the array expression is converted from "N-element array of T" to "pointer to T", and the value of the expression is the address of the first element in the array.  </p>

<p>In short, the array name is not a pointer, but in most contexts it is treated <em>as though</em> it were a pointer.  </p>

<p><strong>Edit</strong></p>

<p>Answering the question in the comment:</p>

<blockquote>
  <p>If I use sizeof, do i count the size of only the elements of the array? Then the array head also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?</p>
</blockquote>

<p>When you create an array, the only space that's allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];
</code></pre>

<p>what you get in memory is</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">   +---+
a: |   | a[<span class="hljs-number">0</span>]
   +---+ 
   |   | a[<span class="hljs-number">1</span>]
   +---+
   |   | a[<span class="hljs-number">2</span>]
   +---+
    ...
   +---+
   |   | a[<span class="hljs-number">9</span>]
   +---+
</code></pre>

<p>The <em>expression</em> <code>a</code> refers to the entire array, but there's no <em>object</em> <code>a</code> separate from the array elements themselves.  Thus, <code>sizeof a</code> gives you the size (in bytes) of the entire array.  The expression <code>&amp;a</code> gives you the address of the array, <em>which is the same as the address of the first element</em>.  The difference between <code>&amp;a</code> and <code>&amp;a[0]</code> is the type of the result<sup>1</sup> - <code>char (*)[10]</code> in the first case and <code>char *</code> in the second.  </p>

<p>Where things get weird is when you want to access individual elements - the expression <code>a[i]</code> is defined as the result of <code>*(a + i)</code> - given an address value <code>a</code>, offset <code>i</code> elements (<em>not bytes</em>) from that address and dereference the result.</p>

<p>The problem is that <code>a</code> isn't a pointer or an address - it's the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as <code>a</code>, which has type <code>char [10]</code>) <em>and</em> that expression isn't the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, the type of that expression is converted ("decays") to a pointer type (<code>char *</code>), and the value of the expression is the address of the first element of the array.  Therefore, the <em>expression</em> <code>a</code> has the same type and value as the expression <code>&amp;a[0]</code> (and by extension, the expression <code>*a</code> has the same type and value as the expression <code>a[0]</code>).  </p>

<p>C was derived from an earlier language called B, and in B <code>a</code> <em>was</em> a separate pointer object from the array elements <code>a[0]</code>, <code>a[1]</code>, etc.  Ritchie wanted to keep B's array semantics, but he didn't want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.  </p>

<p>Remember that I said arrays don't store any metadata about their size.  As soon as that array expression "decays" to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There's no way to know based on the pointer itself.  </p>

<p>When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the <code>gets</code> function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.  </p>

<hr>

<ol>
<sup><li>Which *may* affect how the address value is interpreted - depends on the machine.</li></sup>
</ol>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An array declared like this</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];
</code></pre>

<p>allocates memory for 10 <code>int</code>s. You can't modify <code>a</code> but you can do pointer arithmetic with <code>a</code>.</p>

<p>A pointer like this allocates memory for just the pointer <code>p</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *p;
</code></pre>

<p>It doesn't allocate any <code>int</code>s. You can modify it:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p = a;
</code></pre>

<p>and use array subscripts as you can with a:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;
a[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;    <span class="hljs-comment">// same</span>
*(p+<span class="hljs-number">2</span>) = <span class="hljs-number">5</span>;  <span class="hljs-comment">// same effect</span>
*(a+<span class="hljs-number">2</span>) = <span class="hljs-number">5</span>;  <span class="hljs-comment">// same effect</span>
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The array name by itself yields a memory location, so you can treat the array name like a pointer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[<span class="hljs-number">7</span>];

a[<span class="hljs-number">0</span>] = <span class="hljs-number">1976</span>;
a[<span class="hljs-number">1</span>] = <span class="hljs-number">1984</span>;

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"memory location of a: %p"</span>, a);

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"value at memory location %p is %d"</span>, a, *a);
</code></pre>

<p>And other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"value at memory location %p is %d"</span>, a + <span class="hljs-number">1</span>, *(a + <span class="hljs-number">1</span>));
</code></pre>

<p>Language-wise, if C didn't expose the array as just <strong>some sort of "pointer"</strong>(pedantically it's just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"value at memory location %p is %d"</span>, &amp;a[<span class="hljs-number">1</span>], a[<span class="hljs-number">1</span>]);
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think this example sheds some light on the issue:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
        <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>};
        <span class="hljs-type">int</span> **b = &amp;a;

        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a == &amp;a: %d\n"</span>, a == b);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>It compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">a == &amp;a: <span class="hljs-number">1</span>
</code></pre>

<p>oops :-)</p>

<p>So, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the &amp; operator. But - oops - that operator does not work :-)), either way, you've been warned:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">p.c: In function main:
pp.c:<span class="hljs-number">6</span>:<span class="hljs-number">12</span>: warning: initialization from incompatible pointer type
  <span class="hljs-type">int</span> **b = &amp;a;
            ^
p.c:<span class="hljs-number">8</span>:<span class="hljs-number">28</span>: warning: comparison of distinct pointer types lacks a cast
  <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-string">"a == &amp;a: %d\n"</span>, a == b)</span>;
</code></pre>

<p>C++ refuses any such attempts with errors in compile-time.</p>

<p>Edit:</p>

<p>This is what I meant to demonstrate:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>};
    <span class="hljs-type">void</span> *c = a;

    <span class="hljs-type">void</span> *b = &amp;a;
    <span class="hljs-type">void</span> *d = &amp;c;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a == &amp;a: %d\n"</span>, a == b);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"c == &amp;c: %d\n"</span>, c == d);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Even though <code>c</code> and <code>a</code> "point" to the same memory, you can obtain address of the <code>c</code> pointer, but you cannot obtain the address of the <code>a</code> pointer.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The following example provides a concrete difference between an array name and a pointer. Let say that you want to represent a 1D line with some given maximum dimension, you could do it either with an array or a pointer:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
   <span class="hljs-type">int</span> length;
   <span class="hljs-type">int</span> line_as_array[<span class="hljs-number">1000</span>];
   <span class="hljs-type">int</span>* line_as_pointer;
} Line;
</code></pre>
<p>Now let's look at the behavior of the following code:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">
<span class="hljs-type">void</span> <span class="hljs-title function_">do_something_with_line</span><span class="hljs-params">(Line line)</span> {
   line.line_as_pointer[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
   line.line_as_array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
   Line my_line;
   my_line.length = <span class="hljs-number">20</span>;
   my_line.line_as_pointer = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">calloc</span>(my_line.length, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));

   my_line.line_as_pointer[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;
   my_line.line_as_array[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;

   do_something_with_line(my_line);

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, my_line.line_as_pointer[<span class="hljs-number">0</span>], my_line.line_as_array[<span class="hljs-number">0</span>]);
};

</code></pre>
<p>This code will output:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">0</span> <span class="hljs-number">10</span>
</code></pre>
<p>That is because in the function call to <code>do_something_with_line</code> the object was copied so:</p>
<ol>
<li>The pointer <code>line_as_pointer</code> still contains the same address it was pointing to</li>
<li>The array <code>line_as_array</code> was copied to a new address which does not outlive the scope of the function</li>
</ol>
<p>So while arrays are not given by values when you directly input them to functions, when you encapsulate them in structs they are given by value (i.e. copied) which outlines here a major difference in behavior compared to the implementation using pointers.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The array name behaves like a pointer and points to the first element of the array. Example:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a[]={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>,a);     <span class="hljs-comment">//result is similar to 0x7fff6fe40bc0</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>,&amp;a[<span class="hljs-number">0</span>]); <span class="hljs-comment">//result is similar to 0x7fff6fe40bc0</span>
</code></pre>

<p>Both the print statements will give exactly same output for a machine. In my system it gave: </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">0x7fff6fe40bc0</span>
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Array name is the address of 1st element of an array. So yes array name is a const pointer.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-does-the-java-&#x27;for-each&#x27;-loop-work-1657388423749">How does the Java &#x27;for each&#x27; loop work?</a><a href="/questions/how-to-make-a-great-r-reproducible-example-1657384198173">How to make a great R reproducible example</a><a href="/questions/sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292">SQL select only rows with max value on a column [duplicate]</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824">Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]</a><a href="/questions/how-to-make-good-reproducible-pandas-examples-1657384310402">How to make good reproducible pandas examples</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/does-python-have-a-ternary-conditional-operator-1657387555448">Does Python have a ternary conditional operator?</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/getcontactsfromfirebase()-method-return-an-empty-list-1657388433928">getContactsFromFirebase() method return an empty list</a><a href="/questions/what&#x27;s-the-simplest-way-to-print-a-java-array-1657384702397">What&#x27;s the simplest way to print a Java array?</a><a href="/questions/is-there-a-unique-android-device-id-1657388089268">Is there a unique Android device ID?</a><a href="/questions/tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410">Tkinter: AttributeError: NoneType object has no attribute &lt;attribute name&gt;</a><a href="/questions/get-selected-value-in-dropdown-list-using-javascript-1657387631638">Get selected value in dropdown list using JavaScript</a><a href="/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679">Is JavaScript a pass-by-reference or pass-by-value language?</a><a href="/questions/how-to-manage-startactivityforresult-on-android-1657387967393">How to manage startActivityForResult on Android</a><a href="/questions/javascript-property-access:-dot-notation-vs.-brackets-1657384717494">JavaScript property access: dot notation vs. brackets?</a><a href="/questions/accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754">Accessing nested JavaScript objects and arrays by string path</a><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;An array is an array and a pointer is a pointer, but in most cases array names are \u0026lt;em\u0026gt;converted\u0026lt;/em\u0026gt; to pointers. A term often used is that they \u0026lt;em\u0026gt;decay\u0026lt;/em\u0026gt; to pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is an array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; contains space for seven integers, and you can put a value in one of them with an assignment, like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; doesn\u0026apos;t contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, such as the first one:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p = \u0026amp;amp;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What can be confusing is that you can also write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p = a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; copy the contents of the array \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; into the pointer \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; (whatever that would mean). Instead, the array name \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is converted to a pointer to its first element. So that assignment does the same as the previous one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now you can use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; in a similar way to an array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The reason that this works is that the array dereferencing operator in C, \u0026lt;code\u0026gt;[ ]\u0026lt;/code\u0026gt;, is defined in terms of pointers. \u0026lt;code\u0026gt;x[y]\u0026lt;/code\u0026gt; means: start with the pointer \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, step \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, \u0026lt;code\u0026gt;x[y]\u0026lt;/code\u0026gt; can also be written as \u0026lt;code\u0026gt;*(x+y)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For this to work with a normal array, such as our \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, the name \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;a[3]\u0026lt;/code\u0026gt; must first be converted to a pointer (to the first element in \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; operator on an array. If \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; was converted to a pointer in this context, \u0026lt;code\u0026gt;sizeof a\u0026lt;/code\u0026gt; would give the size of a pointer and not of the actual array, which would be rather useless, so in that case \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; means the array itself.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When an array is used as a value, its name represents the address of the first element.\u0026lt;br\u0026gt;\nWhen an array is not used as a value its name represents the whole array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* arr used as value */\u0026lt;/span\u0026gt;\nfoo(arr);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = *(arr + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* same as arr[1] */\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* arr not used as value */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; bytes = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; arr;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *q = \u0026amp;amp;arr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* void pointers are compatible with pointers to any object */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If an expression of array type (such as the array name) appears in a larger expression and it isn\u0026apos;t the operand of either the \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; operators, then the type of the array expression is converted from \u0026quot;N-element array of T\u0026quot; to \u0026quot;pointer to T\u0026quot;, and the value of the expression is the address of the first element in the array.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In short, the array name is not a pointer, but in most contexts it is treated \u0026lt;em\u0026gt;as though\u0026lt;/em\u0026gt; it were a pointer.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Answering the question in the comment:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If I use sizeof, do i count the size of only the elements of the array? Then the array head also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When you create an array, the only space that\u0026apos;s allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what you get in memory is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;   +---+\na: |   | a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n   +---+ \n   |   | a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n   +---+\n   |   | a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]\n   +---+\n    ...\n   +---+\n   |   | a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;]\n   +---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;expression\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; refers to the entire array, but there\u0026apos;s no \u0026lt;em\u0026gt;object\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; separate from the array elements themselves.  Thus, \u0026lt;code\u0026gt;sizeof a\u0026lt;/code\u0026gt; gives you the size (in bytes) of the entire array.  The expression \u0026lt;code\u0026gt;\u0026amp;amp;a\u0026lt;/code\u0026gt; gives you the address of the array, \u0026lt;em\u0026gt;which is the same as the address of the first element\u0026lt;/em\u0026gt;.  The difference between \u0026lt;code\u0026gt;\u0026amp;amp;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;a[0]\u0026lt;/code\u0026gt; is the type of the result\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; - \u0026lt;code\u0026gt;char (*)[10]\u0026lt;/code\u0026gt; in the first case and \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; in the second.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Where things get weird is when you want to access individual elements - the expression \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; is defined as the result of \u0026lt;code\u0026gt;*(a + i)\u0026lt;/code\u0026gt; - given an address value \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, offset \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; elements (\u0026lt;em\u0026gt;not bytes\u0026lt;/em\u0026gt;) from that address and dereference the result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem is that \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; isn\u0026apos;t a pointer or an address - it\u0026apos;s the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, which has type \u0026lt;code\u0026gt;char [10]\u0026lt;/code\u0026gt;) \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; that expression isn\u0026apos;t the operand of the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; or unary \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; operators, the type of that expression is converted (\u0026quot;decays\u0026quot;) to a pointer type (\u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;), and the value of the expression is the address of the first element of the array.  Therefore, the \u0026lt;em\u0026gt;expression\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; has the same type and value as the expression \u0026lt;code\u0026gt;\u0026amp;amp;a[0]\u0026lt;/code\u0026gt; (and by extension, the expression \u0026lt;code\u0026gt;*a\u0026lt;/code\u0026gt; has the same type and value as the expression \u0026lt;code\u0026gt;a[0]\u0026lt;/code\u0026gt;).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C was derived from an earlier language called B, and in B \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;was\u0026lt;/em\u0026gt; a separate pointer object from the array elements \u0026lt;code\u0026gt;a[0]\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;a[1]\u0026lt;/code\u0026gt;, etc.  Ritchie wanted to keep B\u0026apos;s array semantics, but he didn\u0026apos;t want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Remember that I said arrays don\u0026apos;t store any metadata about their size.  As soon as that array expression \u0026quot;decays\u0026quot; to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There\u0026apos;s no way to know based on the pointer itself.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.  \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;sup\u0026gt;\u0026lt;li\u0026gt;Which *may* affect how the address value is interpreted - depends on the machine.\u0026lt;/li\u0026gt;\u0026lt;/sup\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An array declared like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates memory for 10 \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s. You can\u0026apos;t modify \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; but you can do pointer arithmetic with \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A pointer like this allocates memory for just the pointer \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t allocate any \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s. You can modify it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p = a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and use array subscripts as you can with a:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\na[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// same\u0026lt;/span\u0026gt;\n*(p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// same effect\u0026lt;/span\u0026gt;\n*(a+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// same effect\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The array name by itself yields a memory location, so you can treat the array name like a pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\na[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1976\u0026lt;/span\u0026gt;;\na[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1984\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;memory location of a: %p\u0026quot;\u0026lt;/span\u0026gt;, a);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value at memory location %p is %d\u0026quot;\u0026lt;/span\u0026gt;, a, *a);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value at memory location %p is %d\u0026quot;\u0026lt;/span\u0026gt;, a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, *(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Language-wise, if C didn\u0026apos;t expose the array as just \u0026lt;strong\u0026gt;some sort of \u0026quot;pointer\u0026quot;\u0026lt;/strong\u0026gt;(pedantically it\u0026apos;s just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value at memory location %p is %d\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think this example sheds some light on the issue:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;};\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; **b = \u0026amp;amp;a;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a == \u0026amp;amp;a: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, a == b);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;a == \u0026amp;amp;a: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;oops :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the \u0026amp;amp; operator. But - oops - that operator does not work :-)), either way, you\u0026apos;ve been warned:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;p.c: In function main:\npp.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;: warning: initialization from incompatible pointer type\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; **b = \u0026amp;amp;a;\n            ^\np.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;28\u0026lt;/span\u0026gt;: warning: comparison of distinct pointer types lacks a cast\n  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a == \u0026amp;amp;a: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, a == b)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;C++ refuses any such attempts with errors in compile-time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Edit:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is what I meant to demonstrate:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *c = a;\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *b = \u0026amp;amp;a;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *d = \u0026amp;amp;c;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a == \u0026amp;amp;a: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, a == b);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c == \u0026amp;amp;c: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, c == d);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Even though \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; \u0026quot;point\u0026quot; to the same memory, you can obtain address of the \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; pointer, but you cannot obtain the address of the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; pointer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The following example provides a concrete difference between an array name and a pointer. Let say that you want to represent a 1D line with some given maximum dimension, you could do it either with an array or a pointer:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; length;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; line_as_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;];\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* line_as_pointer;\n} Line;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now let\u0026apos;s look at the behavior of the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;do_something_with_line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Line line)\u0026lt;/span\u0026gt; {\n   line.line_as_pointer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   line.line_as_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n   Line my_line;\n   my_line.length = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n   my_line.line_as_pointer = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calloc\u0026lt;/span\u0026gt;(my_line.length, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;));\n\n   my_line.line_as_pointer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n   my_line.line_as_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\n   do_something_with_line(my_line);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, my_line.line_as_pointer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], my_line.line_as_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n};\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This code will output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That is because in the function call to \u0026lt;code\u0026gt;do_something_with_line\u0026lt;/code\u0026gt; the object was copied so:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The pointer \u0026lt;code\u0026gt;line_as_pointer\u0026lt;/code\u0026gt; still contains the same address it was pointing to\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The array \u0026lt;code\u0026gt;line_as_array\u0026lt;/code\u0026gt; was copied to a new address which does not outlive the scope of the function\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;So while arrays are not given by values when you directly input them to functions, when you encapsulate them in structs they are given by value (i.e. copied) which outlines here a major difference in behavior compared to the implementation using pointers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The array name behaves like a pointer and points to the first element of the array. Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[]={\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;,a);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//result is similar to 0x7fff6fe40bc0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;,\u0026amp;amp;a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//result is similar to 0x7fff6fe40bc0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Both the print statements will give exactly same output for a machine. In my system it gave: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fff6fe40bc0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Array name is the address of 1st element of an array. So yes array name is a const pointer.\u0026lt;/p\u0026gt;\n    "],"id":405,"title":"Is an array name a pointer?","content":"\n                \n\u0026lt;p\u0026gt;Is an array\u0026apos;s name a pointer in C?\nIf not, what is the difference between an array\u0026apos;s name and a pointer variable?\u0026lt;/p\u0026gt;\n    ","slug":"is-an-array-name-a-pointer-1657387874827","postType":"QUESTION","createdAt":"2022-07-09T17:31:14.000Z","updatedAt":"2022-07-09T17:31:14.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"How to make a great R reproducible example","slug":"how-to-make-a-great-r-reproducible-example-1657384198173"},{"title":"SQL select only rows with max value on a column [duplicate]","slug":"sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"Does Python have a ternary conditional operator?","slug":"does-python-have-a-ternary-conditional-operator-1657387555448"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"getContactsFromFirebase() method return an empty list","slug":"getcontactsfromfirebase()-method-return-an-empty-list-1657388433928"},{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"Is there a unique Android device ID?","slug":"is-there-a-unique-android-device-id-1657388089268"},{"title":"Tkinter: AttributeError: NoneType object has no attribute \u003cattribute name\u003e","slug":"tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410"},{"title":"Get selected value in dropdown list using JavaScript","slug":"get-selected-value-in-dropdown-list-using-javascript-1657387631638"},{"title":"Is JavaScript a pass-by-reference or pass-by-value language?","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"JavaScript property access: dot notation vs. brackets?","slug":"javascript-property-access:-dot-notation-vs.-brackets-1657384717494"},{"title":"Accessing nested JavaScript objects and arrays by string path","slug":"accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-an-array-name-a-pointer-1657387874827"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>