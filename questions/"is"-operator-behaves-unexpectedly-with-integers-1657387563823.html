<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>&quot;is&quot; operator behaves unexpectedly with integers | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Why does the following behave unexpectedly in Python?

&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a is b
True           # This is an expected result
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; a is b
False          # What happened here? Why is this False?
&gt;&gt;&gt; 257 is 257
True           # Yet the literal numbers compare properly


I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.

Based on the above, I can hypothesize that Python is internally implemented such that &quot;small&quot; integers are stored in a different way than larger integers and the is operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don&#x27;t know in advance whether they are numbers or not?
    "/><meta property="og:title" content="&quot;is&quot; operator behaves unexpectedly with integers | Solutions Checker"/><meta property="og:description" content="Why does the following behave unexpectedly in Python?

&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a is b
True           # This is an expected result
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; a is b
False          # What happened here? Why is this False?
&gt;&gt;&gt; 257 is 257
True           # Yet the literal numbers compare properly


I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.

Based on the above, I can hypothesize that Python is internally implemented such that &quot;small&quot; integers are stored in a different way than larger integers and the is operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don&#x27;t know in advance whether they are numbers or not?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"&quot;is&quot; operator behaves unexpectedly with integers","text":"Why does the following behave unexpectedly in Python?\n\n&gt;&gt;&gt; a = 256\n&gt;&gt;&gt; b = 256\n&gt;&gt;&gt; a is b\nTrue           # This is an expected result\n&gt;&gt;&gt; a = 257\n&gt;&gt;&gt; b = 257\n&gt;&gt;&gt; a is b\nFalse          # What happened here? Why is this False?\n&gt;&gt;&gt; 257 is 257\nTrue           # Yet the literal numbers compare properly\n\n\nI am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.\n\nBased on the above, I can hypothesize that Python is internally implemented such that &quot;small&quot; integers are stored in a different way than larger integers and the is operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don&apos;t know in advance whether they are numbers or not?\n    ","answerCount":11,"upVoteCount":500,"suggestedAnswer":[{"text":"Take a look at this:\n\n&gt;&gt;&gt; a = 256\n&gt;&gt;&gt; b = 256\n&gt;&gt;&gt; id(a)\n9987148\n&gt;&gt;&gt; id(b)\n9987148\n&gt;&gt;&gt; a = 257\n&gt;&gt;&gt; b = 257\n&gt;&gt;&gt; id(a)\n11662816\n&gt;&gt;&gt; id(b)\n11662828\n\n\nHere&apos;s what I found in the Python 2 documentation, &quot;Plain Integer Objects&quot; (It&apos;s the same for Python 3):\n\n\n  The current implementation keeps an\n  array of integer objects for all\n  integers between -5 and 256, when you\n  create an int in that range you\n  actually just get back a reference to\n  the existing object. So it should be\n  possible to change the value of 1. I\n  suspect the behaviour of Python in\n  this case is undefined. :-)\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"\n  Python&apos;s is operator behaves unexpectedly with integers?\n\n\nIn summary - let me emphasize: Do not use is to compare integers.\n\nThis isn&apos;t behavior you should have any expectations about.\n\nInstead, use == and != to compare for equality and inequality, respectively. For example:\n\n&gt;&gt;&gt; a = 1000\n&gt;&gt;&gt; a == 1000       # Test integers like this,\nTrue\n&gt;&gt;&gt; a != 5000       # or this!\nTrue\n&gt;&gt;&gt; a is 1000       # Don&apos;t do this! - Don&apos;t use `is` to test integers!!\nFalse\n\n\nExplanation\n\nTo know this, you need to know the following.\n\nFirst, what does is do? It is a comparison operator. From the documentation:\n\n\n  The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. x is not y yields the\n  inverse truth value.\n\n\nAnd so the following are equivalent. \n\n&gt;&gt;&gt; a is b\n&gt;&gt;&gt; id(a) == id(b)\n\n\nFrom the documentation:\n\n\n  id\n  Return the identity of an object. This is an integer (or long\n  integer) which is guaranteed to be unique and constant for this object\n  during its lifetime. Two objects with non-overlapping lifetimes may\n  have the same id() value.\n\n\nNote that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for id.\n\nSo what is the use-case for is?  PEP8 describes:\n\n\n  Comparisons to singletons like None should always be done with is or\n  is not, never the equality operators.\n\n\nThe Question\n\nYou ask, and state, the following question (with code):\n\n\n  Why does the following behave unexpectedly in Python?\n\n&gt;&gt;&gt; a = 256\n&gt;&gt;&gt; b = 256\n&gt;&gt;&gt; a is b\nTrue           # This is an expected result\n\n\n\nIt is not an expected result. Why is it expected? It only means that the integers valued at 256 referenced by both a and b are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail. \n\nBut perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256. \n\n\n&gt;&gt;&gt; a = 257\n&gt;&gt;&gt; b = 257\n&gt;&gt;&gt; a is b\nFalse          # What happened here? Why is this False?\n\n\n\nLooks like we now have two separate instances of integers with the value of 257 in memory. Since integers are immutable, this wastes memory. Let&apos;s hope we&apos;re not wasting a lot of it. We&apos;re probably not. But this behavior is not guaranteed.\n\n\n&gt;&gt;&gt; 257 is 257\nTrue           # Yet the literal numbers compare properly\n\n\n\nWell, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython. \n\nIt might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might. \n\nBut as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. ==.\n\nWhat is does\n\nis checks that the id of two objects are the same. In CPython, the id is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code:\n\n&gt;&gt;&gt; a is b\n\n\nis the same as\n\n&gt;&gt;&gt; id(a) == id(b)\n\n\nWhy would we want to use is then?\n\nThis can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for None, which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with is, but these are relatively rare. Here&apos;s an example (will work in Python 2 and 3) e.g.\n\nSENTINEL_SINGLETON = object() # this will only be created one time.\n\ndef foo(keyword_argument=None):\n    if keyword_argument is None:\n        print(&apos;no argument given to foo&apos;)\n    bar()\n    bar(keyword_argument)\n    bar(&apos;baz&apos;)\n\ndef bar(keyword_argument=SENTINEL_SINGLETON):\n    # SENTINEL_SINGLETON tells us if we were not passed anything\n    # as None is a legitimate potential argument we could get.\n    if keyword_argument is SENTINEL_SINGLETON:\n        print(&apos;no argument given to bar&apos;)\n    else:\n        print(&apos;argument to bar: {0}&apos;.format(keyword_argument))\n\nfoo()\n\n\nWhich prints:\n\nno argument given to foo\nno argument given to bar\nargument to bar: None\nargument to bar: baz\n\n\nAnd so we see, with is and a sentinel, we are able to differentiate between when bar is called with no arguments and when it is called with None. These are the primary use-cases for is - do not use it to test for equality of integers, strings, tuples, or other things like these.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I&apos;m late but, you want some source with your answer? I&apos;ll try and word this in an introductory manner so more folks can follow along.\n\nA good thing about CPython is that you can actually see the source for this. I&apos;m going to use links for the 3.5 release, but finding the corresponding 2.x ones is trivial.\nIn CPython, the C-API function that handles creating a new int object is PyLong_FromLong(long v). The description for this function is:\n\nThe current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)\n\n(My italics)\nDon&apos;t know about you but I see this and think: Let&apos;s find that array!\nIf you haven&apos;t fiddled with the C code implementing CPython you should; everything is pretty organized and readable. For our case, we need to look in the Objects subdirectory of the main source code directory tree.\nPyLong_FromLong deals with long objects so it shouldn&apos;t be hard to deduce that we need to peek inside longobject.c. After looking inside you might think things are chaotic; they are, but fear not, the function we&apos;re looking for is chilling at line 230 waiting for us to check it out. It&apos;s a smallish function so the main body (excluding declarations) is easily pasted here:\nPyObject *\nPyLong_FromLong(long ival)\n{\n    // omitting declarations\n\n    CHECK_SMALL_INT(ival);\n\n    if (ival &lt; 0) {\n        /* negate: cant write this as abs_ival = -ival since that\n           invokes undefined behaviour when ival is LONG_MIN */\n        abs_ival = 0U-(unsigned long)ival;\n        sign = -1;\n    }\n    else {\n        abs_ival = (unsigned long)ival;\n    }\n\n    /* Fast path for single-digit ints */\n    if (!(abs_ival &gt;&gt; PyLong_SHIFT)) {\n        v = _PyLong_New(1);\n        if (v) {\n            Py_SIZE(v) = sign;\n            v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(\n                abs_ival, unsigned long, digit);\n        }\n        return (PyObject*)v; \n}\n\nNow, we&apos;re no C master-code-haxxorz but we&apos;re also not dumb, we can see that CHECK_SMALL_INT(ival); peeking at us all seductively; we can understand it has something to do with this. Let&apos;s check it out:\n#define CHECK_SMALL_INT(ival) \\\n    do if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) { \\\n        return get_small_int((sdigit)ival); \\\n    } while(0)\n\nSo it&apos;s a macro that calls function get_small_int if the value ival satisfies the condition:\nif (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS)\n\nSo what are NSMALLNEGINTS and NSMALLPOSINTS? Macros! Here they are:\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n\nSo our condition is if (-5 &lt;= ival &amp;&amp; ival &lt; 257) call get_small_int.\nNext let&apos;s look at get_small_int in all its glory (well, we&apos;ll just look at its body because that&apos;s where the interesting things are):\nPyObject *v;\nassert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);\nv = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];\nPy_INCREF(v);\n\nOkay, declare a PyObject, assert that the previous condition holds and execute the assignment:\nv = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];\n\nsmall_ints looks a lot like that array we&apos;ve been searching for, and it is! We could&apos;ve just read the damn documentation and we would&apos;ve know all along!:\n/* Small integers are preallocated in this array so that they\n   can be shared.\n   The integers that are preallocated are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\nstatic PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\n\nSo yup, this is our guy. When you want to create a new int in the range [NSMALLNEGINTS, NSMALLPOSINTS) you&apos;ll just get back a reference to an already existing object that has been preallocated.\nSince the reference refers to the same object, issuing id() directly or checking for identity with is on it will return exactly the same thing.\nBut, when are they allocated??\nDuring initialization in _PyLong_Init Python will gladly enter in a for loop to do this for you:\nfor (ival = -NSMALLNEGINTS; ival &lt;  NSMALLPOSINTS; ival++, v++) {\n\nCheck out the source to read the loop body!\nI hope my explanation has made you C things clearly now (pun obviously intented).\n\nBut, 257 is 257? What&apos;s up?\nThis is actually easier to explain, and I have attempted to do so already; it&apos;s due to the fact that Python will execute this interactive statement as a single block:\n&gt;&gt;&gt; 257 is 257\n\nDuring complilation of this statement, CPython will see that you have two matching literals and will use the same PyLongObject representing 257. You can see this if you do the compilation yourself and examine its contents:\n&gt;&gt;&gt; codeObj = compile(&quot;257 is 257&quot;, &quot;blah!&quot;, &quot;exec&quot;)\n&gt;&gt;&gt; codeObj.co_consts\n(257, None)\n\nWhen CPython does the operation, it&apos;s now just going to load the exact same object:\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(codeObj)\n  1           0 LOAD_CONST               0 (257)   # dis\n              3 LOAD_CONST               0 (257)   # dis again\n              6 COMPARE_OP               8 (is)\n\nSo is will return True.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"It depends on whether you&apos;re looking to see if 2 things are equal, or the same object. \n\nis checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency \n\nIn [29]: a = 3\nIn [30]: b = 3\nIn [31]: id(a)\nOut[31]: 500729144\nIn [32]: id(b)\nOut[32]: 500729144\n\n\nYou should use == to compare equality of arbitrary objects. You can specify the behavior with the __eq__, and __ne__ attributes.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"As you can check in source file intobject.c, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object.\n\nIt is better to use == for that purpose.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I think your hypotheses is correct. Experiment with id (identity of object):\n\nIn [1]: id(255)\nOut[1]: 146349024\n\nIn [2]: id(255)\nOut[2]: 146349024\n\nIn [3]: id(257)\nOut[3]: 146802752\n\nIn [4]: id(257)\nOut[4]: 148993740\n\nIn [5]: a=255\n\nIn [6]: b=255\n\nIn [7]: c=257\n\nIn [8]: d=257\n\nIn [9]: id(a), id(b), id(c), id(d)\nOut[9]: (146349024, 146349024, 146783024, 146804020)\n\n\nIt appears that numbers &lt;= 255 are treated as literals and anything above is treated differently!\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It&apos;s better to think about equality. Identity is essentially an implementation detail for value objects - since they&apos;re immutable, there&apos;s no effective difference between having multiple refs to the same object or multiple objects.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"There&apos;s another issue that isn&apos;t pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never guaranteed to do this, but they all do it for more than just small ints.\n\n\n\nFor one thing, there are some other pre-created values, such as the empty tuple, str, and bytes, and some short strings (in CPython 3.6, it&apos;s the 256 single-character Latin-1 strings). For example:\n\n&gt;&gt;&gt; a = ()\n&gt;&gt;&gt; b = ()\n&gt;&gt;&gt; a is b\nTrue\n\n\n\n\nBut also, even non-pre-created values can be identical. Consider these examples:\n\n&gt;&gt;&gt; c = 257\n&gt;&gt;&gt; d = 257\n&gt;&gt;&gt; c is d\nFalse\n&gt;&gt;&gt; e, f = 258, 258\n&gt;&gt;&gt; e is f\nTrue\n\n\nAnd this isn&apos;t limited to int values:\n\n&gt;&gt;&gt; g, h = 42.23e100, 42.23e100\n&gt;&gt;&gt; g is h\nTrue\n\n\nObviously, CPython doesn&apos;t come with a pre-created float value for 42.23e100. So, what&apos;s going on here?\n\nThe CPython compiler will merge constant values of some known-immutable types like int, float, str, bytes,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since c and d are defined in separate statements, their values aren&apos;t merged. Since e and f are defined in the same statement, their values are merged.\n\n\n\nYou can see what&apos;s going on by disassembling the bytecode. Try defining a function that does e, f = 128, 128 and then calling dis.dis on it, and you&apos;ll see that there&apos;s a single constant value (128, 128)\n\n&gt;&gt;&gt; def f(): i, j = 258, 258\n&gt;&gt;&gt; dis.dis(f)\n  1           0 LOAD_CONST               2 ((128, 128))\n              2 UNPACK_SEQUENCE          2\n              4 STORE_FAST               0 (i)\n              6 STORE_FAST               1 (j)\n              8 LOAD_CONST               0 (None)\n             10 RETURN_VALUE\n&gt;&gt;&gt; f.__code__.co_consts\n(None, 128, (128, 128))\n&gt;&gt;&gt; id(f.__code__.co_consts[1], f.__code__.co_consts[2][0], f.__code__.co_consts[2][1])\n4305296480, 4305296480, 4305296480\n\n\n\n\nYou may notice that the compiler has stored 128 as a constant even though it&apos;s not actually used by the bytecode, which gives you an idea of how little optimization CPython&apos;s compiler does. Which means that (non-empty) tuples actually don&apos;t end up merged:\n\n&gt;&gt;&gt; k, l = (1, 2), (1, 2)\n&gt;&gt;&gt; k is l\nFalse\n\n\nPut that in a function, dis it, and look at the co_conststhere&apos;s a 1 and a 2, two (1, 2) tuples that share the same 1 and 2 but are not identical, and a ((1, 2), (1, 2)) tuple that has the two distinct equal tuples.\n\n\n\nThere&apos;s one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn&apos;t restricted to source code literals:\n\n&gt;&gt;&gt; m = &apos;abc&apos;\n&gt;&gt;&gt; n = &apos;abc&apos;\n&gt;&gt;&gt; m is n\nTrue\n\n\nOn the other hand, it is limited to the str type, and to strings of internal storage kind &quot;ascii compact&quot;, &quot;compact&quot;, or &quot;legacy ready&quot;, and in many cases only &quot;ascii compact&quot; will get interned.\n\n\n\nAt any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation.\n\nIt can be worth learning the rules for one specific Python for the fun of it. But it&apos;s not worth relying on them in your code. The only safe rule is:\n\n\nDo not write code that assumes two equal but separately-created immutable values are identical (don&apos;t use x is y, use x == y)\nDo not write code that assumes two equal but separately-created immutable values are distinct (don&apos;t use x is not y, use x != y)\n\n\nOr, in other words, only use is to test for the documented singletons (like None) or that are only created in one place in the code (like the _sentinel = object() idiom).\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"is is the identity equality operator (functioning like id(a) == id(b)); it&apos;s just that two equal numbers aren&apos;t necessarily the same object. For performance reasons some small integers happen to be memoized so they will tend to be the same (this can be done since they are immutable).\n\nPHP&apos;s === operator, on the other hand, is described as checking equality and type: x == y and type(x) == type(y) as per Paulo Freitas&apos; comment. This will suffice for common numbers, but differ from is for classes that define __eq__ in an absurd manner:\n\nclass Unequal:\n    def __eq__(self, other):\n        return False\n\n\nPHP apparently allows the same thing for &quot;built-in&quot; classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it&apos;s used as a number. Quite why you&apos;d want to emulate Visual Basic&apos;s Now instead of showing that it is an evaluation with time.time() I don&apos;t know.\n\nGreg Hewgill (OP) made one clarifying comment &quot;My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value.&quot;\n\nThis would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with == or is. CPython defines the number protocol, including PyNumber_Check, but this is not accessible from Python itself.\n\nWe could try to use isinstance with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class numbers.Number, but it has the same problem:\n\nimport numpy, numbers\nassert not issubclass(numpy.int16,numbers.Number)\nassert issubclass(int,numbers.Number)\n\n\nBy the way, NumPy will produce separate instances of low numbers.\n\nI don&apos;t actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call PyNumber_Check, but even that function has been debated, and it&apos;s certainly not portable. We&apos;ll just have to be less particular about what we test for now.\n\nIn the end, this issue stems from Python not originally having a type tree with predicates like Scheme&apos;s number?, or Haskell&apos;s type class Num. is checks object identity, not value equality. PHP has a colorful history as well, where === apparently behaves as is only on objects in PHP5, but not PHP4. Such are the growing pains of moving across languages (including versions of one).\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"It also happens with strings:\n\n&gt;&gt;&gt; s = b = &apos;somestr&apos;\n&gt;&gt;&gt; s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\n\n\nNow everything seems fine.\n\n&gt;&gt;&gt; s = &apos;somestr&apos;\n&gt;&gt;&gt; b = &apos;somestr&apos;\n&gt;&gt;&gt; s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\n\n\nThat&apos;s expected too.\n\n&gt;&gt;&gt; s1 = b1 = &apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a&apos;\n&gt;&gt;&gt; s1 == b1, s1 is b1, id(s1), id(b1)\n(True, True, 4555308080, 4555308080)\n\n&gt;&gt;&gt; s1 = &apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a&apos;\n&gt;&gt;&gt; b1 = &apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a&apos;\n&gt;&gt;&gt; s1 == b1, s1 is b1, id(s1), id(b1)\n(True, False, 4555308176, 4555308272)\n\n\nNow that&apos;s unexpected.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Whats New In Python 3.8: Changes in Python behavior:\n\n\n  The compiler now produces a SyntaxWarning when identity checks (is and\n  is not) are used with certain types of literals (e.g. strings, ints).\n  These can often work by accident in CPython, but are not guaranteed by\n  the language spec. The warning advises users to use equality tests (==\n  and !=) instead.\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/%22is%22-operator-behaves-unexpectedly-with-integers-1657387563823#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/%22is%22-operator-behaves-unexpectedly-with-integers-1657387563823">&quot;is&quot; operator behaves unexpectedly with integers</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/identity">identity</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/python-internals">python-internals</a></div></div><div class="question-content mt-5">
                
<p>Why does the following behave unexpectedly in Python?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">True</span>           <span class="hljs-comment"># This is an expected result</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>          <span class="hljs-comment"># What happened here? Why is this False?</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">257</span> <span class="hljs-keyword">is</span> <span class="hljs-number">257</span>
<span class="hljs-literal">True</span>           <span class="hljs-comment"># Yet the literal numbers compare properly</span>
</code></pre>

<p>I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.</p>

<p>Based on the above, I can hypothesize that Python is internally implemented such that "small" integers are stored in a different way than larger integers and the <code>is</code> operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don't know in advance whether they are numbers or not?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Take a look at this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)
<span class="hljs-number">9987148</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)
<span class="hljs-number">9987148</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)
<span class="hljs-number">11662816</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)
<span class="hljs-number">11662828</span>
</code></pre>

<p>Here's what I found in the Python 2 documentation, <a href="https://docs.python.org/2/c-api/int.html" rel="noreferrer">"Plain Integer Objects"</a> (It's the same for <a href="https://docs.python.org/3/c-api/long.html" rel="noreferrer">Python 3</a>):</p>

<blockquote>
  <p>The current implementation keeps an
  array of integer objects for all
  integers between -5 and 256, when you
  create an int in that range you
  actually just get back a reference to
  the existing object. So it should be
  possible to change the value of 1. I
  suspect the behaviour of Python in
  this case is undefined. :-)</p>
</blockquote>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <h1>Python's is operator behaves unexpectedly with integers?</h1>
</blockquote>

<p>In summary - let me emphasize: <strong><em>Do not use <code>is</code> to compare integers.</em></strong></p>

<p>This isn't behavior you should have any expectations about.</p>

<p>Instead, use <code>==</code> and <code>!=</code> to compare for equality and inequality, respectively. For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1000</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a == <span class="hljs-number">1000</span>       <span class="hljs-comment"># Test integers like this,</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a != <span class="hljs-number">5000</span>       <span class="hljs-comment"># or this!</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> <span class="hljs-number">1000</span>       <span class="hljs-comment"># Don't do this! - Don't use `is` to test integers!!</span>
<span class="hljs-literal">False</span>
</code></pre>

<h2>Explanation</h2>

<p>To know this, you need to know the following.</p>

<p>First, what does <code>is</code> do? It is a comparison operator. From the <a href="https://docs.python.org/2/reference/expressions.html#not-in" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p>The operators <code>is</code> and <code>is not</code> test for object identity: <code>x is y</code> is true
  if and only if x and y are the same object. <code>x is not y</code> yields the
  inverse truth value.</p>
</blockquote>

<p>And so the following are equivalent. </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(b)
</code></pre>

<p>From the <a href="https://docs.python.org/library/functions.html#id" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p><strong><code>id</code></strong>
  Return the identity of an object. This is an integer (or long
  integer) which is guaranteed to be unique and constant for this object
  during its lifetime. Two objects with non-overlapping lifetimes may
  have the same <code>id()</code> value.</p>
</blockquote>

<p>Note that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for <code>id</code>.</p>

<p>So what is the use-case for <code>is</code>?  <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">PEP8 describes</a>:</p>

<blockquote>
  <p>Comparisons to singletons like <code>None</code> should always be done with <code>is</code> or
  <code>is not</code>, never the equality operators.</p>
</blockquote>

<h2>The Question</h2>

<p>You ask, and state, the following question (with code):</p>

<blockquote>
  <p><strong>Why does the following behave unexpectedly in Python?</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">256</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">True</span>           <span class="hljs-comment"># This is an expected result</span>
</code></pre>
</blockquote>

<p>It is <em>not</em> an expected result. Why is it expected? It only means that the integers valued at <code>256</code> referenced by both <code>a</code> and <code>b</code> are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail. </p>

<p>But perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256. </p>

<blockquote>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>          <span class="hljs-comment"># What happened here? Why is this False?</span>
</code></pre>
</blockquote>

<p>Looks like we now have two separate instances of integers with the value of <code>257</code> in memory. Since integers are immutable, this wastes memory. Let's hope we're not wasting a lot of it. We're probably not. But this behavior is not guaranteed.</p>

<blockquote>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">257</span> <span class="hljs-keyword">is</span> <span class="hljs-number">257</span>
<span class="hljs-literal">True</span>           <span class="hljs-comment"># Yet the literal numbers compare properly</span>
</code></pre>
</blockquote>

<p>Well, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython. </p>

<p>It might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might. </p>

<p>But as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. <code>==</code>.</p>

<h2>What <code>is</code> does</h2>

<p><code>is</code> checks that the <code>id</code> of two objects are the same. In CPython, the <code>id</code> is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
</code></pre>

<p>is the same as</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(b)
</code></pre>

<h2>Why would we want to use <code>is</code> then?</h2>

<p>This can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for <code>None</code>, which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with <code>is</code>, but these are relatively rare. Here's an example (will work in Python 2 and 3) e.g.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">SENTINEL_SINGLETON = <span class="hljs-built_in">object</span>() <span class="hljs-comment"># this will only be created one time.</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">keyword_argument=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> keyword_argument <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'no argument given to foo'</span>)
    bar()
    bar(keyword_argument)
    bar(<span class="hljs-string">'baz'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">keyword_argument=SENTINEL_SINGLETON</span>):
    <span class="hljs-comment"># SENTINEL_SINGLETON tells us if we were not passed anything</span>
    <span class="hljs-comment"># as None is a legitimate potential argument we could get.</span>
    <span class="hljs-keyword">if</span> keyword_argument <span class="hljs-keyword">is</span> SENTINEL_SINGLETON:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'no argument given to bar'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'argument to bar: {0}'</span>.<span class="hljs-built_in">format</span>(keyword_argument))

foo()
</code></pre>

<p>Which prints:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">no argument given to foo
no argument given to bar
argument to bar: <span class="hljs-literal">None</span>
argument to bar: baz
</code></pre>

<p>And so we see, with <code>is</code> and a sentinel, we are able to differentiate between when <code>bar</code> is called with no arguments and when it is called with <code>None</code>. These are the primary use-cases for <code>is</code> - do <em>not</em> use it to test for equality of integers, strings, tuples, or other things like these.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">

<p><em>I'm late but, you want some source with your answer?</em> I'll try and word this in an introductory manner so more folks can follow along.</p>
<hr>
<p>A good thing about CPython is that you can actually see the source for this. I'm going to use links for the <strong>3.5</strong> release, but finding the corresponding <strong>2.x</strong> ones is trivial.</p>
<p>In CPython, the <strong>C-API</strong> function that handles creating a new <code>int</code> object is <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="noreferrer"><code>PyLong_FromLong(long v)</code></a>. The description for this function is:</p>
<blockquote>
<p><em>The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object</em>. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)</p>
</blockquote>
<p>(My italics)</p>
<p>Don't know about you but I see this and think: <em>Let's find that array!</em></p>
<p>If you haven't fiddled with the C code implementing CPython <em>you should</em>; everything is pretty organized and readable. For our case, we need to look in the <a href="https://hg.python.org/cpython/file/d489394a73de/Objects/" rel="noreferrer"><code>Objects</code> subdirectory</a> of the <a href="https://hg.python.org/cpython/file/tip" rel="noreferrer">main source code directory tree</a>.</p>
<p><code>PyLong_FromLong</code> deals with <code>long</code> objects so it shouldn't be hard to deduce that we need to peek inside <a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c" rel="noreferrer"><code>longobject.c</code></a>. After looking inside you might think things are chaotic; they are, but fear not, the function we're looking for is chilling at <a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l230" rel="noreferrer">line 230</a> waiting for us to check it out. It's a smallish function so the main body (excluding declarations) is easily pasted here:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">PyObject *
<span class="hljs-title function_">PyLong_FromLong</span><span class="hljs-params">(<span class="hljs-type">long</span> ival)</span>
{
    <span class="hljs-comment">// omitting declarations</span>

    CHECK_SMALL_INT(ival);

    <span class="hljs-keyword">if</span> (ival &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/* negate: cant write this as abs_ival = -ival since that
           invokes undefined behaviour when ival is LONG_MIN */</span>
        abs_ival = <span class="hljs-number">0U</span>-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ival;
        sign = <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">else</span> {
        abs_ival = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ival;
    }

    <span class="hljs-comment">/* Fast path for single-digit ints */</span>
    <span class="hljs-keyword">if</span> (!(abs_ival &gt;&gt; PyLong_SHIFT)) {
        v = _PyLong_New(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (v) {
            Py_SIZE(v) = sign;
            v-&gt;ob_digit[<span class="hljs-number">0</span>] = Py_SAFE_DOWNCAST(
                abs_ival, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, digit);
        }
        <span class="hljs-keyword">return</span> (PyObject*)v; 
}
</code></pre>
<p>Now, we're no C <em>master-code-haxxorz</em> but we're also not dumb, we can see that <code>CHECK_SMALL_INT(ival);</code> peeking at us all seductively; we can understand it has something to do with this. <a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l51" rel="noreferrer">Let's check it out:</a></p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK_SMALL_INT(ival) \
    do <span class="hljs-keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) { \
        return get_small_int((sdigit)ival); \
    } while(0)</span>
</code></pre>
<p>So it's a macro that calls function <code>get_small_int</code> if the value <code>ival</code> satisfies the condition:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS)
</code></pre>
<p>So what are <code>NSMALLNEGINTS</code> and <code>NSMALLPOSINTS</code>? Macros! <em><a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l12" rel="noreferrer">Here they are</a></em>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NSMALLPOSINTS</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLPOSINTS           257</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NSMALLNEGINTS</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLNEGINTS           5</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>So our condition is <code>if (-5 &lt;= ival &amp;&amp; ival &lt; 257)</code> call <code>get_small_int</code>.</p>
<p>Next let's look at <a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l37" rel="noreferrer"><code>get_small_int</code> in all its glory</a> (well, we'll just look at its body because that's where the interesting things are):</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">PyObject *v;
assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);
v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];
Py_INCREF(v);
</code></pre>
<p>Okay, declare a <code>PyObject</code>, assert that the previous condition holds and execute the assignment:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];
</code></pre>
<p><code>small_ints</code> looks a lot like that array we've been searching for, and it is! <em><a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l25" rel="noreferrer">We could've just read the damn documentation and we would've know all along!</a></em>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* Small integers are preallocated in this array so that they
   can be shared.
   The integers that are preallocated are those in the range
   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).
*/</span>
<span class="hljs-type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
</code></pre>
<p>So yup, this is our guy. When you want to create a new <code>int</code> in the range <code>[NSMALLNEGINTS, NSMALLPOSINTS)</code> you'll just get back a reference to an already existing object that has been preallocated.</p>
<p>Since the reference refers to the same object, issuing <code>id()</code> directly or checking for identity with <code>is</code> on it will return exactly the same thing.</p>
<h3>But, when are they allocated??</h3>
<p><a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l5343" rel="noreferrer">During initialization in <code>_PyLong_Init</code></a> Python will gladly enter in a for loop to do this for you:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">for</span> (ival = -NSMALLNEGINTS; ival &lt;  NSMALLPOSINTS; ival++, v++) {
</code></pre>
<p>Check out the source to read the loop body!</p>
<p>I hope my explanation has made you <em>C</em> things clearly now (pun obviously intented).</p>
<hr>
<h3>But, <code>257 is 257</code>? What's up?</h3>
<p>This is actually easier to explain, <a href="https://stackoverflow.com/questions/34147515/is-operator-returns-different-results-on-integers">and I have attempted to do so already</a>; it's due to the fact that Python will execute this interactive statement as a single block:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">&gt;&gt;&gt; <span class="hljs-number">257</span> is <span class="hljs-number">257</span>
</code></pre>
<p>During complilation of this statement, CPython will see that you have two matching literals and will use the same <code>PyLongObject</code> representing <code>257</code>. You can see this if you do the compilation yourself and examine its contents:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">&gt;&gt;&gt; codeObj = compile(<span class="hljs-string">"257 is 257"</span>, <span class="hljs-string">"blah!"</span>, <span class="hljs-string">"exec"</span>)
&gt;&gt;&gt; codeObj.co_consts
(<span class="hljs-number">257</span>, None)
</code></pre>
<p>When CPython does the operation, it's now just going to load the exact same object:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(codeObj)
  <span class="hljs-number">1</span>           <span class="hljs-number">0</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-number">257</span>)   <span class="hljs-meta"># dis</span>
              <span class="hljs-number">3</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-number">257</span>)   <span class="hljs-meta"># dis again</span>
              <span class="hljs-number">6</span> COMPARE_OP               <span class="hljs-number">8</span> (is)
</code></pre>
<p>So <code>is</code> will return <code>True</code>.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It depends on whether you're looking to see if 2 things are equal, or the same object. </p>

<p><code>is</code> checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency </p>

<pre class="lang-py s-code-block"><code class="hljs language-python">In [<span class="hljs-number">29</span>]: a = <span class="hljs-number">3</span>
In [<span class="hljs-number">30</span>]: b = <span class="hljs-number">3</span>
In [<span class="hljs-number">31</span>]: <span class="hljs-built_in">id</span>(a)
Out[<span class="hljs-number">31</span>]: <span class="hljs-number">500729144</span>
In [<span class="hljs-number">32</span>]: <span class="hljs-built_in">id</span>(b)
Out[<span class="hljs-number">32</span>]: <span class="hljs-number">500729144</span>
</code></pre>

<p>You should use <code>==</code> to compare equality of arbitrary objects. You can specify the behavior with the <code>__eq__</code>, and <code>__ne__</code> attributes.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As you can check in <a href="http://svn.python.org/projects/python/trunk/Objects/intobject.c" rel="noreferrer">source file <em>intobject.c</em></a>, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object.</p>

<p>It is better to use <code>==</code> for that purpose.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think your hypotheses is correct. Experiment with <code>id</code> (identity of object):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">In [<span class="hljs-number">1</span>]: <span class="hljs-built_in">id</span>(<span class="hljs-number">255</span>)
Out[<span class="hljs-number">1</span>]: <span class="hljs-number">146349024</span>

In [<span class="hljs-number">2</span>]: <span class="hljs-built_in">id</span>(<span class="hljs-number">255</span>)
Out[<span class="hljs-number">2</span>]: <span class="hljs-number">146349024</span>

In [<span class="hljs-number">3</span>]: <span class="hljs-built_in">id</span>(<span class="hljs-number">257</span>)
Out[<span class="hljs-number">3</span>]: <span class="hljs-number">146802752</span>

In [<span class="hljs-number">4</span>]: <span class="hljs-built_in">id</span>(<span class="hljs-number">257</span>)
Out[<span class="hljs-number">4</span>]: <span class="hljs-number">148993740</span>

In [<span class="hljs-number">5</span>]: a=<span class="hljs-number">255</span>

In [<span class="hljs-number">6</span>]: b=<span class="hljs-number">255</span>

In [<span class="hljs-number">7</span>]: c=<span class="hljs-number">257</span>

In [<span class="hljs-number">8</span>]: d=<span class="hljs-number">257</span>

In [<span class="hljs-number">9</span>]: <span class="hljs-built_in">id</span>(a), <span class="hljs-built_in">id</span>(b), <span class="hljs-built_in">id</span>(c), <span class="hljs-built_in">id</span>(d)
Out[<span class="hljs-number">9</span>]: (<span class="hljs-number">146349024</span>, <span class="hljs-number">146349024</span>, <span class="hljs-number">146783024</span>, <span class="hljs-number">146804020</span>)
</code></pre>

<p>It appears that numbers <code>&lt;= 255</code> are treated as literals and anything above is treated differently!</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It's better to think about equality. Identity is essentially an implementation detail for value objects - since they're immutable, there's no effective difference between having multiple refs to the same object or multiple objects.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There's another issue that isn't pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never <em>guaranteed</em> to do this, but they all do it for more than just small ints.</p>

<hr>

<p>For one thing, there are some other pre-created values, such as the empty <code>tuple</code>, <code>str</code>, and <code>bytes</code>, and some short strings (in CPython 3.6, it's the 256 single-character Latin-1 strings). For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = ()
<span class="hljs-meta">&gt;&gt;&gt; </span>b = ()
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">True</span>
</code></pre>

<hr>

<p>But also, even non-pre-created values can be identical. Consider these examples:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-number">257</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c <span class="hljs-keyword">is</span> d
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e, f = <span class="hljs-number">258</span>, <span class="hljs-number">258</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e <span class="hljs-keyword">is</span> f
<span class="hljs-literal">True</span>
</code></pre>

<p>And this isn't limited to <code>int</code> values:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>g, h = <span class="hljs-number">42.23e100</span>, <span class="hljs-number">42.23e100</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>g <span class="hljs-keyword">is</span> h
<span class="hljs-literal">True</span>
</code></pre>

<p>Obviously, CPython doesn't come with a pre-created <code>float</code> value for <code>42.23e100</code>. So, what's going on here?</p>

<p>The CPython compiler will merge constant values of some known-immutable types like <code>int</code>, <code>float</code>, <code>str</code>, <code>bytes</code>,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since <code>c</code> and <code>d</code> are defined in separate statements, their values aren't merged. Since <code>e</code> and <code>f</code> are defined in the same statement, their values are merged.</p>

<hr>

<p>You can see what's going on by disassembling the bytecode. Try defining a function that does <code>e, f = 128, 128</code> and then calling <code>dis.dis</code> on it, and you'll see that there's a single constant value <code>(128, 128)</code></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(): i, j = <span class="hljs-number">258</span>, <span class="hljs-number">258</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>dis.dis(f)
  <span class="hljs-number">1</span>           <span class="hljs-number">0</span> LOAD_CONST               <span class="hljs-number">2</span> ((<span class="hljs-number">128</span>, <span class="hljs-number">128</span>))
              <span class="hljs-number">2</span> UNPACK_SEQUENCE          <span class="hljs-number">2</span>
              <span class="hljs-number">4</span> STORE_FAST               <span class="hljs-number">0</span> (i)
              <span class="hljs-number">6</span> STORE_FAST               <span class="hljs-number">1</span> (j)
              <span class="hljs-number">8</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)
             <span class="hljs-number">10</span> RETURN_VALUE
<span class="hljs-meta">&gt;&gt;&gt; </span>f.__code__.co_consts
(<span class="hljs-literal">None</span>, <span class="hljs-number">128</span>, (<span class="hljs-number">128</span>, <span class="hljs-number">128</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(f.__code__.co_consts[<span class="hljs-number">1</span>], f.__code__.co_consts[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], f.__code__.co_consts[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])
<span class="hljs-number">4305296480</span>, <span class="hljs-number">4305296480</span>, <span class="hljs-number">4305296480</span>
</code></pre>

<hr>

<p>You may notice that the compiler has stored <code>128</code> as a constant even though it's not actually used by the bytecode, which gives you an idea of how little optimization CPython's compiler does. Which means that (non-empty) tuples actually don't end up merged:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>k, l = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>k <span class="hljs-keyword">is</span> l
<span class="hljs-literal">False</span>
</code></pre>

<p>Put that in a function, <code>dis</code> it, and look at the <code>co_consts</code>there's a <code>1</code> and a <code>2</code>, two <code>(1, 2)</code> tuples that share the same <code>1</code> and <code>2</code> but are not identical, and a <code>((1, 2), (1, 2))</code> tuple that has the two distinct equal tuples.</p>

<hr>

<p>There's one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn't restricted to source code literals:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>m = <span class="hljs-string">'abc'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>n = <span class="hljs-string">'abc'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>m <span class="hljs-keyword">is</span> n
<span class="hljs-literal">True</span>
</code></pre>

<p>On the other hand, it is limited to the <code>str</code> type, and to strings of <a href="https://github.com/python/cpython/blob/master/Include/unicodeobject.h#L197" rel="noreferrer">internal storage kind "ascii compact", "compact", or "legacy ready"</a>, and in many cases only "ascii compact" will get interned.</p>

<hr>

<p>At any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation.</p>

<p>It can be worth learning the rules for one specific Python for the fun of it. But it's not worth relying on them in your code. The only safe rule is:</p>

<ul>
<li>Do not write code that assumes two equal but separately-created immutable values are identical (don't use <code>x is y</code>, use <code>x == y</code>)</li>
<li>Do not write code that assumes two equal but separately-created immutable values are distinct (don't use <code>x is not y</code>, use <code>x != y</code>)</li>
</ul>

<p>Or, in other words, only use <code>is</code> to test for the documented singletons (like <code>None</code>) or that are only created in one place in the code (like the <code>_sentinel = object()</code> idiom).</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>is</code> <em>is</em> the identity equality operator (functioning like <code>id(a) == id(b)</code>); it's just that two equal numbers aren't necessarily the same object. For performance reasons some small integers happen to be <a href="http://en.wikipedia.org/wiki/Memoization" rel="nofollow">memoized</a> so they will tend to be the same (this can be done since they are immutable).</p>

<p><a href="http://en.wikipedia.org/wiki/PHP" rel="nofollow">PHP's</a> <code>===</code> operator, on the other hand, is described as checking equality and type: <code>x == y and type(x) == type(y)</code> as per Paulo Freitas' comment. This will suffice for common numbers, but differ from <code>is</code> for classes that define <code>__eq__</code> in an absurd manner:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Unequal</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>

<p>PHP apparently allows the same thing for "built-in" classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it's used as a number. Quite why you'd want to emulate Visual Basic's <code>Now</code> instead of showing that it is an evaluation with <code>time.time()</code> I don't know.</p>

<p>Greg Hewgill (OP) made one clarifying comment "My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value."</p>

<p>This would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with <code>==</code> or <code>is</code>. <a href="http://en.wikipedia.org/wiki/CPython" rel="nofollow">CPython</a> defines the <a href="http://docs.python.org/2/c-api/number.html" rel="nofollow">number protocol</a>, including PyNumber_Check, but this is not accessible from Python itself.</p>

<p>We could try to use <code>isinstance</code> with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class <a href="https://docs.python.org/2/library/numbers.html#numbers.Number" rel="nofollow"><code>numbers.Number</code></a>, but it has the same problem:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> numpy, numbers
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">issubclass</span>(numpy.int16,numbers.Number)
<span class="hljs-keyword">assert</span> <span class="hljs-built_in">issubclass</span>(<span class="hljs-built_in">int</span>,numbers.Number)
</code></pre>

<p>By the way, <a href="http://en.wikipedia.org/wiki/NumPy" rel="nofollow">NumPy</a> will produce separate instances of low numbers.</p>

<p>I don't actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call <code>PyNumber_Check</code>, but even that function <a href="http://mail.python.org/pipermail/python-dev/2002-November/030237.html" rel="nofollow">has been debated</a>, and it's certainly not portable. We'll just have to be less particular about what we test for now.</p>

<p>In the end, this issue stems from Python not originally having a type tree with predicates like <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29" rel="nofollow">Scheme's</a> <code>number?</code>, or <a href="http://en.wikipedia.org/wiki/Haskell_%28programming_language%29" rel="nofollow">Haskell's</a> <a href="https://en.wikipedia.org/wiki/Type_class" rel="nofollow">type class</a> <a href="http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/base-4.5.1.0/Prelude.html#t:Num" rel="nofollow">Num</a>. <code>is</code> checks object identity, not value equality. PHP has a colorful history as well, where <code>===</code> apparently behaves as <code>is</code> only on objects <a href="http://www.php.net/manual/en/language.operators.comparison.php" rel="nofollow">in PHP5, but not PHP4</a>. Such are the growing pains of moving across languages (including versions of one).</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It also happens with strings:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = b = <span class="hljs-string">'somestr'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s == b, s <span class="hljs-keyword">is</span> b, <span class="hljs-built_in">id</span>(s), <span class="hljs-built_in">id</span>(b)
(<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4555519392</span>, <span class="hljs-number">4555519392</span>)
</code></pre>

<p>Now everything seems fine.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'somestr'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">'somestr'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s == b, s <span class="hljs-keyword">is</span> b, <span class="hljs-built_in">id</span>(s), <span class="hljs-built_in">id</span>(b)
(<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4555519392</span>, <span class="hljs-number">4555519392</span>)
</code></pre>

<p>That's expected too.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = b1 = <span class="hljs-string">'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s1 == b1, s1 <span class="hljs-keyword">is</span> b1, <span class="hljs-built_in">id</span>(s1), <span class="hljs-built_in">id</span>(b1)
(<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4555308080</span>, <span class="hljs-number">4555308080</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b1 = <span class="hljs-string">'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s1 == b1, s1 <span class="hljs-keyword">is</span> b1, <span class="hljs-built_in">id</span>(s1), <span class="hljs-built_in">id</span>(b1)
(<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-number">4555308176</span>, <span class="hljs-number">4555308272</span>)
</code></pre>

<p>Now that's unexpected.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior" rel="nofollow noreferrer">Whats New In Python 3.8: Changes in Python behavior</a>:</p>

<blockquote>
  <p>The compiler now produces a <a href="https://docs.python.org/3.8/library/exceptions.html#SyntaxWarning" rel="nofollow noreferrer">SyntaxWarning</a> when identity checks (<code>is</code> and
  <code>is not</code>) are used with certain types of literals (e.g. strings, ints).
  These can often work by accident in CPython, but are not guaranteed by
  the language spec. The warning advises users to use equality tests (<code>==</code>
  and <code>!=</code>) instead.</p>
</blockquote>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Take a look at this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9987148\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9987148\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11662816\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11662828\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s what I found in the Python 2 documentation, \u0026lt;a href=\u0026quot;https://docs.python.org/2/c-api/int.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;Plain Integer Objects\u0026quot;\u0026lt;/a\u0026gt; (It\u0026apos;s the same for \u0026lt;a href=\u0026quot;https://docs.python.org/3/c-api/long.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Python 3\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The current implementation keeps an\n  array of integer objects for all\n  integers between -5 and 256, when you\n  create an int in that range you\n  actually just get back a reference to\n  the existing object. So it should be\n  possible to change the value of 1. I\n  suspect the behaviour of Python in\n  this case is undefined. :-)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h1\u0026gt;Python\u0026apos;s is operator behaves unexpectedly with integers?\u0026lt;/h1\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In summary - let me emphasize: \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Do not use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to compare integers.\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This isn\u0026apos;t behavior you should have any expectations about.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead, use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt; to compare for equality and inequality, respectively. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Test integers like this,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5000\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# or this!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Don\u0026apos;t do this! - Don\u0026apos;t use `is` to test integers!!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Explanation\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;To know this, you need to know the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First, what does \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; do? It is a comparison operator. From the \u0026lt;a href=\u0026quot;https://docs.python.org/2/reference/expressions.html#not-in\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The operators \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is not\u0026lt;/code\u0026gt; test for object identity: \u0026lt;code\u0026gt;x is y\u0026lt;/code\u0026gt; is true\n  if and only if x and y are the same object. \u0026lt;code\u0026gt;x is not y\u0026lt;/code\u0026gt; yields the\n  inverse truth value.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And so the following are equivalent. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://docs.python.org/library/functions.html#id\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\n  Return the identity of an object. This is an integer (or long\n  integer) which is guaranteed to be unique and constant for this object\n  during its lifetime. Two objects with non-overlapping lifetimes may\n  have the same \u0026lt;code\u0026gt;id()\u0026lt;/code\u0026gt; value.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So what is the use-case for \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;?  \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP8 describes\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Comparisons to singletons like \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; should always be done with \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; or\n  \u0026lt;code\u0026gt;is not\u0026lt;/code\u0026gt;, never the equality operators.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;The Question\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;You ask, and state, the following question (with code):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Why does the following behave unexpectedly in Python?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This is an expected result\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; an expected result. Why is it expected? It only means that the integers valued at \u0026lt;code\u0026gt;256\u0026lt;/code\u0026gt; referenced by both \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256. \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# What happened here? Why is this False?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Looks like we now have two separate instances of integers with the value of \u0026lt;code\u0026gt;257\u0026lt;/code\u0026gt; in memory. Since integers are immutable, this wastes memory. Let\u0026apos;s hope we\u0026apos;re not wasting a lot of it. We\u0026apos;re probably not. But this behavior is not guaranteed.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Yet the literal numbers compare properly\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Well, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;What \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; does\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks that the \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt; of two objects are the same. In CPython, the \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt; is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Why would we want to use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; then?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;, which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;, but these are relatively rare. Here\u0026apos;s an example (will work in Python 2 and 3) e.g.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;SENTINEL_SINGLETON = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# this will only be created one time.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;keyword_argument=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; keyword_argument \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;no argument given to foo\u0026apos;\u0026lt;/span\u0026gt;)\n    bar()\n    bar(keyword_argument)\n    bar(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;baz\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;keyword_argument=SENTINEL_SINGLETON\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# SENTINEL_SINGLETON tells us if we were not passed anything\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# as None is a legitimate potential argument we could get.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; keyword_argument \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; SENTINEL_SINGLETON:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;no argument given to bar\u0026apos;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;argument to bar: {0}\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(keyword_argument))\n\nfoo()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which prints:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;no argument given to foo\nno argument given to bar\nargument to bar: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\nargument to bar: baz\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And so we see, with \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and a sentinel, we are able to differentiate between when \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is called with no arguments and when it is called with \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;. These are the primary use-cases for \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; - do \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; use it to test for equality of integers, strings, tuples, or other things like these.\u0026lt;/p\u0026gt;\n    ","\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;I\u0026apos;m late but, you want some source with your answer?\u0026lt;/em\u0026gt; I\u0026apos;ll try and word this in an introductory manner so more folks can follow along.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;A good thing about CPython is that you can actually see the source for this. I\u0026apos;m going to use links for the \u0026lt;strong\u0026gt;3.5\u0026lt;/strong\u0026gt; release, but finding the corresponding \u0026lt;strong\u0026gt;2.x\u0026lt;/strong\u0026gt; ones is trivial.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In CPython, the \u0026lt;strong\u0026gt;C-API\u0026lt;/strong\u0026gt; function that handles creating a new \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; object is \u0026lt;a href=\u0026quot;https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;PyLong_FromLong(long v)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. The description for this function is:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object\u0026lt;/em\u0026gt;. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;(My italics)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Don\u0026apos;t know about you but I see this and think: \u0026lt;em\u0026gt;Let\u0026apos;s find that array!\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you haven\u0026apos;t fiddled with the C code implementing CPython \u0026lt;em\u0026gt;you should\u0026lt;/em\u0026gt;; everything is pretty organized and readable. For our case, we need to look in the \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/d489394a73de/Objects/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Objects\u0026lt;/code\u0026gt; subdirectory\u0026lt;/a\u0026gt; of the \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;main source code directory tree\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;PyLong_FromLong\u0026lt;/code\u0026gt; deals with \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; objects so it shouldn\u0026apos;t be hard to deduce that we need to peek inside \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;longobject.c\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. After looking inside you might think things are chaotic; they are, but fear not, the function we\u0026apos;re looking for is chilling at \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l230\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;line 230\u0026lt;/a\u0026gt; waiting for us to check it out. It\u0026apos;s a smallish function so the main body (excluding declarations) is easily pasted here:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;PyObject *\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;PyLong_FromLong\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; ival)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// omitting declarations\u0026lt;/span\u0026gt;\n\n    CHECK_SMALL_INT(ival);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ival \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* negate: cant write this as abs_ival = -ival since that\n           invokes undefined behaviour when ival is LONG_MIN */\u0026lt;/span\u0026gt;\n        abs_ival = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0U\u0026lt;/span\u0026gt;-(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)ival;\n        sign = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n        abs_ival = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)ival;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Fast path for single-digit ints */\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!(abs_ival \u0026amp;gt;\u0026amp;gt; PyLong_SHIFT)) {\n        v = _PyLong_New(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v) {\n            Py_SIZE(v) = sign;\n            v-\u0026amp;gt;ob_digit[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = Py_SAFE_DOWNCAST(\n                abs_ival, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;, digit);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (PyObject*)v; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, we\u0026apos;re no C \u0026lt;em\u0026gt;master-code-haxxorz\u0026lt;/em\u0026gt; but we\u0026apos;re also not dumb, we can see that \u0026lt;code\u0026gt;CHECK_SMALL_INT(ival);\u0026lt;/code\u0026gt; peeking at us all seductively; we can understand it has something to do with this. \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l51\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Let\u0026apos;s check it out:\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CHECK_SMALL_INT(ival) \\\n    do \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (-NSMALLNEGINTS \u0026amp;lt;= ival \u0026amp;amp;\u0026amp;amp; ival \u0026amp;lt; NSMALLPOSINTS) { \\\n        return get_small_int((sdigit)ival); \\\n    } while(0)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So it\u0026apos;s a macro that calls function \u0026lt;code\u0026gt;get_small_int\u0026lt;/code\u0026gt; if the value \u0026lt;code\u0026gt;ival\u0026lt;/code\u0026gt; satisfies the condition:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (-NSMALLNEGINTS \u0026amp;lt;= ival \u0026amp;amp;\u0026amp;amp; ival \u0026amp;lt; NSMALLPOSINTS)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So what are \u0026lt;code\u0026gt;NSMALLNEGINTS\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;NSMALLPOSINTS\u0026lt;/code\u0026gt;? Macros! \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l12\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Here they are\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; NSMALLPOSINTS\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NSMALLPOSINTS           257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; NSMALLNEGINTS\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NSMALLNEGINTS           5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So our condition is \u0026lt;code\u0026gt;if (-5 \u0026amp;lt;= ival \u0026amp;amp;\u0026amp;amp; ival \u0026amp;lt; 257)\u0026lt;/code\u0026gt; call \u0026lt;code\u0026gt;get_small_int\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Next let\u0026apos;s look at \u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l37\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;get_small_int\u0026lt;/code\u0026gt; in all its glory\u0026lt;/a\u0026gt; (well, we\u0026apos;ll just look at its body because that\u0026apos;s where the interesting things are):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;PyObject *v;\nassert(-NSMALLNEGINTS \u0026amp;lt;= ival \u0026amp;amp;\u0026amp;amp; ival \u0026amp;lt; NSMALLPOSINTS);\nv = (PyObject *)\u0026amp;amp;small_ints[ival + NSMALLNEGINTS];\nPy_INCREF(v);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Okay, declare a \u0026lt;code\u0026gt;PyObject\u0026lt;/code\u0026gt;, assert that the previous condition holds and execute the assignment:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;v = (PyObject *)\u0026amp;amp;small_ints[ival + NSMALLNEGINTS];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;small_ints\u0026lt;/code\u0026gt; looks a lot like that array we\u0026apos;ve been searching for, and it is! \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l25\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;We could\u0026apos;ve just read the damn documentation and we would\u0026apos;ve know all along!\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Small integers are preallocated in this array so that they\n   can be shared.\n   The integers that are preallocated are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So yup, this is our guy. When you want to create a new \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; in the range \u0026lt;code\u0026gt;[NSMALLNEGINTS, NSMALLPOSINTS)\u0026lt;/code\u0026gt; you\u0026apos;ll just get back a reference to an already existing object that has been preallocated.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since the reference refers to the same object, issuing \u0026lt;code\u0026gt;id()\u0026lt;/code\u0026gt; directly or checking for identity with \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; on it will return exactly the same thing.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;But, when are they allocated??\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://hg.python.org/cpython/file/tip/Objects/longobject.c#l5343\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;During initialization in \u0026lt;code\u0026gt;_PyLong_Init\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; Python will gladly enter in a for loop to do this for you:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (ival = -NSMALLNEGINTS; ival \u0026amp;lt;  NSMALLPOSINTS; ival++, v++) {\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Check out the source to read the loop body!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I hope my explanation has made you \u0026lt;em\u0026gt;C\u0026lt;/em\u0026gt; things clearly now (pun obviously intented).\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;But, \u0026lt;code\u0026gt;257 is 257\u0026lt;/code\u0026gt;? What\u0026apos;s up?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This is actually easier to explain, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/34147515/is-operator-returns-different-results-on-integers\u0026quot;\u0026gt;and I have attempted to do so already\u0026lt;/a\u0026gt;; it\u0026apos;s due to the fact that Python will execute this interactive statement as a single block:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt; is \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;During complilation of this statement, CPython will see that you have two matching literals and will use the same \u0026lt;code\u0026gt;PyLongObject\u0026lt;/code\u0026gt; representing \u0026lt;code\u0026gt;257\u0026lt;/code\u0026gt;. You can see this if you do the compilation yourself and examine its contents:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; codeObj = compile(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;257 is 257\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;blah!\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;exec\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; codeObj.co_consts\n(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;, None)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When CPython does the operation, it\u0026apos;s now just going to load the exact same object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; import dis\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; dis.dis(codeObj)\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# dis\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# dis again\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt; COMPARE_OP               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; (is)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; will return \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It depends on whether you\u0026apos;re looking to see if 2 things are equal, or the same object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;In [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;29\u0026lt;/span\u0026gt;]: a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;]: b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500729144\u0026lt;/span\u0026gt;\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500729144\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You should use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; to compare equality of arbitrary objects. You can specify the behavior with the \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;__ne__\u0026lt;/code\u0026gt; attributes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As you can check in \u0026lt;a href=\u0026quot;http://svn.python.org/projects/python/trunk/Objects/intobject.c\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;source file \u0026lt;em\u0026gt;intobject.c\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is better to use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; for that purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think your hypotheses is correct. Experiment with \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt; (identity of object):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;In [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146349024\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146349024\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146802752\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;148993740\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]: a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;]: b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;]: c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]: d=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(c), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(d)\nOut[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;]: (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146349024\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146349024\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146783024\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;146804020\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It appears that numbers \u0026lt;code\u0026gt;\u0026amp;lt;= 255\u0026lt;/code\u0026gt; are treated as literals and anything above is treated differently!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It\u0026apos;s better to think about equality. Identity is essentially an implementation detail for value objects - since they\u0026apos;re immutable, there\u0026apos;s no effective difference between having multiple refs to the same object or multiple objects.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There\u0026apos;s another issue that isn\u0026apos;t pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never \u0026lt;em\u0026gt;guaranteed\u0026lt;/em\u0026gt; to do this, but they all do it for more than just small ints.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For one thing, there are some other pre-created values, such as the empty \u0026lt;code\u0026gt;tuple\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;bytes\u0026lt;/code\u0026gt;, and some short strings (in CPython 3.6, it\u0026apos;s the 256 single-character Latin-1 strings). For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = ()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = ()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;But also, even non-pre-created values can be identical. Consider these examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;d = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; d\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;e, f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;258\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;258\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;e \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; f\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And this isn\u0026apos;t limited to \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; values:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;g, h = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42.23e100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42.23e100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;g \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; h\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, CPython doesn\u0026apos;t come with a pre-created \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; value for \u0026lt;code\u0026gt;42.23e100\u0026lt;/code\u0026gt;. So, what\u0026apos;s going on here?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The CPython compiler will merge constant values of some known-immutable types like \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;bytes\u0026lt;/code\u0026gt;,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; are defined in separate statements, their values aren\u0026apos;t merged. Since \u0026lt;code\u0026gt;e\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; are defined in the same statement, their values are merged.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You can see what\u0026apos;s going on by disassembling the bytecode. Try defining a function that does \u0026lt;code\u0026gt;e, f = 128, 128\u0026lt;/code\u0026gt; and then calling \u0026lt;code\u0026gt;dis.dis\u0026lt;/code\u0026gt; on it, and you\u0026apos;ll see that there\u0026apos;s a single constant value \u0026lt;code\u0026gt;(128, 128)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(): i, j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;258\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;258\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;dis.dis(f)\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;128\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;128\u0026lt;/span\u0026gt;))\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; UNPACK_SEQUENCE          \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; STORE_FAST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (i)\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt; STORE_FAST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; (j)\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n             \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; RETURN_VALUE\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;f.__code__.co_consts\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;128\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;128\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;128\u0026lt;/span\u0026gt;))\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(f.__code__.co_consts[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], f.__code__.co_consts[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], f.__code__.co_consts[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4305296480\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4305296480\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4305296480\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You may notice that the compiler has stored \u0026lt;code\u0026gt;128\u0026lt;/code\u0026gt; as a constant even though it\u0026apos;s not actually used by the bytecode, which gives you an idea of how little optimization CPython\u0026apos;s compiler does. Which means that (non-empty) tuples actually don\u0026apos;t end up merged:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;k, l = (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; l\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Put that in a function, \u0026lt;code\u0026gt;dis\u0026lt;/code\u0026gt; it, and look at the \u0026lt;code\u0026gt;co_consts\u0026lt;/code\u0026gt;there\u0026apos;s a \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt;, two \u0026lt;code\u0026gt;(1, 2)\u0026lt;/code\u0026gt; tuples that share the same \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; but are not identical, and a \u0026lt;code\u0026gt;((1, 2), (1, 2))\u0026lt;/code\u0026gt; tuple that has the two distinct equal tuples.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn\u0026apos;t restricted to source code literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;m = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;abc\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;n = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;abc\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;m \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; n\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, it is limited to the \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; type, and to strings of \u0026lt;a href=\u0026quot;https://github.com/python/cpython/blob/master/Include/unicodeobject.h#L197\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;internal storage kind \u0026quot;ascii compact\u0026quot;, \u0026quot;compact\u0026quot;, or \u0026quot;legacy ready\u0026quot;\u0026lt;/a\u0026gt;, and in many cases only \u0026quot;ascii compact\u0026quot; will get interned.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;At any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It can be worth learning the rules for one specific Python for the fun of it. But it\u0026apos;s not worth relying on them in your code. The only safe rule is:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Do not write code that assumes two equal but separately-created immutable values are identical (don\u0026apos;t use \u0026lt;code\u0026gt;x is y\u0026lt;/code\u0026gt;, use \u0026lt;code\u0026gt;x == y\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Do not write code that assumes two equal but separately-created immutable values are distinct (don\u0026apos;t use \u0026lt;code\u0026gt;x is not y\u0026lt;/code\u0026gt;, use \u0026lt;code\u0026gt;x != y\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Or, in other words, only use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to test for the documented singletons (like \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;) or that are only created in one place in the code (like the \u0026lt;code\u0026gt;_sentinel = object()\u0026lt;/code\u0026gt; idiom).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; the identity equality operator (functioning like \u0026lt;code\u0026gt;id(a) == id(b)\u0026lt;/code\u0026gt;); it\u0026apos;s just that two equal numbers aren\u0026apos;t necessarily the same object. For performance reasons some small integers happen to be \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Memoization\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;memoized\u0026lt;/a\u0026gt; so they will tend to be the same (this can be done since they are immutable).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/PHP\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;PHP\u0026apos;s\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator, on the other hand, is described as checking equality and type: \u0026lt;code\u0026gt;x == y and type(x) == type(y)\u0026lt;/code\u0026gt; as per Paulo Freitas\u0026apos; comment. This will suffice for common numbers, but differ from \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; for classes that define \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; in an absurd manner:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Unequal\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__eq__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, other\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;PHP apparently allows the same thing for \u0026quot;built-in\u0026quot; classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it\u0026apos;s used as a number. Quite why you\u0026apos;d want to emulate Visual Basic\u0026apos;s \u0026lt;code\u0026gt;Now\u0026lt;/code\u0026gt; instead of showing that it is an evaluation with \u0026lt;code\u0026gt;time.time()\u0026lt;/code\u0026gt; I don\u0026apos;t know.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Greg Hewgill (OP) made one clarifying comment \u0026quot;My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;. \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/CPython\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;CPython\u0026lt;/a\u0026gt; defines the \u0026lt;a href=\u0026quot;http://docs.python.org/2/c-api/number.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;number protocol\u0026lt;/a\u0026gt;, including PyNumber_Check, but this is not accessible from Python itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We could try to use \u0026lt;code\u0026gt;isinstance\u0026lt;/code\u0026gt; with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/numbers.html#numbers.Number\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;\u0026lt;code\u0026gt;numbers.Number\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, but it has the same problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; numpy, numbers\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;issubclass\u0026lt;/span\u0026gt;(numpy.int16,numbers.Number)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;issubclass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,numbers.Number)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;By the way, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/NumPy\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;NumPy\u0026lt;/a\u0026gt; will produce separate instances of low numbers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I don\u0026apos;t actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call \u0026lt;code\u0026gt;PyNumber_Check\u0026lt;/code\u0026gt;, but even that function \u0026lt;a href=\u0026quot;http://mail.python.org/pipermail/python-dev/2002-November/030237.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;has been debated\u0026lt;/a\u0026gt;, and it\u0026apos;s certainly not portable. We\u0026apos;ll just have to be less particular about what we test for now.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the end, this issue stems from Python not originally having a type tree with predicates like \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Scheme\u0026apos;s\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;number?\u0026lt;/code\u0026gt;, or \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Haskell\u0026apos;s\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Type_class\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;type class\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/base-4.5.1.0/Prelude.html#t:Num\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Num\u0026lt;/a\u0026gt;. \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks object identity, not value equality. PHP has a colorful history as well, where \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; apparently behaves as \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; only on objects \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/language.operators.comparison.php\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;in PHP5, but not PHP4\u0026lt;/a\u0026gt;. Such are the growing pains of moving across languages (including versions of one).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It also happens with strings:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s = b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestr\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s == b, s \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(s), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555519392\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555519392\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now everything seems fine.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestr\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestr\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s == b, s \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(s), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555519392\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555519392\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s expected too.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s1 = b1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s1 == b1, s1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b1, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(s1), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b1)\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555308080\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555308080\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;s1 == b1, s1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b1, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(s1), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b1)\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555308176\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4555308272\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now that\u0026apos;s unexpected.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Whats New In Python 3.8: Changes in Python behavior\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The compiler now produces a \u0026lt;a href=\u0026quot;https://docs.python.org/3.8/library/exceptions.html#SyntaxWarning\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SyntaxWarning\u0026lt;/a\u0026gt; when identity checks (\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and\n  \u0026lt;code\u0026gt;is not\u0026lt;/code\u0026gt;) are used with certain types of literals (e.g. strings, ints).\n  These can often work by accident in CPython, but are not guaranteed by\n  the language spec. The warning advises users to use equality tests (\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;\n  and \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt;) instead.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"id":305,"title":"\"is\" operator behaves unexpectedly with integers","content":"\n                \n\u0026lt;p\u0026gt;Why does the following behave unexpectedly in Python?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This is an expected result\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# What happened here? Why is this False?\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Yet the literal numbers compare properly\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Based on the above, I can hypothesize that Python is internally implemented such that \u0026quot;small\u0026quot; integers are stored in a different way than larger integers and the \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don\u0026apos;t know in advance whether they are numbers or not?\u0026lt;/p\u0026gt;\n    ","slug":"\"is\"-operator-behaves-unexpectedly-with-integers-1657387563823","postType":"QUESTION","createdAt":"2022-07-09T17:26:03.000Z","updatedAt":"2022-07-09T17:26:03.000Z","tags":[{"id":1818,"name":"identity","slug":"identity","createdAt":"2022-07-09T17:26:03.000Z","updatedAt":"2022-07-09T17:26:03.000Z","Questions_Tags":{"questionId":305,"tagId":1818}},{"id":1819,"name":"python-internals","slug":"python-internals","createdAt":"2022-07-09T17:26:03.000Z","updatedAt":"2022-07-09T17:26:03.000Z","Questions_Tags":{"questionId":305,"tagId":1819}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"\"is\"-operator-behaves-unexpectedly-with-integers-1657387563823"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>