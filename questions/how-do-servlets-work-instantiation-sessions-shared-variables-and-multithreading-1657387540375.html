<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-bf26e92d2540e305.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_buildManifest.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreading-1657387540375#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreading-1657387540375">How do servlets work? Instantiation, sessions, shared variables and multithreading</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/multithreading">multithreading</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/session-variables">session-variables</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/instance-variables">instance-variables</a></div></div><div class="question-content mt-5">
                
<p>Suppose, I have a webserver which holds numerous servlets. For information passing among those servlets I am setting session and instance variables.</p>

<p>Now, if 2 or more users send request to this server then what happens to the session variables?<br>
Will they all be common for all the users or they will be different for each user?<br>
If they are different, then how was the server able to differentiate between different users?</p>

<p>One more similar question, if there are <code>n</code> users accessing a particular servlet, then this servlet gets instantiated only the first time the first user accessed it or does it get instantiated for all the users separately?<br>
In other words, what happens to the instance variables?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><code>ServletContext</code></h2>
<p>When the servlet container (like <a href="http://tomcat.apache.org" rel="noreferrer">Apache Tomcat</a>) starts up, it will deploy and load all its web applications. When a web application is loaded, the servlet container creates the <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContext.html" rel="noreferrer"><code>ServletContext</code></a> once and keeps it in the server's memory. The web app's <code>web.xml</code> and all of included <code>web-fragment.xml</code> files is parsed, and each <code>&lt;servlet&gt;</code>, <code>&lt;filter&gt;</code> and <code>&lt;listener&gt;</code> found (or each class annotated with <code>@WebServlet</code>, <code>@WebFilter</code> and <code>@WebListener</code> respectively) will be instantiated once and be kept in the server's memory as well, registred via the <code>ServletContext</code>. For each instantiated filter, its <code>init()</code> method is invoked with a new <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/FilterConfig.html" rel="noreferrer"><code>FilterConfig</code></a> argument which in turn contains the involved <code>ServletContext</code>.</p>
<p>When a <code>Servlet</code> has a <code>&lt;servlet&gt;&lt;load-on-startup&gt;</code> or <code>@WebServlet(loadOnStartup)</code> value greater than <code>0</code>, then its <code>init()</code> method is also invoked during startup with a new <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletConfig.html" rel="noreferrer"><code>ServletConfig</code></a> argument which in turn contains the involved <code>ServletContext</code>. Those servlets are initialized in the same order specified by that value (<code>1</code> is 1st, <code>2</code> is 2nd, etc). If the same value is specified for more than one servlet, then each of those servlets is loaded in the same order as they appear in the <code>web.xml</code>, <code>web-fragment.xml</code>, or <code>@WebServlet</code> classloading. In the event the "load-on-startup" value is absent, the <code>init()</code> method will be invoked whenever the <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_message" rel="noreferrer">HTTP request</a> hits that servlet for the very first time.</p>
<p>When the servlet container is finished with all of the above described initialization steps, then the <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html#contextInitialized-javax.servlet.ServletContextEvent-" rel="noreferrer"><code>ServletContextListener#contextInitialized()</code></a> will be invoked with a <code>ServletContextEvent</code> argument which in turn contains the involved <code>ServletContext</code>. This will allow the developer the opportunity to programmatically register yet another <code>Servlet</code>, <code>Filter</code> or <code>Listener</code>.</p>
<p>When the servlet container shuts down, it unloads all web applications, invokes the <code>destroy()</code> method of all its initialized servlets and filters, and all <code>Servlet</code>, <code>Filter</code> and <code>Listener</code> instances registered via the <code>ServletContext</code> are trashed. Finally the <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html#contextDestroyed-javax.servlet.ServletContextEvent-" rel="noreferrer"><code>ServletContextListener#contextDestroyed()</code></a> will be invoked and the <code>ServletContext</code> itself will be trashed.</p>
<h2><code>HttpServletRequest</code> and <code>HttpServletResponse</code></h2>
<p>The servlet container is attached to a web server that listens for HTTP requests on a certain port number (port 8080 is usually used during development and port 80 in production). When a client (e.g. user with a web browser, or <a href="https://stackoverflow.com/questions/2793150/how-to-use-java-net-urlconnection-to-fire-and-handle-http-requests">programmatically using <code>URLConnection</code></a>) sends an HTTP request, the servlet container creates new <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html" rel="noreferrer"><code>HttpServletRequest</code></a> and <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html" rel="noreferrer"><code>HttpServletResponse</code></a> objects and passes them through any defined <code>Filter</code> in the chain and, eventually, the <code>Servlet</code> instance.</p>
<p>In the case of <a href="https://stackoverflow.com/tags/servlet-filters/info">filters</a>, the <code>doFilter()</code> method is invoked. When the servlet container's code calls <code>chain.doFilter(request, response)</code>, the request and response continue on to the next filter, or hit the servlet if there are no remaining filters.</p>
<p>In the case of <a href="https://stackoverflow.com/tags/servlets/info">servlets</a>, the <code>service()</code> method is invoked. By default, this method determines which one of the <code>doXxx()</code> methods to invoke based off of  <code>request.getMethod()</code>. If the determined method is absent from the servlet, then an HTTP 405 error is returned in the response.</p>
<p>The request object provides access to all of the information about the HTTP request, such as its <a href="https://en.wikipedia.org/wiki/URL" rel="noreferrer">URL</a>, <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" rel="noreferrer">headers</a>, <a href="https://en.wikipedia.org/wiki/Query_string" rel="noreferrer">query string</a> and body. The response object provides the ability to control and send the HTTP response the way you want by, for instance, allowing you to set the headers and the body (usually with generated HTML content from a JSP file). When the HTTP response is committed and finished, both the request and response objects are recycled and made available for reuse.</p>
<h2><code>HttpSession</code></h2>
<p>When a client visits the webapp for the first time and/or the <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpSession.html" rel="noreferrer"><code>HttpSession</code></a> is obtained for the first time via <code>request.getSession()</code>, the servlet container creates a new <code>HttpSession</code> object, generates a long and unique ID (which you can get by <code>session.getId()</code>), and stores it in the server's memory. The servlet container also sets a <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/Cookie.html" rel="noreferrer"><code>Cookie</code></a> in the <code>Set-Cookie</code> header of the HTTP response with <code>JSESSIONID</code> as its name and the unique session ID as its value.</p>
<p>As per the <a href="http://www.faqs.org/rfcs/rfc2965.html" rel="noreferrer">HTTP cookie specification</a> (a contract any decent web browser and web server must adhere to), the client (the web browser) is required to send this <a href="https://en.wikipedia.org/wiki/HTTP_cookie" rel="noreferrer">cookie</a> back in subsequent requests in the <code>Cookie</code> header for as long as the cookie is valid (i.e. the unique ID must refer to an unexpired session and the domain and path are correct). Using your browser's built-in HTTP traffic monitor, you can verify that the cookie is valid (press F12 in Chrome / Firefox 23+ / IE9+, and check the <em>Net/Network</em> tab). The servlet container will check the <code>Cookie</code> header of every incoming HTTP request for the presence of the cookie with the name <code>JSESSIONID</code> and use its value (the session ID) to get the associated <code>HttpSession</code> from server's memory.</p>
<p>The <code>HttpSession</code> stays alive until it has been idle (i.e. not used in a request) for more than the timeout value specified in <code>&lt;session-timeout&gt;</code>, a setting in <code>web.xml</code>. The timeout value defaults to 30 minutes. So, when the client doesn't visit the web app for longer than the time specified, the servlet container trashes the <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session" rel="noreferrer">session</a>. Every subsequent request, even with the cookie specified, will not have access to the same session anymore; the servlet container will create a new session.</p>
<p>On the client side, the session cookie stays alive for as long as the browser instance is running. So, if the client closes the browser instance (all tabs/windows), then the session is trashed on the client's side. In a new browser instance, the cookie associated with the session wouldn't exist, so it would no longer be sent. This causes an entirely new <code>HttpSession</code> to be created, with an entirely new session cookie being used.</p>
<h2>In a nutshell</h2>
<ul>
<li>The <code>ServletContext</code> lives for as long as the web app lives. It is shared among <em>all</em> requests in <em>all</em> sessions.</li>
<li>The <code>HttpSession</code> lives for as long as the client is interacting with the web app with the same browser instance, and the session hasn't timed out at the server side. It is shared among <em>all</em> requests in the <em>same</em> session.</li>
<li>The <code>HttpServletRequest</code> and <code>HttpServletResponse</code> live from the time the servlet receives an HTTP request from the client, until the complete response (the web page) has arrived. It is <em>not</em> shared elsewhere.</li>
<li>All <code>Servlet</code>, <code>Filter</code> and <code>Listener</code> instances live as long as the web app lives. They are shared among <em>all</em> requests in <em>all</em> sessions.</li>
<li>Any <code>attribute</code> that is defined in <code>ServletContext</code>, <code>HttpServletRequest</code> and <code>HttpSession</code> will live as long as the object in question lives. The object itself represents the "scope" in bean management frameworks such as JSF, CDI, Spring, etc. Those frameworks store their scoped beans as an <code>attribute</code> of its closest matching scope.</li>
</ul>
<h2>Thread Safety</h2>
<p>That said, your major concern is possibly <a href="https://en.wikipedia.org/wiki/Thread_safety" rel="noreferrer"><em>thread safety</em></a>. You should now know that servlets and filters are shared among all requests. That's the nice thing about Java, it's multithreaded and different threads (read: HTTP requests) can make use of the same instance. It would otherwise be too expensive to recreate, <code>init()</code> and <code>destroy()</code> them for every single request.</p>
<p>You should also realize that you should <strong>never</strong> assign any request or session scoped data as an <em>instance</em> variable of a servlet or filter. It will be shared among all other requests in other sessions. That's <strong>not</strong> thread-safe! The below example illustrates this:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> {

    <span class="hljs-keyword">private</span> Object thisIsNOTThreadSafe;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException {
        Object thisIsThreadSafe;

        thisIsNOTThreadSafe = request.getParameter(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// BAD!! Shared among all requests!</span>
        thisIsThreadSafe = request.getParameter(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// OK, this is thread safe.</span>
    } 
}
</code></pre>
<h3>See also:</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2095397/what-is-the-difference-between-jsf-servlet-and-jsp">What is the difference between JSF, Servlet and JSP?</a></li>
<li><a href="https://stackoverflow.com/questions/1700390/best-option-for-session-management-in-java">Best option for Session management in Java</a></li>
<li><a href="https://stackoverflow.com/questions/4140448/difference-between-and-in-servlet-mapping-url-pattern">Difference between / and /* in servlet mapping url pattern</a></li>
<li><a href="https://stackoverflow.com/questions/2349633/doget-and-dopost-in-servlets">doGet and doPost in Servlets</a></li>
<li><a href="https://stackoverflow.com/questions/8011138/servlet-seems-to-handle-multiple-concurrent-requests-synchronously/">Servlet seems to handle multiple concurrent browser requests synchronously</a></li>
<li><a href="https://stackoverflow.com/questions/9555842/why-servlets-are-not-thread-safe/">Why Servlets are not thread Safe?</a></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Sessions</h2>

<p><img src="https://i.stack.imgur.com/ABDSX.png" alt="enter image description here">
<img src="https://i.stack.imgur.com/IWAF3.png" alt="enter image description here"></p>

<p>In short: the web server issues a unique identifier to <em>each visitor</em> on his <em>first</em> visit. The visitor must bring back that ID for him to be recognised next time around. This identifier also allows the server to properly segregate objects owned by one session against that of another.</p>

<h2>Servlet Instantiation</h2>

<p>If <strong>load-on-startup</strong> is <strong>false</strong>:</p>

<p><img src="https://i.stack.imgur.com/Jjvcb.png" alt="enter image description here">
<img src="https://i.stack.imgur.com/7Bw3x.png" alt="enter image description here"></p>

<p>If <strong>load-on-startup</strong> is <strong>true</strong>:</p>

<p><img src="https://i.stack.imgur.com/t33bd.png" alt="enter image description here">
<img src="https://i.stack.imgur.com/e7BB7.png" alt="enter image description here"></p>

<p>Once he's on the service mode and on the groove, the <em>same</em> servlet will work on the requests from all other clients. </p>

<p><img src="https://i.stack.imgur.com/gqoR4.png" alt="enter image description here"></p>

<p>Why isn't it a good idea to have one instance per client? Think about this: Will you hire one pizza guy for every order that came? Do that and you'd be out of business in no time.</p>

<p>It comes with a small risk though. Remember: this single guy holds all the order information in his pocket: so if you're not cautious about <a href="http://tutorials.jenkov.com/java-servlets/servlet-concurrency.html" rel="noreferrer">thread safety on servlets</a>, he may end up giving the wrong order to a certain client.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Session in Java servlets is the same as session in other languages such as PHP.  It is unique to the user.  The server can keep track of it in different ways such as cookies, url rewriting etc.  This <a href="http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/HttpSession.html" rel="noreferrer">Java doc</a> article explains it in the context of Java servlets and indicates that exactly how session is maintained is an implementation detail left to the designers of the server.  The specification only stipulates that it must be maintained as unique to a user across multiple connections to the server.  Check out <a href="http://download.oracle.com/docs/cd/A97336_01/buslog.102/a83726/tecbkgn2.htm" rel="noreferrer">this article from Oracle</a> for more information about both of your questions.</p>

<p><strong>Edit</strong> There is an excellent tutorial <a href="http://www.apl.jhu.edu/~hall/java/Servlet-Tutorial/Servlet-Tutorial-Session-Tracking.html" rel="noreferrer">here</a> on how to work with session inside of servlets. And <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnafd.html" rel="noreferrer">here</a> is a chapter from Sun about Java Servlets, what they are and how to use them.  Between those two articles, you should be able to answer all of your questions.  </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When the servlet container (like Apache Tomcat) starts up, it will read from the web.xml file (only one per application) if anything goes wrong or shows up an error at container side console, otherwise, it will deploy and load all web applications by using web.xml (so named it as deployment descriptor).</p>
<p>During instantiation phase of the servlet, servlet instance is ready but it cannot serve the client request because it is missing with two pieces of information:<br>
1: context information<br>
2: initial configuration information</p>
<p>Servlet engine creates servletConfig interface object encapsulating the above missing information into it
servlet engine calls init() of the servlet by supplying servletConfig object references as an argument. Once init() is completely executed servlet is ready to serve the client request.</p>
<h3>Q) In the lifetime of servlet how many times instantiation and initialization happens ??</h3>
<p>A)only once (for every client request a new thread is created)
only one instance of the servlet serves any number of the client request ie, after serving one client request server does not die. It waits for other client requests ie what CGI (for every client request a new process is created) limitation is overcome with the servlet (internally servlet engine creates the thread).</p>
<h3>Q)How session concept works?</h3>
<p>A)whenever getSession() is called on HttpServletRequest object</p>
<p><strong>Step 1</strong>: request object is evaluated for incoming session ID.</p>
<p><strong>Step 2</strong>: if ID not available a brand new HttpSession object is created and its corresponding session ID is generated (ie of HashTable) session ID is stored into httpservlet response object and the reference of HttpSession object is returned to the servlet (doGet/doPost).</p>
<p><strong>Step 3</strong>: if ID available brand new session object is not created session ID is picked up from the request object search is made in the collection of sessions by using session ID as the key.</p>
<p>Once the search is successful session ID is stored into HttpServletResponse and the existing session object references are returned to the doGet() or doPost() of UserDefineservlet.</p>
<h3>Note:</h3>
<p>1)when control leaves from servlet code to client don't forget that session object is being held by servlet container ie, the servlet engine</p>
<p>2)multithreading is left to servlet developers people for implementing ie., handle the multiple requests of client nothing to bother about multithread code</p>
<h3>Inshort form:</h3>
<p>A servlet is created when the application starts (it is deployed on the servlet container) or when it is first accessed (depending on the load-on-startup setting)
when the servlet is instantiated, the init() method of the servlet is called
then the servlet (its one and only instance) handles all requests (its service() method being called by multiple threads). That's why it is not advisable to have any synchronization in it, and you should avoid instance variables of the servlet
when the application is undeployed (the servlet container stops), the destroy() method is called.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Sessions</strong> - what Chris Thompson said.</p>

<p><strong>Instantiation</strong> - a servlet is instantiated when the container receives the first request mapped to the servlet (unless the servlet is configured to load on startup with the <code>&lt;load-on-startup&gt;</code> element in <code>web.xml</code>). The same instance is used to serve subsequent requests.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The Servlet Specification <strong>JSR-315</strong> clearly defines the web container behavior in the service (and doGet, doPost, doPut etc.) methods (2.3.3.1 Multithreading Issues, Page 9):</p>

<blockquote>
  <p>A servlet container may send concurrent requests through the service
  method of the servlet. To handle the requests, the Servlet Developer
  must make adequate provisions for concurrent processing with multiple
  threads in the service method.</p>
  
  <p>Although it is not recommended, an alternative for the Developer is to
  implement the SingleThreadModel interface which requires the container
  to guarantee that there is only one request thread at a time in the
  service method. A servlet container may satisfy this requirement by
  serializing requests on a servlet, or by maintaining a pool of servlet
  instances. If the servlet is part of a Web application that has been
  marked as distributable, the container may maintain a pool of servlet
  instances in each JVM that the application is distributed across.</p>
  
  <p>For servlets not implementing the SingleThreadModel interface, if the
  service method (or methods such as doGet or doPost which are
  dispatched to the service method of the HttpServlet abstract class)
  has been defined with the synchronized keyword, the servlet container
  cannot use the instance pool approach, but must serialize requests
  through it. It is strongly recommended that Developers not synchronize
  the service method (or methods dispatched to it) in these
  circumstances because of detrimental effects on performance</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>No.</strong> Servlets are <strong>not Thread safe</strong></p>

<p>This is allows accessing more than one threads at a time</p>

<p><strong>if u want to make it Servlet as Thread safe ., U can go for</strong></p>

<p><code>Implement SingleThreadInterface(i)</code> 
which is a blank Interface there is no</p>

<p>methods</p>

<p>or we can go for synchronize methods</p>

<p>we can make whole service method as synchronized by using synchronized</p>

<p>keyword in front of method</p>

<p><strong>Example::</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> Synchronized <span class="hljs-keyword">class</span> <span class="hljs-title class_">service</span>(ServletRequest request,ServletResponse response)<span class="hljs-keyword">throws</span> ServletException,IOException
</code></pre>

<p>or we can the put block of the code in the Synchronized block</p>

<p><strong>Example::</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Synchronized(Object)

{

----Instructions-----

}
</code></pre>

<p>I feel that Synchronized block is better than making the whole method</p>

<p>Synchronized</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As is clear from above explanations, by implementing the <b>SingleThreadModel</b>, a servlet can be assured thread-safety by the servlet container. The container implementation can do this in 2 ways:</p>

<p>1) Serializing requests (queuing) to a single instance - this is similar to a servlet NOT implementing SingleThreadModel BUT synchronizing the service/ doXXX methods; OR</p>

<p>2) Creating a pool of instances - which's a better option and a trade-off between the boot-up/initialization effort/time of the servlet as against the restrictive parameters (memory/ CPU time) of the environment hosting the servlet.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When the servlet container (like \u0026lt;a href=\u0026quot;http://tomcat.apache.org\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Apache Tomcat\u0026lt;/a\u0026gt;) starts up, it will deploy and load all its web applications. When a web application is loaded, the servlet container creates the \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContext.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; once and keeps it in the server\u0026apos;s memory. The web app\u0026apos;s \u0026lt;code\u0026gt;web.xml\u0026lt;/code\u0026gt; and all of included \u0026lt;code\u0026gt;web-fragment.xml\u0026lt;/code\u0026gt; files is parsed, and each \u0026lt;code\u0026gt;\u0026amp;lt;servlet\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;filter\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;listener\u0026amp;gt;\u0026lt;/code\u0026gt; found (or each class annotated with \u0026lt;code\u0026gt;@WebServlet\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;@WebFilter\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;@WebListener\u0026lt;/code\u0026gt; respectively) will be instantiated once and be kept in the server\u0026apos;s memory as well, registred via the \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;. For each instantiated filter, its \u0026lt;code\u0026gt;init()\u0026lt;/code\u0026gt; method is invoked with a new \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/FilterConfig.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;FilterConfig\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; argument which in turn contains the involved \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When a \u0026lt;code\u0026gt;Servlet\u0026lt;/code\u0026gt; has a \u0026lt;code\u0026gt;\u0026amp;lt;servlet\u0026amp;gt;\u0026amp;lt;load-on-startup\u0026amp;gt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;@WebServlet(loadOnStartup)\u0026lt;/code\u0026gt; value greater than \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;, then its \u0026lt;code\u0026gt;init()\u0026lt;/code\u0026gt; method is also invoked during startup with a new \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletConfig.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ServletConfig\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; argument which in turn contains the involved \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;. Those servlets are initialized in the same order specified by that value (\u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; is 1st, \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; is 2nd, etc). If the same value is specified for more than one servlet, then each of those servlets is loaded in the same order as they appear in the \u0026lt;code\u0026gt;web.xml\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;web-fragment.xml\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;@WebServlet\u0026lt;/code\u0026gt; classloading. In the event the \u0026quot;load-on-startup\u0026quot; value is absent, the \u0026lt;code\u0026gt;init()\u0026lt;/code\u0026gt; method will be invoked whenever the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_message\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTTP request\u0026lt;/a\u0026gt; hits that servlet for the very first time.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When the servlet container is finished with all of the above described initialization steps, then the \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html#contextInitialized-javax.servlet.ServletContextEvent-\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ServletContextListener#contextInitialized()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; will be invoked with a \u0026lt;code\u0026gt;ServletContextEvent\u0026lt;/code\u0026gt; argument which in turn contains the involved \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;. This will allow the developer the opportunity to programmatically register yet another \u0026lt;code\u0026gt;Servlet\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Filter\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;Listener\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When the servlet container shuts down, it unloads all web applications, invokes the \u0026lt;code\u0026gt;destroy()\u0026lt;/code\u0026gt; method of all its initialized servlets and filters, and all \u0026lt;code\u0026gt;Servlet\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Filter\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Listener\u0026lt;/code\u0026gt; instances registered via the \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt; are trashed. Finally the \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html#contextDestroyed-javax.servlet.ServletContextEvent-\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ServletContextListener#contextDestroyed()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; will be invoked and the \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt; itself will be trashed.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;HttpServletRequest\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;HttpServletResponse\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The servlet container is attached to a web server that listens for HTTP requests on a certain port number (port 8080 is usually used during development and port 80 in production). When a client (e.g. user with a web browser, or \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2793150/how-to-use-java-net-urlconnection-to-fire-and-handle-http-requests\u0026quot;\u0026gt;programmatically using \u0026lt;code\u0026gt;URLConnection\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;) sends an HTTP request, the servlet container creates new \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;HttpServletRequest\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;HttpServletResponse\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; objects and passes them through any defined \u0026lt;code\u0026gt;Filter\u0026lt;/code\u0026gt; in the chain and, eventually, the \u0026lt;code\u0026gt;Servlet\u0026lt;/code\u0026gt; instance.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;a href=\u0026quot;https://stackoverflow.com/tags/servlet-filters/info\u0026quot;\u0026gt;filters\u0026lt;/a\u0026gt;, the \u0026lt;code\u0026gt;doFilter()\u0026lt;/code\u0026gt; method is invoked. When the servlet container\u0026apos;s code calls \u0026lt;code\u0026gt;chain.doFilter(request, response)\u0026lt;/code\u0026gt;, the request and response continue on to the next filter, or hit the servlet if there are no remaining filters.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;a href=\u0026quot;https://stackoverflow.com/tags/servlets/info\u0026quot;\u0026gt;servlets\u0026lt;/a\u0026gt;, the \u0026lt;code\u0026gt;service()\u0026lt;/code\u0026gt; method is invoked. By default, this method determines which one of the \u0026lt;code\u0026gt;doXxx()\u0026lt;/code\u0026gt; methods to invoke based off of  \u0026lt;code\u0026gt;request.getMethod()\u0026lt;/code\u0026gt;. If the determined method is absent from the servlet, then an HTTP 405 error is returned in the response.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The request object provides access to all of the information about the HTTP request, such as its \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/URL\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;URL\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;headers\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Query_string\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;query string\u0026lt;/a\u0026gt; and body. The response object provides the ability to control and send the HTTP response the way you want by, for instance, allowing you to set the headers and the body (usually with generated HTML content from a JSP file). When the HTTP response is committed and finished, both the request and response objects are recycled and made available for reuse.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When a client visits the webapp for the first time and/or the \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpSession.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is obtained for the first time via \u0026lt;code\u0026gt;request.getSession()\u0026lt;/code\u0026gt;, the servlet container creates a new \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; object, generates a long and unique ID (which you can get by \u0026lt;code\u0026gt;session.getId()\u0026lt;/code\u0026gt;), and stores it in the server\u0026apos;s memory. The servlet container also sets a \u0026lt;a href=\u0026quot;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/Cookie.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Cookie\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; in the \u0026lt;code\u0026gt;Set-Cookie\u0026lt;/code\u0026gt; header of the HTTP response with \u0026lt;code\u0026gt;JSESSIONID\u0026lt;/code\u0026gt; as its name and the unique session ID as its value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As per the \u0026lt;a href=\u0026quot;http://www.faqs.org/rfcs/rfc2965.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTTP cookie specification\u0026lt;/a\u0026gt; (a contract any decent web browser and web server must adhere to), the client (the web browser) is required to send this \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/HTTP_cookie\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;cookie\u0026lt;/a\u0026gt; back in subsequent requests in the \u0026lt;code\u0026gt;Cookie\u0026lt;/code\u0026gt; header for as long as the cookie is valid (i.e. the unique ID must refer to an unexpired session and the domain and path are correct). Using your browser\u0026apos;s built-in HTTP traffic monitor, you can verify that the cookie is valid (press F12 in Chrome / Firefox 23+ / IE9+, and check the \u0026lt;em\u0026gt;Net/Network\u0026lt;/em\u0026gt; tab). The servlet container will check the \u0026lt;code\u0026gt;Cookie\u0026lt;/code\u0026gt; header of every incoming HTTP request for the presence of the cookie with the name \u0026lt;code\u0026gt;JSESSIONID\u0026lt;/code\u0026gt; and use its value (the session ID) to get the associated \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; from server\u0026apos;s memory.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; stays alive until it has been idle (i.e. not used in a request) for more than the timeout value specified in \u0026lt;code\u0026gt;\u0026amp;lt;session-timeout\u0026amp;gt;\u0026lt;/code\u0026gt;, a setting in \u0026lt;code\u0026gt;web.xml\u0026lt;/code\u0026gt;. The timeout value defaults to 30 minutes. So, when the client doesn\u0026apos;t visit the web app for longer than the time specified, the servlet container trashes the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;session\u0026lt;/a\u0026gt;. Every subsequent request, even with the cookie specified, will not have access to the same session anymore; the servlet container will create a new session.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On the client side, the session cookie stays alive for as long as the browser instance is running. So, if the client closes the browser instance (all tabs/windows), then the session is trashed on the client\u0026apos;s side. In a new browser instance, the cookie associated with the session wouldn\u0026apos;t exist, so it would no longer be sent. This causes an entirely new \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; to be created, with an entirely new session cookie being used.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;In a nutshell\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt; lives for as long as the web app lives. It is shared among \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; requests in \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; sessions.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; lives for as long as the client is interacting with the web app with the same browser instance, and the session hasn\u0026apos;t timed out at the server side. It is shared among \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; requests in the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; session.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;HttpServletRequest\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;HttpServletResponse\u0026lt;/code\u0026gt; live from the time the servlet receives an HTTP request from the client, until the complete response (the web page) has arrived. It is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; shared elsewhere.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All \u0026lt;code\u0026gt;Servlet\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Filter\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Listener\u0026lt;/code\u0026gt; instances live as long as the web app lives. They are shared among \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; requests in \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; sessions.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any \u0026lt;code\u0026gt;attribute\u0026lt;/code\u0026gt; that is defined in \u0026lt;code\u0026gt;ServletContext\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;HttpServletRequest\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;HttpSession\u0026lt;/code\u0026gt; will live as long as the object in question lives. The object itself represents the \u0026quot;scope\u0026quot; in bean management frameworks such as JSF, CDI, Spring, etc. Those frameworks store their scoped beans as an \u0026lt;code\u0026gt;attribute\u0026lt;/code\u0026gt; of its closest matching scope.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h2\u0026gt;Thread Safety\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;That said, your major concern is possibly \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Thread_safety\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;thread safety\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. You should now know that servlets and filters are shared among all requests. That\u0026apos;s the nice thing about Java, it\u0026apos;s multithreaded and different threads (read: HTTP requests) can make use of the same instance. It would otherwise be too expensive to recreate, \u0026lt;code\u0026gt;init()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;destroy()\u0026lt;/code\u0026gt; them for every single request.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You should also realize that you should \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; assign any request or session scoped data as an \u0026lt;em\u0026gt;instance\u0026lt;/em\u0026gt; variable of a servlet or filter. It will be shared among all other requests in other sessions. That\u0026apos;s \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; thread-safe! The below example illustrates this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExampleServlet\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HttpServlet\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Object thisIsNOTThreadSafe;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;doGet\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(HttpServletRequest request, HttpServletResponse response)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throws\u0026lt;/span\u0026gt; ServletException, IOException {\n        Object thisIsThreadSafe;\n\n        thisIsNOTThreadSafe = request.getParameter(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BAD!! Shared among all requests!\u0026lt;/span\u0026gt;\n        thisIsThreadSafe = request.getParameter(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK, this is thread safe.\u0026lt;/span\u0026gt;\n    } \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;See also:\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2095397/what-is-the-difference-between-jsf-servlet-and-jsp\u0026quot;\u0026gt;What is the difference between JSF, Servlet and JSP?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1700390/best-option-for-session-management-in-java\u0026quot;\u0026gt;Best option for Session management in Java\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4140448/difference-between-and-in-servlet-mapping-url-pattern\u0026quot;\u0026gt;Difference between / and /* in servlet mapping url pattern\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2349633/doget-and-dopost-in-servlets\u0026quot;\u0026gt;doGet and doPost in Servlets\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8011138/servlet-seems-to-handle-multiple-concurrent-requests-synchronously/\u0026quot;\u0026gt;Servlet seems to handle multiple concurrent browser requests synchronously\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/9555842/why-servlets-are-not-thread-safe/\u0026quot;\u0026gt;Why Servlets are not thread Safe?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Sessions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ABDSX.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/IWAF3.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In short: the web server issues a unique identifier to \u0026lt;em\u0026gt;each visitor\u0026lt;/em\u0026gt; on his \u0026lt;em\u0026gt;first\u0026lt;/em\u0026gt; visit. The visitor must bring back that ID for him to be recognised next time around. This identifier also allows the server to properly segregate objects owned by one session against that of another.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Servlet Instantiation\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;strong\u0026gt;load-on-startup\u0026lt;/strong\u0026gt; is \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Jjvcb.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/7Bw3x.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;strong\u0026gt;load-on-startup\u0026lt;/strong\u0026gt; is \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/t33bd.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/e7BB7.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Once he\u0026apos;s on the service mode and on the groove, the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; servlet will work on the requests from all other clients. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/gqoR4.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why isn\u0026apos;t it a good idea to have one instance per client? Think about this: Will you hire one pizza guy for every order that came? Do that and you\u0026apos;d be out of business in no time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It comes with a small risk though. Remember: this single guy holds all the order information in his pocket: so if you\u0026apos;re not cautious about \u0026lt;a href=\u0026quot;http://tutorials.jenkov.com/java-servlets/servlet-concurrency.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;thread safety on servlets\u0026lt;/a\u0026gt;, he may end up giving the wrong order to a certain client.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Session in Java servlets is the same as session in other languages such as PHP.  It is unique to the user.  The server can keep track of it in different ways such as cookies, url rewriting etc.  This \u0026lt;a href=\u0026quot;http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/HttpSession.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java doc\u0026lt;/a\u0026gt; article explains it in the context of Java servlets and indicates that exactly how session is maintained is an implementation detail left to the designers of the server.  The specification only stipulates that it must be maintained as unique to a user across multiple connections to the server.  Check out \u0026lt;a href=\u0026quot;http://download.oracle.com/docs/cd/A97336_01/buslog.102/a83726/tecbkgn2.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this article from Oracle\u0026lt;/a\u0026gt; for more information about both of your questions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit\u0026lt;/strong\u0026gt; There is an excellent tutorial \u0026lt;a href=\u0026quot;http://www.apl.jhu.edu/~hall/java/Servlet-Tutorial/Servlet-Tutorial-Session-Tracking.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; on how to work with session inside of servlets. And \u0026lt;a href=\u0026quot;http://docs.oracle.com/javaee/5/tutorial/doc/bnafd.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; is a chapter from Sun about Java Servlets, what they are and how to use them.  Between those two articles, you should be able to answer all of your questions.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When the servlet container (like Apache Tomcat) starts up, it will read from the web.xml file (only one per application) if anything goes wrong or shows up an error at container side console, otherwise, it will deploy and load all web applications by using web.xml (so named it as deployment descriptor).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;During instantiation phase of the servlet, servlet instance is ready but it cannot serve the client request because it is missing with two pieces of information:\u0026lt;br\u0026gt;\n1: context information\u0026lt;br\u0026gt;\n2: initial configuration information\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Servlet engine creates servletConfig interface object encapsulating the above missing information into it\nservlet engine calls init() of the servlet by supplying servletConfig object references as an argument. Once init() is completely executed servlet is ready to serve the client request.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Q) In the lifetime of servlet how many times instantiation and initialization happens ??\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;A)only once (for every client request a new thread is created)\nonly one instance of the servlet serves any number of the client request ie, after serving one client request server does not die. It waits for other client requests ie what CGI (for every client request a new process is created) limitation is overcome with the servlet (internally servlet engine creates the thread).\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Q)How session concept works?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;A)whenever getSession() is called on HttpServletRequest object\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Step 1\u0026lt;/strong\u0026gt;: request object is evaluated for incoming session ID.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Step 2\u0026lt;/strong\u0026gt;: if ID not available a brand new HttpSession object is created and its corresponding session ID is generated (ie of HashTable) session ID is stored into httpservlet response object and the reference of HttpSession object is returned to the servlet (doGet/doPost).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Step 3\u0026lt;/strong\u0026gt;: if ID available brand new session object is not created session ID is picked up from the request object search is made in the collection of sessions by using session ID as the key.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Once the search is successful session ID is stored into HttpServletResponse and the existing session object references are returned to the doGet() or doPost() of UserDefineservlet.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Note:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;1)when control leaves from servlet code to client don\u0026apos;t forget that session object is being held by servlet container ie, the servlet engine\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2)multithreading is left to servlet developers people for implementing ie., handle the multiple requests of client nothing to bother about multithread code\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Inshort form:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;A servlet is created when the application starts (it is deployed on the servlet container) or when it is first accessed (depending on the load-on-startup setting)\nwhen the servlet is instantiated, the init() method of the servlet is called\nthen the servlet (its one and only instance) handles all requests (its service() method being called by multiple threads). That\u0026apos;s why it is not advisable to have any synchronization in it, and you should avoid instance variables of the servlet\nwhen the application is undeployed (the servlet container stops), the destroy() method is called.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sessions\u0026lt;/strong\u0026gt; - what Chris Thompson said.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Instantiation\u0026lt;/strong\u0026gt; - a servlet is instantiated when the container receives the first request mapped to the servlet (unless the servlet is configured to load on startup with the \u0026lt;code\u0026gt;\u0026amp;lt;load-on-startup\u0026amp;gt;\u0026lt;/code\u0026gt; element in \u0026lt;code\u0026gt;web.xml\u0026lt;/code\u0026gt;). The same instance is used to serve subsequent requests.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Servlet Specification \u0026lt;strong\u0026gt;JSR-315\u0026lt;/strong\u0026gt; clearly defines the web container behavior in the service (and doGet, doPost, doPut etc.) methods (2.3.3.1 Multithreading Issues, Page 9):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A servlet container may send concurrent requests through the service\n  method of the servlet. To handle the requests, the Servlet Developer\n  must make adequate provisions for concurrent processing with multiple\n  threads in the service method.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Although it is not recommended, an alternative for the Developer is to\n  implement the SingleThreadModel interface which requires the container\n  to guarantee that there is only one request thread at a time in the\n  service method. A servlet container may satisfy this requirement by\n  serializing requests on a servlet, or by maintaining a pool of servlet\n  instances. If the servlet is part of a Web application that has been\n  marked as distributable, the container may maintain a pool of servlet\n  instances in each JVM that the application is distributed across.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;For servlets not implementing the SingleThreadModel interface, if the\n  service method (or methods such as doGet or doPost which are\n  dispatched to the service method of the HttpServlet abstract class)\n  has been defined with the synchronized keyword, the servlet container\n  cannot use the instance pool approach, but must serialize requests\n  through it. It is strongly recommended that Developers not synchronize\n  the service method (or methods dispatched to it) in these\n  circumstances because of detrimental effects on performance\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;No.\u0026lt;/strong\u0026gt; Servlets are \u0026lt;strong\u0026gt;not Thread safe\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is allows accessing more than one threads at a time\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;if u want to make it Servlet as Thread safe ., U can go for\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Implement SingleThreadInterface(i)\u0026lt;/code\u0026gt; \nwhich is a blank Interface there is no\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;methods\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;or we can go for synchronize methods\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;we can make whole service method as synchronized by using synchronized\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;keyword in front of method\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example::\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Synchronized \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;service\u0026lt;/span\u0026gt;(ServletRequest request,ServletResponse response)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throws\u0026lt;/span\u0026gt; ServletException,IOException\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or we can the put block of the code in the Synchronized block\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example::\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Synchronized(Object)\n\n{\n\n----Instructions-----\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I feel that Synchronized block is better than making the whole method\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Synchronized\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As is clear from above explanations, by implementing the \u0026lt;b\u0026gt;SingleThreadModel\u0026lt;/b\u0026gt;, a servlet can be assured thread-safety by the servlet container. The container implementation can do this in 2 ways:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) Serializing requests (queuing) to a single instance - this is similar to a servlet NOT implementing SingleThreadModel BUT synchronizing the service/ doXXX methods; OR\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2) Creating a pool of instances - which\u0026apos;s a better option and a trade-off between the boot-up/initialization effort/time of the servlet as against the restrictive parameters (memory/ CPU time) of the environment hosting the servlet.\u0026lt;/p\u0026gt;\n    "],"id":297,"title":"How do servlets work? Instantiation, sessions, shared variables and multithreading","content":"\n                \n\u0026lt;p\u0026gt;Suppose, I have a webserver which holds numerous servlets. For information passing among those servlets I am setting session and instance variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, if 2 or more users send request to this server then what happens to the session variables?\u0026lt;br\u0026gt;\nWill they all be common for all the users or they will be different for each user?\u0026lt;br\u0026gt;\nIf they are different, then how was the server able to differentiate between different users?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One more similar question, if there are \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; users accessing a particular servlet, then this servlet gets instantiated only the first time the first user accessed it or does it get instantiated for all the users separately?\u0026lt;br\u0026gt;\nIn other words, what happens to the instance variables?\u0026lt;/p\u0026gt;\n    ","slug":"how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreading-1657387540375","postType":"QUESTION","createdAt":"2022-07-09T17:25:40.000Z","updatedAt":"2022-07-09T17:25:40.000Z","tags":[{"id":1790,"name":"multithreading","slug":"multithreading","createdAt":"2022-07-09T17:25:40.000Z","updatedAt":"2022-07-09T17:25:40.000Z","Questions_Tags":{"questionId":297,"tagId":1790}},{"id":1791,"name":"session-variables","slug":"session-variables","createdAt":"2022-07-09T17:25:40.000Z","updatedAt":"2022-07-09T17:25:40.000Z","Questions_Tags":{"questionId":297,"tagId":1791}},{"id":1792,"name":"instance-variables","slug":"instance-variables","createdAt":"2022-07-09T17:25:40.000Z","updatedAt":"2022-07-09T17:25:40.000Z","Questions_Tags":{"questionId":297,"tagId":1792}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreading-1657387540375"},"buildId":"9SrIo1zGFc3tF1E8on9-4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>