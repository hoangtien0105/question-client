<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the strict aliasing rule? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="When asking about common undefined behavior in C, people sometimes refer to the strict aliasing rule.
What are they talking about?
    "/><meta property="og:title" content="What is the strict aliasing rule? | Solutions Checker"/><meta property="og:description" content="When asking about common undefined behavior in C, people sometimes refer to the strict aliasing rule.
What are they talking about?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the strict aliasing rule?","text":"When asking about common undefined behavior in C, people sometimes refer to the strict aliasing rule.\nWhat are they talking about?\n    ","answerCount":11,"upVoteCount":500,"suggestedAnswer":[{"text":"A typical situation where you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to uint32_ts or uint16_ts). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.\nSo in this kind of setup, if I want to send a message to something I&apos;d have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:\ntypedef struct Msg\n{\n    unsigned int a;\n    unsigned int b;\n} Msg;\n\nvoid SendWord(uint32_t);\n\nint main(void)\n{\n    // Get a 32-bit buffer from the system\n    uint32_t* buff = malloc(sizeof(Msg));\n    \n    // Alias that buffer through message\n    Msg* msg = (Msg*)(buff);\n    \n    // Send a bunch of messages    \n    for (int i = 0; i &lt; 10; ++i)\n    {\n        msg-&gt;a = i;\n        msg-&gt;b = i+1;\n        SendWord(buff[0]);\n        SendWord(buff[1]);   \n    }\n}\n\nThe strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a compatible type or one of the other types allowed by C 2011 6.5 paragraph 71 is undefined behavior. Unfortunately, you can still code this way, maybe get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.\n(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)\nTo see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn&apos;t have to think about inserting instructions to refresh the contents of buff every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load buff[0] and buff[1] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of buff could change by any preceding memory stores. So to get an extra performance edge, and assuming most people don&apos;t type-pun pointers, the strict aliasing rule was introduced.\nKeep in mind, if you think the example is contrived, this might even happen if you&apos;re passing a buffer to another function doing the sending for you, if instead you have.\nvoid SendMessage(uint32_t* buff, size_t size32)\n{\n    for (int i = 0; i &lt; size32; ++i) \n    {\n        SendWord(buff[i]);\n    }\n}\n\nAnd rewrote our earlier loop to take advantage of this convenient function\nfor (int i = 0; i &lt; 10; ++i)\n{\n    msg-&gt;a = i;\n    msg-&gt;b = i+1;\n    SendMessage(buff, 2);\n}\n\nThe compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If SendMessage is part of another API that&apos;s compiled separately, it probably has instructions to load buff&apos;s contents. Then again, maybe you&apos;re in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it&apos;s just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what&apos;s happening under the hood, it&apos;s still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn&apos;t necessarily help.\nSo how do I get around this?\n\nUse a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.\n  union {\n      Msg msg;\n      unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];\n  };\n\n\nYou can disable strict aliasing in your compiler (f[no-]strict-aliasing in gcc))\n\nYou can use char* for aliasing instead of your system&apos;s word. The rules allow an exception for char* (including signed char and unsigned char). It&apos;s always assumed that char* aliases other types. However this won&apos;t work the other way: there&apos;s no assumption that your struct aliases a buffer of chars.\n\n\nBeginner beware\nThis is only one potential minefield when overlaying two types onto each other. You should also learn about endianness, word alignment, and how to deal with alignment issues through packing structs correctly.\nFootnote\n1 The types that C 2011 6.5 7 allows an lvalue to access are:\n\na type compatible with the effective type of the object,\na qualified version of a type compatible with the effective type of the object,\na type that is the signed or unsigned type corresponding to the effective type of the object,\na type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,\nan aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or\na character type.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The best explanation I have found is by Mike Acton, Understanding Strict Aliasing. It&apos;s focused a little on PS3 development, but that&apos;s basically just GCC.\n\nFrom the article:\n\n\n  &quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;\n\n\nSo basically if you have an int* pointing to some memory containing an int and then you point a float* to that memory and use it as a float you break the rule. If your code does not respect this, then the compiler&apos;s optimizer will most likely break your code.\n\nThe exception to the rule is a char*, which is allowed to point to any type.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Note\nThis is excerpted from my &quot;What is the Strict Aliasing Rule and Why do we care?&quot; write-up.\nWhat is strict aliasing?\nIn C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term strict aliasing rule. If we attempt to access a value using a type not allowed it is classified as undefined behavior (UB). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.\nUnfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.\nTo understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.\nPreliminary examples\nLet&apos;s look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (live example):\nint x = 10;\nint *ip = &amp;x;\n\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;\n*ip = 12;\nstd::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;\n\nWe have a int* pointing to memory occupied by an int and this is a valid aliasing. The optimizer must assume that assignments through ip could update the value occupied by x.\nThe next example shows aliasing that leads to undefined behavior (live example):\nint foo( float *f, int *i ) { \n    *i = 1;\n    *f = 0.f;\n    \n    return *i;\n}\n\nint main() {\n    int x = 0;\n    \n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0\n    x = foo(reinterpret_cast&lt;float*&gt;(&amp;x), &amp;x);\n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0?\n}\n\nIn the function foo we take an int* and a float*, in this example we call foo and set both parameters to point to the same memory location which in this example contains an int. Note, the reinterpret_cast is telling the compiler to treat the expression as if it had the type specified by its template parameter. In this case we are telling it to treat the expression &amp;x as if it had type float*. We may naively expect the result of the second cout to be 0 but with optimization enabled using -O2 both gcc and clang produce the following result:\n0\n1\n\nWhich may not be expected but is perfectly valid since we have invoked undefined behavior. A float can not validly alias an int object. Therefore the optimizer can assume the constant 1 stored when dereferencing i will be the return value since a store through f could not validly affect an int object. Plugging the code in Compiler Explorer shows this is exactly what is happening(live example):\nfoo(float*, int*): # @foo(float*, int*)\nmov dword ptr [rsi], 1\nmov dword ptr [rdi], 0\nmov eax, 1\nret\n\nThe optimizer using Type-Based Alias Analysis (TBAA) assumes 1 will be returned and directly moves the constant value into register eax which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a float can not alias an int and optimizes away the load of i.\nNow, to the Rule-Book\nWhat exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.\nWhat does the C11 standard say?\nThe C11 standard says the following in section 6.5 Expressions paragraph 7:\n\nAn object shall have its stored value accessed only by an lvalue expression that has one of the following types:88)\n a type compatible with the effective type of the object,\n\nint x = 1;\nint *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type int which is compatible with int\n\n\n a qualified version of a type compatible with the effective type of the object,\n\nint x = 1;\nconst int *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type const int which is compatible with int\n\n\n a type that is the signed or unsigned type corresponding to the effective type of the object,\n\nint x = 1;\nunsigned int *p = (unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type unsigned int which corresponds to \n                     // the effective type of the object\n\ngcc/clang has an extension and also that allows assigning unsigned int* to int* even though they are not compatible types.\n\n a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,\n\nint x = 1;\nconst unsigned int *p = (const unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type const unsigned int which is a unsigned type \n                     // that corresponds with to a qualified version of the effective type of the object\n\n\n an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or\n\nstruct foo {\n    int x;\n};\n    \nvoid foobar( struct foo *fp, int *ip );  // struct foo is an aggregate that includes int among its members so it\n                                         // can alias with *ip\n\nfoo f;\nfoobar( &amp;f, &amp;f.x );\n\n\n a character type.\n\nint x = 65;\nchar *p = (char *)&amp;x;\nprintf(&quot;%c\\n&quot;, *p );  // *p gives us an lvalue expression of type char which is a character type.\n                      // The results are not portable due to endianness issues.\n\nWhat the C++17 Draft Standard says\nThe C++17 draft standard in section [basic.lval] paragraph 11 says:\n\nIf a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:63\n\n\n(11.1)  the dynamic type of the object,\n\nvoid *p = malloc( sizeof(int) ); // We have allocated storage but not started the lifetime of an object\nint *ip = new (p) int{0};        // Placement new changes the dynamic type of the object to int\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;        // *ip gives us a glvalue expression of type int which matches the dynamic type \n                                 // of the allocated object\n\n\n(11.2)  a cv-qualified version of the dynamic type of the object,\n\nint x = 1;\nconst int *cip = &amp;x;\nstd::cout &lt;&lt; *cip &lt;&lt; &quot;\\n&quot;;  // *cip gives us a glvalue expression of type const int which is a cv-qualified \n                            // version of the dynamic type of x\n\n\n(11.3)  a type similar (as defined in 7.5) to the dynamic type of the object,\n\n\n(11.4)  a type that is the signed or unsigned type corresponding to the dynamic type of the object,\n\n// Both si and ui are signed or unsigned types corresponding to each others dynamic types\n// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.\nsigned int foo( signed int &amp;si, unsigned int &amp;ui ) {\n    si = 1;\n    ui = 2;\n\n    return si;\n}\n\n\n(11.5)  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\n\nsigned int foo( const signed int &amp;si1, int &amp;si2); // Hard to show this one assumes aliasing\n\n\n(11.6)  an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),\n\nstruct foo {\n    int x;\n};\n\n// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption\nint foobar( foo &amp;fp, int &amp;ip ) {\n    fp.x = 1;\n    ip = 2;\n\n    return fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n\n\n(11.7)  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\n\nstruct foo { int x; };\n\nstruct bar : public foo {};\n\nint foobar( foo &amp;f, bar &amp;b ) {\n    f.x = 1;\n    b.x = 2;\n\n    return f.x;\n}\n\n\n(11.8)  a char, unsigned char, or std::byte type.\n\nint foo( std::byte &amp;b, uint32_t &amp;ui ) {\n    b = static_cast&lt;std::byte&gt;(&apos;a&apos;);\n    ui = 0xFFFFFFFF;\n  \n    return std::to_integer&lt;int&gt;( b );  // b gives us a glvalue expression of type std::byte which can alias\n                                       // an object of type uint32_t\n}\n\nWorth noting signed char is not included in the list above, this is a notable difference from C which says a character type.\nWhat is Type Punning\nWe have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to type pun, often the methods used violate strict aliasing rules.\nSometimes we want to circumvent the type system and interpret an object as a different type. This is called type punning, to reinterpret a segment of memory as another type. Type punning is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc\nTraditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:\nint x = 1;\n\n// In C\nfloat *fp = (float*)&amp;x;  // Not a valid aliasing\n\n// In C++\nfloat *fp = reinterpret_cast&lt;float*&gt;(&amp;x);  // Not a valid aliasing\n\nprintf( &quot;%f\\n&quot;, *fp );\n\nAs we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but undefined behavior in C++ (see live example):\nunion u1\n{\n    int n;\n    float f;\n};\n\nunion u1 u;\nu.f = 1.0f;\n\nprintf( &quot;%d\\n&quot;, u.n );  // UB in C++ n is not the active member\n\nThis is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.\nHow do we Type Pun correctly?\nThe standard method for type punning in both C and C++ is memcpy. This may seem a little heavy handed but the optimizer should recognize the use of memcpy for type punning and optimize it away and generate a register to register move. For example if we know int64_t is the same size as double:\nstatic_assert( sizeof( double ) == sizeof( int64_t ) );  // C++17 does not require a message\n\nwe can use memcpy:\nvoid func1( double d ) {\n    std::int64_t n;\n    std::memcpy(&amp;n, &amp;d, sizeof d);\n    //...\n\nAt a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned reinterpret_cast method or union method for type punning. Examining the generated code we see it uses just register mov (live Compiler Explorer Example).\nC++20 and bit_cast\nIn C++20 we may gain bit_cast (implementation available in link from proposal) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.\nThe following is an example of how to use bit_cast to type pun a unsigned int to float, (see it live):\nstd::cout &lt;&lt; bit_cast&lt;float&gt;(0x447a0000) &lt;&lt; &quot;\\n&quot;; //assuming sizeof(float) == sizeof(unsigned int)\n\nIn the case where To and From types don&apos;t have the same size, it requires us to use an intermediate struct15. We will use a struct containing a sizeof( unsigned int ) character array (assumes 4 byte unsigned int) to be the From type and unsigned int as the To type.:\nstruct uint_chars {\n    unsigned char arr[sizeof( unsigned int )] = {};  // Assume sizeof( unsigned int ) == 4\n};\n\n// Assume len is a multiple of 4 \nint bar( unsigned char *p, size_t len ) {\n    int result = 0;\n\n    for( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) {\n        uint_chars f;\n        std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int));\n        unsigned int result = bit_cast&lt;unsigned int&gt;(f);\n\n        result += foo( result );\n    }\n\n    return result;\n}\n\nIt is unfortunate that we need this intermediate type but that is the current constraint of bit_cast.\nCatching Strict Aliasing Violations\nWe don&apos;t have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.\ngcc using the flag -fstrict-aliasing and -Wstrict-aliasing can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (see it live):\nint a = 1;\nshort j;\nfloat f = 1.f; // Originally not initialized but tis-kernel caught \n               // it was being accessed w/ an indeterminate value below\n\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(&amp;a)));\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));\n\nalthough it will not catch this additional case (see it live):\nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(p)));\n\nAlthough clang allows these flags it apparently does not actually implement the warnings.\nAnother tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using -fsanitize=address\nint *x = new int[2];               // 8 bytes: [0,7].\nint *u = (int*)((char*)x + 6);     // regardless of alignment of x this will not be an aligned address\n*u = 1;                            // Access to range [6-9]\nprintf( &quot;%d\\n&quot;, *u );              // Access to range [6-9]\n\nThe last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don&apos;t allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using -Wold-style-cast. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.\nFor C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C version of the earlier example where using -fstrict-aliasing misses one case (see it live)\nint a = 1;\nshort j;\nfloat f = 1.0;\n\nprintf(&quot;%i\\n&quot;, j = *((short*)&amp;a));\nprintf(&quot;%i\\n&quot;, j = *((int*)&amp;f));\n    \nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *((short*)p));\n\ntis-interpeter is able to catch all three, the following example invokes tis-kernel as tis-interpreter (output is edited for brevity):\n./bin/tis-kernel -sa example1.c \n...\nexample1.c:9:[sa] warning: The pointer (short *)(&amp; a) has type short *. It violates strict aliasing\n              rules by accessing a cell with effective type int.\n...\n\nexample1.c:10:[sa] warning: The pointer (int *)(&amp; f) has type int *. It violates strict aliasing rules by\n              accessing a cell with effective type float.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The pointer (short *)p has type short *. It violates strict aliasing rules by\n              accessing a cell with effective type int.\n\nFinally there is TySan which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"This is the strict aliasing rule, found in section 3.10 of the C++03 standard (other answers provide good explanation, but none provided the rule itself):\n\nIf a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:\n\nthe dynamic type of the object,\na cv-qualified version of the dynamic type of the object,\na type that is the signed or unsigned type corresponding to the dynamic type of the object,\na type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\nan aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),\na type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\na char or unsigned char type.\n\n\nC++11 and C++14 wording (changes emphasized):\n\nIf a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:\n\nthe dynamic type of the object,\na cv-qualified version of the dynamic type of the object,\na type similar (as defined in 4.4) to the dynamic type of the object,\na type that is the signed or unsigned type corresponding to the dynamic type of the object,\na type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\nan aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),\na type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\na char or unsigned char type.\n\n\nTwo changes were small: glvalue instead of lvalue, and clarification of the aggregate/union case.\nThe third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of similar types that are now safe to alias.\n\nAlso the C wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 §6.5 ¶7):\n\nAn object shall have its stored value accessed only by an lvalue\nexpression that has one of the following types  73) or 88):\n\na type compatible with the effective type of the object,\na qualied version of a type compatible with the effective type of\nthe object,\na type that is the signed or unsigned type corresponding to the\neffective type of the object,\na type that is the signed or unsigned type corresponding to a\nqualied version of the effective type of the object,\nan aggregate or union type that includes one of the aforementioned\ntypes among its members (including, recursively, a member of a\nsubaggregate or contained union), or\na character type.\n\n 73) or 88) The intent of this list is to specify those circumstances in which an object may or may not be aliased.\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Strict aliasing doesn&apos;t refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. Strict Aliasing White Paper.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :\n\ncheck.c\n\n#include &lt;stdio.h&gt;\n\nvoid check(short *h,long *k)\n{\n    *h=5;\n    *k=6;\n    if (*h == 5)\n        printf(&quot;strict aliasing problem\\n&quot;);\n}\n\nint main(void)\n{\n    long      k[1];\n    check((short *)k,k);\n    return 0;\n}\n\n\nCompile with gcc -O2 -o check check.c .\nUsually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the if (*h == 5) away and always calls the printf.\n\nFor those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:\n\nmovw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC0, %edi\njmp puts\n\n\nSo the if condition is completely gone from the assembler code.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:\n\nint x;\nint test(double *p)\n{\n  x=5;\n  *p = 1.0;\n  return x;\n}\n\n\nshould be required to reload the value of x between the assignment and return statement so as to allow for the possibility that p might point to x, and the assignment to *p might consequently alter the value of x.  The notion that a compiler should be entitled to presume that there won&apos;t be aliasing in situations like the above was non-controversial.\n\nUnfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:\n\nvoid test(void)\n{\n  struct S {int x;} s;\n  s.x = 1;\n}\n\n\nbecause it uses an lvalue of type int to access an object of type struct S, and int is not among the types that may be used accessing a struct S.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.\n\nMuch of the problem is a result of Defect Report #028, which asked about the behavior of a program like:\n\nint test(int *ip, double *dp)\n{\n  *ip = 1;\n  *dp = 1.23;\n  return *ip;\n}\nint test2(void)\n{\n  union U { int i; double d; } u;\n  return test(&amp;u.i, &amp;u.d);\n}\n\n\nDefect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.\n\nThe best way to resolve the original problem would probably be to treat the\nfootnote about the purpose of the rule as though it were normative, and made\nthe rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:\n\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   s.x = 1;\n   p = &amp;s.x;\n   inc_int(p);\n   return s.x;\n }\n\n\nThere&apos;s no conflict within inc_int because all accesses to the storage accessed through *p are done with an lvalue of type int, and there&apos;s no conflict in test because p is visibly derived from a struct S, and by the next time s is used, all accesses to that storage that will ever be made through p will have already happened.\n\nIf the code were changed slightly...\n\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   p = &amp;s.x;\n   s.x = 1;  //  !!*!!\n   *p += 1;\n   return s.x;\n }\n\n\nHere, there is an aliasing conflict between p and the access to s.x on the marked line because at that point in execution another reference exists that will be used to access the same storage.\n\nHad Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Type punning via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"After reading many of the answers, I feel the need to add something:\n\nStrict aliasing (which I&apos;ll describe in a bit) is important because:\n\n\nMemory access can be expensive (performance wise), which is why data is manipulated in CPU registers before being written back to the physical memory.\nIf data in two different CPU registers will be written to the same memory space, we can&apos;t predict which data will &quot;survive&quot; when we code in C.\n\nIn assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.\n\n\nSince two pointers can point to the same location in the memory, this could result in complex code that handles possible collisions.\n\nThis extra code is slow and hurts performance since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.\n\nThe Strict aliasing rule allows us to avoid redundant machine code in cases in which it should be safe to assume that two pointers don&apos;t point to the same memory block (see also the restrict keyword).\n\nThe Strict aliasing states it&apos;s safe to assume that pointers to different types point to different locations in the memory.\n\nIf a compiler notices that two pointers point to different types (for example, an int * and a float *), it will assume the memory address is different and it will not protect against memory address collisions, resulting in faster machine code.\n\nFor example:\n\nLets assume the following function:\n\nvoid merge_two_ints(int *a, int *b) {\n  *b += *a;\n  *a += *b;\n}\n\n\nIn order to handle the case in which a == b (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:\n\n\nload a and b from memory.\nadd a to b.\nsave b and reload a.\n\n(save from CPU register to the memory and load from the memory to the CPU register). \nadd b to a.\nsave a (from the CPU register) to the memory.\n\n\nStep 3 is very slow because it needs to access the physical memory. However, it&apos;s required to protect against instances where a and b point to the same memory address.\n\nStrict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can&apos;t be performed if the pointers share a memory address).\n\n\nThis can be told to the compiler in two ways, by using different types to point to. i.e.:\n\nvoid merge_two_numbers(int *a, long *b) {...}\n\nUsing the restrict keyword. i.e.:\n\nvoid merge_two_ints(int * restrict a, int * restrict b) {...}\n\n\n\nNow, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.\n\nIn fact, by adding the restrict keyword, the whole function could be optimized to:\n\n\nload a and b from memory.\nadd a to b.\nsave result both to a and to b.\n\n\nThis optimization couldn&apos;t have been done before, because of the possible collision (where a and b would be tripled instead of doubled).\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Strict aliasing is not allowing different pointer types to the same data.\n\nThis article should help you understand the issue in full detail.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Technically in C++, the strict aliasing rule is probably never applicable.\n\nNote the definition of indirection (* operator):\n\n\n  The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and the result is an lvalue referring to the object or\n  function to which the expression points.\n\n\nAlso from the definition of glvalue\n\n\n  A glvalue is an expression whose evaluation determines the identity of\n  an object, (...snip)\n\n\nSo in any well defined program trace, a glvalue refers to an object. So the so called strict aliasing rule doesn&apos;t apply, ever. This may not be what the designers wanted.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-strict-aliasing-rule-1657384742852#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-strict-aliasing-rule-1657384742852">What is the strict aliasing rule?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/strict-aliasing">strict-aliasing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/type-punning">type-punning</a></div></div><div class="question-content mt-5">
                
<p>When asking about <a href="https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into">common undefined behavior in C</a>, people sometimes refer to the strict aliasing rule.<br>
What are they talking about?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A typical situation where you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to <code>uint32_t</code>s or <code>uint16_t</code>s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</p>
<p>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Msg</span>
{
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b;
} Msg;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SendWord</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-comment">// Get a 32-bit buffer from the system</span>
    <span class="hljs-type">uint32_t</span>* buff = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Msg));
    
    <span class="hljs-comment">// Alias that buffer through message</span>
    Msg* msg = (Msg*)(buff);
    
    <span class="hljs-comment">// Send a bunch of messages    </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)
    {
        msg-&gt;a = i;
        msg-&gt;b = i+<span class="hljs-number">1</span>;
        <span class="hljs-built_in">SendWord</span>(buff[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">SendWord</span>(buff[<span class="hljs-number">1</span>]);   
    }
}
</code></pre>
<p>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a <a href="http://en.cppreference.com/w/c/language/type" rel="noreferrer">compatible type</a> or one of the other types allowed by C 2011 6.5 paragraph 7<sup>1</sup> is undefined behavior. Unfortunately, you can still code this way, <em>maybe</em> get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</p>
<p>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</p>
<p>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of <code>buff</code> every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load <code>buff[0]</code> and <code>buff[1]</code> into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of <code>buff</code> could change by any preceding memory stores. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</p>
<p>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* buff, <span class="hljs-type">size_t</span> size32)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size32; ++i) 
    {
        <span class="hljs-built_in">SendWord</span>(buff[i]);
    }
}
</code></pre>
<p>And rewrote our earlier loop to take advantage of this convenient function</p>
<pre class="default s-code-block"><code class="hljs language-erlang"><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)</span>
{
    <span class="hljs-title">msg</span>-&gt;</span>a = i;
    msg-&gt;b = i+<span class="hljs-number">1</span>;
    SendMessage(buff, <span class="hljs-number">2</span>);
}
</code></pre>
<p>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If <code>SendMessage</code> is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</p>
<p><strong>So how do I get around this?</strong></p>
<ul>
<li><p>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</p>
<pre class="default s-code-block"><code class="hljs language-objectivec">  <span class="hljs-keyword">union</span> {
      Msg msg;
      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> asBuffer[<span class="hljs-keyword">sizeof</span>(Msg)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)];
  };
</code></pre>
</li>
<li><p>You can disable strict aliasing in your compiler (<a href="http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825" rel="noreferrer">f[no-]strict-aliasing</a> in gcc))</p>
</li>
<li><p>You can use <code>char*</code> for aliasing instead of your system's word. The rules allow an exception for <code>char*</code> (including <code>signed char</code> and <code>unsigned char</code>). It's always assumed that <code>char*</code> aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</p>
</li>
</ul>
<p><strong>Beginner beware</strong></p>
<p>This is only one potential minefield when overlaying two types onto each other. You should also learn about <a href="http://en.wikipedia.org/wiki/Endianness" rel="noreferrer">endianness</a>, <a href="http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html" rel="noreferrer">word alignment</a>, and how to deal with alignment issues through <a href="http://grok2.com/structure_packing.html" rel="noreferrer">packing structs</a> correctly.</p>
<h2>Footnote</h2>
<p><sup>1</sup> The types that C 2011 6.5 7 allows an lvalue to access are:</p>
<ul>
<li>a type compatible with the effective type of the object,</li>
<li>a qualified version of a type compatible with the effective type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to the effective type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</li>
<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</li>
<li>a character type.</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best explanation I have found is by Mike Acton, <a href="http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html" rel="noreferrer">Understanding Strict Aliasing</a>. It's focused a little on PS3 development, but that's basically just GCC.</p>

<p>From the article:</p>

<blockquote>
  <p>"Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)"</p>
</blockquote>

<p>So basically if you have an <code>int*</code> pointing to some memory containing an <code>int</code> and then you point a <code>float*</code> to that memory and use it as a <code>float</code> you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</p>

<p>The exception to the rule is a <code>char*</code>, which is allowed to point to any type.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Note</h2>
<p>This is excerpted from my <a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8" rel="nofollow noreferrer">"What is the Strict Aliasing Rule and Why do we care?"</a> write-up.</p>
<h2>What is strict aliasing?</h2>
<p>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term <em>strict aliasing rule</em>. If we attempt to access a value using a type not allowed it is classified as <a href="http://en.cppreference.com/w/cpp/language/ub" rel="nofollow noreferrer">undefined behavior</a> (<strong>UB</strong>). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</p>
<p>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</p>
<p>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</p>
<h3>Preliminary examples</h3>
<p>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (<a href="https://wandbox.org/permlink/7sCJTAyrifZ0zfFA" rel="nofollow noreferrer">live example</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span> *ip = &amp;x;

std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string">"\n"</span>;
*ip = <span class="hljs-number">12</span>;
std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;
</code></pre>
<p>We have a <em>int*</em> pointing to memory occupied by an <em>int</em> and this is a valid aliasing. The optimizer must assume that assignments through <strong>ip</strong> could update the value occupied by <strong>x</strong>.</p>
<p>The next example shows aliasing that leads to undefined behavior (<a href="https://wandbox.org/permlink/8qA8JyJRVHtS9LPf" rel="nofollow noreferrer">live example</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-type">float</span> *f, <span class="hljs-type">int</span> *i )</span> </span>{ 
    *i = <span class="hljs-number">1</span>;
    *f = <span class="hljs-number">0.f</span>;
    
    <span class="hljs-keyword">return</span> *i;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
    
    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// Expect 0</span>
    x = <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">float</span>*&gt;(&amp;x), &amp;x);
    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// Expect 0?</span>
}
</code></pre>
<p>In the function <strong>foo</strong> we take an <em>int*</em> and a <em>float*</em>, in this example we call <strong>foo</strong> and set both parameters to point to the same memory location which in this example contains an <em>int</em>. Note, the <a href="http://en.cppreference.com/w/cpp/language/reinterpret_cast" rel="nofollow noreferrer">reinterpret_cast</a> is telling the compiler to treat the expression as if it had the type specified by its template parameter. In this case we are telling it to treat the expression <strong>&amp;x</strong> as if it had type <em>float*</em>. We may naively expect the result of the second <strong>cout</strong> to be <strong>0</strong> but with optimization enabled using <strong>-O2</strong> both gcc and clang produce the following result:</p>
<pre class="default s-code-block"><code class="hljs language-undefined">0
1
</code></pre>
<p>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A <em>float</em> can not validly alias an <em>int</em> object. Therefore the optimizer can assume the <em>constant 1</em> stored when dereferencing <strong>i</strong> will be the return value since a store through <strong>f</strong> could not validly affect an <em>int</em> object. Plugging the code in Compiler Explorer shows this is exactly what is happening(<a href="https://godbolt.org/g/yNV5aj" rel="nofollow noreferrer">live example</a>):</p>
<pre class="default s-code-block"><code class="hljs language-sql">foo(<span class="hljs-type">float</span><span class="hljs-operator">*</span>, <span class="hljs-type">int</span><span class="hljs-operator">*</span>): # <span class="hljs-variable">@foo</span>(<span class="hljs-type">float</span><span class="hljs-operator">*</span>, <span class="hljs-type">int</span><span class="hljs-operator">*</span>)
mov dword ptr [rsi], <span class="hljs-number">1</span>
mov dword ptr [rdi], <span class="hljs-number">0</span>
mov eax, <span class="hljs-number">1</span>
ret
</code></pre>
<p>The optimizer using <a href="http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm" rel="nofollow noreferrer">Type-Based Alias Analysis (TBAA)</a> assumes <strong>1</strong> will be returned and directly moves the constant value into register <strong>eax</strong> which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a <em>float</em> can not alias an <em>int</em> and optimizes away the load of <strong>i</strong>.</p>
<h2>Now, to the Rule-Book</h2>
<p>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</p>
<h3>What does the C11 standard say?</h3>
<p>The <strong>C11</strong> standard says the following in section <em>6.5 Expressions paragraph 7</em>:</p>
<blockquote>
<p>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:<sup>88)</sup>
 a type compatible with the effective type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> *p = &amp;<span class="hljs-keyword">x</span>;
<span class="hljs-keyword">printf</span>(<span class="hljs-string">"%d\n"</span>, *p); <span class="hljs-regexp">//</span> *p gives us an lvalue expression of type <span class="hljs-keyword">int</span> which is compatible with <span class="hljs-keyword">int</span>
</code></pre>
<blockquote>
<p> a qualified version of a type compatible with the effective type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *p); <span class="hljs-comment">// *p gives us an lvalue expression of type const int which is compatible with int</span>
</code></pre>
<blockquote>
<p> a type that is the signed or unsigned type corresponding to the effective type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%u\n"</span>, *p ); <span class="hljs-comment">// *p gives us an lvalue expression of type unsigned int which corresponds to </span>
                     <span class="hljs-comment">// the effective type of the object</span>
</code></pre>
<p><a href="https://twitter.com/shafikyaghmour/status/957702383810658304" rel="nofollow noreferrer">gcc/clang has an extension</a> and <a href="https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html" rel="nofollow noreferrer">also</a> that allows assigning <em>unsigned int*</em> to <em>int*</em> even though they are not compatible types.</p>
<blockquote>
<p> a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p = (<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%u\n"</span>, *p ); <span class="hljs-comment">// *p gives us an lvalue expression of type const unsigned int which is a unsigned type </span>
                     <span class="hljs-comment">// that corresponds with to a qualified version of the effective type of the object</span>
</code></pre>
<blockquote>
<p> an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">struct</span> foo {
    <span class="hljs-built_in">int</span> x;
};
    
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foobar</span>(<span class="hljs-params"> <span class="hljs-keyword">struct</span> foo *fp, <span class="hljs-built_in">int</span> *ip </span>)</span>;  <span class="hljs-comment">// struct foo is an aggregate that includes int among its members so it</span>
                                         <span class="hljs-comment">// can alias with *ip</span>

foo f;
foobar( &amp;f, &amp;f.x );
</code></pre>
<blockquote>
<p> a character type.</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">65</span>;
<span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)&amp;x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>, *p );  <span class="hljs-comment">// *p gives us an lvalue expression of type char which is a character type.</span>
                      <span class="hljs-comment">// The results are not portable due to endianness issues.</span>
</code></pre>
<h3>What the C++17 Draft Standard says</h3>
<p>The C++17 draft standard in section <em>[basic.lval] paragraph 11</em> says:</p>
<blockquote>
<p>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:<sup>63</sup></p>
</blockquote>
<blockquote>
<p>(11.1)  the dynamic type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">void</span> *p = <span class="hljs-built_in">malloc</span>( <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) ); <span class="hljs-comment">// We have allocated storage but not started the lifetime of an object</span>
<span class="hljs-type">int</span> *ip = <span class="hljs-built_in">new</span> (p) <span class="hljs-type">int</span>{<span class="hljs-number">0</span>};        <span class="hljs-comment">// Placement new changes the dynamic type of the object to int</span>
std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string">"\n"</span>;        <span class="hljs-comment">// *ip gives us a glvalue expression of type int which matches the dynamic type </span>
                                 <span class="hljs-comment">// of the allocated object</span>
</code></pre>
<blockquote>
<p>(11.2)  a cv-qualified version of the dynamic type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> *cip = &amp;x;
std::cout &lt;&lt; *cip &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// *cip gives us a glvalue expression of type const int which is a cv-qualified </span>
                            <span class="hljs-comment">// version of the dynamic type of x</span>
</code></pre>
<blockquote>
<p>(11.3)  a type similar (as defined in 7.5) to the dynamic type of the object,</p>
</blockquote>
<blockquote>
<p>(11.4)  a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Both si and ui are signed or unsigned types corresponding to each others dynamic types</span>
<span class="hljs-comment">// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.</span>
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-type">signed</span> <span class="hljs-type">int</span> &amp;si, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &amp;ui )</span> </span>{
    si = <span class="hljs-number">1</span>;
    ui = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">return</span> si;
}
</code></pre>
<blockquote>
<p>(11.5)  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> &amp;si1, <span class="hljs-type">int</span> &amp;si2)</span></span>; <span class="hljs-comment">// Hard to show this one assumes aliasing</span>
</code></pre>
<blockquote>
<p>(11.6)  an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">struct</span> foo {
    <span class="hljs-built_in">int</span> x;
};

<span class="hljs-comment">// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption</span>
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">foobar</span>(<span class="hljs-params"> foo &amp;fp, <span class="hljs-built_in">int</span> &amp;ip </span>)</span> {
    fp.x = <span class="hljs-number">1</span>;
    ip = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">return</span> fp.x;
}

foo f;
foobar( f, f.x );
</code></pre>
<blockquote>
<p>(11.7)  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">struct</span> foo { <span class="hljs-built_in">int</span> x; };

<span class="hljs-keyword">struct</span> bar : <span class="hljs-keyword">public</span> foo {};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">foobar</span>(<span class="hljs-params"> foo &amp;f, bar &amp;b </span>)</span> {
    f.x = <span class="hljs-number">1</span>;
    b.x = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">return</span> f.x;
}
</code></pre>
<blockquote>
<p>(11.8)  a char, unsigned char, or std::byte type.</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">foo</span><span class="hljs-params">( std::<span class="hljs-type">byte</span> &amp;b, uint32_t &amp;ui )</span> {
    b = static_cast&lt;std::<span class="hljs-type">byte</span>&gt;(<span class="hljs-string">'a'</span>);
    ui = <span class="hljs-number">0xFFFFFFFF</span>;
  
    <span class="hljs-keyword">return</span> std::to_integer&lt;<span class="hljs-type">int</span>&gt;( b );  <span class="hljs-comment">// b gives us a glvalue expression of type std::byte which can alias</span>
                                       <span class="hljs-comment">// an object of type uint32_t</span>
}
</code></pre>
<p>Worth noting <em>signed char</em> is not included in the list above, this is a notable difference from <em>C</em> which says <em>a character type</em>.</p>
<h2>What is Type Punning</h2>
<p>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to <em>type pun</em>, often the methods used violate strict aliasing rules.</p>
<p>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called <em>type punning</em>, to reinterpret a segment of memory as another type. <em>Type punning</em> is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc</p>
<p>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;

<span class="hljs-comment">// In C</span>
<span class="hljs-type">float</span> *fp = (<span class="hljs-type">float</span>*)&amp;x;  <span class="hljs-comment">// Not a valid aliasing</span>

<span class="hljs-comment">// In C++</span>
<span class="hljs-type">float</span> *fp = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">float</span>*&gt;(&amp;x);  <span class="hljs-comment">// Not a valid aliasing</span>

<span class="hljs-built_in">printf</span>( <span class="hljs-string">"%f\n"</span>, *fp );
</code></pre>
<p>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but <em>undefined behavior</em> in C++ (<a href="https://wandbox.org/permlink/oOf9bPlcWDYrYqPF" rel="nofollow noreferrer">see live example</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">union</span> <span class="hljs-title class_">u1</span>
{
    <span class="hljs-type">int</span> n;
    <span class="hljs-type">float</span> f;
};

<span class="hljs-keyword">union</span> <span class="hljs-title class_">u1</span> u;
u.f = <span class="hljs-number">1.0f</span>;

<span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d\n"</span>, u.n );  <span class="hljs-comment">// UB in C++ n is not the active member</span>
</code></pre>
<p>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</p>
<h3>How do we Type Pun correctly?</h3>
<p>The standard method for <em>type punning</em> in both C and C++ is <strong>memcpy</strong>. This may seem a little heavy handed but the optimizer should recognize the use of <strong>memcpy</strong> for <em>type punning</em> and optimize it away and generate a register to register move. For example if we know <em>int64_t</em> is the same size as <em>double</em>:</p>
<pre class="default s-code-block"><code class="hljs language-csharp">static_assert( <span class="hljs-keyword">sizeof</span>( <span class="hljs-built_in">double</span> ) == <span class="hljs-keyword">sizeof</span>( int64_t ) );  <span class="hljs-comment">// C++17 does not require a message</span>
</code></pre>
<p>we can use <strong>memcpy</strong>:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">( <span class="hljs-type">double</span> d )</span> </span>{
    std::<span class="hljs-type">int64_t</span> n;
    std::<span class="hljs-built_in">memcpy</span>(&amp;n, &amp;d, <span class="hljs-keyword">sizeof</span> d);
    <span class="hljs-comment">//...</span>
</code></pre>
<p>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned <strong>reinterpret_cast</strong> method or <em>union</em> method for <em>type punning</em>. Examining the generated code we see it uses just register mov (<a href="https://godbolt.org/g/BfZGwX" rel="nofollow noreferrer">live Compiler Explorer Example</a>).</p>
<h2>C++20 and bit_cast</h2>
<p>In C++20 we may gain <strong>bit_cast</strong> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html" rel="nofollow noreferrer">implementation available in link from proposal</a>) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</p>
<p>The following is an example of how to use <strong>bit_cast</strong> to type pun a <em>unsigned int</em> to <em>float</em>, (<a href="https://wandbox.org/permlink/i5l0g4IYuCFgLzzl" rel="nofollow noreferrer">see it live</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp">std::cout &lt;&lt; <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">0x447a0000</span>) &lt;&lt; <span class="hljs-string">"\n"</span>; <span class="hljs-comment">//assuming sizeof(float) == sizeof(unsigned int)</span>
</code></pre>
<p>In the case where <em>To</em> and <em>From</em> types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a <strong>sizeof( unsigned int )</strong> character array (<em>assumes 4 byte unsigned int</em>) to be the <em>From</em> type and <em>unsigned int</em> as the <em>To</em> type.:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">uint_chars</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> arr[<span class="hljs-built_in">sizeof</span>( <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )] = {};  <span class="hljs-comment">// Assume sizeof( unsigned int ) == 4</span>
};

<span class="hljs-comment">// Assume len is a multiple of 4 </span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">size_t</span> len )</span> </span>{
    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span>( <span class="hljs-type">size_t</span> index = <span class="hljs-number">0</span>; index &lt; len; index += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) ) {
        uint_chars f;
        std::<span class="hljs-built_in">memcpy</span>( f.arr, &amp;p[index], <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>));
        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(f);

        result += <span class="hljs-built_in">foo</span>( result );
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>It is unfortunate that we need this intermediate type but that is the current constraint of <strong>bit_cast</strong>.</p>
<h2>Catching Strict Aliasing Violations</h2>
<p>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</p>
<p>gcc using the flag <strong>-fstrict-aliasing</strong> and <strong>-Wstrict-aliasing</strong> can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (<a href="https://wandbox.org/permlink/cfckjTgwNTYHDIry" rel="nofollow noreferrer">see it live</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;
<span class="hljs-type">short</span> j;
<span class="hljs-type">float</span> f = <span class="hljs-number">1.f</span>; <span class="hljs-comment">// Originally not initialized but tis-kernel caught </span>
               <span class="hljs-comment">// it was being accessed w/ an indeterminate value below</span>

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">short</span>*&gt;(&amp;a)));
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;f)));
</code></pre>
<p>although it will not catch this additional case (<a href="https://wandbox.org/permlink/dwd9jhy53AF7a2D0" rel="nofollow noreferrer">see it live</a>):</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> *p;

p = &amp;a;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">short</span>*&gt;(p)));
</code></pre>
<p>Although clang allows these flags it apparently does not actually implement the warnings.</p>
<p>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using <strong>-fsanitize=address</strong></p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];               <span class="hljs-comment">// 8 bytes: [0,7].</span>
<span class="hljs-type">int</span> *u = (<span class="hljs-type">int</span>*)((<span class="hljs-type">char</span>*)x + <span class="hljs-number">6</span>);     <span class="hljs-comment">// regardless of alignment of x this will not be an aligned address</span>
*u = <span class="hljs-number">1</span>;                            <span class="hljs-comment">// Access to range [6-9]</span>
<span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d\n"</span>, *u );              <span class="hljs-comment">// Access to range [6-9]</span>
</code></pre>
<p>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using <strong>-Wold-style-cast</strong>. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</p>
<p>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C version of the earlier example where using <strong>-fstrict-aliasing</strong> misses one case (<a href="https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY" rel="nofollow noreferrer">see it live</a>)</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;
<span class="hljs-type">short</span> j;
<span class="hljs-type">float</span> f = <span class="hljs-number">1.0</span>;

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *((<span class="hljs-type">short</span>*)&amp;a));
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *((<span class="hljs-type">int</span>*)&amp;f));
    
<span class="hljs-type">int</span> *p;

p = &amp;a;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, j = *((<span class="hljs-type">short</span>*)p));
</code></pre>
<p>tis-interpeter is able to catch all three, the following example invokes tis-kernel as tis-interpreter (output is edited for brevity):</p>
<pre class="default s-code-block"><code class="hljs language-csharp">./bin/tis-kernel -sa example1.c 
...
example1.c:<span class="hljs-number">9</span>:[sa] warning: <span class="hljs-function">The <span class="hljs-title">pointer</span> (<span class="hljs-params"><span class="hljs-built_in">short</span> *</span>)(<span class="hljs-params">&amp; a</span>) has type <span class="hljs-built_in">short</span> *. It violates strict aliasing
              rules <span class="hljs-keyword">by</span> accessing a cell <span class="hljs-keyword">with</span> effective type <span class="hljs-built_in">int</span>.
...

example1.c:10:[sa] warning: The <span class="hljs-title">pointer</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> *</span>)(<span class="hljs-params">&amp; f</span>) has type <span class="hljs-built_in">int</span> *. It violates strict aliasing rules <span class="hljs-keyword">by</span>
              accessing a cell <span class="hljs-keyword">with</span> effective type <span class="hljs-built_in">float</span>.
              Callstack: main
...

example1.c:15:[sa] warning: The <span class="hljs-title">pointer</span> (<span class="hljs-params"><span class="hljs-built_in">short</span> *</span>)p has type <span class="hljs-built_in">short</span> *. It violates strict aliasing rules <span class="hljs-keyword">by</span>
              accessing a cell <span class="hljs-keyword">with</span> effective type <span class="hljs-built_in">int</span>.
</span></code></pre>
<p>Finally there is <a href="https://www.youtube.com/watch?v=vAXJeN7k32Y" rel="nofollow noreferrer">TySan</a> which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is the strict aliasing rule, found in section 3.10 of the <strong>C++03</strong> standard (other answers provide good explanation, but none provided the rule itself):</p>
<blockquote>
<p>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</p>
<ul>
<li>the dynamic type of the object,</li>
<li>a cv-qualified version of the dynamic type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>
<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</li>
<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>
<li>a <code>char</code> or <code>unsigned char</code> type.</li>
</ul>
</blockquote>
<p><strong>C++11</strong> and <strong>C++14</strong> wording (changes emphasized):</p>
<blockquote>
<p>If a program attempts to access the stored value of an object through a <em>glvalue</em> of other than one of the following types the behavior is undefined:</p>
<ul>
<li>the dynamic type of the object,</li>
<li>a cv-qualified version of the dynamic type of the object,</li>
<li><em>a type similar (as defined in 4.4) to the dynamic type of the object,</em></li>
<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>
<li>an aggregate or union type that includes one of the aforementioned types among its <em>elements or non-static data members</em> (including, recursively, an <em>element or non-static data member</em> of a subaggregate or contained union),</li>
<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>
<li>a <code>char</code> or <code>unsigned char</code> type.</li>
</ul>
</blockquote>
<p>Two changes were small: <em>glvalue</em> instead of <em>lvalue</em>, and clarification of the aggregate/union case.</p>
<p>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of <em>similar types</em> that are now safe to alias.</p>
<hr>
<p>Also the <strong>C</strong> wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 §6.5 ¶7):</p>
<blockquote>
<p>An object shall have its stored value accessed only by an lvalue
expression that has one of the following types <sup> 73) or 88)</sup>:</p>
<ul>
<li>a type compatible with the effective type of the object,</li>
<li>a qualied version of a type compatible with the effective type of
the object,</li>
<li>a type that is the signed or unsigned type corresponding to the
effective type of the object,</li>
<li>a type that is the signed or unsigned type corresponding to a
qualied version of the effective type of the object,</li>
<li>an aggregate or union type that includes one of the aforementioned
types among its members (including, recursively, a member of a
subaggregate or contained union), or</li>
<li>a character type.</li>
</ul>
<p><sup> 73) or 88)</sup> The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>
</blockquote>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. <a href="http://dbp-consulting.com/tutorials/StrictAliasing.html">Strict Aliasing White Paper</a>.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</p>

<p>check.c</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">short</span> *h,<span class="hljs-type">long</span> *k)</span>
</span>{
    *h=<span class="hljs-number">5</span>;
    *k=<span class="hljs-number">6</span>;
    <span class="hljs-keyword">if</span> (*h == <span class="hljs-number">5</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"strict aliasing problem\n"</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">long</span>      k[<span class="hljs-number">1</span>];
    <span class="hljs-built_in">check</span>((<span class="hljs-type">short</span> *)k,k);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile with <code>gcc -O2 -o check check.c</code> .
Usually (with most gcc versions I tried) this outputs "strict aliasing problem", because the compiler assumes that "h" cannot be the same address as "k" in the "check" function. Because of that the compiler optimizes the <code>if (*h == 5)</code> away and always calls the printf.</p>

<p>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</p>

<pre class="default s-code-block"><code class="hljs language-perl">movw    $5, (%rdi)
movq    $6, (%rsi)
movl    $.LC<span class="hljs-number">0</span>, %edi
jmp puts
</code></pre>

<p>So the if condition is completely gone from the assembler code.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-built_in">int</span> x;
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> *p</span>)</span>
{
  x=<span class="hljs-number">5</span>;
  *p = <span class="hljs-number">1.0</span>;
  <span class="hljs-keyword">return</span> x;
}
</code></pre>

<p>should be required to reload the value of <code>x</code> between the assignment and return statement so as to allow for the possibility that <code>p</code> might point to <code>x</code>, and the assignment to <code>*p</code> might consequently alter the value of <code>x</code>.  The notion that a compiler should be entitled to presume that there won't be aliasing <em>in situations like the above</em> was non-controversial.</p>

<p>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>
{
  <span class="hljs-keyword">struct</span> S {<span class="hljs-built_in">int</span> x;} s;
  s.x = <span class="hljs-number">1</span>;
}
</code></pre>

<p>because it uses an lvalue of type <code>int</code> to access an object of type <code>struct S</code>, and <code>int</code> is not among the types that may be used accessing a <code>struct S</code>.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</p>

<p>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *ip, <span class="hljs-type">double</span> *dp)</span>
</span>{
  *ip = <span class="hljs-number">1</span>;
  *dp = <span class="hljs-number">1.23</span>;
  <span class="hljs-keyword">return</span> *ip;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
  <span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> { <span class="hljs-type">int</span> i; <span class="hljs-type">double</span> d; } u;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">test</span>(&amp;u.i, &amp;u.d);
}
</code></pre>

<p>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type "double" and reading one of type "int" invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</p>

<p>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc_int</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> *p</span>)</span> { *p = <span class="hljs-number">3</span>; }
 <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>
 {
   <span class="hljs-built_in">int</span> *p;
   <span class="hljs-keyword">struct</span> S { <span class="hljs-built_in">int</span> x; } s;
   s.x = <span class="hljs-number">1</span>;
   p = &amp;s.x;
   inc_int(p);
   <span class="hljs-keyword">return</span> s.x;
 }
</code></pre>

<p>There's no conflict within <code>inc_int</code> because all accesses to the storage accessed through <code>*p</code> are done with an lvalue of type <code>int</code>, and there's no conflict in <code>test</code> because <code>p</code> is visibly derived from a <code>struct S</code>, and by the next time <code>s</code> is used, all accesses to that storage that will ever be made through <code>p</code> will have already happened.</p>

<p>If the code were changed slightly...</p>

<pre class="default s-code-block"><code class="hljs language-csharp"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc_int</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> *p</span>)</span> { *p = <span class="hljs-number">3</span>; }
 <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>
 {
   <span class="hljs-built_in">int</span> *p;
   <span class="hljs-keyword">struct</span> S { <span class="hljs-built_in">int</span> x; } s;
   p = &amp;s.x;
   s.x = <span class="hljs-number">1</span>;  <span class="hljs-comment">//  !!*!!</span>
   *p += <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> s.x;
 }
</code></pre>

<p>Here, there is an aliasing conflict between <code>p</code> and the access to <code>s.x</code> on the marked line because at that point in execution another reference exists <em>that will be used to access the same storage</em>.</p>

<p>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add "Effective Types" or other such complexity.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://en.wikipedia.org/wiki/Type_punning" rel="noreferrer">Type punning</a> via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>After reading many of the answers, I feel the need to add something:</p>

<p>Strict aliasing (which I'll describe in a bit) <strong>is important because</strong>:</p>

<ol>
<li><p>Memory access can be expensive (performance wise), which is why <strong>data is manipulated in CPU registers</strong> before being written back to the physical memory.</p></li>
<li><p>If data in two different CPU registers will be written to the same memory space, <strong>we can't predict which data will "survive"</strong> when we code in C.</p>

<p>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</p></li>
</ol>

<p>Since two pointers can point to the same location in the memory, this could result in <strong>complex code that handles possible collisions</strong>.</p>

<p>This extra code is slow and <strong>hurts performance</strong> since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</p>

<p>The <strong>Strict aliasing rule allows us to avoid redundant machine code</strong> in cases in which it <em>should be</em> safe to assume that two pointers don't point to the same memory block (see also the <code>restrict</code> keyword).</p>

<p>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</p>

<p>If a compiler notices that two pointers point to different types (for example, an <code>int *</code> and a <code>float *</code>), it will assume the memory address is different and it <strong>will not</strong> protect against memory address collisions, resulting in faster machine code.</p>

<p><strong>For example</strong>:</p>

<p>Lets assume the following function:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_two_ints</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> *a, <span class="hljs-built_in">int</span> *b</span>)</span> {
  *b += *a;
  *a += *b;
}
</code></pre>

<p>In order to handle the case in which <code>a == b</code> (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</p>

<ol>
<li><p>load <code>a</code> and <code>b</code> from memory.</p></li>
<li><p>add <code>a</code> to <code>b</code>.</p></li>
<li><p><strong>save</strong> <code>b</code> and <strong>reload</strong> <code>a</code>.</p>

<p>(save from CPU register to the memory and load from the memory to the CPU register). </p></li>
<li><p>add <code>b</code> to <code>a</code>.</p></li>
<li><p>save <code>a</code> (from the CPU register) to the memory.</p></li>
</ol>

<p>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where <code>a</code> and <code>b</code> point to the same memory address.</p>

<p>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</p>

<ol>
<li><p>This can be told to the compiler in two ways, by using different types to point to. i.e.:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_two_numbers</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> *a, <span class="hljs-built_in">long</span> *b</span>)</span> {...}
</code></pre></li>
<li><p>Using the <code>restrict</code> keyword. i.e.:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_two_ints</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> * restrict a, <span class="hljs-built_in">int</span> * restrict b</span>)</span> {...}
</code></pre></li>
</ol>

<p>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</p>

<p>In fact, by adding the <code>restrict</code> keyword, the whole function could be optimized to:</p>

<ol>
<li><p>load <code>a</code> and <code>b</code> from memory.</p></li>
<li><p>add <code>a</code> to <code>b</code>.</p></li>
<li><p>save result both to <code>a</code> and to <code>b</code>.</p></li>
</ol>

<p>This optimization couldn't have been done before, because of the possible collision (where <code>a</code> and <code>b</code> would be tripled instead of doubled).</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Strict aliasing is not allowing different pointer types to the same data.</p>

<p><a href="http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html" rel="noreferrer">This article</a> should help you understand the issue in full detail.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Technically in C++, the strict aliasing rule is probably never applicable.</p>

<p>Note the definition of indirection (<a href="http://eel.is/c++draft/expr.unary.op#def:indirection" rel="nofollow noreferrer">* operator</a>):</p>

<blockquote>
  <p>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and <strong>the result is an lvalue referring to the object</strong> or
  function <strong>to which the expression points</strong>.</p>
</blockquote>

<p>Also from <a href="http://eel.is/c++draft/basic.lval#1.1" rel="nofollow noreferrer">the definition of glvalue</a></p>

<blockquote>
  <p>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</p>
</blockquote>

<p>So in any well defined program trace, a glvalue refers to an object. <strong>So the so called strict aliasing rule doesn't apply, ever.</strong> This may not be what the designers wanted.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;A typical situation where you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to \u0026lt;code\u0026gt;uint32_t\u0026lt;/code\u0026gt;s or \u0026lt;code\u0026gt;uint16_t\u0026lt;/code\u0026gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So in this kind of setup, if I want to send a message to something I\u0026apos;d have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Msg\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b;\n} Msg;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SendWord\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;uint32_t\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get a 32-bit buffer from the system\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;uint32_t\u0026lt;/span\u0026gt;* buff = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Msg));\n    \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Alias that buffer through message\u0026lt;/span\u0026gt;\n    Msg* msg = (Msg*)(buff);\n    \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Send a bunch of messages    \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; ++i)\n    {\n        msg-\u0026amp;gt;a = i;\n        msg-\u0026amp;gt;b = i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SendWord\u0026lt;/span\u0026gt;(buff[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SendWord\u0026lt;/span\u0026gt;(buff[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);   \n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/language/type\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;compatible type\u0026lt;/a\u0026gt; or one of the other types allowed by C 2011 6.5 paragraph 7\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; is undefined behavior. Unfortunately, you can still code this way, \u0026lt;em\u0026gt;maybe\u0026lt;/em\u0026gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn\u0026apos;t have to think about inserting instructions to refresh the contents of \u0026lt;code\u0026gt;buff\u0026lt;/code\u0026gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load \u0026lt;code\u0026gt;buff[0]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;buff[1]\u0026lt;/code\u0026gt; into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of \u0026lt;code\u0026gt;buff\u0026lt;/code\u0026gt; could change by any preceding memory stores. So to get an extra performance edge, and assuming most people don\u0026apos;t type-pun pointers, the strict aliasing rule was introduced.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Keep in mind, if you think the example is contrived, this might even happen if you\u0026apos;re passing a buffer to another function doing the sending for you, if instead you have.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SendMessage\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;uint32_t\u0026lt;/span\u0026gt;* buff, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size32)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; size32; ++i) \n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SendWord\u0026lt;/span\u0026gt;(buff[i]);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And rewrote our earlier loop to take advantage of this convenient function\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-erlang\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(int i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; ++i)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;msg\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt;a = i;\n    msg-\u0026amp;gt;b = i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    SendMessage(buff, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If \u0026lt;code\u0026gt;SendMessage\u0026lt;/code\u0026gt; is part of another API that\u0026apos;s compiled separately, it probably has instructions to load buff\u0026apos;s contents. Then again, maybe you\u0026apos;re in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it\u0026apos;s just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what\u0026apos;s happening under the hood, it\u0026apos;s still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn\u0026apos;t necessarily help.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So how do I get around this?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-objectivec\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;union\u0026lt;/span\u0026gt; {\n      Msg msg;\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; asBuffer[\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Msg)/\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)];\n  };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;You can disable strict aliasing in your compiler (\u0026lt;a href=\u0026quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;f[no-]strict-aliasing\u0026lt;/a\u0026gt; in gcc))\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; for aliasing instead of your system\u0026apos;s word. The rules allow an exception for \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; (including \u0026lt;code\u0026gt;signed char\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;unsigned char\u0026lt;/code\u0026gt;). It\u0026apos;s always assumed that \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; aliases other types. However this won\u0026apos;t work the other way: there\u0026apos;s no assumption that your struct aliases a buffer of chars.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Beginner beware\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is only one potential minefield when overlaying two types onto each other. You should also learn about \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Endianness\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;endianness\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;word alignment\u0026lt;/a\u0026gt;, and how to deal with alignment issues through \u0026lt;a href=\u0026quot;http://grok2.com/structure_packing.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;packing structs\u0026lt;/a\u0026gt; correctly.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Footnote\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; The types that C 2011 6.5 7 allows an lvalue to access are:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a type compatible with the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a qualified version of a type compatible with the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a character type.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best explanation I have found is by Mike Acton, \u0026lt;a href=\u0026quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Understanding Strict Aliasing\u0026lt;/a\u0026gt;. It\u0026apos;s focused a little on PS3 development, but that\u0026apos;s basically just GCC.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From the article:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So basically if you have an \u0026lt;code\u0026gt;int*\u0026lt;/code\u0026gt; pointing to some memory containing an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and then you point a \u0026lt;code\u0026gt;float*\u0026lt;/code\u0026gt; to that memory and use it as a \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; you break the rule. If your code does not respect this, then the compiler\u0026apos;s optimizer will most likely break your code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The exception to the rule is a \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt;, which is allowed to point to any type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Note\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;This is excerpted from my \u0026lt;a href=\u0026quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026quot;What is the Strict Aliasing Rule and Why do we care?\u0026quot;\u0026lt;/a\u0026gt; write-up.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;What is strict aliasing?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term \u0026lt;em\u0026gt;strict aliasing rule\u0026lt;/em\u0026gt;. If we attempt to access a value using a type not allowed it is classified as \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/language/ub\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt; (\u0026lt;strong\u0026gt;UB\u0026lt;/strong\u0026gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Preliminary examples\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;live example\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ip = \u0026amp;amp;x;\n\nstd::cout \u0026amp;lt;\u0026amp;lt; *ip \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n*ip = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;;\nstd::cout \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We have a \u0026lt;em\u0026gt;int*\u0026lt;/em\u0026gt; pointing to memory occupied by an \u0026lt;em\u0026gt;int\u0026lt;/em\u0026gt; and this is a valid aliasing. The optimizer must assume that assignments through \u0026lt;strong\u0026gt;ip\u0026lt;/strong\u0026gt; could update the value occupied by \u0026lt;strong\u0026gt;x\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The next example shows aliasing that leads to undefined behavior (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;live example\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; *f, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *i )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n    *i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    *f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.f\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *i;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \n    std::cout \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Expect 0\u0026lt;/span\u0026gt;\n    x = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;*\u0026amp;gt;(\u0026amp;amp;x), \u0026amp;amp;x);\n    std::cout \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Expect 0?\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the function \u0026lt;strong\u0026gt;foo\u0026lt;/strong\u0026gt; we take an \u0026lt;em\u0026gt;int*\u0026lt;/em\u0026gt; and a \u0026lt;em\u0026gt;float*\u0026lt;/em\u0026gt;, in this example we call \u0026lt;strong\u0026gt;foo\u0026lt;/strong\u0026gt; and set both parameters to point to the same memory location which in this example contains an \u0026lt;em\u0026gt;int\u0026lt;/em\u0026gt;. Note, the \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/a\u0026gt; is telling the compiler to treat the expression as if it had the type specified by its template parameter. In this case we are telling it to treat the expression \u0026lt;strong\u0026gt;\u0026amp;amp;x\u0026lt;/strong\u0026gt; as if it had type \u0026lt;em\u0026gt;float*\u0026lt;/em\u0026gt;. We may naively expect the result of the second \u0026lt;strong\u0026gt;cout\u0026lt;/strong\u0026gt; to be \u0026lt;strong\u0026gt;0\u0026lt;/strong\u0026gt; but with optimization enabled using \u0026lt;strong\u0026gt;-O2\u0026lt;/strong\u0026gt; both gcc and clang produce the following result:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-undefined\u0026quot;\u0026gt;0\n1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Which may not be expected but is perfectly valid since we have invoked undefined behavior. A \u0026lt;em\u0026gt;float\u0026lt;/em\u0026gt; can not validly alias an \u0026lt;em\u0026gt;int\u0026lt;/em\u0026gt; object. Therefore the optimizer can assume the \u0026lt;em\u0026gt;constant 1\u0026lt;/em\u0026gt; stored when dereferencing \u0026lt;strong\u0026gt;i\u0026lt;/strong\u0026gt; will be the return value since a store through \u0026lt;strong\u0026gt;f\u0026lt;/strong\u0026gt; could not validly affect an \u0026lt;em\u0026gt;int\u0026lt;/em\u0026gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(\u0026lt;a href=\u0026quot;https://godbolt.org/g/yNV5aj\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;live example\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;foo(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;): # \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;@foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;)\nmov dword ptr [rsi], \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nmov dword ptr [rdi], \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nmov eax, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The optimizer using \u0026lt;a href=\u0026quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Type-Based Alias Analysis (TBAA)\u0026lt;/a\u0026gt; assumes \u0026lt;strong\u0026gt;1\u0026lt;/strong\u0026gt; will be returned and directly moves the constant value into register \u0026lt;strong\u0026gt;eax\u0026lt;/strong\u0026gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a \u0026lt;em\u0026gt;float\u0026lt;/em\u0026gt; can not alias an \u0026lt;em\u0026gt;int\u0026lt;/em\u0026gt; and optimizes away the load of \u0026lt;strong\u0026gt;i\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Now, to the Rule-Book\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;What does the C11 standard say?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;C11\u0026lt;/strong\u0026gt; standard says the following in section \u0026lt;em\u0026gt;6.5 Expressions paragraph 7\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An object shall have its stored value accessed only by an lvalue expression that has one of the following types:\u0026lt;sup\u0026gt;88)\u0026lt;/sup\u0026gt;\n a type compatible with the effective type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p = \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, *p); \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt; *p gives us an lvalue expression of type \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; which is compatible with \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt; a qualified version of a type compatible with the effective type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p = \u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, *p); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *p gives us an lvalue expression of type const int which is compatible with int\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt; a type that is the signed or unsigned type corresponding to the effective type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)\u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%u\\n\u0026quot;\u0026lt;/span\u0026gt;, *p ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *p gives us an lvalue expression of type unsigned int which corresponds to \u0026lt;/span\u0026gt;\n                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the effective type of the object\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://twitter.com/shafikyaghmour/status/957702383810658304\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;gcc/clang has an extension\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;also\u0026lt;/a\u0026gt; that allows assigning \u0026lt;em\u0026gt;unsigned int*\u0026lt;/em\u0026gt; to \u0026lt;em\u0026gt;int*\u0026lt;/em\u0026gt; even though they are not compatible types.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)\u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%u\\n\u0026quot;\u0026lt;/span\u0026gt;, *p ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *p gives us an lvalue expression of type const unsigned int which is a unsigned type \u0026lt;/span\u0026gt;\n                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// that corresponds with to a qualified version of the effective type of the object\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n};\n    \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foobar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo *fp, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ip \u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// struct foo is an aggregate that includes int among its members so it\u0026lt;/span\u0026gt;\n                                         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// can alias with *ip\u0026lt;/span\u0026gt;\n\nfoo f;\nfoobar( \u0026amp;amp;f, \u0026amp;amp;f.x );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt; a character type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *)\u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\\n\u0026quot;\u0026lt;/span\u0026gt;, *p );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *p gives us an lvalue expression of type char which is a character type.\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The results are not portable due to endianness issues.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;What the C++17 Draft Standard says\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The C++17 draft standard in section \u0026lt;em\u0026gt;[basic.lval] paragraph 11\u0026lt;/em\u0026gt; says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:\u0026lt;sup\u0026gt;63\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.1)  the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We have allocated storage but not started the lifetime of an object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ip = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; (p) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;};        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Placement new changes the dynamic type of the object to int\u0026lt;/span\u0026gt;\nstd::cout \u0026amp;lt;\u0026amp;lt; *ip \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *ip gives us a glvalue expression of type int which matches the dynamic type \u0026lt;/span\u0026gt;\n                                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// of the allocated object\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.2)  a cv-qualified version of the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *cip = \u0026amp;amp;x;\nstd::cout \u0026amp;lt;\u0026amp;lt; *cip \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// *cip gives us a glvalue expression of type const int which is a cv-qualified \u0026lt;/span\u0026gt;\n                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// version of the dynamic type of x\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.3)  a type similar (as defined in 7.5) to the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.4)  a type that is the signed or unsigned type corresponding to the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Both si and ui are signed or unsigned types corresponding to each others dynamic types\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;signed\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;signed\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;si, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;ui )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    si = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    ui = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; si;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.5)  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;signed\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;signed\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;si1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;si2)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hard to show this one assumes aliasing\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.6)  an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foobar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; foo \u0026amp;amp;fp, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;ip \u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    fp.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    ip = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.7)  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; bar : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; foo {};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foobar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; foo \u0026amp;amp;f, bar \u0026amp;amp;b \u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    f.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    b.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; f.x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(11.8)  a char, unsigned char, or std::byte type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt; \u0026amp;amp;b, uint32_t \u0026amp;amp;ui )\u0026lt;/span\u0026gt; {\n    b = static_cast\u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;);\n    ui = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xFFFFFFFF\u0026lt;/span\u0026gt;;\n  \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::to_integer\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;( b );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b gives us a glvalue expression of type std::byte which can alias\u0026lt;/span\u0026gt;\n                                       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// an object of type uint32_t\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Worth noting \u0026lt;em\u0026gt;signed char\u0026lt;/em\u0026gt; is not included in the list above, this is a notable difference from \u0026lt;em\u0026gt;C\u0026lt;/em\u0026gt; which says \u0026lt;em\u0026gt;a character type\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;What is Type Punning\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to \u0026lt;em\u0026gt;type pun\u0026lt;/em\u0026gt;, often the methods used violate strict aliasing rules.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Sometimes we want to circumvent the type system and interpret an object as a different type. This is called \u0026lt;em\u0026gt;type punning\u0026lt;/em\u0026gt;, to reinterpret a segment of memory as another type. \u0026lt;em\u0026gt;Type punning\u0026lt;/em\u0026gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// In C\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; *fp = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;*)\u0026amp;amp;x;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not a valid aliasing\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// In C++\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; *fp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;*\u0026amp;gt;(\u0026amp;amp;x);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not a valid aliasing\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%f\\n\u0026quot;\u0026lt;/span\u0026gt;, *fp );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; in C++ (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;see live example\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;union\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;u1\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; f;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;union\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;u1\u0026lt;/span\u0026gt; u;\nu.f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.0f\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u.n );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB in C++ n is not the active member\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;How do we Type Pun correctly?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The standard method for \u0026lt;em\u0026gt;type punning\u0026lt;/em\u0026gt; in both C and C++ is \u0026lt;strong\u0026gt;memcpy\u0026lt;/strong\u0026gt;. This may seem a little heavy handed but the optimizer should recognize the use of \u0026lt;strong\u0026gt;memcpy\u0026lt;/strong\u0026gt; for \u0026lt;em\u0026gt;type punning\u0026lt;/em\u0026gt; and optimize it away and generate a register to register move. For example if we know \u0026lt;em\u0026gt;int64_t\u0026lt;/em\u0026gt; is the same size as \u0026lt;em\u0026gt;double\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;static_assert( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; ) == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;( int64_t ) );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C++17 does not require a message\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;we can use \u0026lt;strong\u0026gt;memcpy\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int64_t\u0026lt;/span\u0026gt; n;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memcpy\u0026lt;/span\u0026gt;(\u0026amp;amp;n, \u0026amp;amp;d, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; d);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned \u0026lt;strong\u0026gt;reinterpret_cast\u0026lt;/strong\u0026gt; method or \u0026lt;em\u0026gt;union\u0026lt;/em\u0026gt; method for \u0026lt;em\u0026gt;type punning\u0026lt;/em\u0026gt;. Examining the generated code we see it uses just register mov (\u0026lt;a href=\u0026quot;https://godbolt.org/g/BfZGwX\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;live Compiler Explorer Example\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;C++20 and bit_cast\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In C++20 we may gain \u0026lt;strong\u0026gt;bit_cast\u0026lt;/strong\u0026gt; (\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;implementation available in link from proposal\u0026lt;/a\u0026gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following is an example of how to use \u0026lt;strong\u0026gt;bit_cast\u0026lt;/strong\u0026gt; to type pun a \u0026lt;em\u0026gt;unsigned int\u0026lt;/em\u0026gt; to \u0026lt;em\u0026gt;float\u0026lt;/em\u0026gt;, (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;see it live\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bit_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x447a0000\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//assuming sizeof(float) == sizeof(unsigned int)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the case where \u0026lt;em\u0026gt;To\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;From\u0026lt;/em\u0026gt; types don\u0026apos;t have the same size, it requires us to use an intermediate struct15. We will use a struct containing a \u0026lt;strong\u0026gt;sizeof( unsigned int )\u0026lt;/strong\u0026gt; character array (\u0026lt;em\u0026gt;assumes 4 byte unsigned int\u0026lt;/em\u0026gt;) to be the \u0026lt;em\u0026gt;From\u0026lt;/em\u0026gt; type and \u0026lt;em\u0026gt;unsigned int\u0026lt;/em\u0026gt; as the \u0026lt;em\u0026gt;To\u0026lt;/em\u0026gt; type.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;uint_chars\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; )] = {};  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assume sizeof( unsigned int ) == 4\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assume len is a multiple of 4 \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; index = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; index \u0026amp;lt; len; index += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) ) {\n        uint_chars f;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memcpy\u0026lt;/span\u0026gt;( f.arr, \u0026amp;amp;p[index], \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;));\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bit_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(f);\n\n        result += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( result );\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It is unfortunate that we need this intermediate type but that is the current constraint of \u0026lt;strong\u0026gt;bit_cast\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Catching Strict Aliasing Violations\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;We don\u0026apos;t have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;gcc using the flag \u0026lt;strong\u0026gt;-fstrict-aliasing\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;-Wstrict-aliasing\u0026lt;/strong\u0026gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;see it live\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; j;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.f\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Originally not initialized but tis-kernel caught \u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// it was being accessed w/ an indeterminate value below\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;*\u0026amp;gt;(\u0026amp;amp;a)));\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;(\u0026amp;amp;f)));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;although it will not catch this additional case (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;see it live\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n\np = \u0026amp;amp;a;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;*\u0026amp;gt;(p)));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Although clang allows these flags it apparently does not actually implement the warnings.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using \u0026lt;strong\u0026gt;-fsanitize=address\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 8 bytes: [0,7].\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *u = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// regardless of alignment of x this will not be an aligned address\u0026lt;/span\u0026gt;\n*u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Access to range [6-9]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, *u );              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Access to range [6-9]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don\u0026apos;t allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using \u0026lt;strong\u0026gt;-Wold-style-cast\u0026lt;/strong\u0026gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C version of the earlier example where using \u0026lt;strong\u0026gt;-fstrict-aliasing\u0026lt;/strong\u0026gt; misses one case (\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;see it live\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; j;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;*)\u0026amp;amp;a));\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)\u0026amp;amp;f));\n    \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n\np = \u0026amp;amp;a;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i\\n\u0026quot;\u0026lt;/span\u0026gt;, j = *((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;*)p));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;tis-interpeter is able to catch all three, the following example invokes tis-kernel as tis-interpreter (output is edited for brevity):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;./bin/tis-kernel -sa example1.c \n...\nexample1.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;:[sa] warning: \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;The \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pointer\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026amp;amp; a\u0026lt;/span\u0026gt;) has type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *. It violates strict aliasing\n              rules \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;by\u0026lt;/span\u0026gt; accessing a cell \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; effective type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;.\n...\n\nexample1.c:10:[sa] warning: The \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pointer\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026amp;amp; f\u0026lt;/span\u0026gt;) has type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *. It violates strict aliasing rules \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;by\u0026lt;/span\u0026gt;\n              accessing a cell \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; effective type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pointer\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *\u0026lt;/span\u0026gt;)p has type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *. It violates strict aliasing rules \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;by\u0026lt;/span\u0026gt;\n              accessing a cell \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; effective type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;.\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Finally there is \u0026lt;a href=\u0026quot;https://www.youtube.com/watch?v=vAXJeN7k32Y\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;TySan\u0026lt;/a\u0026gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is the strict aliasing rule, found in section 3.10 of the \u0026lt;strong\u0026gt;C++03\u0026lt;/strong\u0026gt; standard (other answers provide good explanation, but none provided the rule itself):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a cv-qualified version of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;unsigned char\u0026lt;/code\u0026gt; type.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++11\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;C++14\u0026lt;/strong\u0026gt; wording (changes emphasized):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If a program attempts to access the stored value of an object through a \u0026lt;em\u0026gt;glvalue\u0026lt;/em\u0026gt; of other than one of the following types the behavior is undefined:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a cv-qualified version of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;a type similar (as defined in 4.4) to the dynamic type of the object,\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;an aggregate or union type that includes one of the aforementioned types among its \u0026lt;em\u0026gt;elements or non-static data members\u0026lt;/em\u0026gt; (including, recursively, an \u0026lt;em\u0026gt;element or non-static data member\u0026lt;/em\u0026gt; of a subaggregate or contained union),\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;unsigned char\u0026lt;/code\u0026gt; type.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Two changes were small: \u0026lt;em\u0026gt;glvalue\u0026lt;/em\u0026gt; instead of \u0026lt;em\u0026gt;lvalue\u0026lt;/em\u0026gt;, and clarification of the aggregate/union case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of \u0026lt;em\u0026gt;similar types\u0026lt;/em\u0026gt; that are now safe to alias.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Also the \u0026lt;strong\u0026gt;C\u0026lt;/strong\u0026gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 §6.5 ¶7):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An object shall have its stored value accessed only by an lvalue\nexpression that has one of the following types \u0026lt;sup\u0026gt; 73) or 88)\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a type compatible with the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a qualied version of a type compatible with the effective type of\nthe object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to the\neffective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a type that is the signed or unsigned type corresponding to a\nqualied version of the effective type of the object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;an aggregate or union type that includes one of the aforementioned\ntypes among its members (including, recursively, a member of a\nsubaggregate or contained union), or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a character type.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt; 73) or 88)\u0026lt;/sup\u0026gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Strict aliasing doesn\u0026apos;t refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. \u0026lt;a href=\u0026quot;http://dbp-consulting.com/tutorials/StrictAliasing.html\u0026quot;\u0026gt;Strict Aliasing White Paper\u0026lt;/a\u0026gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;check.c\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *h,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; *k)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    *h=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    *k=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*h == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;strict aliasing problem\\n\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;      k[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; *)k,k);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile with \u0026lt;code\u0026gt;gcc -O2 -o check check.c\u0026lt;/code\u0026gt; .\nUsually (with most gcc versions I tried) this outputs \u0026quot;strict aliasing problem\u0026quot;, because the compiler assumes that \u0026quot;h\u0026quot; cannot be the same address as \u0026quot;k\u0026quot; in the \u0026quot;check\u0026quot; function. Because of that the compiler optimizes the \u0026lt;code\u0026gt;if (*h == 5)\u0026lt;/code\u0026gt; away and always calls the printf.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;movw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, %edi\njmp puts\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So the if condition is completely gone from the assembler code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *p\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  x=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n  *p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;should be required to reload the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; between the assignment and return statement so as to allow for the possibility that \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; might point to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and the assignment to \u0026lt;code\u0026gt;*p\u0026lt;/code\u0026gt; might consequently alter the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.  The notion that a compiler should be entitled to presume that there won\u0026apos;t be aliasing \u0026lt;em\u0026gt;in situations like the above\u0026lt;/em\u0026gt; was non-controversial.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; S {\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;} s;\n  s.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;because it uses an lvalue of type \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; to access an object of type \u0026lt;code\u0026gt;struct S\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; is not among the types that may be used accessing a \u0026lt;code\u0026gt;struct S\u0026lt;/code\u0026gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ip, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *dp)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  *ip = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n  *dp = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.23\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *ip;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;union\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;U\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d; } u;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026amp;amp;u.i, \u0026amp;amp;u.d);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type \u0026quot;double\u0026quot; and reading one of type \u0026quot;int\u0026quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The best way to resolve the original problem would probably be to treat the\nfootnote about the purpose of the rule as though it were normative, and made\nthe rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;inc_int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { *p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; }\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n {\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; S { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; } s;\n   s.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   p = \u0026amp;amp;s.x;\n   inc_int(p);\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; s.x;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s no conflict within \u0026lt;code\u0026gt;inc_int\u0026lt;/code\u0026gt; because all accesses to the storage accessed through \u0026lt;code\u0026gt;*p\u0026lt;/code\u0026gt; are done with an lvalue of type \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, and there\u0026apos;s no conflict in \u0026lt;code\u0026gt;test\u0026lt;/code\u0026gt; because \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; is visibly derived from a \u0026lt;code\u0026gt;struct S\u0026lt;/code\u0026gt;, and by the next time \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is used, all accesses to that storage that will ever be made through \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; will have already happened.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the code were changed slightly...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;inc_int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { *p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; }\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n {\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *p;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; S { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; } s;\n   p = \u0026amp;amp;s.x;\n   s.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  !!*!!\u0026lt;/span\u0026gt;\n   *p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; s.x;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, there is an aliasing conflict between \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; and the access to \u0026lt;code\u0026gt;s.x\u0026lt;/code\u0026gt; on the marked line because at that point in execution another reference exists \u0026lt;em\u0026gt;that will be used to access the same storage\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add \u0026quot;Effective Types\u0026quot; or other such complexity.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Type_punning\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Type punning\u0026lt;/a\u0026gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;After reading many of the answers, I feel the need to add something:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Strict aliasing (which I\u0026apos;ll describe in a bit) \u0026lt;strong\u0026gt;is important because\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Memory access can be expensive (performance wise), which is why \u0026lt;strong\u0026gt;data is manipulated in CPU registers\u0026lt;/strong\u0026gt; before being written back to the physical memory.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If data in two different CPU registers will be written to the same memory space, \u0026lt;strong\u0026gt;we can\u0026apos;t predict which data will \u0026quot;survive\u0026quot;\u0026lt;/strong\u0026gt; when we code in C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Since two pointers can point to the same location in the memory, this could result in \u0026lt;strong\u0026gt;complex code that handles possible collisions\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This extra code is slow and \u0026lt;strong\u0026gt;hurts performance\u0026lt;/strong\u0026gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Strict aliasing rule allows us to avoid redundant machine code\u0026lt;/strong\u0026gt; in cases in which it \u0026lt;em\u0026gt;should be\u0026lt;/em\u0026gt; safe to assume that two pointers don\u0026apos;t point to the same memory block (see also the \u0026lt;code\u0026gt;restrict\u0026lt;/code\u0026gt; keyword).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Strict aliasing states it\u0026apos;s safe to assume that pointers to different types point to different locations in the memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If a compiler notices that two pointers point to different types (for example, an \u0026lt;code\u0026gt;int *\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;float *\u0026lt;/code\u0026gt;), it will assume the memory address is different and it \u0026lt;strong\u0026gt;will not\u0026lt;/strong\u0026gt; protect against memory address collisions, resulting in faster machine code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;For example\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lets assume the following function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;merge_two_ints\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *a, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *b\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n  *b += *a;\n  *a += *b;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In order to handle the case in which \u0026lt;code\u0026gt;a == b\u0026lt;/code\u0026gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;load \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; from memory.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;add \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;save\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; and \u0026lt;strong\u0026gt;reload\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(save from CPU register to the memory and load from the memory to the CPU register). \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;add \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;save \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; (from the CPU register) to the memory.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Step 3 is very slow because it needs to access the physical memory. However, it\u0026apos;s required to protect against instances where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; point to the same memory address.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can\u0026apos;t be performed if the pointers share a memory address).\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This can be told to the compiler in two ways, by using different types to point to. i.e.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;merge_two_numbers\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *a, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; *b\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {...}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Using the \u0026lt;code\u0026gt;restrict\u0026lt;/code\u0026gt; keyword. i.e.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;merge_two_ints\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * restrict a, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * restrict b\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {...}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, by adding the \u0026lt;code\u0026gt;restrict\u0026lt;/code\u0026gt; keyword, the whole function could be optimized to:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;load \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; from memory.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;add \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;save result both to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and to \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This optimization couldn\u0026apos;t have been done before, because of the possible collision (where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; would be tripled instead of doubled).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Strict aliasing is not allowing different pointer types to the same data.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;This article\u0026lt;/a\u0026gt; should help you understand the issue in full detail.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Technically in C++, the strict aliasing rule is probably never applicable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note the definition of indirection (\u0026lt;a href=\u0026quot;http://eel.is/c++draft/expr.unary.op#def:indirection\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;* operator\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and \u0026lt;strong\u0026gt;the result is an lvalue referring to the object\u0026lt;/strong\u0026gt; or\n  function \u0026lt;strong\u0026gt;to which the expression points\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Also from \u0026lt;a href=\u0026quot;http://eel.is/c++draft/basic.lval#1.1\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;the definition of glvalue\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A glvalue is an expression whose evaluation determines the identity of\n  an object, (...snip)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So in any well defined program trace, a glvalue refers to an object. \u0026lt;strong\u0026gt;So the so called strict aliasing rule doesn\u0026apos;t apply, ever.\u0026lt;/strong\u0026gt; This may not be what the designers wanted.\u0026lt;/p\u0026gt;\n    "],"id":140,"title":"What is the strict aliasing rule?","content":"\n                \n\u0026lt;p\u0026gt;When asking about \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into\u0026quot;\u0026gt;common undefined behavior in C\u0026lt;/a\u0026gt;, people sometimes refer to the strict aliasing rule.\u0026lt;br\u0026gt;\nWhat are they talking about?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-strict-aliasing-rule-1657384742852","postType":"QUESTION","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","tags":[{"id":511,"name":"strict-aliasing","slug":"strict-aliasing","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","Questions_Tags":{"questionId":140,"tagId":511}},{"id":512,"name":"type-punning","slug":"type-punning","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","Questions_Tags":{"questionId":140,"tagId":512}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-strict-aliasing-rule-1657384742852"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>