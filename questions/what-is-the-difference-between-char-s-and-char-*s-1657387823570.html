<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-bf26e92d2540e305.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_buildManifest.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570">What is the difference between char s[] and char *s?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/constants">constants</a></div></div><div class="question-content mt-5">
                
<p>In C, one can use a string literal in a declaration like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>or like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. </p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The difference here is that </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>will place <code>"Hello world"</code> in the <em>read-only parts of the memory</em>, and making <code>s</code> a pointer to that makes any writing operation on this memory illegal. </p>

<p>While doing:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">s[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>;
</code></pre>

<p>legal.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First off, in function arguments, they are exactly equivalent:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> *x)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> x[])</span>; <span class="hljs-comment">// exactly the same in all respects</span>
</code></pre>

<p>In other contexts, <code>char *</code> allocates a pointer, while <code>char []</code> allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"Foo"</span>;
<span class="hljs-comment">// is approximately equivalent to:</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> __secret_anonymous_array[] = <span class="hljs-string">"Foo"</span>;
<span class="hljs-type">char</span> *x = (<span class="hljs-type">char</span> *) __secret_anonymous_array;
</code></pre>

<p>Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// BAD. DON'T DO THIS.</span>
</code></pre>

<p>Using the array syntax directly allocates it into new memory. Thus modification is safe:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"Foo"</span>;
x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// No problem.</span>
</code></pre>

<p>However the array only lives as long as its contaning scope, so if you do this in a function, don't return or leak a pointer to this array - make a copy instead with <code>strdup()</code> or similar. If the array is allocated in global scope, of course, no problem.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>one</em> object - a <code>char</code> array of size 6, called <code>s</code>, initialised with the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it's outside a function, it will <em>probably</em> be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.</p>

<p>On the other hand, this declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s =<span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>two</em> objects:</p>

<ul>
<li>a <strong>read-only</strong> array of 6 <code>char</code>s containing the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>, which has no name and has <em>static storage duration</em> (meaning that it lives for the entire life of the program); and</li>
<li>a variable of type pointer-to-char, called <code>s</code>, which is initialised with the location of the first character in that unnamed, read-only array.</li>
</ul>

<p>The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the <code>s</code> pointer variable in memory depends on where the declaration appears (just like in the first example).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Given the declarations</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
<span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the <code>0x00</code> in the bottom right corner is at address <code>0x0001000C + 3</code> = <code>0x0001000F</code>):</p>
<pre>                     +0    +1    +2    +3
        0x00008000: 'h'   'e'   'l'   'l'
        0x00008004: 'o'   ' '   'w'   'o'
        0x00008008: 'r'   'l'   'd'   0x00
        ...
s0:     0x00010000: 0x00  0x00  0x80  0x00
s1:     0x00010004: 'h'   'e'   'l'   'l'
        0x00010008: 'o'   ' '   'w'   'o'
        0x0001000C: 'r'   'l'   'd'   0x00
</pre>
<p>The string literal <code>"hello world"</code> is a 12-element array of <code>char</code> (<code>const char</code> in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s0</code> as a pointer to <code>char</code> with auto storage duration (meaning the variable <code>s0</code> only exists for the scope in which it is declared) and copies the <em>address</em> of the string literal (<code>0x00008000</code> in this example) to it. Note that since <code>s0</code> points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., <code>strtok()</code>, <code>strcat()</code>, <code>strcpy()</code>, etc.).</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s1</code> as a 12-element array of <code>char</code> (length is taken from the string literal) with auto storage duration and copies the <em>contents</em> of the literal to the array.  As you can see from the memory map, we have two copies of the string <code>"hello world"</code>; the difference is that you can modify the string contained in <code>s1</code>.</p>
<p><code>s0</code> and <code>s1</code> are interchangeable in most contexts; here are the exceptions:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">sizeof</span> s0 == <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">char</span>*)
<span class="hljs-keyword">sizeof</span> s1 == <span class="hljs-number">12</span>

type of &amp;s0 == <span class="hljs-type">char</span> **
type of &amp;s1 == <span class="hljs-type">char</span> (*)[<span class="hljs-number">12</span>] <span class="hljs-comment">// pointer to a 12-element array of char</span>
</code></pre>
<p>You can reassign the variable <code>s0</code> to point to a different string literal or to another variable.  You cannot reassign the variable <code>s1</code> to point to a different array.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C99 N1256 draft</strong></p>

<p>There are two different uses of character string literals:</p>

<ol>
<li><p>Initialize <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = <span class="hljs-string">"abc"</span>;      
</code></pre>

<p>This is "more magic", and described at 6.7.8/14 "Initialization":</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal, optionally
  enclosed in braces. Successive characters of the character string literal (including the
  terminating null character if there is room or if the array is of unknown size) initialize the
  elements of the array.</p>
</blockquote>

<p>So this is just a shortcut for:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = {<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span>};
</code></pre>

<p>Like any other regular array, <code>c</code> can be modified.</p></li>
<li><p>Everywhere else: it generates an:</p>

<ul>
<li>unnamed</li>
<li>array of char <a href="https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c">What is the type of string literals in C and C++?</a></li>
<li>with static storage</li>
<li>that gives UB if modified</li>
</ul>

<p>So when you write:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *c = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>This is similar to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* __unnamed is magic because modifying it gives UB. */</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> __unnamed[] = <span class="hljs-string">"abc"</span>;
<span class="hljs-type">char</span> *c = __unnamed;
</code></pre>

<p>Note the implicit cast from <code>char[]</code> to <code>char *</code>, which is always legal.</p>

<p>Then if you modify <code>c[0]</code>, you also modify <code>__unnamed</code>, which is UB.</p>

<p>This is documented at 6.4.5 "String literals":</p>

<blockquote>
  <p>5 In translation phase 7, a byte or code of value zero is appended to each multibyte
  character sequence that results from a string literal or literals. The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. For character string literals, the array elements have
  type char, and are initialized with the individual bytes of the multibyte character
  sequence [...]</p>
  
  <p>6 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined.</p>
</blockquote></li>
</ol>

<p>6.7.8/32 "Initialization" gives a direct example:</p>

<blockquote>
  <p>EXAMPLE 8: The declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>, t[<span class="hljs-number">3</span>] = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines "plain" char array objects <code>s</code> and <code>t</code> whose elements are initialized with character string literals.</p>
  
  <p>This declaration is identical to</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span> },
t[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> };
</code></pre>
  
  <p>The contents of the arrays are modifiable. On the other hand, the declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *p = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines <code>p</code> with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use <code>p</code> to modify the contents of the array, the behavior is undefined.</p>
</blockquote>

<p><strong>GCC 4.8 x86-64 ELF implementation</strong></p>

<p>Program:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile and decompile:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">gcc -ggdb -<span class="hljs-built_in">std</span>=c99 -c main.c
objdump -Sr main.o
</code></pre>

<p>Output contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
<span class="hljs-number">8</span>:  <span class="hljs-number">48</span> c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x8</span>(%rbp)
f:  <span class="hljs-number">00</span> 
        c: R_X86_64_32S .rodata
</code></pre>

<p>Conclusion: GCC stores <code>char*</code> it in <code>.rodata</code> section, not in <code>.text</code>.</p>

<p>Note however that the default linker script puts <code>.rodata</code> and <code>.text</code> in the same <a href="https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710">segment</a>, which has execute but no write permission. This can be observed with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">readelf -l a.out
</code></pre>

<p>which contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> Section to Segment mapping:
  Segment Sections...
   <span class="hljs-number">02</span>     .text .rodata
</code></pre>

<p>If we do the same for <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>we obtain:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">17</span>:   c7 <span class="hljs-number">45</span> f0 <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span>    movl   $<span class="hljs-number">0x636261</span>,<span class="hljs-number">-0x10</span>(%rbp)
</code></pre>

<p>so it gets stored in the stack (relative to <code>%rbp</code>).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be an array of <code>char</code> which is long enough to hold the initializer (5 + 1 <code>char</code>s) and initializes the array by copying the members of the given string literal into the array.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be a pointer to one or more (in this case more) <code>char</code>s and points it directly at a fixed (read-only) location containing the literal <code>"hello"</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>Here, <code>s</code> is an array of characters, which can be overwritten if we wish.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>A string literal is used to create these character blocks somewhere in the memory which this pointer <code>s</code> is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can't be changed.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with <code>[]</code> or <code>*(&lt;var&gt; + &lt;index&gt;)</code>
format:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, x[<span class="hljs-number">1</span>]);     <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>And:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, *(x + <span class="hljs-number">1</span>)); <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>Obviously, if you attempt to do</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*(x + <span class="hljs-number">1</span>) = <span class="hljs-string">'a'</span>;
</code></pre>

<p>You will probably get a Segmentation Fault, as you are trying to access read-only memory.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to add: you also get different values for their sizes.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof s[] = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//6</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof *s  = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//4 or 8</span>
</code></pre>

<p>As mentioned above, for an array <code>'\0'</code> will be allocated as the final element.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>The above sets str to point to the literal value "Hello" which is hard-coded in the program's binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">means str[<span class="hljs-number">0</span>] = <span class="hljs-string">'M'</span>;
</code></pre>

<p>will change the str to "Mello".</p>

<p>For more details, please go through the similar question:</p>

<p><a href="https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha">Why do I get a segmentation fault when writing to a string initialized with "char *s" but not "char s[]"?</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An example to the difference:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">//llo</span>
<span class="hljs-type">char</span> a[] = <span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//error</span>
</code></pre>
<p>In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s1 = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// Points to fixed character string which is not allowed to modify</span>
<span class="hljs-type">char</span> s2[] = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// As good as fixed array of characters in string so allowed to modify</span>

<span class="hljs-comment">// s1[0] = 'J'; // Illegal</span>
s2[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>; <span class="hljs-comment">// Legal</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is an <a href="http://en.wikipedia.org/wiki/Lvalue" rel="nofollow noreferrer">lvalue</a> -- it can be assigned to. But in the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is not an lvalue, it is an rvalue -- you cannot assign to it.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the light of comments here it should be obvious that : char * s = "hello" ;
Is a bad idea, and should be used in very narrow scope. </p>

<p>This might be a good opportunity to point out that "const correctness" is a "good thing". Whenever and wherever You can, use the "const" keyword to protect your code, from "relaxed" callers or programmers, which are usually most "relaxed" when pointers come into play.</p>

<p>Enough melodrama, here is what one can achieve when adorning pointers with "const".
(Note: One has to read pointer declarations right-to-left.)
Here are the 3 different ways to protect yourself when playing with pointers :</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* p means <span class="hljs-string">"p points to a DBJ that is const"</span> 
</code></pre>

<p> that is, the DBJ object can't be changed via p.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a DBJ"</span> 
</code></pre>

<p> that is, you can change the DBJ object via p, but you can't change the pointer p itself.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a const DBJ"</span> 
</code></pre>

<p> that is, you can't change the pointer p itself, nor can you change the DBJ object via p.</p>

<p>The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.</p>

<p>(Assumption is you are using C++ compiler, of course ?)</p>

<p>--DBJ</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The difference here is that \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will place \u0026lt;code\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/code\u0026gt; in the \u0026lt;em\u0026gt;read-only parts of the memory\u0026lt;/em\u0026gt;, and making \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; a pointer to that makes any writing operation on this memory illegal. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While doing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;legal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First off, in function arguments, they are exactly equivalent:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[])\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// exactly the same in all respects\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In other contexts, \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; allocates a pointer, while \u0026lt;code\u0026gt;char []\u0026lt;/code\u0026gt; allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// is approximately equivalent to:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __secret_anonymous_array[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *) __secret_anonymous_array;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BAD. DON\u0026apos;T DO THIS.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using the array syntax directly allocates it into new memory. Thus modification is safe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\nx[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No problem.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However the array only lives as long as its contaning scope, so if you do this in a function, don\u0026apos;t return or leak a pointer to this array - make a copy instead with \u0026lt;code\u0026gt;strdup()\u0026lt;/code\u0026gt; or similar. If the array is allocated in global scope, of course, no problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;one\u0026lt;/em\u0026gt; object - a \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; array of size 6, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, initialised with the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it\u0026apos;s outside a function, it will \u0026lt;em\u0026gt;probably\u0026lt;/em\u0026gt; be stored within an \u0026quot;initialised data segment\u0026quot; that is loaded from the executable file into writeable memory when the program is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, this declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;two\u0026lt;/em\u0026gt; objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a \u0026lt;strong\u0026gt;read-only\u0026lt;/strong\u0026gt; array of 6 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s containing the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;, which has no name and has \u0026lt;em\u0026gt;static storage duration\u0026lt;/em\u0026gt; (meaning that it lives for the entire life of the program); and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a variable of type pointer-to-char, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, which is initialised with the location of the first character in that unnamed, read-only array.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The unnamed read-only array is typically located in the \u0026quot;text\u0026quot; segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; pointer variable in memory depends on where the declaration appears (just like in the first example).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Given the declarations\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the \u0026lt;code\u0026gt;0x00\u0026lt;/code\u0026gt; in the bottom right corner is at address \u0026lt;code\u0026gt;0x0001000C + 3\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;0x0001000F\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;                     +0    +1    +2    +3\n        0x00008000: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00008004: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x00008008: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n        ...\ns0:     0x00010000: 0x00  0x00  0x80  0x00\ns1:     0x00010004: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00010008: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x0001000C: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The string literal \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt; is a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;const char\u0026lt;/code\u0026gt; in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; as a pointer to \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; with auto storage duration (meaning the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; only exists for the scope in which it is declared) and copies the \u0026lt;em\u0026gt;address\u0026lt;/em\u0026gt; of the string literal (\u0026lt;code\u0026gt;0x00008000\u0026lt;/code\u0026gt; in this example) to it. Note that since \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., \u0026lt;code\u0026gt;strtok()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcat()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcpy()\u0026lt;/code\u0026gt;, etc.).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; as a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (length is taken from the string literal) with auto storage duration and copies the \u0026lt;em\u0026gt;contents\u0026lt;/em\u0026gt; of the literal to the array.  As you can see from the memory map, we have two copies of the string \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt;; the difference is that you can modify the string contained in \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; are interchangeable in most contexts; here are the exceptions:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s0 == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s1 == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;\n\ntype of \u0026amp;amp;s0 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **\ntype of \u0026amp;amp;s1 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (*)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to a 12-element array of char\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can reassign the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; to point to a different string literal or to another variable.  You cannot reassign the variable \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; to point to a different array.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C99 N1256 draft\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two different uses of character string literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Initialize \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is \u0026quot;more magic\u0026quot;, and described at 6.7.8/14 \u0026quot;Initialization\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So this is just a shortcut for:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other regular array, \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; can be modified.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Everywhere else: it generates an:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unnamed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array of char \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c\u0026quot;\u0026gt;What is the type of string literals in C and C++?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with static storage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that gives UB if modified\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So when you write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is similar to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* __unnamed is magic because modifying it gives UB. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __unnamed[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = __unnamed;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the implicit cast from \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;, which is always legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you modify \u0026lt;code\u0026gt;c[0]\u0026lt;/code\u0026gt;, you also modify \u0026lt;code\u0026gt;__unnamed\u0026lt;/code\u0026gt;, which is UB.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is documented at 6.4.5 \u0026quot;String literals\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;6.7.8/32 \u0026quot;Initialization\u0026quot; gives a direct example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;EXAMPLE 8: The declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;, t[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026quot;plain\u0026quot; char array objects \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; whose elements are initialized with character string literals.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This declaration is identical to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; },\nt[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;The contents of the arrays are modifiable. On the other hand, the declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; with type \u0026quot;pointer to char\u0026quot; and initializes it to point to an object with type \u0026quot;array of char\u0026quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to modify the contents of the array, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;GCC 4.8 x86-64 ELF implementation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, s);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile and decompile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;gcc -ggdb -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c99 -c main.c\nobjdump -Sr main.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movq   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x8\u0026lt;/span\u0026gt;(%rbp)\nf:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \n        c: R_X86_64_32S .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion: GCC stores \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; it in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section, not in \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note however that the default linker script puts \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt; in the same \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710\u0026quot;\u0026gt;segment\u0026lt;/a\u0026gt;, which has execute but no write permission. This can be observed with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;readelf -l a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; Section to Segment mapping:\n  Segment Sections...\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;     .text .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we do the same for \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we obtain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;:   c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f0 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;62\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x636261\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x10\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so it gets stored in the stack (relative to \u0026lt;code\u0026gt;%rbp\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be an array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; which is long enough to hold the initializer (5 + 1 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s) and initializes the array by copying the members of the given string literal into the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be a pointer to one or more (in this case more) \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s and points it directly at a fixed (read-only) location containing the literal \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is an array of characters, which can be overwritten if we wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A string literal is used to create these character blocks somewhere in the memory which this pointer \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can\u0026apos;t be changed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*(\u0026amp;lt;var\u0026amp;gt; + \u0026amp;lt;index\u0026amp;gt;)\u0026lt;/code\u0026gt;\nformat:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, *(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, if you attempt to do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will probably get a Segmentation Fault, as you are trying to access read-only memory.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to add: you also get different values for their sizes.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof s[] = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof *s  = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//4 or 8\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As mentioned above, for an array \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; will be allocated as the final element.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above sets str to point to the literal value \u0026quot;Hello\u0026quot; which is hard-coded in the program\u0026apos;s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;means str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;M\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will change the str to \u0026quot;Mello\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more details, please go through the similar question:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha\u0026quot;\u0026gt;Why do I get a segmentation fault when writing to a string initialized with \u0026quot;char *s\u0026quot; but not \u0026quot;char s[]\u0026quot;?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An example to the difference:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//llo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Points to fixed character string which is not allowed to modify\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s2[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// As good as fixed array of characters in string so allowed to modify\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// s1[0] = \u0026apos;J\u0026apos;; // Illegal\u0026lt;/span\u0026gt;\ns2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is an \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Lvalue\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;lvalue\u0026lt;/a\u0026gt; -- it can be assigned to. But in the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is not an lvalue, it is an rvalue -- you cannot assign to it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the light of comments here it should be obvious that : char * s = \u0026quot;hello\u0026quot; ;\nIs a bad idea, and should be used in very narrow scope. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This might be a good opportunity to point out that \u0026quot;const correctness\u0026quot; is a \u0026quot;good thing\u0026quot;. Whenever and wherever You can, use the \u0026quot;const\u0026quot; keyword to protect your code, from \u0026quot;relaxed\u0026quot; callers or programmers, which are usually most \u0026quot;relaxed\u0026quot; when pointers come into play.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Enough melodrama, here is what one can achieve when adorning pointers with \u0026quot;const\u0026quot;.\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p points to a DBJ that is const\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, the DBJ object can\u0026apos;t be changed via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can change the DBJ object via p, but you can\u0026apos;t change the pointer p itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a const DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can\u0026apos;t change the pointer p itself, nor can you change the DBJ object via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Assumption is you are using C++ compiler, of course ?)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;--DBJ\u0026lt;/p\u0026gt;\n    "],"id":386,"title":"What is the difference between char s[] and char *s?","content":"\n                \n\u0026lt;p\u0026gt;In C, one can use a string literal in a declaration like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. \u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570","postType":"QUESTION","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","tags":[{"id":2098,"name":"char","slug":"char","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2098}},{"id":2099,"name":"constants","slug":"constants","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2099}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570"},"buildId":"9SrIo1zGFc3tF1E8on9-4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>