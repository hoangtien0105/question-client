{"pageProps":{"data":{"answer":["\n&lt;p&gt;If your goal is to use a profiler, use one of the suggested ones.&lt;/p&gt;\n\n&lt;p&gt;However, if you&apos;re in a hurry and you can manually interrupt your program under the debugger while it&apos;s being subjectively slow, there&apos;s a simple way to find performance problems.&lt;/p&gt;\n\n&lt;p&gt;Just halt it several times, and each time look at the call stack. If there is some code that is wasting some percentage of the time, 20% or 50% or whatever, that is the probability that you will catch it in the act on each sample. So, that is roughly the percentage of samples on which you will see it. There is no educated guesswork required. If you do have a guess as to what the problem is, this will prove or disprove it.&lt;/p&gt;\n\n&lt;p&gt;You may have multiple performance problems of different sizes. If you clean out any one of them, the remaining ones will take a larger percentage, and be easier to spot, on subsequent passes. This &lt;em&gt;magnification effect&lt;/em&gt;, when compounded over multiple problems, can lead to truly massive speedup factors.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Caveat&lt;/strong&gt;: Programmers tend to be skeptical of this technique unless they&apos;ve used it themselves. They will say that profilers give you this information, but that is only true if they sample the entire call stack, and then let you examine a random set of samples. (The summaries are where the insight is lost.) Call graphs don&apos;t give you the same information, because &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;They don&apos;t summarize at the instruction level, and&lt;/li&gt;\n&lt;li&gt;They give confusing summaries in the presence of recursion.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;They will also say it only works on toy programs, when actually it works on any program, and it seems to work better on bigger programs, because they tend to have more problems to find. They will say it sometimes finds things that aren&apos;t problems, but that is only true if you see something &lt;em&gt;once&lt;/em&gt;. If you see a problem on more than one sample, it is real.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; This can also be done on multi-thread programs if there is a way to collect call-stack samples of the thread pool at a point in time, as there is in Java.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;P.P.S&lt;/strong&gt; As a rough generality, the more layers of abstraction you have in your software, the more likely you are to find that that is the cause of performance problems (and the opportunity to get speedup).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: It might not be obvious, but the stack sampling technique works equally well in the presence of recursion. The reason is that the time that would be saved by removal of an instruction is approximated by the fraction of samples containing it, regardless of the number of times it may occur within a sample.&lt;/p&gt;\n\n&lt;p&gt;Another objection I often hear is: &quot;&lt;em&gt;It will stop someplace random, and it will miss the real problem&lt;/em&gt;&quot;.\nThis comes from having a prior concept of what the real problem is.\nA key property of performance problems is that they defy expectations.\nSampling tells you something is a problem, and your first reaction is disbelief.\nThat is natural, but you can be sure if it finds a problem it is real, and vice-versa.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: Let me make a Bayesian explanation of how it works.  Suppose there is some instruction &lt;code&gt;I&lt;/code&gt; (call or otherwise) which is on the call stack some fraction &lt;code&gt;f&lt;/code&gt; of the time (and thus costs that much). For simplicity, suppose we don&apos;t know what &lt;code&gt;f&lt;/code&gt; is, but assume it is either 0.1, 0.2, 0.3, ... 0.9, 1.0, and the prior probability of each of these possibilities is 0.1, so all of these costs are equally likely a-priori.&lt;/p&gt;\n\n&lt;p&gt;Then suppose we take just 2 stack samples, and we see instruction &lt;code&gt;I&lt;/code&gt; on both samples, designated observation &lt;code&gt;o=2/2&lt;/code&gt;. This gives us new estimates of the frequency &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;I&lt;/code&gt;, according to this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Prior                                    \n&lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f=x)&lt;/span&gt; x  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;|f=x)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f=x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f &amp;gt;= x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f &amp;gt;= x | o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;\n\n0.1    1     1             0.1          0.1            0.25974026\n0.1    0.9   0.81          0.081        0.181          0.47012987\n0.1    0.8   0.64          0.064        0.245          0.636363636\n0.1    0.7   0.49          0.049        0.294          0.763636364\n0.1    0.6   0.36          0.036        0.33           0.857142857\n0.1    0.5   0.25          0.025        0.355          0.922077922\n0.1    0.4   0.16          0.016        0.371          0.963636364\n0.1    0.3   0.09          0.009        0.38           0.987012987\n0.1    0.2   0.04          0.004        0.384          0.997402597\n0.1    0.1   0.01          0.001        0.385          1\n\n                  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt; 0.385                \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The last column says that, for example, the probability that &lt;code&gt;f&lt;/code&gt; &amp;gt;= 0.5 is 92%, up from the prior assumption of 60%.&lt;/p&gt;\n\n&lt;p&gt;Suppose the prior assumptions are different. Suppose we assume &lt;code&gt;P(f=0.1)&lt;/code&gt; is .991 (nearly certain), and all the other possibilities are almost impossible (0.001). In other words, our prior certainty is that &lt;code&gt;I&lt;/code&gt; is cheap. Then we get:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Prior                                    \n&lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f=x)&lt;/span&gt; x  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;|f=x)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp; f=x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f &amp;gt;= x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f &amp;gt;= x | o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;\n\n0.001  1    1              0.001        0.001          0.072727273\n0.001  0.9  0.81           0.00081      0.00181        0.131636364\n0.001  0.8  0.64           0.00064      0.00245        0.178181818\n0.001  0.7  0.49           0.00049      0.00294        0.213818182\n0.001  0.6  0.36           0.00036      0.0033         0.24\n0.001  0.5  0.25           0.00025      0.00355        0.258181818\n0.001  0.4  0.16           0.00016      0.00371        0.269818182\n0.001  0.3  0.09           0.00009      0.0038         0.276363636\n0.001  0.2  0.04           0.00004      0.00384        0.279272727\n0.991  0.1  0.01           0.00991      0.01375        1\n\n                  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt; 0.01375                \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now it says &lt;code&gt;P(f &amp;gt;= 0.5)&lt;/code&gt; is 26%, up from the prior assumption of 0.6%. So Bayes allows us to update our estimate of the probable cost of &lt;code&gt;I&lt;/code&gt;. If the amount of data is small, it doesn&apos;t tell us accurately what the cost is, only that it is big enough to be worth fixing.&lt;/p&gt;\n\n&lt;p&gt;Yet another way to look at it is called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_succession&quot; rel=&quot;noreferrer&quot;&gt;Rule Of Succession&lt;/a&gt;.\nIf you flip a coin 2 times, and it comes up heads both times, what does that tell you about the probable weighting of the coin?\nThe respected way to answer is to say that it&apos;s a Beta distribution, with average value &lt;code&gt;(number of hits + 1) / (number of tries + 2) = (2+1)/(2+2) = 75%&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(The key is that we see &lt;code&gt;I&lt;/code&gt; more than once. If we only see it once, that doesn&apos;t tell us much except that &lt;code&gt;f&lt;/code&gt; &amp;gt; 0.)&lt;/p&gt;\n\n&lt;p&gt;So, even a very small number of samples can tell us a lot about the cost of instructions that it sees. (And it will see them with a frequency, on average, proportional to their cost. If &lt;code&gt;n&lt;/code&gt; samples are taken, and &lt;code&gt;f&lt;/code&gt; is the cost, then &lt;code&gt;I&lt;/code&gt; will appear on &lt;code&gt;nf+/-sqrt(nf(1-f))&lt;/code&gt; samples. Example, &lt;code&gt;n=10&lt;/code&gt;, &lt;code&gt;f=0.3&lt;/code&gt;, that is &lt;code&gt;3+/-1.4&lt;/code&gt; samples.)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: To give an intuitive feel for the difference between measuring and random stack sampling:&lt;br&gt;\nThere are profilers now that sample the stack, even on wall-clock time, but &lt;em&gt;what comes out&lt;/em&gt; is measurements (or hot path, or hot spot, from which a &quot;bottleneck&quot; can easily hide). What they don&apos;t show you (and they easily could) is the actual samples themselves. And if your goal is to &lt;em&gt;find&lt;/em&gt; the bottleneck, the number of them you need to see is, &lt;em&gt;on average&lt;/em&gt;, 2 divided by the fraction of time it takes.\nSo if it takes 30% of time, 2/.3 = 6.7 samples, on average, will show it, and the chance that 20 samples will show it is 99.2%.&lt;/p&gt;\n\n&lt;p&gt;Here is an off-the-cuff illustration of the difference between examining measurements and examining stack samples.\nThe bottleneck could be one big blob like this, or numerous small ones, it makes no difference.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/FpWuS.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/FpWuS.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Measurement is horizontal; it tells you what fraction of time specific routines take.\nSampling is vertical.\nIf there is any way to avoid what the whole program is doing at that moment, &lt;em&gt;and if you see it on a second sample&lt;/em&gt;, you&apos;ve found the bottleneck.\nThat&apos;s what makes the difference - seeing the whole reason for the time being spent, not just how much.&lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;nofollow noreferrer&quot;&gt;Valgrind&lt;/a&gt; with the following options:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind ./(Your binary)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This generates a file called &lt;code&gt;callgrind.out.x&lt;/code&gt;. Use the &lt;code&gt;kcachegrind&lt;/code&gt; tool to read this file. It will give you a graphical analysis of things with results like which lines cost how much.&lt;/p&gt;\n    ","\n&lt;p&gt;I assume you&apos;re using GCC. The standard solution would be to profile with &lt;a href=&quot;http://www.math.utah.edu/docs/info/gprof_toc.html&quot; rel=&quot;noreferrer&quot;&gt;gprof&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Be sure to add &lt;code&gt;-pg&lt;/code&gt; to compilation before profiling:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cc -o myprog myprog.c utils.c -g -pg\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I haven&apos;t tried it yet but I&apos;ve heard good things about &lt;a href=&quot;https://github.com/gperftools/gperftools&quot; rel=&quot;noreferrer&quot;&gt;google-perftools&lt;/a&gt;. It is definitely worth a try.&lt;/p&gt;\n\n&lt;p&gt;Related question &lt;a href=&quot;https://stackoverflow.com/questions/56672/how-do-you-profile-your-code&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;A few other buzzwords if &lt;code&gt;gprof&lt;/code&gt; does not do the job for you: &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;noreferrer&quot;&gt;Valgrind&lt;/a&gt;, Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/VTune&quot; rel=&quot;noreferrer&quot;&gt;VTune&lt;/a&gt;, Sun &lt;a href=&quot;http://en.wikipedia.org/wiki/DTrace&quot; rel=&quot;noreferrer&quot;&gt;DTrace&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Newer kernels (e.g. the latest Ubuntu kernels) come with the new &apos;perf&apos; tools (&lt;code&gt;apt-get install linux-tools&lt;/code&gt;) AKA &lt;a href=&quot;https://en.wikipedia.org/wiki/Perf_(Linux)&quot; rel=&quot;noreferrer&quot;&gt;perf_events&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;These come with classic sampling profilers (&lt;a href=&quot;http://manpages.ubuntu.com/manpages/trusty/man1/perf.1.html&quot; rel=&quot;noreferrer&quot;&gt;man-page&lt;/a&gt;) as well as the awesome &lt;a href=&quot;http://web.archive.org/web/20090922171904/http://blog.fenrus.org/?p=5&quot; rel=&quot;noreferrer&quot;&gt;timechart&lt;/a&gt;!&lt;/p&gt;\n\n&lt;p&gt;The important thing is that these tools can be &lt;strong&gt;system profiling&lt;/strong&gt; and not just process profiling - they can show the interaction between threads, processes and the kernel and let you understand the scheduling and I/O dependencies between processes.&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/FMYp4.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;The answer to run &lt;code&gt;valgrind --tool=callgrind&lt;/code&gt; is not quite complete without some options. We usually do not want to profile 10 minutes of slow startup time under Valgrind and want to profile our program when it is doing some task.&lt;/p&gt;\n\n&lt;p&gt;So this is what I recommend. Run program first:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind --dump-instr=yes -v --instr-atstart=no ./binary &amp;gt; tmp\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now when it works and we want to start profiling we should run in another window:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;callgrind_control -i on\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This turns profiling on. To turn it off and stop whole task we might use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;callgrind_control -k\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now we have some files named callgrind.out.* in current directory. To see profiling results use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;kcachegrind callgrind.out.*\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I recommend in next window to click on &quot;Self&quot; column header, otherwise it shows that &quot;main()&quot; is most time consuming task. &quot;Self&quot; shows how much each function itself took time, not together with dependents. &lt;/p&gt;\n    ","\n&lt;p&gt;I would use Valgrind and Callgrind as a base for my profiling tool suite. What is important to know is that Valgrind is basically a Virtual Machine:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;(wikipedia) Valgrind is in essence a virtual\n  machine using just-in-time (JIT)\n  compilation techniques, including\n  dynamic recompilation. Nothing from\n  the original program ever gets run\n  directly on the host processor.\n  Instead, Valgrind first translates the\n  program into a temporary, simpler form\n  called Intermediate Representation\n  (IR), which is a processor-neutral,\n  SSA-based form. After the conversion,\n  a tool (see below) is free to do\n  whatever transformations it would like\n  on the IR, before Valgrind translates\n  the IR back into machine code and lets\n  the host processor run it. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Callgrind is a profiler build upon that. Main benefit is that you don&apos;t have to run your aplication for hours to get reliable result. Even one second run is sufficient to get rock-solid, reliable results, because Callgrind is a &lt;strong&gt;non-probing&lt;/strong&gt; profiler. &lt;/p&gt;\n\n&lt;p&gt;Another tool build upon Valgrind is Massif. I use it to profile heap memory usage. It works great. What it does is that it gives you snapshots of memory usage -- detailed information WHAT holds WHAT percentage of memory, and WHO had put it there. Such information is available at different points of time of application run.&lt;/p&gt;\n    ","\n&lt;p&gt;This is a response to &lt;a href=&quot;https://stackoverflow.com/a/375930/321731&quot;&gt;Nazgob&apos;s Gprof answer&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;I&apos;ve been using Gprof the last couple of days and have already found three significant limitations, one of which I&apos;ve not seen documented anywhere else (yet):&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;It doesn&apos;t work properly on multi-threaded code, unless you use a &lt;a href=&quot;http://sam.zoy.org/writings/programming/gprof.html&quot; rel=&quot;noreferrer&quot;&gt;workaround&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The call graph gets confused by function pointers. Example: I have a function called &lt;code&gt;multithread()&lt;/code&gt; which enables me to multi-thread a specified function over a specified array (both passed as arguments). Gprof however, views all calls to &lt;code&gt;multithread()&lt;/code&gt; as equivalent for the purposes of computing time spent in children. Since some functions I pass to &lt;code&gt;multithread()&lt;/code&gt; take much longer than others my call graphs are mostly useless. (To those wondering if threading is the issue here: no, &lt;code&gt;multithread()&lt;/code&gt; can optionally, and did in this case, run everything sequentially on the calling thread only).&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;It says &lt;a href=&quot;http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; that &quot;... the number-of-calls figures are derived by counting, not sampling. They are completely accurate...&quot;. Yet I find my call graph giving me 5345859132+784984078 as call stats to my most-called function, where the first number is supposed to be direct calls, and the second recursive calls (which are all from itself). Since this implied I had a bug, I put in long (64-bit) counters into the code and did the same run again. My counts: 5345859132 direct, and 78094395406 self-recursive calls.  There are a lot of digits there, so I&apos;ll point out the recursive calls I measure are 78bn, versus 784m from Gprof: a factor of 100 different. Both runs were single threaded and unoptimised code, one compiled &lt;code&gt;-g&lt;/code&gt; and the other &lt;code&gt;-pg&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This was GNU &lt;a href=&quot;https://en.wikipedia.org/wiki/Gprof&quot; rel=&quot;noreferrer&quot;&gt;Gprof&lt;/a&gt; (GNU Binutils for Debian) 2.18.0.20080103 running under 64-bit Debian Lenny, if that helps anyone.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Survey of C++ profiling techniques: gprof vs valgrind vs perf vs gperftools&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;In this answer, I will use several different tools to a analyze a few very simple test programs, in order to concretely compare how those tools work.&lt;/p&gt;\n&lt;p&gt;The following test program is very simple and does the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt; calls &lt;code&gt;fast&lt;/code&gt; and &lt;code&gt;maybe_slow&lt;/code&gt; 3 times, one of the &lt;code&gt;maybe_slow&lt;/code&gt; calls being slow&lt;/p&gt;\n&lt;p&gt;The slow call of &lt;code&gt;maybe_slow&lt;/code&gt; is 10x longer, and dominates runtime if we consider calls to the child function &lt;code&gt;common&lt;/code&gt;. Ideally, the profiling tool will be able to point us to the specific slow call.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;both &lt;code&gt;fast&lt;/code&gt; and &lt;code&gt;maybe_slow&lt;/code&gt; call &lt;code&gt;common&lt;/code&gt;, which accounts for the bulk of the program execution&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The program interface is:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;./main.out [n [seed]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and the program does &lt;code&gt;O(n^2)&lt;/code&gt; loops in total. &lt;code&gt;seed&lt;/code&gt; is just to get different output without affecting runtime.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;main.c&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i) {\n        seed = (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed) {\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; max = (n / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; max; ++i) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(n, (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; is_slow) {\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; max = n;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (is_slow) {\n        max *= &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; max; ++i) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(n, (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, seed;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (argc &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {\n        n = &lt;span class=&quot;hljs-built_in&quot;&gt;strtoll&lt;/span&gt;(argv[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n        n = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (argc &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;strtoll&lt;/span&gt;(argv[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n        seed = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    }\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%&quot;&lt;/span&gt; PRIX64 &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;, seed);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gprof&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;gprof requires recompiling the software with instrumentation, and it also uses a sampling approach together with that instrumentation. It therefore strikes a balance between accuracy (sampling is not always fully accurate and can skip functions) and execution slowdown (instrumentation and sampling are relatively fast techniques that don&apos;t slow down execution very much).&lt;/p&gt;\n&lt;p&gt;gprof is built-into GCC/binutils, so all we have to do is to compile with the &lt;code&gt;-pg&lt;/code&gt; option to enable gprof. We then run the program normally with a size CLI parameter that produces a run of reasonable duration of a few seconds (&lt;code&gt;10000&lt;/code&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -pg -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\ntime ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For educational reasons, we will also do a run without optimizations enabled. Note that this is useless in practice, as you normally only care about optimizing the performance of the optimized program:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -pg -ggdb3 -O0 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\n./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;First, &lt;code&gt;time&lt;/code&gt; tells us that the execution time with and without &lt;code&gt;-pg&lt;/code&gt; were the same, which is great: no slowdown! I have however seen accounts of 2x - 3x slowdowns on complex software, e.g. as &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;shown in this ticket&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Because we compiled with &lt;code&gt;-pg&lt;/code&gt;, running the program produces a file &lt;code&gt;gmon.out&lt;/code&gt; file containing the profiling data.&lt;/p&gt;\n&lt;p&gt;We can observe that file graphically with &lt;code&gt;gprof2dot&lt;/code&gt; as asked at: &lt;a href=&quot;https://stackoverflow.com/questions/2439060/is-it-possible-to-get-a-graphical-representation-of-gprof-results&quot;&gt;Is it possible to get a graphical representation of gprof results?&lt;/a&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install graphviz\npython3 -m pip install --user gprof2dot\ngprof main.out &amp;gt; main.gprof\ngprof2dot &amp;lt; main.gprof | dot -Tsvg -o output.svg\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here, the &lt;code&gt;gprof&lt;/code&gt; tool reads the &lt;code&gt;gmon.out&lt;/code&gt; trace information, and generates a human readable report in &lt;code&gt;main.gprof&lt;/code&gt;, which &lt;code&gt;gprof2dot&lt;/code&gt; then reads to generate a graph.&lt;/p&gt;\n&lt;p&gt;The source for gprof2dot is at: &lt;a href=&quot;https://github.com/jrfonseca/gprof2dot&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/jrfonseca/gprof2dot&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;We observe the following for the &lt;code&gt;-O0&lt;/code&gt; run:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mM8NQ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mM8NQ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;and for the &lt;code&gt;-O3&lt;/code&gt; run:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/31VNy.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/31VNy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;-O0&lt;/code&gt; output is pretty much self-explanatory. For example, it shows that the 3 &lt;code&gt;maybe_slow&lt;/code&gt; calls and their child calls take up 97.56% of the total runtime, although execution of &lt;code&gt;maybe_slow&lt;/code&gt; itself without children accounts for 0.00% of the total execution time, i.e. almost all the time spent in that function was spent on child calls.&lt;/p&gt;\n&lt;p&gt;TODO: why is &lt;code&gt;main&lt;/code&gt; missing from the &lt;code&gt;-O3&lt;/code&gt; output, even though I can see it on a &lt;code&gt;bt&lt;/code&gt; in GDB? &lt;a href=&quot;https://stackoverflow.com/questions/39041871/missing-function-from-gprof-output&quot;&gt;Missing function from GProf output&lt;/a&gt; I think it is because gprof is also sampling based in addition to its compiled instrumentation, and the &lt;code&gt;-O3&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; is just too fast and got no samples.&lt;/p&gt;\n&lt;p&gt;I choose SVG output instead of PNG because the SVG is searchable with &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;F&lt;/kbd&gt; and the file size can be about 10x smaller. Also, the width and height of the generated image can be humoungous with tens of thousands of pixels for complex software, and GNOME &lt;code&gt;eog&lt;/code&gt; 3.28.1 bugs out in that case for PNGs, while SVGs get opened by my browser automatically. gimp 2.8 worked well though, see also:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/1112641/how-to-view-extremely-large-images&quot;&gt;https://askubuntu.com/questions/1112641/how-to-view-extremely-large-images&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/77968/viewing-large-image-on-linux&quot;&gt;https://unix.stackexchange.com/questions/77968/viewing-large-image-on-linux&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/356038/viewer-for-huge-images-under-linux-100-mp-color-images&quot;&gt;https://superuser.com/questions/356038/viewer-for-huge-images-under-linux-100-mp-color-images&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;but even then, you will be dragging the image around a lot to find what you want, see e.g. this image from a &quot;real&quot; software example taken from &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;this ticket&lt;/a&gt;:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Nvg9G.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Nvg9G.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Can you find the most critical call stack easily with all those tiny unsorted spaghetti lines going over one another? There might be better &lt;code&gt;dot&lt;/code&gt; options I&apos;m sure, but I don&apos;t want to go there now. What we really need is a proper dedicated viewer for it, but I haven&apos;t found one yet:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7274095/view-gprof-output-in-kcachegrind&quot;&gt;View gprof output in kcachegrind&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1576666/which-is-the-best-replacement-for-kprof&quot;&gt;Which is the best replacement for KProf?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;You can however use the color map to mitigate those problems a bit. For example, on the previous huge image, I finally managed to find the critical path on the left when I made the brilliant deduction that green comes after red, followed finally by darker and darker blue.&lt;/p&gt;\n&lt;p&gt;Alternatively, we can also observe the text output of the &lt;code&gt;gprof&lt;/code&gt; built-in binutils tool which we previously saved at:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cat main.gprof\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;By default, this produces an extremely verbose output that explains what the output data means. Since I can&apos;t explain better than that, I&apos;ll let you read it yourself.&lt;/p&gt;\n&lt;p&gt;Once you have understood the data output format, you can reduce verbosity to show just the data without the tutorial with the &lt;code&gt;-b&lt;/code&gt; option:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gprof -b main.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In our example, outputs were for &lt;code&gt;-O0&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Flat profile:\n\nEach sample counts as &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt; seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls   s/call   s/call  name    \n&lt;span class=&quot;hljs-number&quot;&gt;100.35&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  common\n  &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.03&lt;/span&gt;  fast\n  &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;1.19&lt;/span&gt;  maybe_slow\n\n            Call graph\n\n\ngranularity: each sample hit covers &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;byte&lt;/span&gt;(s) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.27&lt;/span&gt;% of &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt; seconds\n\nindex % time    self  children    called     name\n                &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;         common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;                 main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n-----------------------------------------------\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]      &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n\nIndex by function name\n\n   [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] common                  [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] fast                    [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] maybe_slow\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and for &lt;code&gt;-O3&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Flat profile:\n\nEach sample counts as &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt; seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls  us/call  us/call  name    \n&lt;span class=&quot;hljs-number&quot;&gt;100.52&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;14.96&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;14.96&lt;/span&gt;  common\n\n            Call graph\n\n\ngranularity: each sample hit covers &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;byte&lt;/span&gt;(s) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.54&lt;/span&gt;% of &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt; seconds\n\nindex % time    self  children    called     name\n                &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      fast [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;         common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;                 maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]      &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;                 fast [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n\nIndex by function name\n\n   [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] common\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;As a very quick summary for each section e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;centers around the function that is left indented (&lt;code&gt;maybe_flow&lt;/code&gt;). &lt;code&gt;[3]&lt;/code&gt; is the ID of that function. Above the function, are its callers, and below it the callees.&lt;/p&gt;\n&lt;p&gt;For &lt;code&gt;-O3&lt;/code&gt;, see here like in the graphical output that &lt;code&gt;maybe_slow&lt;/code&gt; and &lt;code&gt;fast&lt;/code&gt; don&apos;t have a known parent, which is what the documentation says that &lt;code&gt;&amp;lt;spontaneous&amp;gt;&lt;/code&gt; means.&lt;/p&gt;\n&lt;p&gt;I&apos;m not sure if there is a nice way to do line-by-line profiling with gprof: &lt;a href=&quot;https://stackoverflow.com/questions/9608949/gprof-time-spent-in-particular-lines-of-code&quot;&gt;`gprof` time spent in particular lines of code&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;valgrind callgrind&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;valgrind runs the program through the valgrind virtual machine. This makes the profiling very accurate, but it also produces a very large slowdown of the program. I have also mentioned kcachegrind previously at: &lt;a href=&quot;https://stackoverflow.com/questions/517589/tools-to-get-a-pictorial-function-call-graph-of-code/31190167#31190167&quot;&gt;Tools to get a pictorial function call graph of code&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;callgrind is the valgrind&apos;s tool to profile code and kcachegrind is a KDE program that can visualize cachegrind output.&lt;/p&gt;\n&lt;p&gt;First we have to remove the &lt;code&gt;-pg&lt;/code&gt; flag to go back to normal compilation, otherwise the run actually fails with &lt;a href=&quot;https://stackoverflow.com/questions/2146082/valgrind-profiling-timer-expired&quot;&gt;&lt;code&gt;Profiling timer expired&lt;/code&gt;&lt;/a&gt;, and yes, this is so common that I did and there was a Stack Overflow question for it.&lt;/p&gt;\n&lt;p&gt;So we compile and run as:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install kcachegrind valgrind\ngcc -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\ntime valgrind --tool=callgrind valgrind --dump-instr=yes \\\n  --collect-jumps=yes ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I enable &lt;code&gt;--dump-instr=yes --collect-jumps=yes&lt;/code&gt; because this also dumps information that enables us to view a per assembly line breakdown of performance, at a relatively small added overhead cost.&lt;/p&gt;\n&lt;p&gt;Off the bat, &lt;code&gt;time&lt;/code&gt; tells us that the program took 29.5 seconds to execute, so we had a slowdown of about 15x on this example. Clearly, this slowdown is going to be a serious limitation for larger workloads. On the &quot;real world software example&quot; &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;mentioned here&lt;/a&gt;, I observed a slowdown of 80x.&lt;/p&gt;\n&lt;p&gt;The run generates a profile data file named &lt;code&gt;callgrind.out.&amp;lt;pid&amp;gt;&lt;/code&gt; e.g. &lt;code&gt;callgrind.out.8554&lt;/code&gt; in my case. We view that file with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;kcachegrind callgrind.out&lt;span class=&quot;hljs-number&quot;&gt;.8554&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;which shows a GUI that contains data similar to the textual gprof output:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/v1kfK.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/v1kfK.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Also, if we go on the bottom right &quot;Call Graph&quot; tab, we see a call graph which we can export by right clicking it to obtain the following image with unreasonable amounts of white border :-)&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ZTdAJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZTdAJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;I think &lt;code&gt;fast&lt;/code&gt; is not showing on that graph because kcachegrind must have simplified the visualization because that call takes up too little time, this will likely be the behavior you want on a real program. The right click menu has some settings to control when to cull such nodes, but I couldn&apos;t get it to show such a short call after a quick attempt. If I click on &lt;code&gt;fast&lt;/code&gt; on the left window, it does show a call graph with &lt;code&gt;fast&lt;/code&gt;, so that stack was actually captured. No one had yet found a way to show the complete graph call graph: &lt;a href=&quot;https://stackoverflow.com/questions/33769323/make-callgrind-show-all-function-calls-in-the-kcachegrind-callgraph&quot;&gt;Make callgrind show all function calls in the kcachegrind callgraph&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;TODO on complex C++ software, I see some entries of type &lt;code&gt;&amp;lt;cycle N&amp;gt;&lt;/code&gt;, e.g. &lt;code&gt;&amp;lt;cycle 11&amp;gt;&lt;/code&gt; where I&apos;d expect function names, what does that mean? I noticed there is a &quot;Cycle Detection&quot; button to toggle that on and off, but what does it mean?&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;perf&lt;/code&gt; from &lt;code&gt;linux-tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; seems to use exclusively Linux kernel sampling mechanisms. This makes it very simple to setup, but also not fully accurate.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install linux-tools\ntime perf record -g ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This added 0.2s to execution, so we are fine time-wise, but I still don&apos;t see much of interest, after expanding the &lt;code&gt;common&lt;/code&gt; node with the keyboard right arrow:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Samples: &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;K of event &lt;span class=&quot;hljs-string&quot;&gt;&apos;cycles:uppp&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;Event &lt;span class=&quot;hljs-title&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(approx.)&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;6228527608&lt;/span&gt;     \n  Children      Self  Command   Shared Object     Symbol                  \n-   &lt;span class=&quot;hljs-number&quot;&gt;99.98&lt;/span&gt;%    &lt;span class=&quot;hljs-number&quot;&gt;99.88&lt;/span&gt;%  main.out  main.out          [.] common              \n     common                                                               \n     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a6009e7&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a600158&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [k] &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000040&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_sysdep_start    \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] dl_main             \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] mprotect            \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_map_object      \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _xstat              \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] __GI___tunables_init\n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x2f3d4f4944555453&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x00007fff3cfc57ac&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _start              \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So then I try to benchmark the &lt;code&gt;-O0&lt;/code&gt; program to see if that shows anything, and only now, at last, do I see a call graph:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Samples: &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;K of event &lt;span class=&quot;hljs-string&quot;&gt;&apos;cycles:uppp&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;Event &lt;span class=&quot;hljs-title&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(approx.)&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;12438962281&lt;/span&gt;   \n  Children      Self  Command   Shared Object     Symbol                  \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x04be258d4c544155&lt;/span&gt;  \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  libc&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so      [.] __libc_start_main   \n-   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  main.out          [.] main                \n   - main                                                                 \n      - &lt;span class=&quot;hljs-number&quot;&gt;97.54&lt;/span&gt;% maybe_slow                                                 \n           common                                                         \n      - &lt;span class=&quot;hljs-number&quot;&gt;2.45&lt;/span&gt;% fast                                                        \n           common                                                         \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.96&lt;/span&gt;%    &lt;span class=&quot;hljs-number&quot;&gt;99.85&lt;/span&gt;%  main.out  main.out          [.] common              \n+   &lt;span class=&quot;hljs-number&quot;&gt;97.54&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.03&lt;/span&gt;%  main.out  main.out          [.] maybe_slow          \n+    &lt;span class=&quot;hljs-number&quot;&gt;2.45&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  main.out          [.] fast                \n     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a6009e7&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [k] &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000040&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_sysdep_start    \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] dl_main             \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_lookup_symbol_x \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a600158&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] mmap64              \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_map_object      \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] __GI___tunables_init\n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x552e53555f6e653d&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x00007ffe1cf20fdb&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _start              \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;TODO: what happened on the &lt;code&gt;-O3&lt;/code&gt; execution? Is it simply that &lt;code&gt;maybe_slow&lt;/code&gt; and &lt;code&gt;fast&lt;/code&gt; were too fast and did not get any samples? Does it work well with &lt;code&gt;-O3&lt;/code&gt; on larger programs that take longer to execute? Did I miss some CLI option? I found out about &lt;code&gt;-F&lt;/code&gt; to control the sample frequency in Hertz, but I turned it up to the max allowed by default of &lt;code&gt;-F 39500&lt;/code&gt; (could be increased with &lt;code&gt;sudo&lt;/code&gt;) and I still don&apos;t see clear calls.&lt;/p&gt;\n&lt;p&gt;One cool thing about &lt;code&gt;perf&lt;/code&gt; is the FlameGraph tool from Brendan Gregg which displays the call stack timings in a very neat way that allows you to quickly see the big calls. The tool is available at: &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt; and is also mentioned on his perf tutorial at: &lt;a href=&quot;http://www.brendangregg.com/perf.html#FlameGraphs&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.brendangregg.com/perf.html#FlameGraphs&lt;/a&gt; When I ran &lt;code&gt;perf&lt;/code&gt; without &lt;code&gt;sudo&lt;/code&gt; I got &lt;a href=&quot;https://github.com/brendangregg/FlameGraph/issues/132&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;ERROR: No stack counts found&lt;/code&gt;&lt;/a&gt; so for now I&apos;ll be doing it with &lt;code&gt;sudo&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;git clone https:&lt;span class=&quot;hljs-comment&quot;&gt;//github.com/brendangregg/FlameGraph&lt;/span&gt;\nsudo perf record -F &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt; -g -o perf_with_stack.data ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\nsudo perf script -i perf_with_stack.data | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl &amp;gt; flamegraph.svg\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;but in such a simple program the output is not very easy to understand, since we can&apos;t easily see neither &lt;code&gt;maybe_slow&lt;/code&gt; nor &lt;code&gt;fast&lt;/code&gt; on that graph:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QFKSS.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QFKSS.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;On the a more complex example it becomes clear what the graph means:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4Ufpd.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4Ufpd.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;TODO there are a log of &lt;code&gt;[unknown]&lt;/code&gt; functions in that example, why is that?&lt;/p&gt;\n&lt;p&gt;Another perf GUI interfaces which might be worth it include:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Eclipse Trace Compass plugin: &lt;a href=&quot;https://www.eclipse.org/tracecompass/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.eclipse.org/tracecompass/&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;But this has the downside that you have to first convert the data to the Common Trace Format, which can be done with &lt;code&gt;perf data --to-ctf&lt;/code&gt;, but it needs to be enabled at build time/have &lt;code&gt;perf&lt;/code&gt; new enough, either of which is not the case for the perf in Ubuntu 18.04&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/KDAB/hotspot&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/KDAB/hotspot&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The downside of this is that there seems to be no Ubuntu package, and building it requires Qt 5.10 while Ubuntu 18.04 is at Qt 5.9.&lt;/p&gt;\n&lt;p&gt;But &lt;a href=&quot;https://stackoverflow.com/users/758288/david-faure&quot;&gt;David Faure&lt;/a&gt; mentions in the comments that there is no an AppImage package which might be a convenient way to use it.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;gperftools&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Previously called &quot;Google Performance Tools&quot;, source: &lt;a href=&quot;https://github.com/gperftools/gperftools&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/gperftools/gperftools&lt;/a&gt; Sample based.&lt;/p&gt;\n&lt;p&gt;First install gperftools with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install google-perftools\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then, we can enable the gperftools CPU profiler in two ways: at runtime, or at build time.&lt;/p&gt;\n&lt;p&gt;At runtime, we have to pass set the &lt;code&gt;LD_PRELOAD&lt;/code&gt; to point to &lt;code&gt;libprofiler.so&lt;/code&gt;, which you can find with &lt;code&gt;locate libprofiler.so&lt;/code&gt;, e.g. on my system:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\nLD_PRELOAD=/usr/lib/x86_64-linux-gnu/libprofiler.so \\\n  CPUPROFILE=prof.out ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Alternatively, we can build the library in at link time, dispensing passing &lt;code&gt;LD_PRELOAD&lt;/code&gt; at runtime:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -Wl,--no-as-needed,-lprofiler,--as-needed -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\nCPUPROFILE=prof.out ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also: &lt;a href=&quot;https://stackoverflow.com/questions/46949407/gperftools-profile-file-not-dumped&quot;&gt;gperftools - profile file not dumped&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The nicest way to view this data I&apos;ve found so far is to make pprof output the same format that kcachegrind takes as input (yes, the Valgrind-project-viewer-tool) and use kcachegrind to view that:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --callgrind main.out prof.out  &amp;gt; callgrind.out\nkcachegrind callgrind.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;After running with either of those methods, we get a &lt;code&gt;prof.out&lt;/code&gt; profile data file as output. We can view that file graphically as an SVG with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --web main.out prof.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SiISF.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SiISF.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;which gives as a familiar call graph like other tools, but with the clunky unit of number of samples rather than seconds.&lt;/p&gt;\n&lt;p&gt;Alternatively, we can also get some textual data with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --text main.out prof.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;which gives:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Using local file main.out.\nUsing local file prof.out.\nTotal: &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; samples\n     &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% common\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% __libc_start_main\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% _start\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%        &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;2.1&lt;/span&gt;% fast\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% main\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;183&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;97.9&lt;/span&gt;% maybe_slow\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also: &lt;a href=&quot;https://stackoverflow.com/questions/10874308/how-to-use-google-perf-tools&quot;&gt;How to use google perf tools&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Instrument your code with raw &lt;code&gt;perf_event_open&lt;/code&gt; syscalls&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;I think this is the same underlying subsystem that &lt;code&gt;perf&lt;/code&gt; uses, but you could of course attain even greater control by explicitly instrumenting your program at compile time with events of interest.&lt;/p&gt;\n&lt;p&gt;This is likely too hardcore for most people, but it&apos;s kind of fun. Minimal runnable example at: &lt;a href=&quot;https://stackoverflow.com/questions/13313510/quick-way-to-count-number-of-instructions-executed-in-a-c-program/64863392#64863392&quot;&gt;Quick way to count number of instructions executed in a C program&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Intel VTune&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/VTune&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/VTune&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This seems to be closed source and x86-only, but it is likely to be amazing from what I&apos;ve heard. I&apos;m not sure how free it is to use, but it seems to be free to download. TODO evaluate.&lt;/p&gt;\n&lt;p&gt;Tested in Ubuntu 18.04, gprof2dot 2019.11.30, valgrind 3.13.0, perf 4.15.18, Linux kernel 4.15.0, FLameGraph 1a0dc6985aad06e76857cf2a354bd5ba0c9ce96b, gperftools 2.5-2.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Use Valgrind, callgrind and kcachegrind:&lt;/strong&gt; &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind ./(Your binary)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;generates callgrind.out.x. Read it using kcachegrind.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Use gprof (add -pg):&lt;/strong&gt; &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cc -o myprog myprog.c utils.c -g -pg \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(not so good for multi-threads, function pointers)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Use google-perftools:&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Uses time sampling, I/O and CPU bottlenecks are revealed.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Intel VTune is the best (free for educational purposes).&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Others:&lt;/strong&gt; AMD Codeanalyst (since replaced with AMD CodeXL), OProfile, &apos;perf&apos; tools (apt-get install linux-tools)&lt;/p&gt;\n    ","\n&lt;p&gt;For single-threaded programs you can use &lt;strong&gt;igprof&lt;/strong&gt;, The Ignominous Profiler: &lt;a href=&quot;https://igprof.org/&quot; rel=&quot;noreferrer&quot;&gt;https://igprof.org/&lt;/a&gt; .&lt;/p&gt;\n\n&lt;p&gt;It is a sampling profiler, along the lines of the... long... answer by Mike Dunlavey, which will gift wrap the results in a browsable call stack tree, annotated with the time or memory spent in each function, either cumulative or per-function.&lt;/p&gt;\n    ","\n&lt;p&gt;Also worth mentioning are&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;HPCToolkit (&lt;a href=&quot;http://hpctoolkit.org/&quot; rel=&quot;noreferrer&quot;&gt;http://hpctoolkit.org/&lt;/a&gt;) - Open-source, works for parallel programs and has a GUI with which to look at the results multiple ways&lt;/li&gt;\n&lt;li&gt;Intel VTune (&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot; rel=&quot;noreferrer&quot;&gt;https://software.intel.com/en-us/vtune&lt;/a&gt;) - If you have intel compilers this is very good &lt;/li&gt;\n&lt;li&gt;TAU (&lt;a href=&quot;http://www.cs.uoregon.edu/research/tau/home.php&quot; rel=&quot;noreferrer&quot;&gt;http://www.cs.uoregon.edu/research/tau/home.php&lt;/a&gt;) &lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;I have used HPCToolkit and VTune and they are very effective at finding the long pole in the tent and do not need your code to be recompiled (except that you have to use -g -O or RelWithDebInfo type build in CMake to get meaningful output). I have heard TAU is similar in capabilities.&lt;/p&gt;\n    ","\n&lt;p&gt;Actually a bit surprised not many mentioned about &lt;a href=&quot;https://github.com/google/benchmark&quot; rel=&quot;nofollow noreferrer&quot;&gt;google/benchmark&lt;/a&gt; , while it is a bit cumbersome to pin the specific area of code, specially if the code base is a little big one, however I found this really helpful when used in combination with &lt;code&gt;callgrind&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;IMHO identifying the piece that is causing bottleneck is the key here. I&apos;d however try and answer the following questions first and choose tool based on that&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;is my algorithm correct ?&lt;/li&gt;\n&lt;li&gt;are there locks that are proving to be bottle necks ?&lt;/li&gt;\n&lt;li&gt;is there a specific section of code that&apos;s proving to be a culprit ?&lt;/li&gt;\n&lt;li&gt;how about IO, handled and optimized ?&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;valgrind&lt;/code&gt; with the combination of &lt;code&gt;callgrind&lt;/code&gt; and &lt;code&gt;kcachegrind&lt;/code&gt; should provide a decent estimation on the points above, and once it&apos;s established that there are issues with some section of code, I&apos;d suggest to do a micro bench mark - &lt;code&gt;google benchmark&lt;/code&gt; is a good place to start.&lt;/p&gt;\n    ","\n&lt;p&gt;These are the two methods I use for speeding up my code:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;For CPU bound applications:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use a profiler in DEBUG mode to identify questionable parts of your code&lt;/li&gt;\n&lt;li&gt;Then switch to RELEASE mode and comment out the questionable sections of your code (stub it with nothing) until you see changes in performance.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;For I/O bound applications:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use a profiler in RELEASE mode to identify questionable parts of your code.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;N.B.&lt;/p&gt;\n\n&lt;p&gt;If you don&apos;t have a profiler, use the poor man&apos;s profiler. Hit pause while debugging your application. Most developer suites will break into assembly with commented line numbers. You&apos;re statistically likely to land in a region that is eating most of your CPU cycles.&lt;/p&gt;\n\n&lt;p&gt;For CPU, the reason for profiling in &lt;strong&gt;DEBUG&lt;/strong&gt; mode is because if your tried profiling in &lt;strong&gt;RELEASE&lt;/strong&gt; mode, the compiler is going to reduce math, vectorize loops, and inline functions which tends to glob your code into an un-mappable mess when it&apos;s assembled. &lt;strong&gt;An un-mappable mess means your profiler will not be able to clearly identify what is taking so long because the assembly may not correspond to the source code under optimization&lt;/strong&gt;. If you need the performance (e.g. timing sensitive) of &lt;strong&gt;RELEASE&lt;/strong&gt; mode, disable debugger features as needed to keep a usable performance.&lt;/p&gt;\n\n&lt;p&gt;For I/O-bound, the profiler can still identify I/O operations in &lt;strong&gt;RELEASE&lt;/strong&gt; mode because I/O operations are either externally linked to a shared library (most of the time) or in the worst case, will result in a sys-call interrupt vector (which is also easily identifiable by the profiler).&lt;/p&gt;\n    ","\n&lt;p&gt;You can use the iprof library:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://gitlab.com/Neurochrom/iprof&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://gitlab.com/Neurochrom/iprof&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/Neurochrom/iprof&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/Neurochrom/iprof&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;It&apos;s cross-platform and allows you not to measure performance of your application also in real-time. You can even couple it with a live graph.\nFull disclaimer: I am the author.&lt;/p&gt;\n    ","\n&lt;p&gt;You can use a logging framework like &lt;a href=&quot;https://github.com/emilk/loguru&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;loguru&lt;/code&gt;&lt;/a&gt; since it includes timestamps and total uptime which can be used nicely for profiling:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/eHqdn.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/eHqdn.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;At work we have a really nice tool that helps us monitoring what we want in terms of scheduling. This has been useful numerous times.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s in C++ and must be customized to your needs. Unfortunately I can&apos;t share code, just concepts.\nYou use a &quot;large&quot; &lt;code&gt;volatile&lt;/code&gt; buffer containing timestamps and event ID that you can dump post mortem or after stopping the logging system (and dump this into a file for example).&lt;/p&gt;\n\n&lt;p&gt;You retrieve the so-called large buffer with all the data and a small interface parses it and shows events with name (up/down + value) like an oscilloscope does with colors (configured in &lt;code&gt;.hpp&lt;/code&gt; file).&lt;/p&gt;\n\n&lt;p&gt;You customize the amount of events generated to focus solely on what you desire. It helped us a lot for scheduling issues while consuming the amount of CPU we wanted based on the amount of logged events per second. &lt;/p&gt;\n\n&lt;p&gt;You need 3 files : &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;toolname.hpp &lt;span class=&quot;hljs-comment&quot;&gt;// interface&lt;/span&gt;\ntoolname.cpp &lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\ntool_events_id.hpp &lt;span class=&quot;hljs-comment&quot;&gt;// Events ID&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The concept is to define events in &lt;code&gt;tool_events_id.hpp&lt;/code&gt; like that :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// EVENT_NAME                         ID      BEGIN_END BG_COLOR NAME&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SOCK_PDU_RECV_D               0x0301  &lt;span class=&quot;hljs-comment&quot;&gt;//@D00301 BGEEAAAA # TX_PDU_Recv&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SOCK_PDU_RECV_F               0x0302  &lt;span class=&quot;hljs-comment&quot;&gt;//@F00301 BGEEAAAA # TX_PDU_Recv&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You also define a few functions in &lt;code&gt;toolname.hpp&lt;/code&gt; :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; LOG_LEVEL_ERROR 0&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; LOG_LEVEL_WARN 1&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;probe&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id,payload)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// etc&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Wherever in you code you can use :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;toolname&amp;lt;LOG_LEVEL&amp;gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;log&lt;/span&gt;(EVENT_NAME,VALUE);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;probe&lt;/code&gt; function uses a few assembly lines to retrieve the clock timestamp ASAP and then sets an entry in the buffer. We also have an atomic increment to safely find an index where to store the log event.\nOf course buffer is circular.&lt;/p&gt;\n\n&lt;p&gt;Hope the idea is not obfuscated by the lack of sample code.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;use a debugging software&lt;/strong&gt; \nhow to identify where the code is running slowly ?&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;just think you have a obstacle while you are in motion then it will decrease your speed&lt;/strong&gt;  &lt;/p&gt;\n\n&lt;p&gt;like that unwanted reallocation&apos;s looping,buffer overflows,searching,memory leakages etc operations consumes more execution power it will effect adversely over performance of the code,\nBe sure to add -pg to compilation before profiling:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;g++ your_prg.cpp -pg&lt;/code&gt; or &lt;code&gt;cc my_program.cpp -g -pg&lt;/code&gt; as per your compiler&lt;/p&gt;\n\n&lt;p&gt;haven&apos;t tried it yet but I&apos;ve heard good things about google-perftools. It is definitely worth a try.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;valgrind --tool=callgrind ./(Your binary)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;It will generate a file called gmon.out or callgrind.out.x. You can then use kcachegrind or debugger tool to read this file. It will give you a graphical analysis of things with results like which lines cost how much. &lt;/p&gt;\n\n&lt;p&gt;i think so&lt;/p&gt;\n    ","\n&lt;p&gt;As no one mentioned Arm MAP, I&apos;d add it as personally I have successfully used Map to profile a C++ scientific program. &lt;/p&gt;\n\n&lt;p&gt;Arm MAP is the profiler for parallel, multithreaded or single threaded C, C++, Fortran and F90 codes.  It provides in-depth analysis and bottleneck pinpointing to the source line.  Unlike most profilers, it&apos;s designed to be able to profile pthreads, OpenMP or MPI for parallel and threaded code.&lt;/p&gt;\n\n&lt;p&gt;MAP is commercial software. &lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;-pg&lt;/code&gt; flag when compiling and linking the code and run the executable file. While this program is executed, profiling data is collected in the file a.out.&lt;br&gt;\nThere is two different type of profiling&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;1- Flat profiling: &lt;br&gt;\n by running the command &lt;code&gt;gprog --flat-profile a.out&lt;/code&gt; you got the following data&lt;br&gt;\n - what percentage of the overall time was spent for the function,&lt;br&gt;\n - how many seconds were spent in a functionincluding and excluding calls to sub-functions,&lt;br&gt;\n - the number of calls,&lt;br&gt;\n - the average time per call.&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;2- graph profiling&lt;br&gt;\nus the command &lt;code&gt;gprof --graph a.out&lt;/code&gt; to get the following data for each function which includes&lt;br&gt;\n - In each section, one function is marked with an index number.&lt;br&gt;\n - Above function , there is a list of functions that call the function .&lt;br&gt;\n - Below function , there is a list of functions that are called by the function .&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;To get more info you can look in &lt;a href=&quot;https://sourceware.org/binutils/docs-2.32/gprof/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://sourceware.org/binutils/docs-2.32/gprof/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;\n    "],"id":144,"title":"How do I profile C++ code running on Linux?","content":"\n                \n&lt;p&gt;How do I find areas of my code that run slowly in a C++ application running on Linux?&lt;/p&gt;\n    ","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272","postType":"QUESTION","createdAt":"2022-07-09T16:39:14.000Z","updatedAt":"2022-07-09T16:39:14.000Z","tags":[{"id":524,"name":"profiling","slug":"profiling","createdAt":"2022-07-09T16:39:14.000Z","updatedAt":"2022-07-09T16:39:14.000Z","Questions_Tags":{"questionId":144,"tagId":524}}]}},"__N_SSG":true}