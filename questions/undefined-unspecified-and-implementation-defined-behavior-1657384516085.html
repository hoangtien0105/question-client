<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-bf26e92d2540e305.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_buildManifest.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085">Undefined, unspecified and implementation-defined behavior</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div><div class="question-content mt-5">
                
<p>What is <em>undefined behavior</em> (UB) in C and C++?  What about <em>unspecified behavior</em> and <em>implementation-defined</em> behavior?  What is the difference between them?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em><strong>Undefined behavior</strong></em> is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</p>
<p>Let's look at a classic example:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">char</span>* p = <span class="hljs-string">"hello!\n"</span>;   <span class="hljs-comment">// yes I know, deprecated conversion</span>
    p[<span class="hljs-number">0</span>] = <span class="hljs-string">'y'</span>;
    p[<span class="hljs-number">5</span>] = <span class="hljs-string">'w'</span>;
    std::cout &lt;&lt; p;
}
</code></pre>
<p>The variable <code>p</code> points to the string literal <code>"hello!\n"</code>, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes <em>undefined behavior</em>:</p>
<blockquote>
<p>The effect of attempting to modify a string literal is undefined.</p>
</blockquote>
<p>I can hear people screaming "But wait, I can compile this no problem and get the output <code>yellow</code>" or "What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump". This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a "correct" behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</p>
<p>Other examples of undefined behavior include accessing an array beyond its bounds, <a href="https://stackoverflow.com/q/2894891">dereferencing the null pointer</a>, <a href="https://stackoverflow.com/q/6441218">accessing objects after their lifetime ended</a> or writing <a href="https://stackoverflow.com/q/949433">allegedly clever expressions</a> like <code>i++ + ++i</code>.</p>
<p>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, <strong>unspecified behavior</strong> and <strong>implementation-defined behavior</strong>:</p>
<blockquote>
<p>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</p>
<p>Certain aspects and operations of the abstract machine are described in this International Standard as <strong>implementation-defined</strong> (for example, <code>sizeof(int)</code>). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</p>
<p>Certain other aspects and operations of the abstract machine are described in this International Standard as <strong>unspecified</strong> (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</p>
<p>Certain other operations are described in this International Standard as <strong>undefined</strong> (for example, the  effect of dereferencing the null pointer). [ <em>Note</em>: <strong>this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.</strong> <em>end note</em> ]</p>
</blockquote>
<p>Specifically, section 1.3.24 states:</p>
<blockquote>
<p>Permissible undefined behavior ranges from <strong>ignoring the situation completely with unpredictable results</strong>, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>
</blockquote>
<p>What can you do to avoid running into undefined behavior? Basically, you have to read <a href="https://stackoverflow.com/questions/388242/">good C++ books</a> by authors who know what they're talking about. Avoid internet tutorials. Avoid bullschildt.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, this is basically a straight copy-paste from the standard</p>
<blockquote>
<p><strong>3.4.1</strong> 1 <strong>implementation-defined behavior</strong> unspecified behavior where
each implementation documents how the
choice is made</p>
<p>2 EXAMPLE An example of
implementation-defined behavior is the
propagation of the high-order bit when
a signed integer is shifted right.</p>
<p><strong>3.4.3</strong> 1 <strong>undefined behavior</strong> behavior, upon use of a nonportable or erroneous
program construct or of erroneous
data, for which this International
Standard imposes no requirements</p>
<p>2
NOTE Possible undefined behavior
ranges from ignoring the situation
completely with unpredictable results,
to behaving during translation or
program execution in a documented
manner characteristic of the
environment (with or without the
issuance of a diagnostic message), to
terminating a translation or execution
(with the issuance of a diagnostic
message).</p>
<p>3 EXAMPLE An example of
undefined behavior is the behavior on
integer overflow.</p>
<p><strong>3.4.4</strong> 1 <strong>unspecified behavior</strong> use of an unspecified value, or other behavior
where this International Standard
provides two or more possibilities and
imposes no further requirements on
which is chosen in any instance</p>
<p>2
EXAMPLE An example of unspecified
behavior is the order in which the
arguments to a function are evaluated.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</p>
<p><strong>implementation-defined behavior</strong><br>
The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</p>
<p><strong>undefined behavior</strong><br>
You are doing something wrong. For example, you have a very large value in an <code>int</code> that doesn't fit in <code>char</code>. How do you put that value in <code>char</code>? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in <code>char</code>. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</p>
<p><strong>unspecified behavior</strong><br>
Which function of these two is executed first?</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"fun1"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"fun2"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}
...
<span class="hljs-built_in">fun</span>(<span class="hljs-built_in">fun1</span>(), <span class="hljs-built_in">fun2</span>()); <span class="hljs-comment">// which one is executed first?</span>
</code></pre>
<p>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</p>
<hr>
<p>@eSKay I think your question is worth editing the answer to clarify more :)</p>
<blockquote>
<p>for <code>fun(fun1(), fun2());</code> isn't the behaviour "implementation defined"? The compiler has to choose one or the other course, after all?</p>
</blockquote>
<p>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of <code>sizeof(int)</code>. So, it can't say that <code>sizeof(int)</code> is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called <em><strong>unspecified</strong></em>. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at <a href="//www.stroustrup.com/bs_faq2.html#undefined" rel="nofollow noreferrer">Dr. Stroustrup's answer for that</a>:</p>
<blockquote>
<p>It is claimed that the difference between what can be produced giving the compiler this freedom and requiring "ordinary left-to-right evaluation" can be significant. I'm unconvinced, but with innumerable compilers "out there" taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as <code>++i+i++</code>. Similarly, the order of evaluation of arguments is unspecified.</p>
<p>IMO far too many "things" are left undefined, unspecified, that's easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From the official C Rationale Document</p>

<blockquote>
  <p>The terms <em>unspecified</em> behavior, <em>undefined</em> behavior, and <em>implementation-defined</em> behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. </p>
  
  <p><em>Unspecified behavior</em> gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. </p>
  
  <p><em>Undefined behavior</em> gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. </p>
  
  <p><em>Implementation-defined</em> behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. </p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://www.devx.com/tips/Tip/12684" rel="noreferrer">Undefined Behavior vs. Unspecified Behavior</a> has a short description of it.</p>

<p>Their final summary:</p>

<blockquote>
  <p>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Implementation defined- </p>

<blockquote>
  <p>Implementors wish,should be well documented,standard gives choices but sure to compile</p>
</blockquote>

<p>Unspecified -</p>

<blockquote>
  <p>Same as implementation-defined but not documented</p>
</blockquote>

<p>Undefined-</p>

<blockquote>
  <p>Anything might happen,take care of it.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose <em>whether the Standard requires it or not</em>.</p>

<p>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior <em>even in cases where nothing the implementation could possibly do would be useful</em>.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but <em>whether there might be implementations where defining a behavior would be simultaneously costly and useless</em>.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</p>

<p>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse <em>not</em> to do so.</p>

<p>For example, given the following code:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scaled_velocity</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pow)</span>
</span>{
  <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">250</span>)
    v = <span class="hljs-number">250</span>;
  <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">-250</span>)
    v = <span class="hljs-number">-250</span>;
  <span class="hljs-keyword">return</span> v &lt;&lt; pow;
}
</code></pre>

<p>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression <code>v &lt;&lt; pow</code> as a two's-complement shift
without regard for whether <code>v</code> was positive or negative.</p>

<p>The preferred philosophy among some of today's compiler writers, however, would suggest that because <code>v</code> can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of <code>v</code>.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++ standard n3337  <strong>ยง</strong> 1.3.10
<strong>implementation-defined behavior</strong></p>

<blockquote>
  <p>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</p>
</blockquote>

<p>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and <strong>described</strong> by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this. </p>

<hr>

<p>C++ standard n3337  <strong>ยง</strong> 1.3.24
<strong>undefined behavior</strong></p>

<blockquote>
  <p>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed.  end note ]</p>
</blockquote>

<p>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). </p>

<hr>

<p>C++ standard n3337  <strong>ยง</strong> 1.3.25
<strong>unspecified behavior</strong></p>

<blockquote>
  <p>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard.  end
  note ]</p>
</blockquote>

<p>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( <strong>bot not necessary described</strong>) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Undefined behavior is <em>ugly</em> -- as in, "The good, the bad, and the ugly".</p>
<p>Good: a program that compiles and works, for the right reasons.</p>
<p>Bad: a program that has an error, of a kind that the compiler can detect and complain about.</p>
<p>Ugly: a program that has an error, that the compiler <em>cannot</em> detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That's what undefined behavior is.</p>
<p>Some program languages and other formal systems try hard to limit the "gulf of undefinedness" -- that is, they try to arrange things so that most or all programs are either "good" or "bad", and that very few are "ugly".  It's a characteristic feature of C, however, that its "gulf of undefinedness" is quite wide.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s look at a classic example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello!\\n\u0026quot;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yes I know, deprecated conversion\u0026lt;/span\u0026gt;\n    p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;;\n    p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;w\u0026apos;\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; p;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The variable \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; points to the string literal \u0026lt;code\u0026gt;\u0026quot;hello!\\n\u0026quot;\u0026lt;/code\u0026gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The effect of attempting to modify a string literal is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;I can hear people screaming \u0026quot;But wait, I can compile this no problem and get the output \u0026lt;code\u0026gt;yellow\u0026lt;/code\u0026gt;\u0026quot; or \u0026quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump\u0026quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a \u0026quot;correct\u0026quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Other examples of undefined behavior include accessing an array beyond its bounds, \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/2894891\u0026quot;\u0026gt;dereferencing the null pointer\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/6441218\u0026quot;\u0026gt;accessing objects after their lifetime ended\u0026lt;/a\u0026gt; or writing \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/949433\u0026quot;\u0026gt;allegedly clever expressions\u0026lt;/a\u0026gt; like \u0026lt;code\u0026gt;i++ + ++i\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Section 1.9 of the C++ standard also mentions undefined behavior\u0026apos;s two less dangerous brothers, \u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain aspects and operations of the abstract machine are described in this International Standard as \u0026lt;strong\u0026gt;implementation-defined\u0026lt;/strong\u0026gt; (for example, \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain other aspects and operations of the abstract machine are described in this International Standard as \u0026lt;strong\u0026gt;unspecified\u0026lt;/strong\u0026gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain other operations are described in this International Standard as \u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt; (for example, the  effect of dereferencing the null pointer). [ \u0026lt;em\u0026gt;Note\u0026lt;/em\u0026gt;: \u0026lt;strong\u0026gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;end note\u0026lt;/em\u0026gt; ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Specifically, section 1.3.24 states:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Permissible undefined behavior ranges from \u0026lt;strong\u0026gt;ignoring the situation completely with unpredictable results\u0026lt;/strong\u0026gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;What can you do to avoid running into undefined behavior? Basically, you have to read \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/388242/\u0026quot;\u0026gt;good C++ books\u0026lt;/a\u0026gt; by authors who know what they\u0026apos;re talking about. Avoid internet tutorials. Avoid bullschildt.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, this is basically a straight copy-paste from the standard\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.1\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt; unspecified behavior where\neach implementation documents how the\nchoice is made\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2 EXAMPLE An example of\nimplementation-defined behavior is the\npropagation of the high-order bit when\na signed integer is shifted right.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.3\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt; behavior, upon use of a nonportable or erroneous\nprogram construct or of erroneous\ndata, for which this International\nStandard imposes no requirements\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2\nNOTE Possible undefined behavior\nranges from ignoring the situation\ncompletely with unpredictable results,\nto behaving during translation or\nprogram execution in a documented\nmanner characteristic of the\nenvironment (with or without the\nissuance of a diagnostic message), to\nterminating a translation or execution\n(with the issuance of a diagnostic\nmessage).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;3 EXAMPLE An example of\nundefined behavior is the behavior on\ninteger overflow.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.4\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt; use of an unspecified value, or other behavior\nwhere this International Standard\nprovides two or more possibilities and\nimposes no further requirements on\nwhich is chosen in any instance\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2\nEXAMPLE An example of unspecified\nbehavior is the order in which the\narguments to a function are evaluated.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Maybe easy wording could be easier for understanding than the rigorous definition of the standards.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nThe language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nYou are doing something wrong. For example, you have a very large value in an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; that doesn\u0026apos;t fit in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;. How do you put that value in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWhich function of these two is executed first?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fun1\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fun2\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n}\n...\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun1\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun2\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which one is executed first?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The language doesn\u0026apos;t specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn\u0026apos;t result in an undefined behavior, but certainly your program should not produce an unspecified behavior.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;@eSKay I think your question is worth editing the answer to clarify more :)\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;for \u0026lt;code\u0026gt;fun(fun1(), fun2());\u0026lt;/code\u0026gt; isn\u0026apos;t the behaviour \u0026quot;implementation defined\u0026quot;? The compiler has to choose one or the other course, after all?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn\u0026apos;t have to in the second case. For example, an implementation must have one and only one definition of \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt;. So, it can\u0026apos;t say that \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function\u0026apos;s arguments are evaluated right-to-left. It can happen in the same program, that\u0026apos;s why it is called \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;unspecified\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at \u0026lt;a href=\u0026quot;//www.stroustrup.com/bs_faq2.html#undefined\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Dr. Stroustrup\u0026apos;s answer for that\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;It is claimed that the difference between what can be produced giving the compiler this freedom and requiring \u0026quot;ordinary left-to-right evaluation\u0026quot; can be significant. I\u0026apos;m unconvinced, but with innumerable compilers \u0026quot;out there\u0026quot; taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as \u0026lt;code\u0026gt;++i+i++\u0026lt;/code\u0026gt;. Similarly, the order of evaluation of arguments is unspecified.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;IMO far too many \u0026quot;things\u0026quot; are left undefined, unspecified, that\u0026apos;s easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the official C Rationale Document\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The terms \u0026lt;em\u0026gt;unspecified\u0026lt;/em\u0026gt; behavior, \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt; behavior, and \u0026lt;em\u0026gt;implementation-defined\u0026lt;/em\u0026gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unspecified behavior\u0026lt;/em\u0026gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Undefined behavior\u0026lt;/em\u0026gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Implementation-defined\u0026lt;/em\u0026gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.devx.com/tips/Tip/12684\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Undefined Behavior vs. Unspecified Behavior\u0026lt;/a\u0026gt; has a short description of it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Their final summary:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;To sum up, unspecified behavior is usually something you shouldn\u0026apos;t\n  worry about, unless your software is required to be portable.\n  Conversely, undefined behavior is always undesirable and should never\n  occur.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Implementation defined- \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Implementors wish,should be well documented,standard gives choices but sure to compile\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Unspecified -\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Same as implementation-defined but not documented\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Undefined-\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Anything might happen,take care of it.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that\u0026apos;s useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose \u0026lt;em\u0026gt;whether the Standard requires it or not\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior \u0026lt;em\u0026gt;even in cases where nothing the implementation could possibly do would be useful\u0026lt;/em\u0026gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but \u0026lt;em\u0026gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless\u0026lt;/em\u0026gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren\u0026apos;t worth the cost even in application fields where they\u0026apos;re vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; to do so.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, given the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scaled_velocity\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; pow)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;)\n    v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-250\u0026lt;/span\u0026gt;)\n    v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-250\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v \u0026amp;lt;\u0026amp;lt; pow;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;a two\u0026apos;s-complement implementation would not have to expend any effort\nwhatsoever to treat the expression \u0026lt;code\u0026gt;v \u0026amp;lt;\u0026amp;lt; pow\u0026lt;/code\u0026gt; as a two\u0026apos;s-complement shift\nwithout regard for whether \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt; was positive or negative.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The preferred philosophy among some of today\u0026apos;s compiler writers, however, would suggest that because \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt; can only be negative if the program is going to engage in Undefined Behavior, there\u0026apos;s no reason to have the program clip the negative range of \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.10\n\u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation and that each implementation documents\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes C++ Standard doesn\u0026apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and \u0026lt;strong\u0026gt;described\u0026lt;/strong\u0026gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn\u0026apos;t describe this. \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.24\n\u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.  end note ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.25\n\u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation [ Note: The implementation is not\n  required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard.  end\n  note ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;C++ Standard doesn\u0026apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( \u0026lt;strong\u0026gt;bot not necessary described\u0026lt;/strong\u0026gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Undefined behavior is \u0026lt;em\u0026gt;ugly\u0026lt;/em\u0026gt; -- as in, \u0026quot;The good, the bad, and the ugly\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Good: a program that compiles and works, for the right reasons.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bad: a program that has an error, of a kind that the compiler can detect and complain about.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Ugly: a program that has an error, that the compiler \u0026lt;em\u0026gt;cannot\u0026lt;/em\u0026gt; detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That\u0026apos;s what undefined behavior is.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some program languages and other formal systems try hard to limit the \u0026quot;gulf of undefinedness\u0026quot; -- that is, they try to arrange things so that most or all programs are either \u0026quot;good\u0026quot; or \u0026quot;bad\u0026quot;, and that very few are \u0026quot;ugly\u0026quot;.  It\u0026apos;s a characteristic feature of C, however, that its \u0026quot;gulf of undefinedness\u0026quot; is quite wide.\u0026lt;/p\u0026gt;\n    "],"id":80,"title":"Undefined, unspecified and implementation-defined behavior","content":"\n                \n\u0026lt;p\u0026gt;What is \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; (UB) in C and C++?  What about \u0026lt;em\u0026gt;unspecified behavior\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;implementation-defined\u0026lt;/em\u0026gt; behavior?  What is the difference between them?\u0026lt;/p\u0026gt;\n    ","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085","postType":"QUESTION","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","tags":[{"id":294,"name":"undefined-behavior","slug":"undefined-behavior","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","Questions_Tags":{"questionId":80,"tagId":294}},{"id":295,"name":"unspecified-behavior","slug":"unspecified-behavior","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","Questions_Tags":{"questionId":80,"tagId":295}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"},"buildId":"9SrIo1zGFc3tF1E8on9-4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>