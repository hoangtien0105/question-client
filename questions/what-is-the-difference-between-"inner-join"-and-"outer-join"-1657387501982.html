<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Also, how do LEFT JOIN, RIGHT JOIN, and FULL JOIN fit in?
    "/><meta property="og:title" content="What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;? | Solutions Checker"/><meta property="og:description" content="Also, how do LEFT JOIN, RIGHT JOIN, and FULL JOIN fit in?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;?","text":"Also, how do LEFT JOIN, RIGHT JOIN, and FULL JOIN fit in?\n    ","answerCount":28,"upVoteCount":500,"suggestedAnswer":[{"text":"Assuming you&apos;re joining on columns with no duplicates, which is a very common case:\n\nAn inner join of A and B gives the result of A intersect B, i.e. the inner part of a Venn diagram intersection.\n\nAn outer join of A and B gives the results of A union B, i.e. the outer parts of a Venn diagram union.\n\n\nExamples\nSuppose you have two tables, with a single column each, and data as follows:\nA    B\n-    -\n1    3\n2    4\n3    5\n4    6\n\nNote that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.\nInner join\nAn inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.\nselect * from a INNER JOIN b on a.a = b.b;\nselect a.*, b.*  from a,b where a.a = b.b;\n\na | b\n--+--\n3 | 3\n4 | 4\n\nLeft outer join\nA left outer join will give all rows in A, plus any common rows in B.\nselect * from a LEFT OUTER JOIN b on a.a = b.b;\nselect a.*, b.*  from a,b where a.a = b.b(+);\n\na |  b\n--+-----\n1 | null\n2 | null\n3 |    3\n4 |    4\n\nRight outer join\nA right outer join will give all rows in B, plus any common rows in A.\nselect * from a RIGHT OUTER JOIN b on a.a = b.b;\nselect a.*, b.*  from a,b where a.a(+) = b.b;\n\na    |  b\n-----+----\n3    |  3\n4    |  4\nnull |  5\nnull |  6\n\nFull outer join\nA full outer join will give you the union of A and B, i.e. all the rows in A and all the rows in B. If something in A doesn&apos;t have a corresponding datum in B, then the B portion is null, and vice versa.\nselect * from a FULL OUTER JOIN b on a.a = b.b;\n\n a   |  b\n-----+-----\n   1 | null\n   2 | null\n   3 |    3\n   4 |    4\nnull |    6\nnull |    5\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The Venn diagrams don&apos;t really do it for me.\nThey don&apos;t show any distinction between a cross join and an inner join, for example, or more generally show any distinction between different types of join predicate or provide a framework for reasoning about how they will operate.\nThere is no substitute for understanding the logical processing and it is relatively straightforward to grasp anyway.\n\nImagine a cross join.\nEvaluate the on clause against all rows from step 1 keeping those where the predicate evaluates to true\n(For outer joins only) add back in any outer rows that were lost in step 2.\n\n(NB: In practice the query optimiser may find more efficient ways of executing the query than the purely logical description above but the final result must be the same)\nI&apos;ll start off with an animated version of a full outer join. Further explanation follows.\n\n\nExplanation\nSource Tables\n\nFirst start with a CROSS JOIN (AKA Cartesian Product). This does not have an ON clause and simply returns every combination of rows from the two tables.\nSELECT A.Colour, B.Colour FROM A CROSS JOIN B\n\nInner and Outer joins have an &quot;ON&quot; clause predicate.\n\nInner Join. Evaluate the condition in the &quot;ON&quot; clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.\nLeft Outer Join. Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.\nRight Outer Join. Same as inner join then for any rows in the right table that did not  match anything output these with NULL values for the left table columns.\nFull Outer Join. Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.\n\nSome examples\nSELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour\nThe above is the classic equi join.\n\nAnimated Version\n\nSELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN (&apos;Green&apos;,&apos;Blue&apos;)\nThe inner join condition need not necessarily be an equality condition and it need not reference columns from both (or even either) of the tables. Evaluating A.Colour NOT IN (&apos;Green&apos;,&apos;Blue&apos;) on each row of the cross join returns.\n\nSELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1\nThe join condition evaluates to true for all rows in the cross join result so this is just the same as a cross join. I won&apos;t repeat the picture of the 16 rows again.\nSELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour\nOuter Joins are logically evaluated in the same way as inner joins except that if a row from the left table (for a left join) does not join with any rows from the right hand table at all it is preserved in the result with NULL values for the right hand columns.\n\nSELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour IS NULL\nThis simply restricts the previous result to only return the rows where B.Colour IS NULL. In this particular case these will be the rows that were preserved as they had no match in the right hand table and the query returns the single red row not matched in table B. This is known as an anti semi join.\nIt is important to select a column for the IS NULL test that is either not nullable or for which the join condition ensures that any NULL values will be excluded in order for this pattern to work correctly and avoid just bringing back rows which happen to have a NULL value for that column in addition to the un matched rows.\n\nSELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour\nRight outer joins act similarly to left outer joins except they preserve non matching rows from the right table and null extend the left hand columns.\n\nSELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour\nFull outer joins combine the behaviour of left and right joins and preserve the non matching rows from both the left and the right tables.\n\nSELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0\nNo rows in the cross join match the 1=0 predicate. All rows from both sides are preserved using normal outer join rules with NULL in the columns from the table on the other side.\n\nSELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON 1 = 0\nWith a minor amend to the preceding query one could simulate a UNION ALL of the two tables.\n\nSELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour = &apos;Green&apos;\nNote that the WHERE clause (if present) logically runs after the join. One common error is to perform a left outer join and then include a WHERE clause with a condition on the right table that ends up excluding the non matching rows. The above ends up performing the outer join...\n\n... And then the &quot;Where&quot; clause runs. NULL= &apos;Green&apos; does not evaluate to true so the row preserved by the outer join ends up discarded (along with the blue one) effectively converting the join back to an inner one.\n\nIf the intention was to include only rows from B where Colour is Green and all rows from A regardless the correct syntax would be\nSELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour AND B.Colour = &apos;Green&apos;\n\nSQL Fiddle\nSee these examples run live at SQLFiddle.com.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Joins are used to combine the data from two tables, with the result being a new, temporary table. Joins are performed based on something called a predicate, which specifies the condition to use in order to perform a join.  The difference between an inner join and an outer join is that an inner join will return only the rows that actually match based on the join predicate.\nFor eg- Lets consider Employee and Location table:\nEmployee\n\n\n\n\nEmpID\nEmpName\n\n\n\n\n13\nJason\n\n\n8\nAlex\n\n\n3\nRam\n\n\n17\nBabu\n\n\n25\nJohnson\n\n\n\nLocation\n\n\n\n\nEmpID\nEmpLoc\n\n\n\n\n13\nSan Jose\n\n\n8\nLos Angeles\n\n\n3\nPune, India\n\n\n17\nChennai, India\n\n\n39\nBangalore, India\n\n\n\n\nInner Join:-\nInner join creates a new result table by combining column values of two tables (Employee and Location) based upon the join-predicate. The query compares each row of Employee with each row of Location to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of Employee and Location are combined into a result row.\nHeres what the SQL for an inner join will look like:\nselect  * from employee inner join location on employee.empID = location.empID\nOR\nselect  * from employee, location where employee.empID = location.empID\n\nNow, here is what the result of running that SQL would look like:\n\n\n\n\nEmployee.EmpId\nEmployee.EmpName\nLocation.EmpId\nLocation.EmpLoc\n\n\n\n\n13\nJason\n13\nSan Jose\n\n\n8\nAlex\n8\nLos Angeles\n\n\n3\nRam\n3\nPune, India\n\n\n17\nBabu\n17\nChennai, India\n\n\n\n\nOuter Join:-\nAn outer join does not require each record in the two joined tables to have a matching record. The joined table retains each recordeven if no other matching record exists. Outer joins subdivide further into left outer joins and right outer joins, depending on which table&apos;s rows are retained (left or right).\nLeft Outer Join:-\nThe result of a left outer join (or simply left join) for tables Employee and Location always contains all records of the &quot;left&quot; table (Employee), even if the join-condition does not find any matching record in the &quot;right&quot; table (Location).\nHere is what the SQL for a left outer join would look like, using the tables above:\nselect  * from employee left outer join location on employee.empID = location.empID;\n//Use of outer keyword is optional\n\nNow, here is what the result of running this SQL would look like:\n\n\n\n\nEmployee.EmpId\nEmployee.EmpName\nLocation.EmpId\nLocation.EmpLoc\n\n\n\n\n13\nJason\n13\nSan Jose\n\n\n8\nAlex\n8\nLos Angeles\n\n\n3\nRam\n3\nPune, India\n\n\n17\nBabu\n17\nChennai, India\n\n\n25\nJohnson\nNULL\nNULL\n\n\n\n\nNote how while Johnson has no entry in the employee location table, he is still included in the results but the location fields are nulled.\nRight Outer Join:-\nA right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the &quot;right&quot; table (Location) will appear in the joined table at least once. If no matching row from the &quot;left&quot; table (Employee) exists, NULL will appear in columns from Employee for those records that have no match in Location.\nThis is what the SQL looks like:\nselect * from employee right outer join location  on employee.empID = location.empID;\n//Use of outer keyword is optional\n\nUsing the tables above, we can show what the result set of a right outer join would look like:\n\n\n\n\nEmployee.EmpId\nEmployee.EmpName\nLocation.EmpId\nLocation.EmpLoc\n\n\n\n\n13\nJason\n13\nSan Jose\n\n\n8\nAlex\n8\nLos Angeles\n\n\n3\nRam\n3\nPune, India\n\n\n17\nBabu\n17\nChennai, India\n\n\nNULL\nNULL\n39\nBangalore, India\n\n\n\n\nNote how while there are no employees listed as working in Bangalore, it is still included in the results with the employee fields nulled out.\nFull Outer Joins:-\nFull Outer Join or Full Join is to retain the nonmatching information by including nonmatching rows in the results of a join, use a full outer join. It includes all rows from both tables, regardless of whether or not the other table has a matching value.\n\n\n\n\nEmployee.EmpId\nEmployee.EmpName\nLocation.EmpId\nLocation.EmpLoc\n\n\n\n\n13\nJason\n13\nSan Jose\n\n\n8\nAlex\n8\nLos Angeles\n\n\n3\nRam\n3\nPune, India\n\n\n17\nBabu\n17\nChennai, India\n\n\n25\nJohnson\nNULL\nNULL\n\n\nNULL\nNULL\n39\nBangalore, India\n\n\n\n\nMySQL 8.0 Reference Manual - Join Syntax\nOracle Join operations\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Inner Join\nRetrieve the matched rows only, that is, A intersect B.\n\nSELECT *\nFROM dbo.Students S\nINNER JOIN dbo.Advisors A\n    ON S.Advisor_ID = A.Advisor_ID\n\n\nLeft Outer Join\nSelect all records from the first table, and any records in the second\ntable that match the joined keys.\n\nSELECT *\nFROM dbo.Students S\nLEFT JOIN dbo.Advisors A\n    ON S.Advisor_ID = A.Advisor_ID\n\n\nFull Outer Join\nSelect all records from the second table, and any records in the first\ntable that match the joined keys.\n\nSELECT *\nFROM dbo.Students S\nFULL JOIN dbo.Advisors A\n    ON S.Advisor_ID = A.Advisor_ID\n\n\nReferences\n\nInner and outer joins SQL examples and the Join block\n\nSQL: JOINS\n\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"In simple words:\n\nAn inner join retrieve the matched rows only.\n\nWhereas an outer join retrieve the matched rows from one table and all rows in other table ....the result depends on which one you are using:\n\n\nLeft: Matched rows in the right table and all rows in the left table\nRight: Matched rows in the left table and all rows in the right table or \nFull: All rows in all tables. It doesn&apos;t matter if there is a match or not\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"A inner join only shows rows if there is a matching record on the other (right) side of the join.\n\nA (left) outer join shows rows for each record on the left hand side, even if there are no matching rows on the other (right) side of the join. If there is no matching row, the columns for the other (right) side would show NULLs.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Inner joins require that a record with a related ID exist in the joined table.\n\nOuter joins will return records for the left side even if nothing exists for the right side.\n\nFor instance, you have an Orders and an OrderDetails table. They are related by an &quot;OrderID&quot;.\n\nOrders\n\n\nOrderID\nCustomerName\n\n\nOrderDetails\n\n\nOrderDetailID\nOrderID\nProductName\nQty\nPrice\n\n\nThe request\n\nSELECT Orders.OrderID, Orders.CustomerName\n  FROM Orders \n INNER JOIN OrderDetails\n    ON Orders.OrderID = OrderDetails.OrderID\n\n\nwill only return Orders that also have something in the OrderDetails table.\n\nIf you change it to OUTER LEFT JOIN\n\nSELECT Orders.OrderID, Orders.CustomerName\n  FROM Orders \n  LEFT JOIN OrderDetails\n    ON Orders.OrderID = OrderDetails.OrderID\n\n\nthen it will return records from the Orders table even if they have no OrderDetails records.\n\nYou can use this to find Orders that do not have any OrderDetails indicating a possible orphaned order by adding a where clause like WHERE OrderDetails.OrderID IS NULL.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"In simple words :\nInner join -&gt; Take ONLY common records from parent and child tables WHERE primary key of Parent table matches Foreign key in Child table.\nLeft join -&gt;\npseudo code\n1.Take All records from left Table\n2.for(each record in right table,) {\n    if(Records from left &amp; right table matching on primary &amp; foreign key){\n       use their values as it is as result of join at the right side for 2nd table.\n    } else {\n       put value NULL values in that particular record as result of join at the right side for 2nd table.\n    }\n  }\n\nRight join : Exactly opposite of left join . Put name of table in LEFT JOIN at right side in Right join , you get same output as LEFT JOIN.\nOuter join : Show all records in Both tables No matter what. If records in Left table are not matching to right table based on Primary , Forieign key , use NULL value as result of join .\nExample :\n\nLets assume now for 2 tables\n1.employees  , 2.phone_numbers_employees\nemployees : id , name \n\nphone_numbers_employees : id , phone_num , emp_id   \n\nHere , employees table is Master table , phone_numbers_employees is child table(it contains emp_id as foreign key which connects employee.id so its child table.)\nInner joins\nTake the records of 2 tables ONLY IF Primary key of employees table(its id) matches Foreign key of Child table phone_numbers_employees(emp_id).\nSo query would be :\nSELECT e.id , e.name , p.phone_num FROM employees AS e INNER JOIN phone_numbers_employees AS p ON e.id = p.emp_id;\n\nHere take only matching rows on primary key = foreign key as explained above.Here non matching rows on primary key = foreign key are skipped as result of join.\nLeft joins :\nLeft join retains all rows of the left table, regardless of whether there is a row that matches on the right table.\nSELECT e.id , e.name , p.phone_num FROM employees AS e LEFT JOIN phone_numbers_employees AS p ON e.id = p.emp_id;\n\nOuter joins :\nSELECT e.id , e.name , p.phone_num FROM employees AS e OUTER JOIN phone_numbers_employees AS p ON e.id = p.emp_id;\n\nDiagramatically it looks like :\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"You use INNER JOIN to return all rows from both tables where there is a match. i.e. In the resulting table all the rows and columns will have values.\n\nIn OUTER JOIN the resulting table may have empty columns. Outer join may be either LEFT or RIGHT.\n\nLEFT OUTER JOIN returns all the rows from the first table, even if there are no matches in the second table.\n\nRIGHT OUTER JOIN returns all the rows from the second table, even if there are no matches in the first table.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"INNER JOIN requires there is at least a match in comparing the two tables. For example, table A and table B which implies A ٨ B (A intersection B).\n\nLEFT OUTER JOIN and LEFT JOIN are the same. It gives all the records matching in both tables and all possibilities of the left table.\n\nSimilarly, RIGHT OUTER JOIN and RIGHT JOIN are the same. It gives all the records matching in both tables and all possibilities of the right table.\n\nFULL JOIN is the combination of LEFT OUTER JOIN and RIGHT OUTER JOIN without duplication.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The answer is in the meaning of each one, so in the results.\n\n\n  Note :\n  In SQLite there is no RIGHT OUTER JOIN or FULL OUTER JOIN.\n  And also in MySQL there is no FULL OUTER JOIN.\n\n\nMy answer is based on above Note.\n\nWhen you have two tables like these: \n\n--[table1]               --[table2]\nid | name                id | name\n---+-------              ---+-------\n1  | a1                  1  | a2\n2  | b1                  3  | b2\n\n\n\n\nCROSS JOIN / OUTER JOIN :\nYou can have all of those tables data with CROSS JOIN or just with , like this:\n\nSELECT * FROM table1, table2\n--[OR]\nSELECT * FROM table1 CROSS JOIN table2\n\n--[Results:]\nid | name | id | name \n---+------+----+------\n1  | a1   | 1  | a2\n1  | a1   | 3  | b2\n2  | b1   | 1  | a2\n2  | b1   | 3  | b2\n\n\n\n\nINNER JOIN :\nWhen you want to add a filter to above results based on a relation like table1.id = table2.id you can use INNER JOIN:\n\nSELECT * FROM table1, table2 WHERE table1.id = table2.id\n--[OR]\nSELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id\n\n--[Results:]\nid | name | id | name \n---+------+----+------\n1  | a1   | 1  | a2\n\n\n\n\nLEFT [OUTER] JOIN :\nWhen you want to have all rows of one of tables in the above result -with same relation- you can use LEFT JOIN:\n(For RIGHT JOIN just change place of tables)\n\nSELECT * FROM table1, table2 WHERE table1.id = table2.id \nUNION ALL\nSELECT *, Null, Null FROM table1 WHERE Not table1.id In (SELECT id FROM table2)\n--[OR]\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id\n\n--[Results:]\nid | name | id   | name \n---+------+------+------\n1  | a1   | 1    | a2\n2  | b1   | Null | Null\n\n\n\n\nFULL OUTER JOIN :\nWhen you also want to have all rows of the other table in your results you can use FULL OUTER JOIN:\n\nSELECT * FROM table1, table2 WHERE table1.id = table2.id\nUNION ALL\nSELECT *, Null, Null FROM table1 WHERE Not table1.id In (SELECT id FROM table2)\nUNION ALL\nSELECT Null, Null, * FROM table2 WHERE Not table2.id In (SELECT id FROM table1)\n--[OR] (recommended for SQLite)\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id\nUNION ALL\nSELECT * FROM table2 LEFT JOIN table1 ON table2.id = table1.id\nWHERE table1.id IS NULL\n--[OR]\nSELECT * FROM table1 FULL OUTER JOIN table2 On table1.id = table2.id\n\n--[Results:]\nid   | name | id   | name \n-----+------+------+------\n1    | a1   | 1    | a2\n2    | b1   | Null | Null\nNull | Null | 3    | b2\n\n\nWell, as your need you choose each one that covers your need ;).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Inner join. \n\nA join is combining the rows from two tables. An inner join attempts to match up the two tables based on the criteria you specify in the query, and only returns the rows that match. If a row from the first table in the join matches two rows in the second table, then two rows will be returned in the results. If theres a row in the first table that doesnt match a row in the second, its not returned; likewise, if theres a row in the second table that doesnt match a row in the first, its not returned.\n\nOuter Join. \n\nA left join attempts to find match up the rows from the first table to rows in the second table. If it cant find a match, it will return the columns from the first table and leave the columns from the second table blank (null).\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"\n\n\nINNER JOIN most typical join for two or more tables.\nIt returns data match on both table ON primarykey and forignkey relation.\nOUTER JOIN is same as INNER JOIN, but it also include NULL data on ResultSet.\n\n\nLEFT JOIN = INNER JOIN + Unmatched data of left table with Null match on right table.\nRIGHT JOIN = INNER JOIN + Unmatched data of right table with Null match on left table.\nFULL JOIN = INNER JOIN + Unmatched data on both right and left tables with Null matches.\n\nSelf join is not a keyword in SQL, when a table references data in itself knows as self join. Using INNER JOIN and OUTER JOIN we can write self join queries.\n\n\nFor example:\n\nSELECT * \nFROM   tablea a \n       INNER JOIN tableb b \n               ON a.primary_key = b.foreign_key \n       INNER JOIN tablec c \n               ON b.primary_key = c.foreign_key \n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I don&apos;t see much details about performance and optimizer in the other answers.\n\nSometimes it is good to know that only INNER JOIN is associative which means the optimizer has the most option to play with it. It can reorder the join order to make it faster keeping the same result. The optimizer can use the most join modes.\n\nGenerally it is a good practice to try to use INNER JOIN instead of the different kind of joins. (Of course if it is possible considering the expected result set.)\n\nThere are a couple of good examples and explanation here about this strange associative behavior:\n\n\nAre left outer joins associative?\nDoes the join order matter in SQL?\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Having criticized the much-loved red-shaded Venn diagram, I thought it only fair to post my own attempt.\n\nAlthough @Martin Smith&apos;s answer is the best of this bunch by a long way, his only shows the key column from each table, whereas I think ideally non-key columns should also be shown.\n\nThe best I could do in the half hour allowed, I still don&apos;t think it adequately shows that the nulls are there due to absence of key values in TableB or that OUTER JOIN is actually a union rather than a join:\n\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"The precise algorithm for INNER JOIN, LEFT/RIGHT OUTER JOIN are as following: \n\n\nTake each row from the first table: a\nConsider all rows from second table beside it: (a, b[i])\nEvaluate the ON ... clause against each pair: ON( a, b[i] ) = true/false?\n\n\nWhen the condition evaluates to true, return that combined row  (a, b[i]).\nWhen reach end of second table without any match, and this is an Outer Join then return a (virtual) pair using Null for all columns of other table: (a, Null) for LEFT outer join or (Null, b) for RIGHT outer join. This is to ensure all rows of first table exists in final results.\n\n\n\nNote: the condition specified in ON clause could be anything, it is not required to use Primary Keys (and you don&apos;t need to always refer to Columns from both tables)! For example:\n\n\n... ON T1.title = T2.title AND T1.version &lt; T2.version ( =&gt; see this post as a sample usage: Select only rows with max value on a column)\n... ON T1.y IS NULL\n... ON 1 = 0 (just as sample)\n\n\n\n\n\n\n\n\nNote: Left Join = Left Outer Join, Right Join = Right Outer Join.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Simplest Definitions\n\nInner Join: Returns matched records from both tables.\n\nFull Outer Join: Returns matched and unmatched records from both tables with null for unmatched records from Both Tables.\n\nLeft Outer Join: Returns matched and unmatched records only from table on Left Side.\n\nRight Outer Join: Returns matched and unmatched records only from table on Right Side.\n\nIn-Short\n\nMatched + Left Unmatched + Right Unmatched = Full Outer Join\n\nMatched + Left Unmatched = Left Outer Join\n\nMatched + Right Unmatched = Right Outer Join\n\nMatched = Inner Join\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"The General Idea\nPlease see the answer by Martin Smith for a better illustations and explanations of the different joins, including and especially differences between FULL OUTER JOIN, RIGHT OUTER JOIN and LEFT OUTER JOIN.\nThese two table form a basis for the representation of the JOINs below:\n\nCROSS JOIN\n\nSELECT *\n  FROM citizen\n CROSS JOIN postalcode\n\nThe result will be the Cartesian products of all combinations. No JOIN condition required:\n\nINNER JOIN\nINNER JOIN is the same as simply: JOIN\n\nSELECT *\n  FROM citizen    c\n  JOIN postalcode p ON c.postal = p.postal\n\nThe result will be combinations that satisfies the required JOIN condition:\n\nLEFT OUTER JOIN\nLEFT OUTER JOIN is the same as LEFT JOIN\n\nSELECT *\n  FROM citizen         c\n  LEFT JOIN postalcode p ON c.postal = p.postal\n\nThe result will be everything from citizen even if there are no matches in postalcode. Again a JOIN condition is required:\n\nData for playing\nAll examples have been run on an Oracle 18c. They&apos;re available at dbfiddle.uk which is also where screenshots of tables came from.\nCREATE TABLE citizen (id      NUMBER,\n                      name    VARCHAR2(20),\n                      postal  NUMBER,  -- &lt;-- could do with a redesign to postalcode.id instead.\n                      leader  NUMBER);\n\nCREATE TABLE postalcode (id      NUMBER,\n                         postal  NUMBER,\n                         city    VARCHAR2(20),\n                         area    VARCHAR2(20));\n\nINSERT INTO citizen (id, name, postal, leader)\n              SELECT 1, &apos;Smith&apos;, 2200,  null FROM DUAL\n        UNION SELECT 2, &apos;Green&apos;, 31006, 1    FROM DUAL\n        UNION SELECT 3, &apos;Jensen&apos;, 623,  1    FROM DUAL;\n\nINSERT INTO postalcode (id, postal, city, area)\n                 SELECT 1, 2200,     &apos;BigCity&apos;,         &apos;Geancy&apos;  FROM DUAL\n           UNION SELECT 2, 31006,    &apos;SmallTown&apos;,       &apos;Snizkim&apos; FROM DUAL\n           UNION SELECT 3, 31006,    &apos;Settlement&apos;,      &apos;Moon&apos;    FROM DUAL  -- &lt;-- Uuh-uhh.\n           UNION SELECT 4, 78567390, &apos;LookoutTowerX89&apos;, &apos;Space&apos;   FROM DUAL;\n\nBlurry boundaries when playing with JOIN and WHERE\nCROSS JOIN\nCROSS JOIN resulting in rows as The General Idea/INNER JOIN:\nSELECT *\n  FROM citizen          c\n  CROSS JOIN postalcode p\n WHERE c.postal = p.postal -- &lt; -- The WHERE condition is limiting the resulting rows\n\nUsing CROSS JOIN to get the result of a LEFT OUTER JOIN requires tricks like adding in a NULL row. It&apos;s omitted.\nINNER JOIN\nINNER JOIN becomes a cartesian products. It&apos;s the same as The General Idea/CROSS JOIN:\nSELECT *\n  FROM citizen    c\n  JOIN postalcode p ON 1 = 1  -- &lt; -- The ON condition makes it a CROSS JOIN\n\nThis is where the inner join can really be seen as the cross join with results not matching the condition removed. Here none of the resulting rows are removed.\nUsing INNER JOIN to get the result of a LEFT OUTER JOIN also requires tricks. It&apos;s omitted.\nLEFT OUTER JOIN\nLEFT JOIN results in rows as The General Idea/CROSS JOIN:\nSELECT *\n  FROM citizen         c\n  LEFT JOIN postalcode p ON 1 = 1 -- &lt; -- The ON condition makes it a CROSS JOIN\n\nLEFT JOIN results in rows as The General Idea/INNER JOIN:\nSELECT *\n  FROM citizen         c\n  LEFT JOIN postalcode p ON c.postal = p.postal\n WHERE p.postal IS NOT NULL -- &lt; -- removed the row where there&apos;s no mathcing result from postalcode\n\n\nThe troubles with the Venn diagram\nAn image internet search on &quot;sql join cross inner outer&quot; will show a multitude of Venn diagrams. I used to have a printed copy of one on my desk. But there are issues with the representation.\nVenn diagram are excellent for set theory, where an element can be in one or both sets. But for databases, an element in one &quot;set&quot; seem, to me, to be a row in a table, and therefore not also present in any other tables. There is no such thing as one row present in multiple tables. A row is unique to the table.\nSelf joins are a corner case where each element is in fact the same in both sets. But it&apos;s still not free of any of the issues below.\nThe set A represents the set on the left (the citizen table) and the set B is the set on the right (the postalcode table) in below discussion.\nCROSS JOIN\nEvery element in both sets are matched with every element in the other set, meaning we need A amount of every B elements and B amount of every A elements to properly represent this Cartesian product. Set theory isn&apos;t made for multiple identical elements in a set, so I find Venn diagrams to properly represent it impractical/impossible. It doesn&apos;t seem that UNION fits at all.\nThe rows are distinct. The UNION is 7 rows in total. But they&apos;re incompatible for a common SQL results set. And this is not how a CROSS JOIN works at all:\n\nTrying to represent it like this:\n\n..but now it just looks like an INTERSECTION, which it&apos;s certainly not. Furthermore there&apos;s no element in the INTERSECTION that is actually in any of the two distinct sets. However, it looks very much like the searchable results similar to this:\n\nFor reference one searchable result for CROSS JOINs can be seen at Tutorialgateway. The INTERSECTION, just like this one, is empty.\nINNER JOIN\nThe value of an element depends on the JOIN condition. It&apos;s possible to represent this under the condition that every row becomes unique to that condition. Meaning id=x is only true for one row. Once a row in table A (citizen) matches multiple rows in table B (postalcode) under the JOIN condition, the result has the same problems as the CROSS JOIN: The row needs to be represented multiple times, and the set theory isn&apos;t really made for that. Under the condition of uniqueness, the diagram could work though, but keep in mind that the JOIN condition determines the placement of an element in the diagram. Looking only at the values of the JOIN condition with the rest of the row just along for the ride:\n\nThis representation falls completely apart when using an INNER JOIN with a ON 1 = 1 condition making it into a CROSS JOIN.\nWith a self-JOIN, the rows are in fact idential elements in both tables, but representing the tables as both A and B isn&apos;t very suitable. For example a common self-JOIN condition that makes an element in A to be matching a different element in B is ON A.parent = B.child, making the match from A to B on seperate elements. From the examples that would be a SQL like this:\nSELECT *\n  FROM citizen c1\n  JOIN citizen c2 ON c1.id = c2.leader\n\n\nMeaning Smith is the leader of both Green and Jensen.\nOUTER JOIN\nAgain the troubles begin when one row has multiple matches to rows in the other table. This is further complicated because the OUTER JOIN can be though of as to match the empty set. But in set theory the union of any set C and an empty set, is always just C. The empty set adds nothing. The representation of this LEFT OUTER JOIN is usually just showing all of A to illustrate that rows in A are selected regardless of whether there is a match or not from B. The &quot;matching elements&quot; however has the same problems as the illustration above. They depend on the condition. And the empty set seems to have wandered over to A:\n\nWHERE clause - making sense\nFinding all rows from a CROSS JOIN with Smith and postalcode on the Moon:\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE c.name = &apos;Smith&apos;\n   AND p.area = &apos;Moon&apos;;\n\n\nNow the Venn diagram isn&apos;t used to reflect the JOIN. It&apos;s used only for the WHERE clause:\n\n..and that makes sense.\nWhen INTERSECT and UNION makes sense\nINTERSECT\nAs explained an INNER JOIN is not really an INTERSECT. However INTERSECTs can be used on results of seperate queries. Here a Venn diagram makes sense, because the elements from the seperate queries are in fact rows that either belonging to just one of the results or both. Intersect will obviously only return results where the row is present in both queries. This SQL will result in the same row as the one above WHERE, and the Venn diagram will also be the same:\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE c.name = &apos;Smith&apos;\nINTERSECT\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE p.area = &apos;Moon&apos;;\n\nUNION\nAn OUTER JOIN is not a UNION. However UNION work under the same conditions as INTERSECT, resulting in a return of all results combining both SELECTs:\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE c.name = &apos;Smith&apos;\nUNION\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE p.area = &apos;Moon&apos;;\n\nwhich is equivalent to:\nSELECT *\n  FROM citizen          c\n CROSS JOIN postalcode  p\n WHERE c.name = &apos;Smith&apos;\n   OR p.area = &apos;Moon&apos;;\n\n..and gives the result:\n\nAlso here a Venn diagram makes sense:\n\nWhen it doesn&apos;t apply\nAn important note is that these only work when the structure of the results from the two SELECT&apos;s are the same, enabling a comparison or union. The results of these two will not enable that:\nSELECT *\n  FROM citizen\n WHERE name = &apos;Smith&apos;\n\nSELECT *\n  FROM postalcode\n WHERE area = &apos;Moon&apos;;\n\n..trying to combine the results with UNION gives a\nORA-01790: expression must have same datatype as corresponding expression\n\n\nFor further interest read Say NO to Venn Diagrams When Explaining JOINs and sql joins as venn diagram. Both also cover EXCEPT.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"In Simple Terms,\n\n1.INNER JOIN OR EQUI JOIN : Returns the resultset that matches only the condition in both the tables.\n\n2.OUTER JOIN : Returns the resultset of all the values from both the tables even if there is condition match or not. \n\n3.LEFT JOIN : Returns the resultset of all the values from left table and only rows that match the condition in right table.\n\n4.RIGHT JOIN : Returns the resultset of all the values from right table and only rows that match the condition in left table.\n\n5.FULL JOIN : Full Join and Full outer Join are same.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"left join on returns inner join on rows union all unmatched left table rows extended by nulls.\nright join on returns inner join on rows union all unmatched right table rows extended by nulls.\nfull join on returns inner join on rowsunion all unmatched left table rows extended by nulls union all unmatched right table rows extended by nulls.\nouter is optional &amp; has no effect.\n(SQL Standard 2006 SQL/Foundation 7.7 Syntax Rules 1, General Rules 1 b, 3 c &amp; d, 5 b.)\nSo don&apos;t outer join on until you know what underlying inner join on is involved.\n\nFind out what rows inner join on returns:\nCROSS JOIN vs INNER JOIN in SQL\nThat also explains why Venn(-like) diagrams are not helpful for inner vs outer join.\nFor more on why they  are not helpful for joins generally:\nVenn Diagram for Natural Join\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"\nInner join - An inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.\nLeft outer join - A left outer join will give all rows in A, plus any common rows in B.\nFull outer join - A full outer join will give you the union of A and B, i.e. All the rows in A and all the rows in B. If something in A doesn&apos;t have a corresponding datum in B, then the B portion is null, and vice versay\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"1.Inner Join: Also called as Join. It returns the rows present in both the Left table, and right table only if there is a match. Otherwise, it returns zero records.\n\nExample:\n\nSELECT\n  e1.emp_name,\n  e2.emp_salary    \nFROM emp1 e1\nINNER JOIN emp2 e2\n  ON e1.emp_id = e2.emp_id\n\n\n\n\n2.Full Outer Join: Also called as Full Join. It returns all the rows present in both the Left table, and right table.\n\nExample:\n\nSELECT\n  e1.emp_name,\n  e2.emp_salary    \nFROM emp1 e1\nFULL OUTER JOIN emp2 e2\n  ON e1.emp_id = e2.emp_id\n\n\n\n\n3.Left Outer join: Or simply called as Left Join. It returns all the rows present in the Left table and matching rows from the right table (if any).\n\n4.Right Outer Join: Also called as Right Join. It returns matching rows from the left table (if any), and all the rows present in the Right table.\n\n\n\nAdvantages of Joins\n\n\nExecutes faster. \n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Joins are more easily explained with an example:\n\nTo simulate persons and emails stored in separate tables,\nTable A and Table B are joined by Table_A.id = Table_B.name_id\nInner Join\n\nOnly matched ids&apos; rows are shown.\nOuter Joins\n\nMatched ids and not matched rows for Table A are shown.\n\nMatched ids and not matched rows for Table B are shown.\n\nMatched ids and not matched rows from both Tables are shown.\nNote: Full outer join is not available on MySQL\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Consider below 2 tables:\n\nEMP\n\nempid   name    dept_id salary\n1       Rob     1       100\n2       Mark    1       300\n3       John    2       100\n4       Mary    2       300\n5       Bill    3       700\n6       Jose    6       400\n\n\nDepartment\n\ndeptid  name\n1       IT\n2       Accounts\n3       Security\n4       HR\n5       R&amp;D\n\n\nInner Join:\n\nMostly written as just JOIN in sql queries. It returns only the matching records between the tables.\n\nFind out all employees and their department names:\n\nSelect a.empid, a.name, b.name as dept_name\nFROM emp a\nJOIN department b\nON a.dept_id = b.deptid\n;\n\nempid   name    dept_name\n1       Rob     IT\n2       Mark    IT\n3       John    Accounts\n4       Mary    Accounts\n5       Bill    Security\n\n\nAs you see above, Jose is not printed from EMP in the output as it&apos;s dept_id 6 does not find a match in the Department table.  Similarly, HR and R&amp;D rows are not printed from Department table as they didn&apos;t find a match in the Emp table. \n\nSo, INNER JOIN or just JOIN, returns only matching rows.\n\nLEFT JOIN :\n\nThis returns all records from the LEFT table and only matching records from the RIGHT table.\n\nSelect a.empid, a.name, b.name as dept_name\nFROM emp a\nLEFT JOIN department b\nON a.dept_id = b.deptid\n;\n\nempid   name    dept_name\n1       Rob     IT\n2       Mark    IT\n3       John    Accounts\n4       Mary    Accounts\n5       Bill    Security\n6       Jose    \n\n\nSo, if you observe the above output, all records from the LEFT table(Emp) are printed with just matching records from RIGHT table.\n\nHR and R&amp;D rows are not printed from Department table as they didn&apos;t find a match in the Emp table on dept_id.\n\nSo, LEFT JOIN returns ALL rows from Left table and only matching rows from RIGHT table. \n\nCan also check DEMO here.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"The difference between inner join and outer join is as follow:\n\n\nInner join is a join that combined tables based on matching tuples, whereas outer join is a join that combined table based on both matched and unmatched tuple.\nInner join merges matched row from two table in where unmatched row are omitted, whereas outer join merges rows from two tables and unmatched rows fill with null value.\nInner join is like an intersection operation, whereas outer join is like an union operation.\nInner join is two types, whereas outer join are three types.\nouter join is faster than inner join.\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"There are a lot of good answers here with very accurate relational algebra examples.  Here is a very simplified answer that might be helpful for amateur or novice coders with SQL coding dilemmas.\nBasically, more often than not, JOIN queries boil down to two cases:\nFor a SELECT of a subset of A data:\n\nuse INNER JOIN when the related B data you are looking for MUST exist per database design;\nuse LEFT JOIN when the related B data you are looking for MIGHT or MIGHT NOT exist per database design.\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"A Demonstration\nSetup\nHop into psql and create a tiny database of cats and humans.\nYou can just copy-paste this whole section.\nCREATE DATABASE catdb;\n\\c catdb;\n\\pset null &apos;[NULL]&apos; -- how to display null values\n\nCREATE TABLE humans (\n  name text primary key\n);\nCREATE TABLE cats (\n  human_name text references humans(name),\n  name text\n);\n\nINSERT INTO humans (name)\nVALUES (&apos;Abe&apos;), (&apos;Ann&apos;), (&apos;Ben&apos;), (&apos;Jen&apos;);\n\nINSERT INTO cats (human_name, name)\nVALUES\n(&apos;Abe&apos;, &apos;Axel&apos;),\n(NULL, &apos;Bitty&apos;),\n(&apos;Jen&apos;, &apos;Jellybean&apos;),\n(&apos;Jen&apos;, &apos;Juniper&apos;);\n\nQuerying\nHere&apos;s a query we&apos;ll run several times, changing [SOMETHING JOIN] to the various types to see the results.\nSELECT\nhumans.name AS human_name,\ncats.name AS cat_name\nFROM humans\n[SOMETHING JOIN] cats ON humans.name = cats.human_name\nORDER BY humans.name;\n\nAn INNER JOIN returns all human-cat pairs.\nAny human without a cat or cat without a human is excluded.\n human_name | cat_name\n------------+-----------\n Abe        | Axel\n Jen        | Jellybean\n Jen        | Juniper\n\nA FULL OUTER JOIN returns all humans and all cats, with NULL if there is no match on either side.\n human_name | cat_name\n------------+-----------\n Abe        | Axel\n Ann        | [NULL]\n Ben        | [NULL]\n Jen        | Jellybean\n Jen        | Juniper\n [NULL]     | Bitty\n\nA LEFT OUTER JOIN returns all humans (the left table).\nAny human without a cat gets a NULL in the cat_name column.\nAny cat without a human is excluded.\n human_name | cat_name\n------------+-----------\n Abe        | Axel\n Ann        | [NULL]\n Ben        | [NULL]\n Jen        | Jellybean\n Jen        | Juniper\n\nA RIGHT OUTER JOIN returns all cats (the right table).\nAny cat without a human gets a NULL in the human_name column.\nAny human without a cat is excluded.\n human_name | cat_name\n------------+-----------\n Abe        | Axel\n Jen        | Jellybean\n Jen        | Juniper\n [NULL]     | Bitty\n\nINNER vs OUTER\nYou can see that while an INNER JOIN gets only matching pairs, each kind of OUTER join includes some items without a match.\nHowever, the actual words INNER and OUTER do not need to appear in queries:\n\nJOIN by itself implies INNER\nLEFT JOIN, RIGHT JOIN and OUTER JOIN all imply OUTER\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"INNER JOIN VS. OUTER JOIN\nIn SQL, join is used to compare and combine  literally, join  and return specific rows of data from two or more tables in a database. INNER JOIN finds and returns matching data from a table, while OUTER JOIN finds and returns matching data and some different data from a table.\n\nINNER JOIN\nINNER JOIN focuses on similarity between 2 tables. When using INNER JOIN, there must be at least some matching data between the two (or more) tables being compared. INNER JOIN searches tables for matching or overlapping data. If found, INNER JOIN combines the information and returns it in a new table.\nExample\nLet&apos;s consider a common scenario with two tables: product price and quantity. The common information in both tables is the product name, so this is the logical column of the join table. Some products are the same in both tables; others are unique to one and have no matches in the other.\nA product INNER JOIN only returns information about products that are common to both tables.\nI&apos;ve put together a little interaction of HTML and CSS so that you can imagine the whole thing visually.\n\n\n/* CSS styles */\n.circles {\n  display: flex;\n}\n\n.circle {\n  height: 100px;\n  width: 100px;\n  border-radius: 50%;\n  background: #99AEBA;\n}\n\n.circle:first-child {\n  background: #FF0000;\n}\n\n.circle:nth-child(2) {\n  background: #05E156;\n  transform: translateX(-45px);\n  z-index: 2;\n  mix-blend-mode: multiply;\n}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;INNER JOIN&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;circles&quot;&gt;\n  &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n Run code snippetHide resultsExpand snippet\n\n\nHere the red circle describes your PRICES and the green circle your QUANTITIES.\n\n\n\n\nPRICES\nQUANTITIES\n\n\n\n\n\n\n\nP.Product\nP.Prices\nQ.Product\nQ.Quantity\n\n\n\n\nA\n6\nA\n92\n\n\nB\n5\nB\n27\n\n\nC\n5\nD\n66\n\n\nD\n1\nE\n20\n\n\n\n\nIf you now want an INNER JOIN where the intersection is determined you can write the following query:\nSELECT Prices.*, Quantities.Quantity\nFROM Prices INNER JOIN Quantities\nON Prices.Product = Quantities.Product;\n\nAs intersection you now get the black area from the diagram and the following query result comes out:\n\n\n\n\nProduct\nPrice\nQuantity\n\n\n\n\nA\n6\n92\n\n\nB\n5\n27\n\n\nD\n1\n66\n\n\n\n\nOUTER JOIN\nAn OUTER JOIN returns a set of records (or rows) that contain what the INNER JOIN would return, but also contain additional rows for which no corresponding match was found in another table.\nThere are three types of outer joins:\n\nLEFT OUTER JOIN (or left join)\nRIGHT OUTER JOIN (or right join)\nFULL OUTER JOIN (or full join)\n\nEach of these OUTER JOIN refers to the portion of data that is being compared, combined, and returned. Sometimes zeros are generated in the process because some data is shared and others are not.\nHowever, this description would now go beyond the scope of the question.\n\nMy sources:\n\nhttps://www.diffen.com/difference/Inner_Join_vs_Outer_Join\nhttps://www.freecodecamp.org/news/sql-join-types-inner-join-vs-outer-join-example/#:~:text=The%20biggest%20difference%20between%20an,table%20in%20the%20resulting%20table.\nhttps://towardsdatascience.com/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377\n\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-difference-between-%22inner-join%22-and-%22outer-join%22-1657387501982#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-difference-between-%22inner-join%22-and-%22outer-join%22-1657387501982">What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/inner-join">inner-join</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/outer-join">outer-join</a></div></div><div class="question-content mt-5">
                
<p>Also, how do <code>LEFT JOIN</code>, <code>RIGHT JOIN</code>, and <code>FULL JOIN</code> fit in?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Assuming you're joining on columns with no duplicates, which is a very common case:</p>
<ul>
<li><p>An inner join of A and B gives the result of A intersect B, i.e. the inner part of a <a href="http://en.wikipedia.org/wiki/Venn_diagram" rel="noreferrer">Venn diagram</a> intersection.</p>
</li>
<li><p>An outer join of A and B gives the results of A union B, i.e. the outer parts of a <a href="http://en.wikipedia.org/wiki/Venn_diagram" rel="noreferrer">Venn diagram</a> union.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<p>Suppose you have two tables, with a single column each, and data as follows:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql">A    B
<span class="hljs-operator">-</span>    <span class="hljs-operator">-</span>
<span class="hljs-number">1</span>    <span class="hljs-number">3</span>
<span class="hljs-number">2</span>    <span class="hljs-number">4</span>
<span class="hljs-number">3</span>    <span class="hljs-number">5</span>
<span class="hljs-number">4</span>    <span class="hljs-number">6</span>
</code></pre>
<p>Note that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.</p>
<p><strong>Inner join</strong></p>
<p>An inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">on</span> a.a <span class="hljs-operator">=</span> b.b;
<span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> a,b <span class="hljs-keyword">where</span> a.a <span class="hljs-operator">=</span> b.b;

a <span class="hljs-operator">|</span> b
<span class="hljs-comment">--+--</span>
<span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-number">3</span>
<span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-number">4</span>
</code></pre>
<p><strong>Left outer join</strong></p>
<p>A left outer join will give all rows in A, plus any common rows in B.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">on</span> a.a <span class="hljs-operator">=</span> b.b;
<span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> a,b <span class="hljs-keyword">where</span> a.a <span class="hljs-operator">=</span> b.b(<span class="hljs-operator">+</span>);

a <span class="hljs-operator">|</span>  b
<span class="hljs-comment">--+-----</span>
<span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">null</span>
<span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">null</span>
<span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">3</span>
<span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">4</span>
</code></pre>
<p><strong>Right outer join</strong></p>
<p>A right outer join will give all rows in B, plus any common rows in A.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">on</span> a.a <span class="hljs-operator">=</span> b.b;
<span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> a,b <span class="hljs-keyword">where</span> a.a(<span class="hljs-operator">+</span>) <span class="hljs-operator">=</span> b.b;

a    <span class="hljs-operator">|</span>  b
<span class="hljs-comment">-----+----</span>
<span class="hljs-number">3</span>    <span class="hljs-operator">|</span>  <span class="hljs-number">3</span>
<span class="hljs-number">4</span>    <span class="hljs-operator">|</span>  <span class="hljs-number">4</span>
<span class="hljs-keyword">null</span> <span class="hljs-operator">|</span>  <span class="hljs-number">5</span>
<span class="hljs-keyword">null</span> <span class="hljs-operator">|</span>  <span class="hljs-number">6</span>
</code></pre>
<p><strong>Full outer join</strong></p>
<p>A full outer join will give you the union of A and B, i.e. all the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versa.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">on</span> a.a <span class="hljs-operator">=</span> b.b;

 a   <span class="hljs-operator">|</span>  b
<span class="hljs-comment">-----+-----</span>
   <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">null</span>
   <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">null</span>
   <span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">3</span>
   <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">4</span>
<span class="hljs-keyword">null</span> <span class="hljs-operator">|</span>    <span class="hljs-number">6</span>
<span class="hljs-keyword">null</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span>
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The Venn diagrams don't really do it for me.</p>
<p>They don't show any distinction between a cross join and an inner join, for example, or more generally show any distinction between different types of join predicate or provide a framework for reasoning about how they will operate.</p>
<p>There is no substitute for understanding the logical processing and it is relatively straightforward to grasp anyway.</p>
<ol>
<li>Imagine a cross join.</li>
<li>Evaluate the <code>on</code> clause against all rows from step 1 keeping those where the predicate evaluates to <code>true</code></li>
<li>(For outer joins only) add back in any outer rows that were lost in step 2.</li>
</ol>
<p>(NB: In practice the query optimiser may find more efficient ways of executing the query than the purely logical description above but the final result must be the same)</p>
<p>I'll start off with an animated version of a <strong>full outer join</strong>. Further explanation follows.</p>
<p><a href="https://i.stack.imgur.com/VUkfU.gif" rel="noreferrer"><img src="https://i.stack.imgur.com/VUkfU.gif" alt="enter image description here"></a></p>
<hr>
<h1>Explanation</h1>
<p><strong>Source Tables</strong></p>
<p><img src="https://i.stack.imgur.com/LVYKx.png" alt="enter link description here"></p>
<p>First start with a <code>CROSS JOIN</code> (AKA Cartesian Product). This does not have an <code>ON</code> clause and simply returns every combination of rows from the two tables.</p>
<p><strong>SELECT A.Colour, B.Colour FROM A CROSS JOIN B</strong></p>
<p><img src="https://i.stack.imgur.com/cv3t6.png" alt="enter link description here"></p>
<p>Inner and Outer joins have an "ON" clause predicate.</p>
<ul>
<li><strong>Inner Join.</strong> Evaluate the condition in the "ON" clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.</li>
<li><strong>Left Outer Join.</strong> Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.</li>
<li><strong>Right Outer Join.</strong> Same as inner join then for any rows in the right table that did not  match anything output these with NULL values for the left table columns.</li>
<li><strong>Full Outer Join.</strong> Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.</li>
</ul>
<h1>Some examples</h1>
<p><strong>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour</strong></p>
<p>The above is the classic equi join.</p>
<p><img src="https://i.stack.imgur.com/a8IHd.png" alt="Inner Join"></p>
<h2>Animated Version</h2>
<p><a href="https://i.stack.imgur.com/kZcvR.gif" rel="noreferrer"><img src="https://i.stack.imgur.com/kZcvR.gif" alt="enter image description here"></a></p>
<h3>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN ('Green','Blue')</h3>
<p>The inner join condition need not necessarily be an equality condition and it need not reference columns from both (or even either) of the tables. Evaluating <code>A.Colour NOT IN ('Green','Blue')</code> on each row of the cross join returns.</p>
<p><img src="https://i.stack.imgur.com/ZwoCi.png" alt="inner 2"></p>
<p><strong>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1</strong></p>
<p>The join condition evaluates to true for all rows in the cross join result so this is just the same as a cross join. I won't repeat the picture of the 16 rows again.</p>
<h3>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</h3>
<p>Outer Joins are logically evaluated in the same way as inner joins except that if a row from the left table (for a left join) does not join with any rows from the right hand table at all it is preserved in the result with <code>NULL</code> values for the right hand columns.</p>
<p><img src="https://i.stack.imgur.com/4bzv2.png" alt="LOJ"></p>
<h3>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour IS NULL</h3>
<p>This simply restricts the previous result to only return the rows where <code>B.Colour IS NULL</code>. In this particular case these will be the rows that were preserved as they had no match in the right hand table and the query returns the single red row not matched in table <code>B</code>. This is known as an anti semi join.</p>
<p>It is important to select a column for the <code>IS NULL</code> test that is either not nullable or for which the join condition ensures that any <code>NULL</code> values will be excluded in order for this pattern to work correctly and avoid just bringing back rows which happen to have a <code>NULL</code> value for that column in addition to the un matched rows.</p>
<p><img src="https://i.stack.imgur.com/d6CVF.png" alt="loj is null"></p>
<h3>SELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour</h3>
<p>Right outer joins act similarly to left outer joins except they preserve non matching rows from the right table and null extend the left hand columns.</p>
<p><img src="https://i.stack.imgur.com/LIOW4.png" alt="ROJ"></p>
<h3>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour</h3>
<p>Full outer joins combine the behaviour of left and right joins and preserve the non matching rows from both the left and the right tables.</p>
<p><img src="https://i.stack.imgur.com/iVoqu.png" alt="FOJ"></p>
<h3>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0</h3>
<p>No rows in the cross join match the <code>1=0</code> predicate. All rows from both sides are preserved using normal outer join rules with NULL in the columns from the table on the other side.</p>
<p><img src="https://i.stack.imgur.com/gtIhf.png" alt="FOJ 2"></p>
<h3>SELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON 1 = 0</h3>
<p>With a minor amend to the preceding query one could simulate a <code>UNION ALL</code> of the two tables.</p>
<p><img src="https://i.stack.imgur.com/WPu9W.png" alt="UNION ALL"></p>
<h3>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour = 'Green'</h3>
<p>Note that the <code>WHERE</code> clause (if present) logically runs after the join. One common error is to perform a left outer join and then include a WHERE clause with a condition on the right table that ends up excluding the non matching rows. The above ends up performing the outer join...</p>
<p><img src="https://i.stack.imgur.com/4bzv2.png" alt="LOJ"></p>
<p>... And then the "Where" clause runs. <code>NULL= 'Green'</code> does not evaluate to true so the row preserved by the outer join ends up discarded (along with the blue one) effectively converting the join back to an inner one.</p>
<p><img src="https://i.stack.imgur.com/tRHdf.png" alt="LOJtoInner"></p>
<p>If the intention was to include only rows from B where Colour is Green and all rows from A regardless the correct syntax would be</p>
<h3>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour AND B.Colour = 'Green'</h3>
<p><img src="https://i.stack.imgur.com/cvJ1s.png" alt="enter image description here"></p>
<h2>SQL Fiddle</h2>
<p>See these examples <a href="http://sqlfiddle.com/#!17/10d3d/29" rel="noreferrer">run live at SQLFiddle.com</a>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Joins</strong> are used to combine the data from two tables, with the result being a new, temporary table. Joins are performed based on something called a predicate, which specifies the condition to use in order to perform a join.  The difference between an inner join and an outer join is that an inner join will return only the rows that actually match based on the join predicate.
For eg- Lets consider Employee and Location table:</p>
<h3>Employee</h3>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>EmpID</th>
<th>EmpName</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>Jason</td>
</tr>
<tr>
<td>8</td>
<td>Alex</td>
</tr>
<tr>
<td>3</td>
<td>Ram</td>
</tr>
<tr>
<td>17</td>
<td>Babu</td>
</tr>
<tr>
<td>25</td>
<td>Johnson</td>
</tr>
</tbody>
</table>
</div><h3>Location</h3>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>EmpID</th>
<th>EmpLoc</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>San Jose</td>
</tr>
<tr>
<td>8</td>
<td>Los Angeles</td>
</tr>
<tr>
<td>3</td>
<td>Pune, India</td>
</tr>
<tr>
<td>17</td>
<td>Chennai, India</td>
</tr>
<tr>
<td>39</td>
<td>Bangalore, India</td>
</tr>
</tbody>
</table>
</div>
<p><em><strong>Inner Join:-</strong></em>
Inner join creates a new result table by combining column values of two tables (<em>Employee</em> and <em>Location</em>) based upon the join-predicate. The query compares each row of <em>Employee</em> with each row of <em>Location</em> to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of <em>Employee</em> and <em>Location</em> are combined into a result row.
Heres what the SQL for an inner join will look like:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> location <span class="hljs-keyword">on</span> employee.empID <span class="hljs-operator">=</span> location.empID
<span class="hljs-keyword">OR</span>
<span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee, location <span class="hljs-keyword">where</span> employee.empID <span class="hljs-operator">=</span> location.empID
</code></pre>
<p>Now, here is what the result of running that SQL would look like:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Employee.EmpId</th>
<th>Employee.EmpName</th>
<th>Location.EmpId</th>
<th>Location.EmpLoc</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>Jason</td>
<td>13</td>
<td>San Jose</td>
</tr>
<tr>
<td>8</td>
<td>Alex</td>
<td>8</td>
<td>Los Angeles</td>
</tr>
<tr>
<td>3</td>
<td>Ram</td>
<td>3</td>
<td>Pune, India</td>
</tr>
<tr>
<td>17</td>
<td>Babu</td>
<td>17</td>
<td>Chennai, India</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Outer Join:-</strong>
An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each recordeven if no other matching record exists. Outer joins subdivide further into left outer joins and right outer joins, depending on which table's rows are retained (left or right).</p>
<p><em><strong>Left Outer Join:-</strong></em>
The result of a left outer join (or simply left join) for tables <em>Employee</em> and <em>Location</em> always contains all records of the "left" table (<em>Employee</em>), even if the join-condition does not find any matching record in the "right" table (<em>Location</em>).
Here is what the SQL for a left outer join would look like, using the tables above:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> location <span class="hljs-keyword">on</span> employee.empID <span class="hljs-operator">=</span> location.empID;
<span class="hljs-operator">/</span><span class="hljs-operator">/</span>Use <span class="hljs-keyword">of</span> <span class="hljs-keyword">outer</span> keyword <span class="hljs-keyword">is</span> optional
</code></pre>
<p>Now, here is what the result of running this SQL would look like:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Employee.EmpId</th>
<th>Employee.EmpName</th>
<th>Location.EmpId</th>
<th>Location.EmpLoc</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>Jason</td>
<td>13</td>
<td>San Jose</td>
</tr>
<tr>
<td>8</td>
<td>Alex</td>
<td>8</td>
<td>Los Angeles</td>
</tr>
<tr>
<td>3</td>
<td>Ram</td>
<td>3</td>
<td>Pune, India</td>
</tr>
<tr>
<td>17</td>
<td>Babu</td>
<td>17</td>
<td>Chennai, India</td>
</tr>
<tr>
<td><strong>25</strong></td>
<td><strong>Johnson</strong></td>
<td><strong>NULL</strong></td>
<td><strong>NULL</strong></td>
</tr>
</tbody>
</table>
</div>
<p>Note how while Johnson has no entry in the employee location table, he is still included in the results but the location fields are nulled.</p>
<p><em><strong>Right Outer Join:-</strong></em>
A right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the "right" table (<em>Location</em>) will appear in the joined table at least once. If no matching row from the "left" table (<em>Employee</em>) exists, NULL will appear in columns from <em>Employee</em> for those records that have no match in <em>Location</em>.
This is what the SQL looks like:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> location  <span class="hljs-keyword">on</span> employee.empID <span class="hljs-operator">=</span> location.empID;
<span class="hljs-operator">/</span><span class="hljs-operator">/</span>Use <span class="hljs-keyword">of</span> <span class="hljs-keyword">outer</span> keyword <span class="hljs-keyword">is</span> optional
</code></pre>
<p>Using the tables above, we can show what the result set of a right outer join would look like:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Employee.EmpId</th>
<th>Employee.EmpName</th>
<th>Location.EmpId</th>
<th>Location.EmpLoc</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>Jason</td>
<td>13</td>
<td>San Jose</td>
</tr>
<tr>
<td>8</td>
<td>Alex</td>
<td>8</td>
<td>Los Angeles</td>
</tr>
<tr>
<td>3</td>
<td>Ram</td>
<td>3</td>
<td>Pune, India</td>
</tr>
<tr>
<td>17</td>
<td>Babu</td>
<td>17</td>
<td>Chennai, India</td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td><strong>NULL</strong></td>
<td><strong>39</strong></td>
<td><strong>Bangalore, India</strong></td>
</tr>
</tbody>
</table>
</div>
<p>Note how while there are no employees listed as working in Bangalore, it is still included in the results with the employee fields nulled out.</p>
<p><strong>Full Outer Joins:-</strong>
Full Outer Join or Full Join is to retain the nonmatching information by including nonmatching rows in the results of a join, use a full outer join. It includes all rows from both tables, regardless of whether or not the other table has a matching value.</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Employee.EmpId</th>
<th>Employee.EmpName</th>
<th>Location.EmpId</th>
<th>Location.EmpLoc</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td>Jason</td>
<td>13</td>
<td>San Jose</td>
</tr>
<tr>
<td>8</td>
<td>Alex</td>
<td>8</td>
<td>Los Angeles</td>
</tr>
<tr>
<td>3</td>
<td>Ram</td>
<td>3</td>
<td>Pune, India</td>
</tr>
<tr>
<td>17</td>
<td>Babu</td>
<td>17</td>
<td>Chennai, India</td>
</tr>
<tr>
<td><strong>25</strong></td>
<td><strong>Johnson</strong></td>
<td><strong>NULL</strong></td>
<td><strong>NULL</strong></td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td><strong>NULL</strong></td>
<td><strong>39</strong></td>
<td><strong>Bangalore, India</strong></td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/join.html" rel="noreferrer">MySQL 8.0 Reference Manual - Join Syntax</a></p>
<p><a href="https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj29840.html" rel="noreferrer">Oracle Join operations</a></p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>Inner Join</h3>
<p>Retrieve the matched rows only, that is, <code>A intersect B</code>.</p>
<p><img src="https://i.stack.imgur.com/Zkk3I.jpg" alt="Enter image description here"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> dbo.Students S
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dbo.Advisors A
    <span class="hljs-keyword">ON</span> S.Advisor_ID <span class="hljs-operator">=</span> A.Advisor_ID
</code></pre>
<hr>
<h3>Left Outer Join</h3>
<p>Select all records from the first table, and any records in the second
table that match the joined keys.</p>
<p><img src="https://i.stack.imgur.com/Z584b.jpg" alt="Enter image description here"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> dbo.Students S
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dbo.Advisors A
    <span class="hljs-keyword">ON</span> S.Advisor_ID <span class="hljs-operator">=</span> A.Advisor_ID
</code></pre>
<hr>
<h3>Full Outer Join</h3>
<p>Select all records from the second table, and any records in the first
table that match the joined keys.</p>
<p><img src="https://i.stack.imgur.com/c1QF3.jpg" alt="Enter image description here"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> dbo.Students S
<span class="hljs-keyword">FULL</span> <span class="hljs-keyword">JOIN</span> dbo.Advisors A
    <span class="hljs-keyword">ON</span> S.Advisor_ID <span class="hljs-operator">=</span> A.Advisor_ID
</code></pre>
<hr>
<h3>References</h3>
<ul>
<li><p><em><a href="http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server" rel="noreferrer">Inner and outer joins SQL examples and the Join block</a></em></p>
</li>
<li><p><em><a href="http://www.techonthenet.com/sql/joins.php" rel="noreferrer">SQL: JOINS</a></em></p>
</li>
</ul>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In simple words:</p>

<p>An <strong>inner join</strong> retrieve the matched rows only.</p>

<p>Whereas an <strong>outer join</strong> retrieve the matched rows from one table and all rows in other table ....the result depends on which one you are using:</p>

<ul>
<li><p><strong>Left</strong>: Matched rows in the right table and all rows in the left table</p></li>
<li><p><strong>Right</strong>: Matched rows in the left table and all rows in the right table or </p></li>
<li><p><strong>Full</strong>: All rows in all tables. It doesn't matter if there is a match or not</p></li>
</ul>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A inner join only shows rows if there is a matching record on the other (right) side of the join.</p>

<p>A (left) outer join shows rows for each record on the left hand side, even if there are no matching rows on the other (right) side of the join. If there is no matching row, the columns for the other (right) side would show NULLs.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Inner joins require that a record with a related ID exist in the joined table.</p>

<p>Outer joins will return records for the left side even if nothing exists for the right side.</p>

<p>For instance, you have an Orders and an OrderDetails table. They are related by an "OrderID".</p>

<p><strong>Orders</strong></p>

<ul>
<li>OrderID</li>
<li>CustomerName</li>
</ul>

<p><strong>OrderDetails</strong></p>

<ul>
<li>OrderDetailID</li>
<li>OrderID</li>
<li>ProductName</li>
<li>Qty</li>
<li>Price</li>
</ul>

<p>The request</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Orders.OrderID, Orders.CustomerName
  <span class="hljs-keyword">FROM</span> Orders 
 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> OrderDetails
    <span class="hljs-keyword">ON</span> Orders.OrderID <span class="hljs-operator">=</span> OrderDetails.OrderID
</code></pre>

<p>will only return Orders that also have something in the OrderDetails table.</p>

<p>If you change it to OUTER LEFT JOIN</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Orders.OrderID, Orders.CustomerName
  <span class="hljs-keyword">FROM</span> Orders 
  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> OrderDetails
    <span class="hljs-keyword">ON</span> Orders.OrderID <span class="hljs-operator">=</span> OrderDetails.OrderID
</code></pre>

<p>then it will return records from the Orders table even if they have no OrderDetails records.</p>

<p>You can use this to find Orders that do not have any OrderDetails indicating a possible orphaned order by adding a where clause like <code>WHERE OrderDetails.OrderID IS NULL</code>.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In simple words :</p>
<p><strong>Inner join</strong> -&gt; Take ONLY common records from parent and child tables WHERE primary key of Parent table matches Foreign key in Child table.</p>
<p><strong>Left join</strong> -&gt;</p>
<p>pseudo code</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-number">1.</span>Take <span class="hljs-keyword">All</span> records <span class="hljs-keyword">from</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">Table</span>
<span class="hljs-number">2.</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">each</span> record <span class="hljs-keyword">in</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">table</span>,) {
    if(Records <span class="hljs-keyword">from</span> <span class="hljs-keyword">left</span> <span class="hljs-operator">&amp;</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">table</span> matching <span class="hljs-keyword">on</span> <span class="hljs-keyword">primary</span> <span class="hljs-operator">&amp;</span> <span class="hljs-keyword">foreign</span> key){
       use their <span class="hljs-keyword">values</span> <span class="hljs-keyword">as</span> it <span class="hljs-keyword">is</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">at</span> the <span class="hljs-keyword">right</span> side <span class="hljs-keyword">for</span> <span class="hljs-number">2</span>nd table.
    } <span class="hljs-keyword">else</span> {
       put <span class="hljs-keyword">value</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">values</span> <span class="hljs-keyword">in</span> that particular record <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">at</span> the <span class="hljs-keyword">right</span> side <span class="hljs-keyword">for</span> <span class="hljs-number">2</span>nd table.
    }
  }
</code></pre>
<p><strong>Right join</strong> : Exactly opposite of left join . Put name of table in LEFT JOIN at right side in Right join , you get same output as LEFT JOIN.</p>
<p><strong>Outer join</strong> : Show all records in Both tables <code>No matter what</code>. If records in Left table are not matching to right table based on Primary , Forieign key , use NULL value as result of join .</p>
<p><strong>Example :</strong></p>
<p><img src="https://i.stack.imgur.com/pCErn.png" alt="Example"></p>
<p>Lets assume now for 2 tables</p>
<p><code>1.employees  , 2.phone_numbers_employees</code></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql">employees : id , name 

phone_numbers_employees : id , phone_num , emp_id   
</code></pre>
<p>Here , employees table is Master table , phone_numbers_employees is child table(it contains <code>emp_id</code> as foreign key which connects <code>employee.id</code> so its child table.)</p>
<p><strong>Inner joins</strong></p>
<p>Take the records of 2 tables <strong>ONLY IF Primary key of employees table(its id) matches Foreign key of Child table phone_numbers_employees(emp_id)</strong>.</p>
<p>So query would be :</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> e.id , e.name , p.phone_num <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> phone_numbers_employees <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">ON</span> e.id <span class="hljs-operator">=</span> p.emp_id;
</code></pre>
<p>Here take only matching rows on primary key = foreign key as explained above.Here non matching rows on primary key = foreign key are skipped as result of join.</p>
<p><strong>Left joins</strong> :</p>
<p>Left join retains all rows of the left table, regardless of whether there is a row that matches on the right table.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> e.id , e.name , p.phone_num <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> phone_numbers_employees <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">ON</span> e.id <span class="hljs-operator">=</span> p.emp_id;
</code></pre>
<p><strong>Outer joins</strong> :</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> e.id , e.name , p.phone_num <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> phone_numbers_employees <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">ON</span> e.id <span class="hljs-operator">=</span> p.emp_id;
</code></pre>
<p><strong>Diagramatically it looks like :</strong></p>
<p><img src="https://i.stack.imgur.com/hMKKt.jpg" alt="Diagram"></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You use <strong><code>INNER JOIN</code></strong> to return all rows from both tables where there is a match. i.e. In the resulting table all the rows and columns will have values.</p>

<p>In <strong><code>OUTER JOIN</code></strong> the resulting table may have empty columns. Outer join may be either <code>LEFT</code> or <code>RIGHT</code>.</p>

<p><strong><code>LEFT OUTER JOIN</code></strong> returns all the rows from the first table, even if there are no matches in the second table.</p>

<p><strong><code>RIGHT OUTER JOIN</code></strong> returns all the rows from the second table, even if there are no matches in the first table.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>INNER JOIN</code> requires there is at least a match in comparing the two tables. For example, table A and table B which implies A ٨ B (A intersection B).</p>

<p><code>LEFT OUTER JOIN</code> and <code>LEFT JOIN</code> are the same. It gives all the records matching in both tables and all possibilities of the left table.</p>

<p>Similarly, <code>RIGHT OUTER JOIN</code> and <code>RIGHT JOIN</code> are the same. It gives all the records matching in both tables and all possibilities of the right table.</p>

<p><code>FULL JOIN</code> is the combination of <code>LEFT OUTER JOIN</code> and <code>RIGHT OUTER JOIN</code> without duplication.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The answer is in the meaning of each one, so in the results.</p>

<blockquote>
  <p><strong>Note :</strong><br>
  In <code>SQLite</code> there is no <code>RIGHT OUTER JOIN</code> or <code>FULL OUTER JOIN</code>.<br>
  And also in <code>MySQL</code> there is no <code>FULL OUTER JOIN</code>.</p>
</blockquote>

<p>My answer is based on above <strong>Note</strong>.</p>

<p>When you have two tables like these: </p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-comment">--[table1]               --[table2]</span>
id <span class="hljs-operator">|</span> name                id <span class="hljs-operator">|</span> name
<span class="hljs-comment">---+-------              ---+-------</span>
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a1                  <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a2
<span class="hljs-number">2</span>  <span class="hljs-operator">|</span> b1                  <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> b2
</code></pre>

<hr>

<p><strong>CROSS JOIN / OUTER JOIN :</strong><br>
You can have all of those tables data with <code>CROSS JOIN</code> or just with <code>,</code> like this:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1, table2
<span class="hljs-comment">--[OR]</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> table2

<span class="hljs-comment">--[Results:]</span>
id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name 
<span class="hljs-comment">---+------+----+------</span>
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a1   <span class="hljs-operator">|</span> <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a2
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a1   <span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> b2
<span class="hljs-number">2</span>  <span class="hljs-operator">|</span> b1   <span class="hljs-operator">|</span> <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a2
<span class="hljs-number">2</span>  <span class="hljs-operator">|</span> b1   <span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> b2
</code></pre>

<hr>

<p><strong>INNER JOIN :</strong><br>
When you want to add a filter to above results based on a relation like <code>table1.id = table2.id</code> you can use <code>INNER JOIN</code>:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1, table2 <span class="hljs-keyword">WHERE</span> table1.id <span class="hljs-operator">=</span> table2.id
<span class="hljs-comment">--[OR]</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.id <span class="hljs-operator">=</span> table2.id

<span class="hljs-comment">--[Results:]</span>
id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name 
<span class="hljs-comment">---+------+----+------</span>
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a1   <span class="hljs-operator">|</span> <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a2
</code></pre>

<hr>

<p><strong>LEFT [OUTER] JOIN :</strong><br>
When you want to have all rows of one of tables in the above result -with same relation- you can use <code>LEFT JOIN</code>:<br>
(For <strong>RIGHT JOIN</strong> just change place of tables)</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1, table2 <span class="hljs-keyword">WHERE</span> table1.id <span class="hljs-operator">=</span> table2.id 
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <span class="hljs-keyword">Null</span>, <span class="hljs-keyword">Null</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Not</span> table1.id <span class="hljs-keyword">In</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table2)
<span class="hljs-comment">--[OR]</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.id <span class="hljs-operator">=</span> table2.id

<span class="hljs-comment">--[Results:]</span>
id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name 
<span class="hljs-comment">---+------+------+------</span>
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> a1   <span class="hljs-operator">|</span> <span class="hljs-number">1</span>    <span class="hljs-operator">|</span> a2
<span class="hljs-number">2</span>  <span class="hljs-operator">|</span> b1   <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span>
</code></pre>

<hr>

<p><strong>FULL OUTER JOIN :</strong><br>
When you also want to have all rows of the other table in your results you can use <code>FULL OUTER JOIN</code>:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1, table2 <span class="hljs-keyword">WHERE</span> table1.id <span class="hljs-operator">=</span> table2.id
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <span class="hljs-keyword">Null</span>, <span class="hljs-keyword">Null</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Not</span> table1.id <span class="hljs-keyword">In</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table2)
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Null</span>, <span class="hljs-keyword">Null</span>, <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table2 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Not</span> table2.id <span class="hljs-keyword">In</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1)
<span class="hljs-comment">--[OR] (recommended for SQLite)</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.id <span class="hljs-operator">=</span> table2.id
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table2 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table1 <span class="hljs-keyword">ON</span> table2.id <span class="hljs-operator">=</span> table1.id
<span class="hljs-keyword">WHERE</span> table1.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>
<span class="hljs-comment">--[OR]</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">On</span> table1.id <span class="hljs-operator">=</span> table2.id

<span class="hljs-comment">--[Results:]</span>
id   <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name 
<span class="hljs-comment">-----+------+------+------</span>
<span class="hljs-number">1</span>    <span class="hljs-operator">|</span> a1   <span class="hljs-operator">|</span> <span class="hljs-number">1</span>    <span class="hljs-operator">|</span> a2
<span class="hljs-number">2</span>    <span class="hljs-operator">|</span> b1   <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span>
<span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> <span class="hljs-number">3</span>    <span class="hljs-operator">|</span> b2
</code></pre>

<p>Well, as your need you choose each one that covers your need ;).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Inner join.</strong> </p>

<p>A join is combining the rows from two tables. An <em>inner join</em> attempts to match up the two tables based on the criteria you specify in the query, and only returns the rows that match. If a row from the first table in the join matches two rows in the second table, then two rows will be returned in the results. If theres a row in the first table that doesnt match a row in the second, its not returned; likewise, if theres a row in the second table that doesnt match a row in the first, its not returned.</p>

<p><strong>Outer Join.</strong> </p>

<p>A <em>left join</em> attempts to find match up the rows from the first table to rows in the second table. If it cant find a match, it will return the columns from the first table and leave the columns from the second table blank (null).</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://i.stack.imgur.com/TBMzF.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/TBMzF.jpg" alt="enter image description here"></a></p>

<ul>
<li><code>INNER JOIN</code> most typical join for two or more tables.
It returns data match on both table ON primarykey and forignkey relation.</li>
<li><code>OUTER JOIN</code> is same as <code>INNER JOIN</code>, but it also include <code>NULL</code> data on ResultSet.

<ul>
<li><code>LEFT JOIN</code> = <code>INNER JOIN</code> + Unmatched data of <strong>left</strong> table with <code>Null</code> match on right table.</li>
<li><code>RIGHT JOIN</code> = <code>INNER JOIN</code> + Unmatched data of <strong>right</strong> table with <code>Null</code> match on left table.</li>
<li><code>FULL JOIN</code> = <code>INNER JOIN</code> + Unmatched data on <strong>both right and left</strong> tables with <code>Null</code> matches.</li>
</ul></li>
<li>Self join is not a keyword in SQL, when a table references data in itself knows as self join. Using <code>INNER JOIN</code> and <code>OUTER JOIN</code> we can write self join queries.</li>
</ul>

<p>For example:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span>   tablea a 
       <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tableb b 
               <span class="hljs-keyword">ON</span> a.primary_key <span class="hljs-operator">=</span> b.foreign_key 
       <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tablec c 
               <span class="hljs-keyword">ON</span> b.primary_key <span class="hljs-operator">=</span> c.foreign_key 
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I don't see much details about performance and optimizer in the other answers.</p>

<p>Sometimes it is good to know that only <code>INNER JOIN</code> is associative which means the optimizer has the most option to play with it. It can reorder the join order to make it faster keeping the same result. The optimizer can use the most join modes.</p>

<p>Generally it is a good practice to try to use <code>INNER JOIN</code> instead of the different kind of joins. (Of course if it is possible considering the expected result set.)</p>

<p>There are a couple of good examples and explanation here about this strange associative behavior:</p>

<ul>
<li><a href="https://stackoverflow.com/questions/20022196/are-left-outer-joins-associative">Are left outer joins associative?</a></li>
<li><a href="https://stackoverflow.com/questions/9614922/does-the-join-order-matter-in-sql">Does the join order matter in SQL?</a></li>
</ul>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Having criticized the much-loved red-shaded Venn diagram, I thought it only fair to post my own attempt.</p>

<p>Although @Martin Smith's answer is the best of this bunch by a long way, his only shows the key column from each table, whereas I think ideally non-key columns should also be shown.</p>

<p>The best I could do in the half hour allowed, I still don't think it adequately shows that the nulls are there due to absence of key values in <code>TableB</code> or that <code>OUTER JOIN</code> is actually a union rather than a join:</p>

<p><a href="https://i.stack.imgur.com/fzwkg.png" rel="noreferrer"><img src="https://i.stack.imgur.com/fzwkg.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The precise algorithm for <code>INNER JOIN</code>, <code>LEFT/RIGHT OUTER JOIN</code> are as following: </p>

<ol>
<li>Take each row from the first table: <code>a</code></li>
<li>Consider all rows from second table beside it: <code>(a, b[i])</code></li>
<li>Evaluate the <code>ON ...</code> clause against each pair: <code>ON( a, b[i] ) = true/false?</code>

<ul>
<li>When the condition evaluates to <code>true</code>, return that combined row  <code>(a, b[i])</code>.</li>
<li>When reach end of second table without any match, and this is an <code>Outer Join</code> then return a <em>(virtual)</em> pair using <code>Null</code> for all columns of other table: <code>(a, Null)</code> for LEFT outer join or <code>(Null, b)</code> for RIGHT outer join. This is to ensure all rows of first table exists in final results.</li>
</ul></li>
</ol>

<p><strong>Note:</strong> the condition specified in <code>ON</code> clause could be anything, it is not required to use <em>Primary Keys</em> (and you don't need to always refer to Columns from both tables)! For example:</p>

<ul>
<li><code>... ON T1.title = T2.title AND T1.version &lt; T2.version</code> ( =&gt; see this post as a sample usage: <a href="https://stackoverflow.com/a/7745635/2803565">Select only rows with max value on a column</a>)</li>
<li><code>... ON T1.y IS NULL</code></li>
<li><code>... ON 1 = 0</code> (just as sample)</li>
</ul>

<p><a href="https://i.stack.imgur.com/0dWzY.png" rel="noreferrer"><img src="https://i.stack.imgur.com/0dWzY.png" alt="Inner Join vs. Left Outer Join"></a></p>

<hr>

<p><a href="https://i.stack.imgur.com/Bsocp.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Bsocp.png" alt="enter image description here"></a></p>

<p><strong>Note:</strong> Left Join = Left Outer Join, Right Join = Right Outer Join.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Simplest Definitions</strong></p>

<p>Inner Join: Returns <strong>matched records</strong> from both tables.</p>

<p>Full Outer Join: Returns matched and <strong>unmatched records</strong> from both tables with null for unmatched records from <strong>Both Tables</strong>.</p>

<p>Left Outer Join: Returns matched and unmatched records only from table on <strong>Left Side</strong>.</p>

<p>Right Outer Join: Returns matched and unmatched records only from table on <strong>Right Side</strong>.</p>

<p>In-Short</p>

<p>Matched + Left Unmatched + Right Unmatched = <strong>Full Outer Join</strong></p>

<p>Matched + Left Unmatched = <strong>Left Outer Join</strong></p>

<p>Matched + Right Unmatched = <strong>Right Outer Join</strong></p>

<p>Matched = <strong>Inner Join</strong></p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>The General Idea</h1>
<p>Please see the <a href="https://stackoverflow.com/a/27458534/12695027">answer</a> by <a href="https://stackoverflow.com/users/73226">Martin Smith</a> for a better illustations and explanations of the different joins, including and especially differences between <code>FULL OUTER JOIN</code>, <code>RIGHT OUTER JOIN</code> and <code>LEFT OUTER JOIN</code>.</p>
<p>These two table form a basis for the representation of the <code>JOIN</code>s below:</p>
<p><img src="https://i.stack.imgur.com/DEAAy.png" alt="Basis"></p>
<h3>CROSS JOIN</h3>
<p><img src="https://i.stack.imgur.com/EqnB9.png" alt="CrossJoin"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode
</code></pre>
<p>The result will be the Cartesian products of all combinations. No <code>JOIN</code> condition required:</p>
<p><img src="https://i.stack.imgur.com/eeFIB.png" alt="CrossJoinResult"></p>
<h3>INNER JOIN</h3>
<p><code>INNER JOIN</code> is the same as simply: <code>JOIN</code></p>
<p><img src="https://i.stack.imgur.com/oXqs0.png" alt="InnerJoin"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen    c
  <span class="hljs-keyword">JOIN</span> postalcode p <span class="hljs-keyword">ON</span> c.postal <span class="hljs-operator">=</span> p.postal
</code></pre>
<p>The result will be combinations that satisfies the required <code>JOIN</code> condition:</p>
<p><img src="https://i.stack.imgur.com/aaNvi.png" alt="InnerJoinResult"></p>
<h3>LEFT OUTER JOIN</h3>
<p><code>LEFT OUTER JOIN</code> is the same as <code>LEFT JOIN</code></p>
<p><img src="https://i.stack.imgur.com/qmy29.png" alt="LeftJoin"></p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen         c
  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> postalcode p <span class="hljs-keyword">ON</span> c.postal <span class="hljs-operator">=</span> p.postal
</code></pre>
<p>The result will be everything from <code>citizen</code> even if there are no matches in <code>postalcode</code>. Again a <code>JOIN</code> condition is required:</p>
<p><img src="https://i.stack.imgur.com/mbaqJ.png" alt="LeftJoinResult"></p>
<h3>Data for playing</h3>
<p>All examples have been run on an Oracle 18c. They're available at <a href="https://dbfiddle.uk/?rdbms=oracle_18&amp;fiddle=19be5f6abb0a5987fddf037b5df343bd" rel="noreferrer">dbfiddle.uk</a> which is also where screenshots of tables came from.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> citizen (id      NUMBER,
                      name    VARCHAR2(<span class="hljs-number">20</span>),
                      postal  NUMBER,  <span class="hljs-comment">-- &lt;-- could do with a redesign to postalcode.id instead.</span>
                      leader  NUMBER);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> postalcode (id      NUMBER,
                         postal  NUMBER,
                         city    VARCHAR2(<span class="hljs-number">20</span>),
                         area    VARCHAR2(<span class="hljs-number">20</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> citizen (id, name, postal, leader)
              <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>, <span class="hljs-string">'Smith'</span>, <span class="hljs-number">2200</span>,  <span class="hljs-keyword">null</span> <span class="hljs-keyword">FROM</span> DUAL
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span>, <span class="hljs-string">'Green'</span>, <span class="hljs-number">31006</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">FROM</span> DUAL
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">3</span>, <span class="hljs-string">'Jensen'</span>, <span class="hljs-number">623</span>,  <span class="hljs-number">1</span>    <span class="hljs-keyword">FROM</span> DUAL;

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> postalcode (id, postal, city, area)
                 <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>, <span class="hljs-number">2200</span>,     <span class="hljs-string">'BigCity'</span>,         <span class="hljs-string">'Geancy'</span>  <span class="hljs-keyword">FROM</span> DUAL
           <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span>, <span class="hljs-number">31006</span>,    <span class="hljs-string">'SmallTown'</span>,       <span class="hljs-string">'Snizkim'</span> <span class="hljs-keyword">FROM</span> DUAL
           <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">3</span>, <span class="hljs-number">31006</span>,    <span class="hljs-string">'Settlement'</span>,      <span class="hljs-string">'Moon'</span>    <span class="hljs-keyword">FROM</span> DUAL  <span class="hljs-comment">-- &lt;-- Uuh-uhh.</span>
           <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">4</span>, <span class="hljs-number">78567390</span>, <span class="hljs-string">'LookoutTowerX89'</span>, <span class="hljs-string">'Space'</span>   <span class="hljs-keyword">FROM</span> DUAL;
</code></pre>
<h1>Blurry boundaries when playing with <code>JOIN</code> and <code>WHERE</code></h1>
<h3>CROSS JOIN</h3>
<p><code>CROSS JOIN</code> resulting in rows as The General Idea/<code>INNER JOIN</code>:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
  <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode p
 <span class="hljs-keyword">WHERE</span> c.postal <span class="hljs-operator">=</span> p.postal <span class="hljs-comment">-- &lt; -- The WHERE condition is limiting the resulting rows</span>
</code></pre>
<p>Using <code>CROSS JOIN</code> to get the result of a <code>LEFT OUTER JOIN</code> requires tricks like adding in a <code>NULL</code> row. It's omitted.</p>
<h2>INNER JOIN</h2>
<p><code>INNER JOIN</code> becomes a cartesian products. It's the same as The General Idea/<code>CROSS JOIN</code>:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen    c
  <span class="hljs-keyword">JOIN</span> postalcode p <span class="hljs-keyword">ON</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  <span class="hljs-comment">-- &lt; -- The ON condition makes it a CROSS JOIN</span>
</code></pre>
<p>This is where the inner join can really be seen as the cross join with results not matching the condition removed. Here none of the resulting rows are removed.</p>
<p>Using <code>INNER JOIN</code> to get the result of a <code>LEFT OUTER JOIN</code> also requires tricks. It's omitted.</p>
<h2>LEFT OUTER JOIN</h2>
<p><code>LEFT JOIN</code> results in rows as The General Idea/<code>CROSS JOIN</code>:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen         c
  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> postalcode p <span class="hljs-keyword">ON</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- &lt; -- The ON condition makes it a CROSS JOIN</span>
</code></pre>
<p><code>LEFT JOIN</code> results in rows as The General Idea/<code>INNER JOIN</code>:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen         c
  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> postalcode p <span class="hljs-keyword">ON</span> c.postal <span class="hljs-operator">=</span> p.postal
 <span class="hljs-keyword">WHERE</span> p.postal <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-comment">-- &lt; -- removed the row where there's no mathcing result from postalcode</span>
</code></pre>
<hr>
<h1>The troubles with the Venn diagram</h1>
<p>An image internet search on "sql join cross inner outer" will show a multitude of Venn diagrams. I used to have a printed copy of one on my desk. But there are issues with the representation.</p>
<p>Venn diagram are excellent for set theory, where an element can be in one or both sets. But for databases, an element in one "set" seem, to me, to be a row in a table, and therefore not also present in any other tables. There is no such thing as one row present in multiple tables. A row is unique to the table.</p>
<p>Self joins are a corner case where each element is in fact the same in both sets. But it's still not free of any of the issues below.</p>
<p>The set <code>A</code> represents the set on the left (the <code>citizen</code> table) and the set <code>B</code> is the set on the right (the <code>postalcode</code> table) in below discussion.</p>
<h3>CROSS JOIN</h3>
<p>Every element in both sets are matched with every element in the other set, meaning we need <code>A</code> amount of every <code>B</code> elements and <code>B</code> amount of every <code>A</code> elements to properly represent this Cartesian product. Set theory isn't made for multiple identical elements in a set, so I find Venn diagrams to properly represent it impractical/impossible. It doesn't seem that <code>UNION</code> fits at all.</p>
<p>The rows are distinct. The <code>UNION</code> is 7 rows in total. But they're incompatible for a common <code>SQL</code> results set. And this is not how a <code>CROSS JOIN</code> works at all:</p>
<p><img src="https://i.stack.imgur.com/MqN6E.png" alt="CrossJoinUnion1"></p>
<p>Trying to represent it like this:</p>
<p><img src="https://i.stack.imgur.com/1BhEE.png" alt="CrossJoinUnion2Crossing"></p>
<p>..but now it just looks like an <code>INTERSECTION</code>, which it's certainly <strong>not</strong>. Furthermore there's no element in the <code>INTERSECTION</code> that is actually in any of the two distinct sets. However, it looks very much like the searchable results similar to this:</p>
<p><img src="https://i.stack.imgur.com/syxYr.png" alt="CrossJoinUnionUnion3"></p>
<p>For reference one searchable result for <code>CROSS JOIN</code>s can be seen at <a href="https://www.tutorialgateway.org/sql-joins/" rel="noreferrer">Tutorialgateway</a>. The <code>INTERSECTION</code>, just like this one, is empty.</p>
<h3>INNER JOIN</h3>
<p>The value of an element depends on the <code>JOIN</code> condition. It's possible to represent this under the condition that every row becomes unique to that condition. Meaning <code>id=x</code> is only true for <strong>one</strong> row. Once a row in table <code>A</code> (<code>citizen</code>) matches multiple rows in table <code>B</code> (<code>postalcode</code>) under the <code>JOIN</code> condition, the result has the same problems as the <code>CROSS JOIN</code>: The row needs to be represented multiple times, and the set theory isn't really made for that. Under the condition of uniqueness, the diagram could work though, but keep in mind that the <code>JOIN</code> condition determines the placement of an element in the diagram. Looking only at the values of the <code>JOIN</code> condition with the rest of the row just along for the ride:</p>
<p><img src="https://i.stack.imgur.com/djpSE.png" alt="InnerJoinIntersection - Filled"></p>
<p>This representation falls completely apart when using an <code>INNER JOIN</code> with a <code>ON 1 = 1</code> condition making it into a <code>CROSS JOIN</code>.</p>
<p>With a self-<code>JOIN</code>, the rows are in fact idential elements in both tables, but representing the tables as both <code>A</code> and <code>B</code> isn't very suitable. For example a common self-<code>JOIN</code> condition that makes an element in <code>A</code> to be matching a <strong>different</strong> element in B is <code>ON A.parent = B.child</code>, making the match from <code>A</code> to <code>B</code> on seperate elements. From the examples that would be a <code>SQL</code> like this:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen c1
  <span class="hljs-keyword">JOIN</span> citizen c2 <span class="hljs-keyword">ON</span> c1.id <span class="hljs-operator">=</span> c2.leader
</code></pre>
<p><img src="https://i.stack.imgur.com/p5r7D.png" alt="SelfJoinResult"></p>
<p>Meaning Smith is the leader of both Green and Jensen.</p>
<h3>OUTER JOIN</h3>
<p>Again the troubles begin when one row has multiple matches to rows in the other table. This is further complicated because the <code>OUTER JOIN</code> can be though of as to match the empty set. But in set theory the union of any set <code>C</code> and an empty set, is always just <code>C</code>. The empty set adds nothing. The representation of this <code>LEFT OUTER JOIN</code> is usually just showing all of <code>A</code> to illustrate that rows in <code>A</code> are selected regardless of whether there is a match or not from <code>B</code>. The "matching elements" however has the same problems as the illustration above. They depend on the condition. And the empty set seems to have wandered over to <code>A</code>:</p>
<p><img src="https://i.stack.imgur.com/Q2yFW.png" alt="LeftJoinIntersection - Filled"></p>
<h3>WHERE clause - making sense</h3>
<p>Finding all rows from a <code>CROSS JOIN</code> with Smith and postalcode on the Moon:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> c.name <span class="hljs-operator">=</span> <span class="hljs-string">'Smith'</span>
   <span class="hljs-keyword">AND</span> p.area <span class="hljs-operator">=</span> <span class="hljs-string">'Moon'</span>;
</code></pre>
<p><img src="https://i.stack.imgur.com/Iy4Z3.png" alt="Where - result"></p>
<p>Now the Venn diagram isn't used to reflect the <code>JOIN</code>. It's used <strong>only</strong> for the <code>WHERE</code> clause:</p>
<p><img src="https://i.stack.imgur.com/fmxEr.png" alt="Where"></p>
<p>..and that makes sense.</p>
<h1>When INTERSECT and UNION makes sense</h1>
<h3>INTERSECT</h3>
<p>As explained an <code>INNER JOIN</code> is not really an <code>INTERSECT</code>. However <code>INTERSECT</code>s can be used on results of seperate queries. Here a Venn diagram makes sense, because the elements from the seperate queries are in fact rows that either belonging to just one of the results or both. Intersect will obviously only return results where the row is present in both queries. This <code>SQL</code> will result in the same row as the one above <code>WHERE</code>, and the Venn diagram will also be the same:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> c.name <span class="hljs-operator">=</span> <span class="hljs-string">'Smith'</span>
<span class="hljs-keyword">INTERSECT</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> p.area <span class="hljs-operator">=</span> <span class="hljs-string">'Moon'</span>;
</code></pre>
<h3>UNION</h3>
<p>An <code>OUTER JOIN</code> is not a <code>UNION</code>. However <code>UNION</code> work under the same conditions as <code>INTERSECT</code>, resulting in a return of all results combining both <code>SELECT</code>s:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> c.name <span class="hljs-operator">=</span> <span class="hljs-string">'Smith'</span>
<span class="hljs-keyword">UNION</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> p.area <span class="hljs-operator">=</span> <span class="hljs-string">'Moon'</span>;
</code></pre>
<p>which is equivalent to:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen          c
 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> postalcode  p
 <span class="hljs-keyword">WHERE</span> c.name <span class="hljs-operator">=</span> <span class="hljs-string">'Smith'</span>
   <span class="hljs-keyword">OR</span> p.area <span class="hljs-operator">=</span> <span class="hljs-string">'Moon'</span>;
</code></pre>
<p>..and gives the result:</p>
<p><img src="https://i.stack.imgur.com/FTPRr.png" alt="Union - Result"></p>
<p>Also here a Venn diagram makes sense:</p>
<p><img src="https://i.stack.imgur.com/GW69a.png" alt="UNION"></p>
<h3>When it doesn't apply</h3>
<p>An <strong>important note</strong> is that these only work when the structure of the results from the two SELECT's are the same, enabling a comparison or union. The results of these two will not enable that:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> citizen
 <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'Smith'</span>
</code></pre>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> postalcode
 <span class="hljs-keyword">WHERE</span> area <span class="hljs-operator">=</span> <span class="hljs-string">'Moon'</span>;
</code></pre>
<p>..trying to combine the results with <code>UNION</code> gives a</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql">ORA<span class="hljs-number">-01790</span>: expression must have same datatype <span class="hljs-keyword">as</span> <span class="hljs-keyword">corresponding</span> expression
</code></pre>
<hr>
<p>For further interest read <a href="https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/" rel="noreferrer">Say NO to Venn Diagrams When Explaining JOINs</a> and <a href="https://stackoverflow.com/questions/13997365/sql-joins-as-venn-diagram">sql joins as venn diagram</a>. Both also cover <code>EXCEPT</code>.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Simple Terms,</p>

<p>1.<strong>INNER JOIN OR EQUI JOIN :</strong> Returns the resultset that matches only the condition in both the tables.</p>

<p>2.<strong>OUTER JOIN :</strong> Returns the resultset of all the values from both the tables even if there is condition match or not. </p>

<p>3.<strong>LEFT JOIN :</strong> Returns the resultset of all the values from left table and only rows that match the condition in right table.</p>

<p>4.<strong>RIGHT JOIN :</strong> Returns the resultset of all the values from right table and only rows that match the condition in left table.</p>

<p>5.<strong>FULL JOIN :</strong> Full Join and Full outer Join are same.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>left join on</code> returns <code>inner join on</code> rows <code>union all</code> unmatched left table rows extended by <code>null</code>s.</p>
<p><code>right join on</code> returns <code>inner join on</code> rows <code>union all</code> unmatched right table rows extended by <code>null</code>s.</p>
<p><code>full join on</code> returns <code>inner join on</code> rows<code>union all</code> unmatched left table rows extended by <code>null</code>s <code>union all</code> unmatched right table rows extended by <code>null</code>s.</p>
<p><code>outer</code> is optional &amp; has no effect.</p>
<p>(SQL Standard 2006 SQL/Foundation 7.7 Syntax Rules 1, General Rules 1 b, 3 c &amp; d, 5 b.)</p>
<p>So don't <code>outer join on</code> until you know what underlying <code>inner join on</code> is involved.</p>
<hr>
<p>Find out what rows <code>inner join on</code> returns:
<a href="https://stackoverflow.com/a/25957600/3404097">CROSS JOIN vs INNER JOIN in SQL</a></p>
<p>That also explains why Venn(-like) diagrams are not helpful for inner vs outer join.
For more on why they  are not helpful for joins generally:
<a href="https://stackoverflow.com/a/55642928/3404097">Venn Diagram for Natural Join</a></p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ul>
<li><p><strong>Inner join</strong> - An <strong>inner join</strong> using either of the equivalent queries gives the intersection of the two <em>tables</em>, i.e. the two rows they have in common.</p></li>
<li><p><strong>Left outer join</strong> - A <strong>left outer join</strong> will give all rows in A, plus any common rows in B.</p></li>
<li><p><strong>Full outer join</strong> - A <strong>full outer join</strong> will give you the union of A and B, i.e. All the rows in A and all the rows in B. If something in A doesn't have a corresponding datum in B, then the B portion is null, and vice versay</p></li>
</ul>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>1.<strong>Inner Join:</strong> Also called as Join. It returns the rows present in both the Left table, and right table only <strong>if there is a match</strong>. Otherwise, it returns zero records.</p>

<p>Example:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  e1.emp_name,
  e2.emp_salary    
<span class="hljs-keyword">FROM</span> emp1 e1
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> emp2 e2
  <span class="hljs-keyword">ON</span> e1.emp_id <span class="hljs-operator">=</span> e2.emp_id
</code></pre>

<p><a href="https://i.stack.imgur.com/lWzlz.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/lWzlz.jpg" alt="output1"></a></p>

<p>2.<strong>Full Outer Join:</strong> Also called as Full Join. It returns <strong>all the rows</strong> present in both the Left table, and right table.</p>

<p>Example:</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  e1.emp_name,
  e2.emp_salary    
<span class="hljs-keyword">FROM</span> emp1 e1
<span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> emp2 e2
  <span class="hljs-keyword">ON</span> e1.emp_id <span class="hljs-operator">=</span> e2.emp_id
</code></pre>

<p><a href="https://i.stack.imgur.com/3yY0Y.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/3yY0Y.jpg" alt="output2"></a></p>

<p>3.<strong>Left Outer join:</strong> Or simply called as Left Join. It returns all the rows present in the Left table and matching rows from the right table (if any).</p>

<p>4.<strong>Right Outer Join:</strong> Also called as Right Join. It returns matching rows from the left table (if any), and all the rows present in the Right table.</p>

<p><a href="https://i.stack.imgur.com/UIVk7.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/UIVk7.png" alt="joins"></a></p>

<p><strong>Advantages of Joins</strong></p>

<ol>
<li>Executes faster. </li>
</ol>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Joins are more easily explained with an example:</strong></p>
<p><a href="https://i.stack.imgur.com/DxeqP.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/DxeqP.png" alt="enter image description here"></a></p>
<p>To simulate persons and emails stored in separate tables,</p>
<p>Table A and Table B are joined by Table_A.<strong>id</strong> = Table_B.<strong>name_id</strong></p>
<p><strong>Inner Join</strong></p>
<p><a href="https://i.stack.imgur.com/l4sbv.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/l4sbv.png" alt="enter image description here"></a></p>
<p>Only matched ids' rows are shown.</p>
<p><strong>Outer Joins</strong></p>
<p><a href="https://i.stack.imgur.com/gL8gT.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/gL8gT.png" alt="enter image description here"></a></p>
<p>Matched ids and not matched rows for <strong>Table A</strong> are shown.</p>
<p><a href="https://i.stack.imgur.com/kXk4J.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/kXk4J.png" alt="enter image description here"></a></p>
<p>Matched ids and not matched rows for <strong>Table B</strong> are shown.</p>
<p><a href="https://i.stack.imgur.com/736nT.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/736nT.png" alt="enter image description here"></a>
Matched ids and not matched rows from both Tables are shown.</p>
<p><em>Note: Full outer join is not available on MySQL</em></p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider below 2 tables:</p>

<p><strong>EMP</strong></p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql">empid   name    dept_id salary
<span class="hljs-number">1</span>       Rob     <span class="hljs-number">1</span>       <span class="hljs-number">100</span>
<span class="hljs-number">2</span>       Mark    <span class="hljs-number">1</span>       <span class="hljs-number">300</span>
<span class="hljs-number">3</span>       John    <span class="hljs-number">2</span>       <span class="hljs-number">100</span>
<span class="hljs-number">4</span>       Mary    <span class="hljs-number">2</span>       <span class="hljs-number">300</span>
<span class="hljs-number">5</span>       Bill    <span class="hljs-number">3</span>       <span class="hljs-number">700</span>
<span class="hljs-number">6</span>       Jose    <span class="hljs-number">6</span>       <span class="hljs-number">400</span>
</code></pre>

<p><strong>Department</strong></p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql">deptid  name
<span class="hljs-number">1</span>       IT
<span class="hljs-number">2</span>       Accounts
<span class="hljs-number">3</span>       Security
<span class="hljs-number">4</span>       HR
<span class="hljs-number">5</span>       R<span class="hljs-operator">&amp;</span>D
</code></pre>

<h3>Inner Join:</h3>

<p>Mostly written as just <strong>JOIN</strong> in sql queries. It returns only the matching records between the tables.</p>

<h3>Find out all employees and their department names:</h3>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">Select</span> a.empid, a.name, b.name <span class="hljs-keyword">as</span> dept_name
<span class="hljs-keyword">FROM</span> emp a
<span class="hljs-keyword">JOIN</span> department b
<span class="hljs-keyword">ON</span> a.dept_id <span class="hljs-operator">=</span> b.deptid
;

empid   name    dept_name
<span class="hljs-number">1</span>       Rob     IT
<span class="hljs-number">2</span>       Mark    IT
<span class="hljs-number">3</span>       John    Accounts
<span class="hljs-number">4</span>       Mary    Accounts
<span class="hljs-number">5</span>       Bill    Security
</code></pre>

<p>As you see above, <code>Jose</code> is not printed from <strong>EMP</strong> in the output as it's dept_id <code>6</code> does not find a match in the Department table.  Similarly, <code>HR</code> and <code>R&amp;D</code> rows are not printed from <strong>Department</strong> table as they didn't find a match in the Emp table. </p>

<p><strong>So, INNER JOIN or just JOIN, returns only matching rows.</strong></p>

<h3>LEFT JOIN :</h3>

<p>This returns all records from the LEFT table and only matching records from the RIGHT table.</p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">Select</span> a.empid, a.name, b.name <span class="hljs-keyword">as</span> dept_name
<span class="hljs-keyword">FROM</span> emp a
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> department b
<span class="hljs-keyword">ON</span> a.dept_id <span class="hljs-operator">=</span> b.deptid
;

empid   name    dept_name
<span class="hljs-number">1</span>       Rob     IT
<span class="hljs-number">2</span>       Mark    IT
<span class="hljs-number">3</span>       John    Accounts
<span class="hljs-number">4</span>       Mary    Accounts
<span class="hljs-number">5</span>       Bill    Security
<span class="hljs-number">6</span>       Jose    
</code></pre>

<p>So, if you observe the above output, all records from the LEFT table(Emp) are printed with just matching records from RIGHT table.</p>

<p><code>HR</code> and <code>R&amp;D</code> rows are not printed from <strong>Department</strong> table as they didn't find a match in the Emp table on dept_id.</p>

<p><strong>So, LEFT JOIN returns ALL rows from Left table and only matching rows from RIGHT table.</strong> </p>

<p>Can also check DEMO <a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389" rel="nofollow noreferrer">here</a>.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The difference between <code>inner join</code> and <code>outer join</code> is as follow:</p>

<ol>
<li><code>Inner join</code> is a join that combined tables based on matching tuples, whereas <code>outer join</code> is a join that combined table based on both matched and unmatched tuple.</li>
<li><code>Inner join</code> merges matched row from two table in where unmatched row are omitted, whereas <code>outer join</code> merges rows from two tables and unmatched rows fill with null value.</li>
<li><code>Inner join</code> is like an intersection operation, whereas <code>outer join</code> is like an union operation.</li>
<li><code>Inner join</code> is two types, whereas <code>outer join</code> are three types.</li>
<li><code>outer join</code> is faster than <code>inner join</code>.</li>
</ol>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a lot of good answers here with very accurate <a href="https://en.wikipedia.org/wiki/Relational_algebra" rel="nofollow noreferrer">relational algebra</a> examples.  Here is a very simplified answer that might be helpful for amateur or novice coders with SQL coding dilemmas.</p>
<p>Basically, more often than not, <code>JOIN</code> queries boil down to two cases:</p>
<p>For a <code>SELECT</code> of a subset of <code>A</code> data:</p>
<ul>
<li>use <code>INNER JOIN</code> when the related <code>B</code> data you are looking for <strong>MUST</strong> exist per database design;</li>
<li>use <code>LEFT JOIN</code> when the related <code>B</code> data you are looking for <strong>MIGHT</strong> or <strong>MIGHT NOT</strong> exist per database design.</li>
</ul>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>A Demonstration</h1>
<h2>Setup</h2>
<p>Hop into <code>psql</code> and create a tiny database of cats and humans.
You can just copy-paste this whole section.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> DATABASE catdb;
\c catdb;
\pset <span class="hljs-keyword">null</span> <span class="hljs-string">'[NULL]'</span> <span class="hljs-comment">-- how to display null values</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> humans (
  name text <span class="hljs-keyword">primary</span> key
);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> cats (
  human_name text <span class="hljs-keyword">references</span> humans(name),
  name text
);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> humans (name)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Abe'</span>), (<span class="hljs-string">'Ann'</span>), (<span class="hljs-string">'Ben'</span>), (<span class="hljs-string">'Jen'</span>);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> cats (human_name, name)
<span class="hljs-keyword">VALUES</span>
(<span class="hljs-string">'Abe'</span>, <span class="hljs-string">'Axel'</span>),
(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">'Bitty'</span>),
(<span class="hljs-string">'Jen'</span>, <span class="hljs-string">'Jellybean'</span>),
(<span class="hljs-string">'Jen'</span>, <span class="hljs-string">'Juniper'</span>);
</code></pre>
<h2>Querying</h2>
<p>Here's a query we'll run several times, changing <code>[SOMETHING JOIN]</code> to the various types to see the results.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
humans.name <span class="hljs-keyword">AS</span> human_name,
cats.name <span class="hljs-keyword">AS</span> cat_name
<span class="hljs-keyword">FROM</span> humans
[SOMETHING <span class="hljs-keyword">JOIN</span>] cats <span class="hljs-keyword">ON</span> humans.name <span class="hljs-operator">=</span> cats.human_name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> humans.name;
</code></pre>
<p>An <code>INNER JOIN</code> returns all human-cat pairs.
Any human without a cat or cat without a human is excluded.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"> human_name <span class="hljs-operator">|</span> cat_name
<span class="hljs-comment">------------+-----------</span>
 Abe        <span class="hljs-operator">|</span> Axel
 Jen        <span class="hljs-operator">|</span> Jellybean
 Jen        <span class="hljs-operator">|</span> Juniper
</code></pre>
<p>A <code>FULL OUTER JOIN</code> returns all humans and all cats, with <code>NULL</code> if there is no match on either side.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"> human_name <span class="hljs-operator">|</span> cat_name
<span class="hljs-comment">------------+-----------</span>
 Abe        <span class="hljs-operator">|</span> Axel
 Ann        <span class="hljs-operator">|</span> [<span class="hljs-keyword">NULL</span>]
 Ben        <span class="hljs-operator">|</span> [<span class="hljs-keyword">NULL</span>]
 Jen        <span class="hljs-operator">|</span> Jellybean
 Jen        <span class="hljs-operator">|</span> Juniper
 [<span class="hljs-keyword">NULL</span>]     <span class="hljs-operator">|</span> Bitty
</code></pre>
<p>A <code>LEFT OUTER JOIN</code> returns all humans (the left table).
Any human without a cat gets a <code>NULL</code> in the <code>cat_name</code> column.
Any cat without a human is excluded.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"> human_name <span class="hljs-operator">|</span> cat_name
<span class="hljs-comment">------------+-----------</span>
 Abe        <span class="hljs-operator">|</span> Axel
 Ann        <span class="hljs-operator">|</span> [<span class="hljs-keyword">NULL</span>]
 Ben        <span class="hljs-operator">|</span> [<span class="hljs-keyword">NULL</span>]
 Jen        <span class="hljs-operator">|</span> Jellybean
 Jen        <span class="hljs-operator">|</span> Juniper
</code></pre>
<p>A <code>RIGHT OUTER JOIN</code> returns all cats (the right table).
Any cat without a human gets a <code>NULL</code> in the <code>human_name</code> column.
Any human without a cat is excluded.</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"> human_name <span class="hljs-operator">|</span> cat_name
<span class="hljs-comment">------------+-----------</span>
 Abe        <span class="hljs-operator">|</span> Axel
 Jen        <span class="hljs-operator">|</span> Jellybean
 Jen        <span class="hljs-operator">|</span> Juniper
 [<span class="hljs-keyword">NULL</span>]     <span class="hljs-operator">|</span> Bitty
</code></pre>
<h2>INNER vs OUTER</h2>
<p>You can see that while an <code>INNER JOIN</code> gets only matching pairs, each kind of <code>OUTER</code> join includes some items without a match.</p>
<p>However, the actual words <code>INNER</code> and <code>OUTER</code> do not need to appear in queries:</p>
<ul>
<li><code>JOIN</code> by itself implies <code>INNER</code></li>
<li><code>LEFT JOIN</code>, <code>RIGHT JOIN</code> and <code>OUTER JOIN</code> all imply <code>OUTER</code></li>
</ul>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>INNER JOIN VS. OUTER JOIN</h2>
<p>In SQL, <strong>join</strong> is used to compare and combine  literally, <strong>join</strong>  and return specific rows of data from two or more tables in a database. <code>INNER JOIN</code> finds and returns matching data from a table, while <code>OUTER JOIN</code> finds and returns matching data and some different data from a table.</p>
<hr>
<h3>INNER JOIN</h3>
<p><code>INNER JOIN</code> focuses on similarity between 2 tables. When using <code>INNER JOIN</code>, there must be at least some matching data between the two (or more) tables being compared. <code>INNER JOIN</code> searches tables for matching or overlapping data. If found, <code>INNER JOIN</code> combines the information and returns it in a new table.</p>
<h4>Example</h4>
<p>Let's consider a common scenario with two tables: product price and quantity. The common information in both tables is the product name, so this is the logical column of the join table. Some products are the same in both tables; others are unique to one and have no matches in the other.</p>
<p>A product <code>INNER JOIN</code> only returns information about products that are common to both tables.</p>
<p><em>I've put together a little interaction of HTML and CSS so that you can imagine the whole thing visually.</em></p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-css lang-css s-code-block"><code class="hljs language-css"><span class="hljs-comment">/* CSS styles */</span>
<span class="hljs-selector-class">.circles</span> {
  <span class="hljs-attribute">display</span>: flex;
}

<span class="hljs-selector-class">.circle</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#99AEBA</span>;
}

<span class="hljs-selector-class">.circle</span><span class="hljs-selector-pseudo">:first</span>-child {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#FF0000</span>;
}

<span class="hljs-selector-class">.circle</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#05E156</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">45px</span>);
  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2</span>;
  <span class="hljs-attribute">mix-blend-mode</span>: multiply;
}</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>INNER JOIN<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"circles"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"circle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"circle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Here the red circle describes your <code>PRICES</code> and the green circle your <code>QUANTITIES</code>.</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>PRICES</th>
<th>QUANTITIES</th>
</tr>
</thead>
</table>
</div><div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>P.Product</th>
<th>P.Prices</th>
<th>Q.Product</th>
<th>Q.Quantity</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>6</td>
<td>A</td>
<td>92</td>
</tr>
<tr>
<td>B</td>
<td>5</td>
<td>B</td>
<td>27</td>
</tr>
<tr>
<td>C</td>
<td>5</td>
<td>D</td>
<td>66</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>E</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>If you now want an <code>INNER JOIN</code> where the intersection is determined you can write the following query:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Prices.<span class="hljs-operator">*</span>, Quantities.Quantity
<span class="hljs-keyword">FROM</span> Prices <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Quantities
<span class="hljs-keyword">ON</span> Prices.Product <span class="hljs-operator">=</span> Quantities.Product;
</code></pre>
<p>As intersection you now get the black area from the diagram and the following query result comes out:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Product</th>
<th>Price</th>
<th>Quantity</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>6</td>
<td>92</td>
</tr>
<tr>
<td>B</td>
<td>5</td>
<td>27</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>66</td>
</tr>
</tbody>
</table>
</div><hr>
<h3>OUTER JOIN</h3>
<p>An <code>OUTER JOIN</code> returns a set of records (or rows) that contain what the <code>INNER JOIN</code> would return, but <strong>also</strong> contain additional rows for which no corresponding match was found in another table.</p>
<p>There are three types of outer joins:</p>
<ul>
<li><code>LEFT OUTER JOIN</code> (or left join)</li>
<li><code>RIGHT OUTER JOIN</code> (or right join)</li>
<li><code>FULL OUTER JOIN</code> (or full join)</li>
</ul>
<p>Each of these <code>OUTER JOIN</code> refers to the portion of data that is being compared, combined, and returned. Sometimes zeros are generated in the process because some data is shared and others are not.</p>
<p><em>However, this description would now go beyond the scope of the question.</em></p>
<blockquote>
<p>My sources:</p>
<ul>
<li><a href="https://www.diffen.com/difference/Inner_Join_vs_Outer_Join" rel="nofollow noreferrer">https://www.diffen.com/difference/Inner_Join_vs_Outer_Join</a></li>
<li><a href="https://www.freecodecamp.org/news/sql-join-types-inner-join-vs-outer-join-example/#:%7E:text=The%20biggest%20difference%20between%20an,table%20in%20the%20resulting%20table." rel="nofollow noreferrer">https://www.freecodecamp.org/news/sql-join-types-inner-join-vs-outer-join-example/#:~:text=The%20biggest%20difference%20between%20an,table%20in%20the%20resulting%20table.</a></li>
<li><a href="https://towardsdatascience.com/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377" rel="nofollow noreferrer">https://towardsdatascience.com/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377</a></li>
</ul>
</blockquote>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Assuming you\u0026apos;re joining on columns with no duplicates, which is a very common case:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;An inner join of A and B gives the result of A intersect B, i.e. the inner part of a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Venn_diagram\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Venn diagram\u0026lt;/a\u0026gt; intersection.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;An outer join of A and B gives the results of A union B, i.e. the outer parts of a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Venn_diagram\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Venn diagram\u0026lt;/a\u0026gt; union.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Examples\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Suppose you have two tables, with a single column each, and data as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;A    B\n\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;-\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;-\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An inner join using either of the equivalent queries gives the intersection of the two tables, i.e. the two rows they have in common.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; a.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, b.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a,b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\na \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--+--\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Left outer join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A left outer join will give all rows in A, plus any common rows in B.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; a.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, b.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a,b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b(\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;+\u0026lt;/span\u0026gt;);\n\na \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  b\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--+-----\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Right outer join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A right outer join will give all rows in B, plus any common rows in A.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;RIGHT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; a.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, b.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a,b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; a.a(\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;+\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\na    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  b\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-----+----\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Full outer join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A full outer join will give you the union of A and B, i.e. all the rows in A and all the rows in B. If something in A doesn\u0026apos;t have a corresponding datum in B, then the B portion is null, and vice versa.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; a.a \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.b;\n\n a   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;  b\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-----+-----\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Venn diagrams don\u0026apos;t really do it for me.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;They don\u0026apos;t show any distinction between a cross join and an inner join, for example, or more generally show any distinction between different types of join predicate or provide a framework for reasoning about how they will operate.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is no substitute for understanding the logical processing and it is relatively straightforward to grasp anyway.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Imagine a cross join.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Evaluate the \u0026lt;code\u0026gt;on\u0026lt;/code\u0026gt; clause against all rows from step 1 keeping those where the predicate evaluates to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;(For outer joins only) add back in any outer rows that were lost in step 2.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;(NB: In practice the query optimiser may find more efficient ways of executing the query than the purely logical description above but the final result must be the same)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;ll start off with an animated version of a \u0026lt;strong\u0026gt;full outer join\u0026lt;/strong\u0026gt;. Further explanation follows.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/VUkfU.gif\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/VUkfU.gif\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;Explanation\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Source Tables\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/LVYKx.png\u0026quot; alt=\u0026quot;enter link description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First start with a \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; (AKA Cartesian Product). This does not have an \u0026lt;code\u0026gt;ON\u0026lt;/code\u0026gt; clause and simply returns every combination of rows from the two tables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SELECT A.Colour, B.Colour FROM A CROSS JOIN B\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/cv3t6.png\u0026quot; alt=\u0026quot;enter link description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Inner and Outer joins have an \u0026quot;ON\u0026quot; clause predicate.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Inner Join.\u0026lt;/strong\u0026gt; Evaluate the condition in the \u0026quot;ON\u0026quot; clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Left Outer Join.\u0026lt;/strong\u0026gt; Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Right Outer Join.\u0026lt;/strong\u0026gt; Same as inner join then for any rows in the right table that did not  match anything output these with NULL values for the left table columns.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Full Outer Join.\u0026lt;/strong\u0026gt; Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h1\u0026gt;Some examples\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The above is the classic equi join.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/a8IHd.png\u0026quot; alt=\u0026quot;Inner Join\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Animated Version\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/kZcvR.gif\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/kZcvR.gif\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN (\u0026apos;Green\u0026apos;,\u0026apos;Blue\u0026apos;)\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The inner join condition need not necessarily be an equality condition and it need not reference columns from both (or even either) of the tables. Evaluating \u0026lt;code\u0026gt;A.Colour NOT IN (\u0026apos;Green\u0026apos;,\u0026apos;Blue\u0026apos;)\u0026lt;/code\u0026gt; on each row of the cross join returns.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ZwoCi.png\u0026quot; alt=\u0026quot;inner 2\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The join condition evaluates to true for all rows in the cross join result so this is just the same as a cross join. I won\u0026apos;t repeat the picture of the 16 rows again.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Outer Joins are logically evaluated in the same way as inner joins except that if a row from the left table (for a left join) does not join with any rows from the right hand table at all it is preserved in the result with \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; values for the right hand columns.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/4bzv2.png\u0026quot; alt=\u0026quot;LOJ\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour IS NULL\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This simply restricts the previous result to only return the rows where \u0026lt;code\u0026gt;B.Colour IS NULL\u0026lt;/code\u0026gt;. In this particular case these will be the rows that were preserved as they had no match in the right hand table and the query returns the single red row not matched in table \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. This is known as an anti semi join.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is important to select a column for the \u0026lt;code\u0026gt;IS NULL\u0026lt;/code\u0026gt; test that is either not nullable or for which the join condition ensures that any \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; values will be excluded in order for this pattern to work correctly and avoid just bringing back rows which happen to have a \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; value for that column in addition to the un matched rows.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/d6CVF.png\u0026quot; alt=\u0026quot;loj is null\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Right outer joins act similarly to left outer joins except they preserve non matching rows from the right table and null extend the left hand columns.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/LIOW4.png\u0026quot; alt=\u0026quot;ROJ\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Full outer joins combine the behaviour of left and right joins and preserve the non matching rows from both the left and the right tables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/iVoqu.png\u0026quot; alt=\u0026quot;FOJ\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;No rows in the cross join match the \u0026lt;code\u0026gt;1=0\u0026lt;/code\u0026gt; predicate. All rows from both sides are preserved using normal outer join rules with NULL in the columns from the table on the other side.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/gtIhf.png\u0026quot; alt=\u0026quot;FOJ 2\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON 1 = 0\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;With a minor amend to the preceding query one could simulate a \u0026lt;code\u0026gt;UNION ALL\u0026lt;/code\u0026gt; of the two tables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/WPu9W.png\u0026quot; alt=\u0026quot;UNION ALL\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour WHERE B.Colour = \u0026apos;Green\u0026apos;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Note that the \u0026lt;code\u0026gt;WHERE\u0026lt;/code\u0026gt; clause (if present) logically runs after the join. One common error is to perform a left outer join and then include a WHERE clause with a condition on the right table that ends up excluding the non matching rows. The above ends up performing the outer join...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/4bzv2.png\u0026quot; alt=\u0026quot;LOJ\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;... And then the \u0026quot;Where\u0026quot; clause runs. \u0026lt;code\u0026gt;NULL= \u0026apos;Green\u0026apos;\u0026lt;/code\u0026gt; does not evaluate to true so the row preserved by the outer join ends up discarded (along with the blue one) effectively converting the join back to an inner one.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/tRHdf.png\u0026quot; alt=\u0026quot;LOJtoInner\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If the intention was to include only rows from B where Colour is Green and all rows from A regardless the correct syntax would be\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour AND B.Colour = \u0026apos;Green\u0026apos;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/cvJ1s.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;SQL Fiddle\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;See these examples \u0026lt;a href=\u0026quot;http://sqlfiddle.com/#!17/10d3d/29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;run live at SQLFiddle.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Joins\u0026lt;/strong\u0026gt; are used to combine the data from two tables, with the result being a new, temporary table. Joins are performed based on something called a predicate, which specifies the condition to use in order to perform a join.  The difference between an inner join and an outer join is that an inner join will return only the rows that actually match based on the join predicate.\nFor eg- Lets consider Employee and Location table:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Employee\u0026lt;/h3\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;EmpID\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;EmpName\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Jason\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Alex\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Ram\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Babu\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Johnson\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\u0026lt;h3\u0026gt;Location\u0026lt;/h3\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;EmpID\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;EmpLoc\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;San Jose\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Los Angeles\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Pune, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Chennai, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;39\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Bangalore, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Inner Join:-\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\nInner join creates a new result table by combining column values of two tables (\u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt;) based upon the join-predicate. The query compares each row of \u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt; with each row of \u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt; to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of \u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt; are combined into a result row.\nHeres what the SQL for an inner join will look like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; employee \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inner\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; location \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; employee.empID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; location.empID\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OR\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; employee, location \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; employee.empID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; location.empID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, here is what the result of running that SQL would look like:\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpName\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpLoc\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Jason\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;San Jose\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Alex\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Los Angeles\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Ram\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Pune, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Babu\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Chennai, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Outer Join:-\u0026lt;/strong\u0026gt;\nAn outer join does not require each record in the two joined tables to have a matching record. The joined table retains each recordeven if no other matching record exists. Outer joins subdivide further into left outer joins and right outer joins, depending on which table\u0026apos;s rows are retained (left or right).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Left Outer Join:-\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\nThe result of a left outer join (or simply left join) for tables \u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt; always contains all records of the \u0026quot;left\u0026quot; table (\u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt;), even if the join-condition does not find any matching record in the \u0026quot;right\u0026quot; table (\u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt;).\nHere is what the SQL for a left outer join would look like, using the tables above:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; employee \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;left\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; location \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; employee.empID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; location.empID;\n\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;/\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;/\u0026lt;/span\u0026gt;Use \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt; keyword \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; optional\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, here is what the result of running this SQL would look like:\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpName\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpLoc\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Jason\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;San Jose\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Alex\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Los Angeles\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Ram\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Pune, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Babu\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Chennai, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;25\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Johnson\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;Note how while Johnson has no entry in the employee location table, he is still included in the results but the location fields are nulled.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Right Outer Join:-\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\nA right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the \u0026quot;right\u0026quot; table (\u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt;) will appear in the joined table at least once. If no matching row from the \u0026quot;left\u0026quot; table (\u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt;) exists, NULL will appear in columns from \u0026lt;em\u0026gt;Employee\u0026lt;/em\u0026gt; for those records that have no match in \u0026lt;em\u0026gt;Location\u0026lt;/em\u0026gt;.\nThis is what the SQL looks like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; employee \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;right\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; location  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; employee.empID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; location.empID;\n\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;/\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;/\u0026lt;/span\u0026gt;Use \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;outer\u0026lt;/span\u0026gt; keyword \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; optional\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Using the tables above, we can show what the result set of a right outer join would look like:\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpName\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpLoc\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Jason\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;San Jose\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Alex\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Los Angeles\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Ram\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Pune, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Babu\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Chennai, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;39\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Bangalore, India\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;Note how while there are no employees listed as working in Bangalore, it is still included in the results with the employee fields nulled out.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Full Outer Joins:-\u0026lt;/strong\u0026gt;\nFull Outer Join or Full Join is to retain the nonmatching information by including nonmatching rows in the results of a join, use a full outer join. It includes all rows from both tables, regardless of whether or not the other table has a matching value.\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Employee.EmpName\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpId\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Location.EmpLoc\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Jason\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;San Jose\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Alex\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;8\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Los Angeles\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Ram\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Pune, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Babu\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;17\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;Chennai, India\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;25\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Johnson\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;NULL\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;39\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Bangalore, India\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://dev.mysql.com/doc/refman/8.0/en/join.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;MySQL 8.0 Reference Manual - Join Syntax\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj29840.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Oracle Join operations\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Inner Join\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Retrieve the matched rows only, that is, \u0026lt;code\u0026gt;A intersect B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Zkk3I.jpg\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; dbo.Students S\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; dbo.Advisors A\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; S.Advisor_ID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; A.Advisor_ID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Left Outer Join\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Select all records from the first table, and any records in the second\ntable that match the joined keys.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Z584b.jpg\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; dbo.Students S\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; dbo.Advisors A\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; S.Advisor_ID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; A.Advisor_ID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Full Outer Join\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Select all records from the second table, and any records in the first\ntable that match the joined keys.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/c1QF3.jpg\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; dbo.Students S\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; dbo.Advisors A\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; S.Advisor_ID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; A.Advisor_ID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;References\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://www.datamartist.com/sql-inner-join-left-outer-join-full-outer-join-examples-with-syntax-for-sql-server\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Inner and outer joins SQL examples and the Join block\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://www.techonthenet.com/sql/joins.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SQL: JOINS\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In simple words:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An \u0026lt;strong\u0026gt;inner join\u0026lt;/strong\u0026gt; retrieve the matched rows only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas an \u0026lt;strong\u0026gt;outer join\u0026lt;/strong\u0026gt; retrieve the matched rows from one table and all rows in other table ....the result depends on which one you are using:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Left\u0026lt;/strong\u0026gt;: Matched rows in the right table and all rows in the left table\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Right\u0026lt;/strong\u0026gt;: Matched rows in the left table and all rows in the right table or \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Full\u0026lt;/strong\u0026gt;: All rows in all tables. It doesn\u0026apos;t matter if there is a match or not\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A inner join only shows rows if there is a matching record on the other (right) side of the join.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A (left) outer join shows rows for each record on the left hand side, even if there are no matching rows on the other (right) side of the join. If there is no matching row, the columns for the other (right) side would show NULLs.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Inner joins require that a record with a related ID exist in the joined table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Outer joins will return records for the left side even if nothing exists for the right side.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For instance, you have an Orders and an OrderDetails table. They are related by an \u0026quot;OrderID\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Orders\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;OrderID\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;CustomerName\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OrderDetails\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;OrderDetailID\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;OrderID\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ProductName\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Qty\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Price\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The request\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; Orders.OrderID, Orders.CustomerName\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; Orders \n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; OrderDetails\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; Orders.OrderID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; OrderDetails.OrderID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will only return Orders that also have something in the OrderDetails table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you change it to OUTER LEFT JOIN\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; Orders.OrderID, Orders.CustomerName\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; Orders \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; OrderDetails\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; Orders.OrderID \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; OrderDetails.OrderID\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then it will return records from the Orders table even if they have no OrderDetails records.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use this to find Orders that do not have any OrderDetails indicating a possible orphaned order by adding a where clause like \u0026lt;code\u0026gt;WHERE OrderDetails.OrderID IS NULL\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In simple words :\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner join\u0026lt;/strong\u0026gt; -\u0026amp;gt; Take ONLY common records from parent and child tables WHERE primary key of Parent table matches Foreign key in Child table.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Left join\u0026lt;/strong\u0026gt; -\u0026amp;gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;pseudo code\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt;Take \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;All\u0026lt;/span\u0026gt; records \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;left\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Table\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;each\u0026lt;/span\u0026gt; record \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;right\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;table\u0026lt;/span\u0026gt;,) {\n    if(Records \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;left\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;amp;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;right\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;table\u0026lt;/span\u0026gt; matching \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;primary\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;amp;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreign\u0026lt;/span\u0026gt; key){\n       use their \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;values\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; it \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt; the \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;right\u0026lt;/span\u0026gt; side \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;nd table.\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n       put \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;values\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; that particular record \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt; the \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;right\u0026lt;/span\u0026gt; side \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;nd table.\n    }\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Right join\u0026lt;/strong\u0026gt; : Exactly opposite of left join . Put name of table in LEFT JOIN at right side in Right join , you get same output as LEFT JOIN.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Outer join\u0026lt;/strong\u0026gt; : Show all records in Both tables \u0026lt;code\u0026gt;No matter what\u0026lt;/code\u0026gt;. If records in Left table are not matching to right table based on Primary , Forieign key , use NULL value as result of join .\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/pCErn.png\u0026quot; alt=\u0026quot;Example\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Lets assume now for 2 tables\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;1.employees  , 2.phone_numbers_employees\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;employees : id , name \n\nphone_numbers_employees : id , phone_num , emp_id   \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here , employees table is Master table , phone_numbers_employees is child table(it contains \u0026lt;code\u0026gt;emp_id\u0026lt;/code\u0026gt; as foreign key which connects \u0026lt;code\u0026gt;employee.id\u0026lt;/code\u0026gt; so its child table.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner joins\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Take the records of 2 tables \u0026lt;strong\u0026gt;ONLY IF Primary key of employees table(its id) matches Foreign key of Child table phone_numbers_employees(emp_id)\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So query would be :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; e.id , e.name , p.phone_num \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; e \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; phone_numbers_employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; e.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.emp_id;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here take only matching rows on primary key = foreign key as explained above.Here non matching rows on primary key = foreign key are skipped as result of join.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Left joins\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Left join retains all rows of the left table, regardless of whether there is a row that matches on the right table.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; e.id , e.name , p.phone_num \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; e \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; phone_numbers_employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; e.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.emp_id;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Outer joins\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; e.id , e.name , p.phone_num \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; e \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; phone_numbers_employees \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; e.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.emp_id;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Diagramatically it looks like :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/hMKKt.jpg\u0026quot; alt=\u0026quot;Diagram\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You use \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; to return all rows from both tables where there is a match. i.e. In the resulting table all the rows and columns will have values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; the resulting table may have empty columns. Outer join may be either \u0026lt;code\u0026gt;LEFT\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;RIGHT\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; returns all the rows from the first table, even if there are no matches in the second table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; returns all the rows from the second table, even if there are no matches in the first table.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; requires there is at least a match in comparing the two tables. For example, table A and table B which implies A ٨ B (A intersection B).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt; are the same. It gives all the records matching in both tables and all possibilities of the left table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, \u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;RIGHT JOIN\u0026lt;/code\u0026gt; are the same. It gives all the records matching in both tables and all possibilities of the right table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;FULL JOIN\u0026lt;/code\u0026gt; is the combination of \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; without duplication.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The answer is in the meaning of each one, so in the results.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note :\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\n  In \u0026lt;code\u0026gt;SQLite\u0026lt;/code\u0026gt; there is no \u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\n  And also in \u0026lt;code\u0026gt;MySQL\u0026lt;/code\u0026gt; there is no \u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;My answer is based on above \u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you have two tables like these: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[table1]               --[table2]\u0026lt;/span\u0026gt;\nid \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name                id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;---+-------              ---+-------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1                  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b1                  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CROSS JOIN / OUTER JOIN :\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nYou can have all of those tables data with \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; or just with \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1, table2\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[OR]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table2\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[Results:]\u0026lt;/span\u0026gt;\nid \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;---+------+----+------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;INNER JOIN :\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWhen you want to add a filter to above results based on a relation like \u0026lt;code\u0026gt;table1.id = table2.id\u0026lt;/code\u0026gt; you can use \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1, table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[OR]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[Results:]\u0026lt;/span\u0026gt;\nid \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;---+------+----+------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;LEFT [OUTER] JOIN :\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWhen you want to have all rows of one of tables in the above result -with same relation- you can use \u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt;:\u0026lt;br\u0026gt;\n(For \u0026lt;strong\u0026gt;RIGHT JOIN\u0026lt;/strong\u0026gt; just change place of tables)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1, table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ALL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Not\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;In\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table2)\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[OR]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[Results:]\u0026lt;/span\u0026gt;\nid \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; id   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;---+------+------+------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;FULL OUTER JOIN :\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWhen you also want to have all rows of the other table in your results you can use \u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1, table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ALL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Not\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;In\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table2)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ALL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Not\u0026lt;/span\u0026gt; table2.id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;In\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1)\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[OR] (recommended for SQLite)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ALL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; table2.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table1.id\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;IS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[OR]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; table1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; table2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;On\u0026lt;/span\u0026gt; table1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; table2.id\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;--[Results:]\u0026lt;/span\u0026gt;\nid   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; id   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; name \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-----+------+------+------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; a2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b1   \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; b2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Well, as your need you choose each one that covers your need ;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner join.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A join is combining the rows from two tables. An \u0026lt;em\u0026gt;inner join\u0026lt;/em\u0026gt; attempts to match up the two tables based on the criteria you specify in the query, and only returns the rows that match. If a row from the first table in the join matches two rows in the second table, then two rows will be returned in the results. If theres a row in the first table that doesnt match a row in the second, its not returned; likewise, if theres a row in the second table that doesnt match a row in the first, its not returned.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Outer Join.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;left join\u0026lt;/em\u0026gt; attempts to find match up the rows from the first table to rows in the second table. If it cant find a match, it will return the columns from the first table and leave the columns from the second table blank (null).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/TBMzF.jpg\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/TBMzF.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; most typical join for two or more tables.\nIt returns data match on both table ON primarykey and forignkey relation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; is same as \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;, but it also include \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; data on ResultSet.\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; + Unmatched data of \u0026lt;strong\u0026gt;left\u0026lt;/strong\u0026gt; table with \u0026lt;code\u0026gt;Null\u0026lt;/code\u0026gt; match on right table.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;RIGHT JOIN\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; + Unmatched data of \u0026lt;strong\u0026gt;right\u0026lt;/strong\u0026gt; table with \u0026lt;code\u0026gt;Null\u0026lt;/code\u0026gt; match on left table.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FULL JOIN\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; + Unmatched data on \u0026lt;strong\u0026gt;both right and left\u0026lt;/strong\u0026gt; tables with \u0026lt;code\u0026gt;Null\u0026lt;/code\u0026gt; matches.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Self join is not a keyword in SQL, when a table references data in itself knows as self join. Using \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; we can write self join queries.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt;   tablea a \n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; tableb b \n               \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; a.primary_key \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.foreign_key \n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; tablec c \n               \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; b.primary_key \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c.foreign_key \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t see much details about performance and optimizer in the other answers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes it is good to know that only \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; is associative which means the optimizer has the most option to play with it. It can reorder the join order to make it faster keeping the same result. The optimizer can use the most join modes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Generally it is a good practice to try to use \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; instead of the different kind of joins. (Of course if it is possible considering the expected result set.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are a couple of good examples and explanation here about this strange associative behavior:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/20022196/are-left-outer-joins-associative\u0026quot;\u0026gt;Are left outer joins associative?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/9614922/does-the-join-order-matter-in-sql\u0026quot;\u0026gt;Does the join order matter in SQL?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Having criticized the much-loved red-shaded Venn diagram, I thought it only fair to post my own attempt.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although @Martin Smith\u0026apos;s answer is the best of this bunch by a long way, his only shows the key column from each table, whereas I think ideally non-key columns should also be shown.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The best I could do in the half hour allowed, I still don\u0026apos;t think it adequately shows that the nulls are there due to absence of key values in \u0026lt;code\u0026gt;TableB\u0026lt;/code\u0026gt; or that \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; is actually a union rather than a join:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/fzwkg.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/fzwkg.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The precise algorithm for \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;LEFT/RIGHT OUTER JOIN\u0026lt;/code\u0026gt; are as following: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Take each row from the first table: \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consider all rows from second table beside it: \u0026lt;code\u0026gt;(a, b[i])\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Evaluate the \u0026lt;code\u0026gt;ON ...\u0026lt;/code\u0026gt; clause against each pair: \u0026lt;code\u0026gt;ON( a, b[i] ) = true/false?\u0026lt;/code\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When the condition evaluates to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;, return that combined row  \u0026lt;code\u0026gt;(a, b[i])\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When reach end of second table without any match, and this is an \u0026lt;code\u0026gt;Outer Join\u0026lt;/code\u0026gt; then return a \u0026lt;em\u0026gt;(virtual)\u0026lt;/em\u0026gt; pair using \u0026lt;code\u0026gt;Null\u0026lt;/code\u0026gt; for all columns of other table: \u0026lt;code\u0026gt;(a, Null)\u0026lt;/code\u0026gt; for LEFT outer join or \u0026lt;code\u0026gt;(Null, b)\u0026lt;/code\u0026gt; for RIGHT outer join. This is to ensure all rows of first table exists in final results.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; the condition specified in \u0026lt;code\u0026gt;ON\u0026lt;/code\u0026gt; clause could be anything, it is not required to use \u0026lt;em\u0026gt;Primary Keys\u0026lt;/em\u0026gt; (and you don\u0026apos;t need to always refer to Columns from both tables)! For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;... ON T1.title = T2.title AND T1.version \u0026amp;lt; T2.version\u0026lt;/code\u0026gt; ( =\u0026amp;gt; see this post as a sample usage: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7745635/2803565\u0026quot;\u0026gt;Select only rows with max value on a column\u0026lt;/a\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;... ON T1.y IS NULL\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;... ON 1 = 0\u0026lt;/code\u0026gt; (just as sample)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/0dWzY.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/0dWzY.png\u0026quot; alt=\u0026quot;Inner Join vs. Left Outer Join\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Bsocp.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Bsocp.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; Left Join = Left Outer Join, Right Join = Right Outer Join.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Simplest Definitions\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inner Join: Returns \u0026lt;strong\u0026gt;matched records\u0026lt;/strong\u0026gt; from both tables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Full Outer Join: Returns matched and \u0026lt;strong\u0026gt;unmatched records\u0026lt;/strong\u0026gt; from both tables with null for unmatched records from \u0026lt;strong\u0026gt;Both Tables\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Left Outer Join: Returns matched and unmatched records only from table on \u0026lt;strong\u0026gt;Left Side\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Right Outer Join: Returns matched and unmatched records only from table on \u0026lt;strong\u0026gt;Right Side\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In-Short\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Matched + Left Unmatched + Right Unmatched = \u0026lt;strong\u0026gt;Full Outer Join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Matched + Left Unmatched = \u0026lt;strong\u0026gt;Left Outer Join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Matched + Right Unmatched = \u0026lt;strong\u0026gt;Right Outer Join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Matched = \u0026lt;strong\u0026gt;Inner Join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;The General Idea\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Please see the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/27458534/12695027\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; by \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/73226\u0026quot;\u0026gt;Martin Smith\u0026lt;/a\u0026gt; for a better illustations and explanations of the different joins, including and especially differences between \u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;These two table form a basis for the representation of the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt;s below:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/DEAAy.png\u0026quot; alt=\u0026quot;Basis\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;CROSS JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/EqnB9.png\u0026quot; alt=\u0026quot;CrossJoin\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result will be the Cartesian products of all combinations. No \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition required:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/eeFIB.png\u0026quot; alt=\u0026quot;CrossJoinResult\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;INNER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; is the same as simply: \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/oXqs0.png\u0026quot; alt=\u0026quot;InnerJoin\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen    c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; c.postal \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.postal\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result will be combinations that satisfies the required \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/aaNvi.png\u0026quot; alt=\u0026quot;InnerJoinResult\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;LEFT OUTER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; is the same as \u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/qmy29.png\u0026quot; alt=\u0026quot;LeftJoin\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen         c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; c.postal \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.postal\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result will be everything from \u0026lt;code\u0026gt;citizen\u0026lt;/code\u0026gt; even if there are no matches in \u0026lt;code\u0026gt;postalcode\u0026lt;/code\u0026gt;. Again a \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition is required:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/mbaqJ.png\u0026quot; alt=\u0026quot;LeftJoinResult\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Data for playing\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;All examples have been run on an Oracle 18c. They\u0026apos;re available at \u0026lt;a href=\u0026quot;https://dbfiddle.uk/?rdbms=oracle_18\u0026amp;amp;fiddle=19be5f6abb0a5987fddf037b5df343bd\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;dbfiddle.uk\u0026lt;/a\u0026gt; which is also where screenshots of tables came from.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CREATE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;TABLE\u0026lt;/span\u0026gt; citizen (id      NUMBER,\n                      name    VARCHAR2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;),\n                      postal  NUMBER,  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt;-- could do with a redesign to postalcode.id instead.\u0026lt;/span\u0026gt;\n                      leader  NUMBER);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CREATE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;TABLE\u0026lt;/span\u0026gt; postalcode (id      NUMBER,\n                         postal  NUMBER,\n                         city    VARCHAR2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;),\n                         area    VARCHAR2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INSERT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INTO\u0026lt;/span\u0026gt; citizen (id, name, postal, leader)\n              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2200\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Green\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31006\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jensen\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;623\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INSERT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INTO\u0026lt;/span\u0026gt; postalcode (id, postal, city, area)\n                 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2200\u0026lt;/span\u0026gt;,     \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;BigCity\u0026apos;\u0026lt;/span\u0026gt;,         \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Geancy\u0026apos;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL\n           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31006\u0026lt;/span\u0026gt;,    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;SmallTown\u0026apos;\u0026lt;/span\u0026gt;,       \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Snizkim\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL\n           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31006\u0026lt;/span\u0026gt;,    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Settlement\u0026apos;\u0026lt;/span\u0026gt;,      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt;-- Uuh-uhh.\u0026lt;/span\u0026gt;\n           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;78567390\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;LookoutTowerX89\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Space\u0026apos;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; DUAL;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h1\u0026gt;Blurry boundaries when playing with \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;WHERE\u0026lt;/code\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;h3\u0026gt;CROSS JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; resulting in rows as The General Idea/\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; c.postal \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.postal \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt; -- The WHERE condition is limiting the resulting rows\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; to get the result of a \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; requires tricks like adding in a \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; row. It\u0026apos;s omitted.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;INNER JOIN\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; becomes a cartesian products. It\u0026apos;s the same as The General Idea/\u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen    c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt; -- The ON condition makes it a CROSS JOIN\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is where the inner join can really be seen as the cross join with results not matching the condition removed. Here none of the resulting rows are removed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; to get the result of a \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; also requires tricks. It\u0026apos;s omitted.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;LEFT OUTER JOIN\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt; results in rows as The General Idea/\u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen         c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt; -- The ON condition makes it a CROSS JOIN\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt; results in rows as The General Idea/\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen         c\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; c.postal \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.postal\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; p.postal \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;IS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NOT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- \u0026amp;lt; -- removed the row where there\u0026apos;s no mathcing result from postalcode\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;The troubles with the Venn diagram\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;An image internet search on \u0026quot;sql join cross inner outer\u0026quot; will show a multitude of Venn diagrams. I used to have a printed copy of one on my desk. But there are issues with the representation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Venn diagram are excellent for set theory, where an element can be in one or both sets. But for databases, an element in one \u0026quot;set\u0026quot; seem, to me, to be a row in a table, and therefore not also present in any other tables. There is no such thing as one row present in multiple tables. A row is unique to the table.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Self joins are a corner case where each element is in fact the same in both sets. But it\u0026apos;s still not free of any of the issues below.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The set \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; represents the set on the left (the \u0026lt;code\u0026gt;citizen\u0026lt;/code\u0026gt; table) and the set \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is the set on the right (the \u0026lt;code\u0026gt;postalcode\u0026lt;/code\u0026gt; table) in below discussion.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;CROSS JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Every element in both sets are matched with every element in the other set, meaning we need \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; amount of every \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; elements and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; amount of every \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; elements to properly represent this Cartesian product. Set theory isn\u0026apos;t made for multiple identical elements in a set, so I find Venn diagrams to properly represent it impractical/impossible. It doesn\u0026apos;t seem that \u0026lt;code\u0026gt;UNION\u0026lt;/code\u0026gt; fits at all.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The rows are distinct. The \u0026lt;code\u0026gt;UNION\u0026lt;/code\u0026gt; is 7 rows in total. But they\u0026apos;re incompatible for a common \u0026lt;code\u0026gt;SQL\u0026lt;/code\u0026gt; results set. And this is not how a \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; works at all:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/MqN6E.png\u0026quot; alt=\u0026quot;CrossJoinUnion1\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Trying to represent it like this:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/1BhEE.png\u0026quot; alt=\u0026quot;CrossJoinUnion2Crossing\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;..but now it just looks like an \u0026lt;code\u0026gt;INTERSECTION\u0026lt;/code\u0026gt;, which it\u0026apos;s certainly \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;. Furthermore there\u0026apos;s no element in the \u0026lt;code\u0026gt;INTERSECTION\u0026lt;/code\u0026gt; that is actually in any of the two distinct sets. However, it looks very much like the searchable results similar to this:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/syxYr.png\u0026quot; alt=\u0026quot;CrossJoinUnionUnion3\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For reference one searchable result for \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt;s can be seen at \u0026lt;a href=\u0026quot;https://www.tutorialgateway.org/sql-joins/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Tutorialgateway\u0026lt;/a\u0026gt;. The \u0026lt;code\u0026gt;INTERSECTION\u0026lt;/code\u0026gt;, just like this one, is empty.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;INNER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The value of an element depends on the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition. It\u0026apos;s possible to represent this under the condition that every row becomes unique to that condition. Meaning \u0026lt;code\u0026gt;id=x\u0026lt;/code\u0026gt; is only true for \u0026lt;strong\u0026gt;one\u0026lt;/strong\u0026gt; row. Once a row in table \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;citizen\u0026lt;/code\u0026gt;) matches multiple rows in table \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;postalcode\u0026lt;/code\u0026gt;) under the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition, the result has the same problems as the \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt;: The row needs to be represented multiple times, and the set theory isn\u0026apos;t really made for that. Under the condition of uniqueness, the diagram could work though, but keep in mind that the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition determines the placement of an element in the diagram. Looking only at the values of the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition with the rest of the row just along for the ride:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/djpSE.png\u0026quot; alt=\u0026quot;InnerJoinIntersection - Filled\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This representation falls completely apart when using an \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; with a \u0026lt;code\u0026gt;ON 1 = 1\u0026lt;/code\u0026gt; condition making it into a \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;With a self-\u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt;, the rows are in fact idential elements in both tables, but representing the tables as both \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; isn\u0026apos;t very suitable. For example a common self-\u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; condition that makes an element in \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; to be matching a \u0026lt;strong\u0026gt;different\u0026lt;/strong\u0026gt; element in B is \u0026lt;code\u0026gt;ON A.parent = B.child\u0026lt;/code\u0026gt;, making the match from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; on seperate elements. From the examples that would be a \u0026lt;code\u0026gt;SQL\u0026lt;/code\u0026gt; like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen c1\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; citizen c2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; c1.id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.leader\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/p5r7D.png\u0026quot; alt=\u0026quot;SelfJoinResult\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Meaning Smith is the leader of both Green and Jensen.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;OUTER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Again the troubles begin when one row has multiple matches to rows in the other table. This is further complicated because the \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; can be though of as to match the empty set. But in set theory the union of any set \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; and an empty set, is always just \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;. The empty set adds nothing. The representation of this \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; is usually just showing all of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; to illustrate that rows in \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; are selected regardless of whether there is a match or not from \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. The \u0026quot;matching elements\u0026quot; however has the same problems as the illustration above. They depend on the condition. And the empty set seems to have wandered over to \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Q2yFW.png\u0026quot; alt=\u0026quot;LeftJoinIntersection - Filled\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;WHERE clause - making sense\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Finding all rows from a \u0026lt;code\u0026gt;CROSS JOIN\u0026lt;/code\u0026gt; with Smith and postalcode on the Moon:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; c.name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AND\u0026lt;/span\u0026gt; p.area \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Iy4Z3.png\u0026quot; alt=\u0026quot;Where - result\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now the Venn diagram isn\u0026apos;t used to reflect the \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt;. It\u0026apos;s used \u0026lt;strong\u0026gt;only\u0026lt;/strong\u0026gt; for the \u0026lt;code\u0026gt;WHERE\u0026lt;/code\u0026gt; clause:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/fmxEr.png\u0026quot; alt=\u0026quot;Where\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;..and that makes sense.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;When INTERSECT and UNION makes sense\u0026lt;/h1\u0026gt;\n\u0026lt;h3\u0026gt;INTERSECT\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As explained an \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; is not really an \u0026lt;code\u0026gt;INTERSECT\u0026lt;/code\u0026gt;. However \u0026lt;code\u0026gt;INTERSECT\u0026lt;/code\u0026gt;s can be used on results of seperate queries. Here a Venn diagram makes sense, because the elements from the seperate queries are in fact rows that either belonging to just one of the results or both. Intersect will obviously only return results where the row is present in both queries. This \u0026lt;code\u0026gt;SQL\u0026lt;/code\u0026gt; will result in the same row as the one above \u0026lt;code\u0026gt;WHERE\u0026lt;/code\u0026gt;, and the Venn diagram will also be the same:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; c.name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INTERSECT\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; p.area \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;UNION\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; is not a \u0026lt;code\u0026gt;UNION\u0026lt;/code\u0026gt;. However \u0026lt;code\u0026gt;UNION\u0026lt;/code\u0026gt; work under the same conditions as \u0026lt;code\u0026gt;INTERSECT\u0026lt;/code\u0026gt;, resulting in a return of all results combining both \u0026lt;code\u0026gt;SELECT\u0026lt;/code\u0026gt;s:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; c.name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;UNION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; p.area \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;which is equivalent to:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen          c\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CROSS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; postalcode  p\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; c.name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OR\u0026lt;/span\u0026gt; p.area \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;..and gives the result:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/FTPRr.png\u0026quot; alt=\u0026quot;Union - Result\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also here a Venn diagram makes sense:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/GW69a.png\u0026quot; alt=\u0026quot;UNION\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;When it doesn\u0026apos;t apply\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;strong\u0026gt;important note\u0026lt;/strong\u0026gt; is that these only work when the structure of the results from the two SELECT\u0026apos;s are the same, enabling a comparison or union. The results of these two will not enable that:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; citizen\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; postalcode\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; area \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Moon\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;..trying to combine the results with \u0026lt;code\u0026gt;UNION\u0026lt;/code\u0026gt; gives a\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;ORA\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-01790\u0026lt;/span\u0026gt;: expression must have same datatype \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;corresponding\u0026lt;/span\u0026gt; expression\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;For further interest read \u0026lt;a href=\u0026quot;https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Say NO to Venn Diagrams When Explaining JOINs\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13997365/sql-joins-as-venn-diagram\u0026quot;\u0026gt;sql joins as venn diagram\u0026lt;/a\u0026gt;. Both also cover \u0026lt;code\u0026gt;EXCEPT\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Simple Terms,\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1.\u0026lt;strong\u0026gt;INNER JOIN OR EQUI JOIN :\u0026lt;/strong\u0026gt; Returns the resultset that matches only the condition in both the tables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2.\u0026lt;strong\u0026gt;OUTER JOIN :\u0026lt;/strong\u0026gt; Returns the resultset of all the values from both the tables even if there is condition match or not. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3.\u0026lt;strong\u0026gt;LEFT JOIN :\u0026lt;/strong\u0026gt; Returns the resultset of all the values from left table and only rows that match the condition in right table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;4.\u0026lt;strong\u0026gt;RIGHT JOIN :\u0026lt;/strong\u0026gt; Returns the resultset of all the values from right table and only rows that match the condition in left table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;5.\u0026lt;strong\u0026gt;FULL JOIN :\u0026lt;/strong\u0026gt; Full Join and Full outer Join are same.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;left join on\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;inner join on\u0026lt;/code\u0026gt; rows \u0026lt;code\u0026gt;union all\u0026lt;/code\u0026gt; unmatched left table rows extended by \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;s.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;right join on\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;inner join on\u0026lt;/code\u0026gt; rows \u0026lt;code\u0026gt;union all\u0026lt;/code\u0026gt; unmatched right table rows extended by \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;s.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;full join on\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;inner join on\u0026lt;/code\u0026gt; rows\u0026lt;code\u0026gt;union all\u0026lt;/code\u0026gt; unmatched left table rows extended by \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;s \u0026lt;code\u0026gt;union all\u0026lt;/code\u0026gt; unmatched right table rows extended by \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;s.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;outer\u0026lt;/code\u0026gt; is optional \u0026amp;amp; has no effect.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(SQL Standard 2006 SQL/Foundation 7.7 Syntax Rules 1, General Rules 1 b, 3 c \u0026amp;amp; d, 5 b.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So don\u0026apos;t \u0026lt;code\u0026gt;outer join on\u0026lt;/code\u0026gt; until you know what underlying \u0026lt;code\u0026gt;inner join on\u0026lt;/code\u0026gt; is involved.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Find out what rows \u0026lt;code\u0026gt;inner join on\u0026lt;/code\u0026gt; returns:\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/25957600/3404097\u0026quot;\u0026gt;CROSS JOIN vs INNER JOIN in SQL\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;That also explains why Venn(-like) diagrams are not helpful for inner vs outer join.\nFor more on why they  are not helpful for joins generally:\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/55642928/3404097\u0026quot;\u0026gt;Venn Diagram for Natural Join\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner join\u0026lt;/strong\u0026gt; - An \u0026lt;strong\u0026gt;inner join\u0026lt;/strong\u0026gt; using either of the equivalent queries gives the intersection of the two \u0026lt;em\u0026gt;tables\u0026lt;/em\u0026gt;, i.e. the two rows they have in common.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Left outer join\u0026lt;/strong\u0026gt; - A \u0026lt;strong\u0026gt;left outer join\u0026lt;/strong\u0026gt; will give all rows in A, plus any common rows in B.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Full outer join\u0026lt;/strong\u0026gt; - A \u0026lt;strong\u0026gt;full outer join\u0026lt;/strong\u0026gt; will give you the union of A and B, i.e. All the rows in A and all the rows in B. If something in A doesn\u0026apos;t have a corresponding datum in B, then the B portion is null, and vice versay\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;1.\u0026lt;strong\u0026gt;Inner Join:\u0026lt;/strong\u0026gt; Also called as Join. It returns the rows present in both the Left table, and right table only \u0026lt;strong\u0026gt;if there is a match\u0026lt;/strong\u0026gt;. Otherwise, it returns zero records.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt;\n  e1.emp_name,\n  e2.emp_salary    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; emp1 e1\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; emp2 e2\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; e1.emp_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; e2.emp_id\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/lWzlz.jpg\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/lWzlz.jpg\u0026quot; alt=\u0026quot;output1\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2.\u0026lt;strong\u0026gt;Full Outer Join:\u0026lt;/strong\u0026gt; Also called as Full Join. It returns \u0026lt;strong\u0026gt;all the rows\u0026lt;/strong\u0026gt; present in both the Left table, and right table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt;\n  e1.emp_name,\n  e2.emp_salary    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; emp1 e1\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FULL\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;OUTER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; emp2 e2\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; e1.emp_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; e2.emp_id\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/3yY0Y.jpg\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/3yY0Y.jpg\u0026quot; alt=\u0026quot;output2\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3.\u0026lt;strong\u0026gt;Left Outer join:\u0026lt;/strong\u0026gt; Or simply called as Left Join. It returns all the rows present in the Left table and matching rows from the right table (if any).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;4.\u0026lt;strong\u0026gt;Right Outer Join:\u0026lt;/strong\u0026gt; Also called as Right Join. It returns matching rows from the left table (if any), and all the rows present in the Right table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/UIVk7.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/UIVk7.png\u0026quot; alt=\u0026quot;joins\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages of Joins\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Executes faster. \u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Joins are more easily explained with an example:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/DxeqP.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/DxeqP.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To simulate persons and emails stored in separate tables,\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Table A and Table B are joined by Table_A.\u0026lt;strong\u0026gt;id\u0026lt;/strong\u0026gt; = Table_B.\u0026lt;strong\u0026gt;name_id\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Inner Join\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/l4sbv.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/l4sbv.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Only matched ids\u0026apos; rows are shown.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Outer Joins\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/gL8gT.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/gL8gT.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Matched ids and not matched rows for \u0026lt;strong\u0026gt;Table A\u0026lt;/strong\u0026gt; are shown.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/kXk4J.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/kXk4J.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Matched ids and not matched rows for \u0026lt;strong\u0026gt;Table B\u0026lt;/strong\u0026gt; are shown.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/736nT.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/736nT.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\nMatched ids and not matched rows from both Tables are shown.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Note: Full outer join is not available on MySQL\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider below 2 tables:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EMP\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;empid   name    dept_id salary\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       Rob     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       Mark    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;300\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       John    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;       Mary    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;300\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;       Bill    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;700\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;       Jose    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;400\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Department\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;deptid  name\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       IT\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       Accounts\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       Security\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;       HR\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;       R\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;amp;\u0026lt;/span\u0026gt;D\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h3\u0026gt;Inner Join:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Mostly written as just \u0026lt;strong\u0026gt;JOIN\u0026lt;/strong\u0026gt; in sql queries. It returns only the matching records between the tables.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Find out all employees and their department names:\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Select\u0026lt;/span\u0026gt; a.empid, a.name, b.name \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; dept_name\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; emp a\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; department b\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; a.dept_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.deptid\n;\n\nempid   name    dept_name\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       Rob     IT\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       Mark    IT\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       John    Accounts\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;       Mary    Accounts\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;       Bill    Security\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you see above, \u0026lt;code\u0026gt;Jose\u0026lt;/code\u0026gt; is not printed from \u0026lt;strong\u0026gt;EMP\u0026lt;/strong\u0026gt; in the output as it\u0026apos;s dept_id \u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt; does not find a match in the Department table.  Similarly, \u0026lt;code\u0026gt;HR\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;R\u0026amp;amp;D\u0026lt;/code\u0026gt; rows are not printed from \u0026lt;strong\u0026gt;Department\u0026lt;/strong\u0026gt; table as they didn\u0026apos;t find a match in the Emp table. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So, INNER JOIN or just JOIN, returns only matching rows.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;LEFT JOIN :\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;This returns all records from the LEFT table and only matching records from the RIGHT table.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Select\u0026lt;/span\u0026gt; a.empid, a.name, b.name \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; dept_name\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; emp a\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;LEFT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; department b\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; a.dept_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; b.deptid\n;\n\nempid   name    dept_name\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       Rob     IT\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       Mark    IT\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       John    Accounts\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;       Mary    Accounts\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;       Bill    Security\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;       Jose    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, if you observe the above output, all records from the LEFT table(Emp) are printed with just matching records from RIGHT table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;HR\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;R\u0026amp;amp;D\u0026lt;/code\u0026gt; rows are not printed from \u0026lt;strong\u0026gt;Department\u0026lt;/strong\u0026gt; table as they didn\u0026apos;t find a match in the Emp table on dept_id.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So, LEFT JOIN returns ALL rows from Left table and only matching rows from RIGHT table.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Can also check DEMO \u0026lt;a href=\u0026quot;https://dbfiddle.uk/?rdbms=postgres_11\u0026amp;amp;fiddle=9dbdd6cf405ae24c5e2a0798a732d389\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The difference between \u0026lt;code\u0026gt;inner join\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; is as follow:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Inner join\u0026lt;/code\u0026gt; is a join that combined tables based on matching tuples, whereas \u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; is a join that combined table based on both matched and unmatched tuple.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Inner join\u0026lt;/code\u0026gt; merges matched row from two table in where unmatched row are omitted, whereas \u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; merges rows from two tables and unmatched rows fill with null value.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Inner join\u0026lt;/code\u0026gt; is like an intersection operation, whereas \u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; is like an union operation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Inner join\u0026lt;/code\u0026gt; is two types, whereas \u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; are three types.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;outer join\u0026lt;/code\u0026gt; is faster than \u0026lt;code\u0026gt;inner join\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a lot of good answers here with very accurate \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Relational_algebra\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;relational algebra\u0026lt;/a\u0026gt; examples.  Here is a very simplified answer that might be helpful for amateur or novice coders with SQL coding dilemmas.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Basically, more often than not, \u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; queries boil down to two cases:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For a \u0026lt;code\u0026gt;SELECT\u0026lt;/code\u0026gt; of a subset of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; data:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;use \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; when the related \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; data you are looking for \u0026lt;strong\u0026gt;MUST\u0026lt;/strong\u0026gt; exist per database design;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;use \u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt; when the related \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; data you are looking for \u0026lt;strong\u0026gt;MIGHT\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;MIGHT NOT\u0026lt;/strong\u0026gt; exist per database design.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;A Demonstration\u0026lt;/h1\u0026gt;\n\u0026lt;h2\u0026gt;Setup\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Hop into \u0026lt;code\u0026gt;psql\u0026lt;/code\u0026gt; and create a tiny database of cats and humans.\nYou can just copy-paste this whole section.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CREATE\u0026lt;/span\u0026gt; DATABASE catdb;\n\\c catdb;\n\\pset \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;[NULL]\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- how to display null values\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CREATE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;TABLE\u0026lt;/span\u0026gt; humans (\n  name text \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;primary\u0026lt;/span\u0026gt; key\n);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;CREATE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;TABLE\u0026lt;/span\u0026gt; cats (\n  human_name text \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;references\u0026lt;/span\u0026gt; humans(name),\n  name text\n);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INSERT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INTO\u0026lt;/span\u0026gt; humans (name)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;VALUES\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Abe\u0026apos;\u0026lt;/span\u0026gt;), (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Ann\u0026apos;\u0026lt;/span\u0026gt;), (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Ben\u0026apos;\u0026lt;/span\u0026gt;), (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jen\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INSERT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INTO\u0026lt;/span\u0026gt; cats (human_name, name)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;VALUES\u0026lt;/span\u0026gt;\n(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Abe\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Axel\u0026apos;\u0026lt;/span\u0026gt;),\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Bitty\u0026apos;\u0026lt;/span\u0026gt;),\n(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jen\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jellybean\u0026apos;\u0026lt;/span\u0026gt;),\n(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jen\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Juniper\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Querying\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s a query we\u0026apos;ll run several times, changing \u0026lt;code\u0026gt;[SOMETHING JOIN]\u0026lt;/code\u0026gt; to the various types to see the results.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt;\nhumans.name \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; human_name,\ncats.name \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; cat_name\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; humans\n[SOMETHING \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt;] cats \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; humans.name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; cats.human_name\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ORDER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;BY\u0026lt;/span\u0026gt; humans.name;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; returns all human-cat pairs.\nAny human without a cat or cat without a human is excluded.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt; human_name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; cat_name\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;------------+-----------\u0026lt;/span\u0026gt;\n Abe        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Axel\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Jellybean\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Juniper\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt; returns all humans and all cats, with \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; if there is no match on either side.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt; human_name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; cat_name\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;------------+-----------\u0026lt;/span\u0026gt;\n Abe        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Axel\n Ann        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]\n Ben        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Jellybean\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Juniper\n [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]     \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Bitty\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; returns all humans (the left table).\nAny human without a cat gets a \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; in the \u0026lt;code\u0026gt;cat_name\u0026lt;/code\u0026gt; column.\nAny cat without a human is excluded.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt; human_name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; cat_name\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;------------+-----------\u0026lt;/span\u0026gt;\n Abe        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Axel\n Ann        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]\n Ben        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Jellybean\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Juniper\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; returns all cats (the right table).\nAny cat without a human gets a \u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; in the \u0026lt;code\u0026gt;human_name\u0026lt;/code\u0026gt; column.\nAny human without a cat is excluded.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt; human_name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; cat_name\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;------------+-----------\u0026lt;/span\u0026gt;\n Abe        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Axel\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Jellybean\n Jen        \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Juniper\n [\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;]     \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;|\u0026lt;/span\u0026gt; Bitty\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;INNER vs OUTER\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;You can see that while an \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; gets only matching pairs, each kind of \u0026lt;code\u0026gt;OUTER\u0026lt;/code\u0026gt; join includes some items without a match.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, the actual words \u0026lt;code\u0026gt;INNER\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;OUTER\u0026lt;/code\u0026gt; do not need to appear in queries:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;JOIN\u0026lt;/code\u0026gt; by itself implies \u0026lt;code\u0026gt;INNER\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;RIGHT JOIN\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; all imply \u0026lt;code\u0026gt;OUTER\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;INNER JOIN VS. OUTER JOIN\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In SQL, \u0026lt;strong\u0026gt;join\u0026lt;/strong\u0026gt; is used to compare and combine  literally, \u0026lt;strong\u0026gt;join\u0026lt;/strong\u0026gt;  and return specific rows of data from two or more tables in a database. \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; finds and returns matching data from a table, while \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; finds and returns matching data and some different data from a table.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;INNER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; focuses on similarity between 2 tables. When using \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;, there must be at least some matching data between the two (or more) tables being compared. \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; searches tables for matching or overlapping data. If found, \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; combines the information and returns it in a new table.\u0026lt;/p\u0026gt;\n\u0026lt;h4\u0026gt;Example\u0026lt;/h4\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s consider a common scenario with two tables: product price and quantity. The common information in both tables is the product name, so this is the logical column of the join table. Some products are the same in both tables; others are unique to one and have no matches in the other.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A product \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; only returns information about products that are common to both tables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;I\u0026apos;ve put together a little interaction of HTML and CSS so that you can imagine the whole thing visually.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-css lang-css s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-css\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* CSS styles */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-selector-class\u0026quot;\u0026gt;.circles\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;display\u0026lt;/span\u0026gt;: flex;\n}\n\n\u0026lt;span class=\u0026quot;hljs-selector-class\u0026quot;\u0026gt;.circle\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;height\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100px\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;width\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100px\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;border-radius\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50%\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;background\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;#99AEBA\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-selector-class\u0026quot;\u0026gt;.circle\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-pseudo\u0026quot;\u0026gt;:first\u0026lt;/span\u0026gt;-child {\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;background\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;#FF0000\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-selector-class\u0026quot;\u0026gt;.circle\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-pseudo\u0026quot;\u0026gt;:nth-child\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;background\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;#05E156\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;translateX\u0026lt;/span\u0026gt;(-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45px\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;z-index\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-attribute\u0026quot;\u0026gt;mix-blend-mode\u0026lt;/span\u0026gt;: multiply;\n}\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;!DOCTYPE \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;head\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;title\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;INNER JOIN\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;title\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;head\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;circles\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;circle\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;circle\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here the red circle describes your \u0026lt;code\u0026gt;PRICES\u0026lt;/code\u0026gt; and the green circle your \u0026lt;code\u0026gt;QUANTITIES\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;PRICES\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;QUANTITIES\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;P.Product\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;P.Prices\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Q.Product\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Q.Quantity\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;A\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;A\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;92\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;B\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;B\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;27\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;C\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;D\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;66\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;D\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;E\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;If you now want an \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; where the intersection is determined you can write the following query:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; Prices.\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;, Quantities.Quantity\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; Prices \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;INNER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;JOIN\u0026lt;/span\u0026gt; Quantities\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ON\u0026lt;/span\u0026gt; Prices.Product \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Quantities.Product;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;As intersection you now get the black area from the diagram and the following query result comes out:\u0026lt;/p\u0026gt;\n\u0026lt;div class=\u0026quot;s-table-container\u0026quot;\u0026gt;\n\u0026lt;table class=\u0026quot;s-table\u0026quot;\u0026gt;\n\u0026lt;thead\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;th\u0026gt;Product\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Price\u0026lt;/th\u0026gt;\n\u0026lt;th\u0026gt;Quantity\u0026lt;/th\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/thead\u0026gt;\n\u0026lt;tbody\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;A\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;92\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;B\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;27\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;D\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;66\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;/tbody\u0026gt;\n\u0026lt;/table\u0026gt;\n\u0026lt;/div\u0026gt;\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;OUTER JOIN\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; returns a set of records (or rows) that contain what the \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt; would return, but \u0026lt;strong\u0026gt;also\u0026lt;/strong\u0026gt; contain additional rows for which no corresponding match was found in another table.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are three types of outer joins:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;LEFT OUTER JOIN\u0026lt;/code\u0026gt; (or left join)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;RIGHT OUTER JOIN\u0026lt;/code\u0026gt; (or right join)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FULL OUTER JOIN\u0026lt;/code\u0026gt; (or full join)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Each of these \u0026lt;code\u0026gt;OUTER JOIN\u0026lt;/code\u0026gt; refers to the portion of data that is being compared, combined, and returned. Sometimes zeros are generated in the process because some data is shared and others are not.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;However, this description would now go beyond the scope of the question.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;My sources:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.diffen.com/difference/Inner_Join_vs_Outer_Join\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.diffen.com/difference/Inner_Join_vs_Outer_Join\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.freecodecamp.org/news/sql-join-types-inner-join-vs-outer-join-example/#:%7E:text=The%20biggest%20difference%20between%20an,table%20in%20the%20resulting%20table.\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.freecodecamp.org/news/sql-join-types-inner-join-vs-outer-join-example/#:~:text=The%20biggest%20difference%20between%20an,table%20in%20the%20resulting%20table.\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://towardsdatascience.com/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://towardsdatascience.com/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"id":283,"title":"What is the difference between \"INNER JOIN\" and \"OUTER JOIN\"?","content":"\n                \n\u0026lt;p\u0026gt;Also, how do \u0026lt;code\u0026gt;LEFT JOIN\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;RIGHT JOIN\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;FULL JOIN\u0026lt;/code\u0026gt; fit in?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-difference-between-\"inner-join\"-and-\"outer-join\"-1657387501982","postType":"QUESTION","createdAt":"2022-07-09T17:25:02.000Z","updatedAt":"2022-07-09T17:25:02.000Z","tags":[{"id":1735,"name":"inner-join","slug":"inner-join","createdAt":"2022-07-09T17:25:02.000Z","updatedAt":"2022-07-09T17:25:02.000Z","Questions_Tags":{"questionId":283,"tagId":1735}},{"id":1736,"name":"outer-join","slug":"outer-join","createdAt":"2022-07-09T17:25:02.000Z","updatedAt":"2022-07-09T17:25:02.000Z","Questions_Tags":{"questionId":283,"tagId":1736}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-difference-between-\"inner-join\"-and-\"outer-join\"-1657387501982"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>