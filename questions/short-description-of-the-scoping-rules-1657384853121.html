<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_buildManifest.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/short-description-of-the-scoping-rules-1657384853121#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dynamic-languages">dynamic-languages</a></div></div><div class="question-content mt-5">
                
<p>What <strong>exactly</strong> are the Python scoping rules?</p>

<p>If I have some code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">code1
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:
   code2
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>.....
      code3
      <span class="hljs-keyword">for</span> code4..:
       code5
       x()
</code></pre>

<p>Where is <code>x</code> found?  Some possible choices include the list below:</p>

<ol>
<li>In the enclosing source file</li>
<li>In the class namespace</li>
<li>In the function definition</li>
<li>In the for loop index variable</li>
<li>Inside the for loop</li>
</ol>

<p>Also there is the context during execution, when the function <code>spam</code> is passed somewhere else. And maybe <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="noreferrer">lambda functions</a> pass a bit differently?</p>

<p>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Actually, a concise rule for Python Scope resolution, from <a href="https://rads.stackoverflow.com/amzn/click/com/0596513984" rel="noreferrer">Learning Python, 3rd. Ed.</a>. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</p>

<p><strong>LEGB Rule</strong></p>

<ul>
<li><p><strong>L</strong>ocal  Names assigned in any way within a function (<code>def</code> or <code>lambda</code>), and not declared global in that function</p></li>
<li><p><strong>E</strong>nclosing-function  Names assigned in the local scope of any and all statically enclosing functions (<code>def</code> or <code>lambda</code>), from inner to outer</p></li>
<li><p><strong>G</strong>lobal (module)  Names assigned at the top-level of a module file, or by executing a <code>global</code> statement in a <code>def</code> within the file</p></li>
<li><p><strong>B</strong>uilt-in (Python)  Names preassigned in the built-in names module: <code>open</code>, <code>range</code>, <code>SyntaxError</code>, etc</p></li>
</ul>

<p>So, in the case of</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">code1
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:
    code2
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
        code3
        <span class="hljs-keyword">for</span> code4:
            code5
            x()
</code></pre>

<p>The <code>for</code> loop does not have its own namespace. In LEGB order, the scopes would be </p>

<ul>
<li>L: Local in <code>def spam</code> (in <code>code3</code>, <code>code4</code>, and <code>code5</code>)</li>
<li>E: Any enclosing functions (if the whole example were in another <code>def</code>)</li>
<li>G: Were there any <code>x</code> declared globally in the module (in <code>code1</code>)?</li>
<li>B: Any builtin <code>x</code> in Python.</li>
</ul>

<p><code>x</code> will never be found in <code>code2</code> (even in cases where you might expect it would, see <a href="https://stackoverflow.com/a/23471004/2810305">Antti's answer</a> or <a href="https://stackoverflow.com/q/13905741/2810305">here</a>).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</p>

<p>In your example there are only 3 scopes where x will be searched in:</p>

<ul>
<li><p>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</p></li>
<li><p>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</p></li>
<li><p>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</p></li>
</ul>

<p>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():
    x=<span class="hljs-number">4</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():
        <span class="hljs-built_in">print</span> x  <span class="hljs-comment"># Accesses x from foo's scope</span>
    bar()  <span class="hljs-comment"># Prints 4</span>
    x=<span class="hljs-number">5</span>
    bar()  <span class="hljs-comment"># Prints 5</span>
</code></pre>

<p><strong>Restrictions:</strong></p>

<p>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new <strong>local</strong> variable instead of affecting the variable in the parent scope.  For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">global_var1 = []
global_var2 = <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():
    <span class="hljs-comment"># This is OK: It's just accessing, not rebinding</span>
    global_var1.append(<span class="hljs-number">4</span>) 

    <span class="hljs-comment"># This won't affect global_var2. Instead it creates a new variable</span>
    global_var2 = <span class="hljs-number">2</span> 

    local1 = <span class="hljs-number">4</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">embedded_func</span>():
        <span class="hljs-comment"># Again, this doen't affect func's local1 variable.  It creates a </span>
        <span class="hljs-comment"># new local variable also called local1 instead.</span>
        local1 = <span class="hljs-number">5</span>
        <span class="hljs-built_in">print</span> local1

    embedded_func() <span class="hljs-comment"># Prints 5</span>
    <span class="hljs-built_in">print</span> local1    <span class="hljs-comment"># Prints 4</span>
</code></pre>

<p>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">global_var = <span class="hljs-number">4</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">change_global</span>():
    <span class="hljs-keyword">global</span> global_var
    global_var = global_var + <span class="hljs-number">1</span>
</code></pre>

<p>Currently there is no way to do the same for variables in enclosing <em>function</em> scopes, but Python 3 introduces a new keyword, "<code>nonlocal</code>" which will act in a similar way to global, but for nested function scopes.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="noreferrer">4.2.2 Resolution of names</a> of the Python 3 documentation.</p>

<p>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the <strong>class body</strong>, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</p>

<p>Especially, <strong>no</strong> block statement, besides <code>def</code> and <code>class</code>, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</p>

<p>To demonstrate the peculiarities of the class body</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = <span class="hljs-number">0</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>(<span class="hljs-title class_ inherited__">object</span>):
    y = x
    x = x + <span class="hljs-number">1</span> <span class="hljs-comment"># x is now a variable</span>
    z = x

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(self.x) <span class="hljs-comment"># -&gt; 1</span>
        <span class="hljs-built_in">print</span>(x)      <span class="hljs-comment"># -&gt; 0, the global x</span>
        <span class="hljs-built_in">print</span>(y)      <span class="hljs-comment"># -&gt; NameError: global name 'y' is not defined</span>

inst = X()
<span class="hljs-built_in">print</span>(inst.x, inst.y, inst.z, x) <span class="hljs-comment"># -&gt; (1, 0, 1, 0)</span>
</code></pre>

<p>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</p>

<hr>

<p>One of the greater surprises to many newcomers to Python is that a <code>for</code> loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>[ i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>) ]
<span class="hljs-meta">&gt;&gt;&gt; </span>i
<span class="hljs-number">4</span>
</code></pre>

<p>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the <code>def</code> statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</p>

<p>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</p>

<hr>

<p>The global really means the module scope; the main python module is the <code>__main__</code>; all imported modules are accessible through the <code>sys.modules</code> variable; to get access to <code>__main__</code> one can use <code>sys.modules['__main__']</code>, or <code>import __main__</code>; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</p>

<hr>

<p>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in <code>UnboundLocalError</code>, which is a subclass of <code>NameError</code>.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = <span class="hljs-number">5</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">foobar</span>():
    <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># causes UnboundLocalError!</span>
    x += <span class="hljs-number">1</span>    <span class="hljs-comment"># because assignment here makes x a local variable within the function</span>

<span class="hljs-comment"># call the function</span>
foobar()
</code></pre>

<p>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = <span class="hljs-number">5</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">foobar</span>():
    <span class="hljs-keyword">global</span> x
    <span class="hljs-built_in">print</span>(x)
    x += <span class="hljs-number">1</span>

foobar() <span class="hljs-comment"># -&gt; 5</span>
<span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># -&gt; 6</span>
</code></pre>

<p>This also is possible even if it was shadowed in enclosing scope:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = <span class="hljs-number">5</span>
y = <span class="hljs-number">13</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">make_closure</span>():
    x = <span class="hljs-number">42</span>
    y = <span class="hljs-number">911</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():
        <span class="hljs-keyword">global</span> x <span class="hljs-comment"># sees the global value</span>
        <span class="hljs-built_in">print</span>(x, y)
        x += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> func

func = make_closure()
func()      <span class="hljs-comment"># -&gt; 5 911</span>
<span class="hljs-built_in">print</span>(x, y) <span class="hljs-comment"># -&gt; 6 13</span>
</code></pre>

<p>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_closure</span>():
    value = [<span class="hljs-number">0</span>]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_next_value</span>():
        value[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> value[<span class="hljs-number">0</span>]

    <span class="hljs-keyword">return</span> get_next_value

get_next = make_closure()
<span class="hljs-built_in">print</span>(get_next()) <span class="hljs-comment"># -&gt; 1</span>
<span class="hljs-built_in">print</span>(get_next()) <span class="hljs-comment"># -&gt; 2</span>
</code></pre>

<p>However in python 3, the <code>nonlocal</code> comes to rescue:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_closure</span>():
    value = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_next_value</span>():
        <span class="hljs-keyword">nonlocal</span> value
        value += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> value
    <span class="hljs-keyword">return</span> get_next_value

get_next = make_closure() <span class="hljs-comment"># identical behavior to the previous example.</span>
</code></pre>

<p>The <a href="https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="noreferrer"><code>nonlocal</code> documentation</a> says that</p>

<blockquote>
  <p>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</p>
</blockquote>

<p>i.e. <code>nonlocal</code> always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the <code>for</code> target variable, in the <code>with</code> clause, or as a function parameter).</p>

<hr>

<p>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was <code>__builtin__</code> and in python 3 it is now called <code>builtins</code>. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</p>

<hr>

<p>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the <code>print</code> statement. In Python 2.6-2.7 you can get hold of the Python 3 <code>print</code> function with:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> __builtin__

print3 = __builtin__.__dict__[<span class="hljs-string">'print'</span>]
</code></pre>

<p>The <code>from __future__ import print_function</code> actually does not import the <code>print</code> function anywhere in Python 2 - instead it just disables the parsing rules for <code>print</code> statement in the current module, handling <code>print</code> like any other variable identifier, and thus allowing the <code>print</code> the function be looked up in the builtins.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A slightly more complete example of scope:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function  <span class="hljs-comment"># for python 2 support</span>

x = <span class="hljs-number">100</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"1. Global x:"</span>, x)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):
    y = x
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"2. Enclosed y:"</span>, y)
    x = x + <span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"3. Enclosed x:"</span>, x)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"4. Enclosed self.x"</span>, self.x)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"5. Global x"</span>, x)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-built_in">print</span>(y)
        <span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"6."</span>, e)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method_local_ref</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-built_in">print</span>(x)
        <span class="hljs-keyword">except</span> UnboundLocalError <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"7."</span>, e)
        x = <span class="hljs-number">200</span> <span class="hljs-comment"># causing 7 because has same name</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"8. Local x"</span>, x)

inst = Test()
inst.method()
inst.method_local_ref()
</code></pre>

<p>output:</p>

<pre class="lang-none s-code-block"><code>1. Global x: 100
2. Enclosed y: 100
3. Enclosed x: 101
4. Enclosed self.x 101
5. Global x 100
6. global name 'y' is not defined
7. local variable 'x' referenced before assignment
8. Local x 200
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</p>

<p>EDIT: Here's the <a href="http://www.python.org/dev/peps/pep-3104/" rel="noreferrer">PEP</a> with more information on this.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python resolves your variables with -- generally -- three namespaces available.  </p>

<blockquote>
  <p>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</p>
</blockquote>

<p>There are two functions: <code>globals</code> and <code>locals</code> which show you the contents two of these namespaces.</p>

<p>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.  </p>

<p>In this case, the call to a function named <code>x</code> has to be resolved in the local name space or the global namespace.</p>

<p>Local in this case, is the body of the method function <code>Foo.spam</code>.</p>

<p>Global is -- well -- global. </p>

<p>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</p>

<p>There are no other scopes.  The <code>for</code> statement (and other compound statements like <code>if</code> and <code>try</code>) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</p>

<p>Inside a class definition, the names are part of the class namespace.  <code>code2</code>, for instance, must be qualified by the class name.  Generally <code>Foo.code2</code>.  However, <code>self.code2</code> will also work because Python objects look at the containing class as a fall-back.</p>

<p>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (<code>variable.instance</code>.)  </p>

<p>From within a class method, you have locals and globals.  You say <code>self.variable</code> to pick the instance as the namespace.  You'll note that <code>self</code> is an argument to every class member function, making it part of the local namespace.</p>

<p>See <a href="http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html" rel="noreferrer">Python Scope Rules</a>, <a href="https://stackoverflow.com/questions/146359/python-scope">Python Scope</a>, <a href="http://showmedo.com/videos/video?name=2800020&amp;fromSeriesID=280" rel="noreferrer">Variable Scope</a>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Where is x found?</p>
</blockquote>

<p>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</p>

<p>code2 (class members) aren't visible to code inside methods of the same classyou would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</p>

<p>Python is statically scoped, so if you pass spam to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</p>

<p>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x= <span class="hljs-number">0</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">fun1</span>():
    x= <span class="hljs-number">1</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun2</span>():
        x= <span class="hljs-number">2</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun3</span>():
            <span class="hljs-keyword">return</span> x
        <span class="hljs-keyword">return</span> fun3()
    <span class="hljs-keyword">return</span> fun2()
<span class="hljs-built_in">print</span> fun1(), x

<span class="hljs-number">2</span> <span class="hljs-number">0</span>
</code></pre>

<p>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</p>

<p>Before nested_scopesin Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-importfun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">0</span> <span class="hljs-number">0</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Python name resolution</a> only knows the following kinds of scope:</p>
<ol>
<li>builtins scope which provides the <a href="https://docs.python.org/3/library/functions.html#built-in-funcs" rel="nofollow noreferrer">Builtin Functions</a>, such as <code>print</code>, <code>int</code>, or <code>zip</code>,</li>
<li><em>module</em> global scope which is always the top-level of the current module,</li>
<li>three user-defined scopes that can be nested into each other, namely
<ol>
<li><em>function</em> closure scope, from any enclosing <code>def</code> block, <code>lambda</code> expression or comprehension.</li>
<li><em>function</em> local scope, inside a <code>def</code> block, <code>lambda</code> expression or comprehension,</li>
<li><em>class</em> scope, inside a <code>class</code> block.</li>
</ol>
</li>
</ol>
<p>Notably, other constructs such as <code>if</code>, <code>for</code>, or <code>with</code> statements do not have their own scope.</p>
<p><strong>The scoping TLDR</strong>: The <em>lookup</em> of a name begins at the scope in which the name is used, then any enclosing scopes (excluding class scopes), to the module globals, and finally the builtins  the first match in this search order is used.
The <em>assignment</em> to a scope is by default to the current scope  the special forms <code>nonlocal</code> and <code>global</code> must be used to <em>assign</em> to a name from an outer scope.</p>
<p>Finally, comprehensions and generator expressions as well as <code>:=</code> asignment expressions have one special rule when combined.</p>
<hr>
<h3>Nested Scopes and Name Resolution</h3>
<p>These different scopes build a hierarchy, with builtins then global always forming the base, and closures, locals and class scope being nested as <em>lexically</em> defined. That is, only the nesting in the source code matters, not for example the call stack.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">"builtins are available without definition"</span>)

some_global = <span class="hljs-string">"1"</span>  <span class="hljs-comment"># global variables are at module scope</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():
    some_closure = <span class="hljs-string">"3.1"</span>  <span class="hljs-comment"># locals and closure are defined the same, at function scope</span>
    some_local = <span class="hljs-string">"3.2"</span>    <span class="hljs-comment"># a variable becomes a closure if a nested scope uses it</span>

    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>:
         some_classvar = <span class="hljs-string">"3.3"</span>   <span class="hljs-comment"># class variables exist *only* at class scope</span>

         <span class="hljs-keyword">def</span> <span class="hljs-title function_">nested_function</span>(<span class="hljs-params">self</span>):
             some_local = <span class="hljs-string">"3.2"</span>   <span class="hljs-comment"># locals can replace outer names</span>
             <span class="hljs-built_in">print</span>(some_closure)  <span class="hljs-comment"># closures are always readable</span>
    <span class="hljs-keyword">return</span> InnerClass
</code></pre>
<p>Even though <code>class</code> creates a scope and may have nested classes, functions and comprehensions, the names of the <code>class</code> scope are not visible to enclosed scopes. This creates the following hierarchy:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"> builtins           [<span class="hljs-built_in">print</span>, ...]
 <span class="hljs-built_in">globals</span>            [some_global]
   outer_function     [some_local, some_closure]
     InnerClass         [some_classvar]
     inner_function     [some_local]
</code></pre>
<p>Name resolution always starts at the <em>current scope</em> in which a name is accessed, then goes up the hierarchy until a match is found. For example, looking up <code>some_local</code> inside <code>outer_function</code> and <code>inner_function</code> starts at the respective function - and immediately finds the <code>some_local</code> defined in <code>outer_function</code> and <code>inner_function</code>, respectively. When a name is not local, it is fetched from the nearest enclosing scope that defines it  looking up <code>some_closure</code> and <code>print</code> inside <code>inner_function</code> searches until <code>outer_function</code> and builtins, respectively.</p>
<hr>
<h3>Scope Declarations and Name Binding</h3>
<p>By default, a name belongs to any scope in which it is bound to a value. Binding the same name again in an inner scope creates a new variable with the same name - for example, <code>some_local</code> exists separately in both <code>outer_function</code> and <code>inner_function</code>. As far as scoping is concerned, binding includes any statement that sets the value of a name  assignment statements, but also the iteration variable of a <code>for</code> loop, or the name of a <code>with</code> context manager. Notably, <code>del</code> also counts as name binding.</p>
<p>When a name must refer to an outer variable <em>and</em> be bound in an inner scope, the name must be declared as not local. Separate declarations exists for the different kinds of enclosing scopes: <code>nonlocal</code> always refers to the nearest closure, and <code>global</code> always refers to a global name. Notably, <code>nonlocal</code> never refers to a global name and <code>global</code> ignores all closures of the same name. There is no declaration to refer to the builtin scope.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">
some_global = <span class="hljs-string">"1"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():
    some_closure = <span class="hljs-string">"3.2"</span>
    some_global = <span class="hljs-string">"this is ignored by a nested global declaration"</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_function</span>():
        <span class="hljs-keyword">global</span> some_global     <span class="hljs-comment"># declare variable from global scope</span>
        <span class="hljs-keyword">nonlocal</span> some_closure  <span class="hljs-comment"># declare variable from enclosing scope</span>
        message = <span class="hljs-string">" bound by an inner scope"</span>
        some_global = some_global + message
        some_closure = some_closure + message
    <span class="hljs-keyword">return</span> inner_function
</code></pre>
<p>Of note is that function local and <code>nonlocal</code> are resolved at compile time. A <code>nonlocal</code> name <em>must</em> exist in some outer scope. In contrast, a <code>global</code> name can be defined dynamically and may be added or removed from the global scope at any time.</p>
<hr>
<h3>Comprehensions and Assignment Expressions</h3>
<p>The scoping rules of list, set and dict comprehensions and generator expressions are <em>almost</em> the same as for functions. Likewise, the scoping rules for assignment expressions are <em>almost</em> the same as for regular name binding.</p>
<p>The scope of comprehensions and generator expressions is of the same kind as function scope. All names bound in the scope, namely the iteration variables, are locals or closures to the comprehensions/generator and nested scopes. All names, including iterables, are resolved using name resolution as applicable inside functions.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">some_global = <span class="hljs-string">"global"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():
    some_closure = <span class="hljs-string">"closure"</span>
    <span class="hljs-keyword">return</span> [            <span class="hljs-comment"># new function-like scope started by comprehension</span>
        comp_local      <span class="hljs-comment"># names resolved using regular name resolution</span>
        <span class="hljs-keyword">for</span> comp_local  <span class="hljs-comment"># iteration targets are local</span>
        <span class="hljs-keyword">in</span> <span class="hljs-string">"iterable"</span>
        <span class="hljs-keyword">if</span> comp_local <span class="hljs-keyword">in</span> some_global <span class="hljs-keyword">and</span> comp_local <span class="hljs-keyword">in</span> some_global
    ]
</code></pre>
<p>An <code>:=</code> assignment expression works on the nearest function, class or global scope. Notably, if the target of an assignment expression has been declared <code>nonlocal</code> or <code>global</code> in the nearest scope, the assignment expression honors this like a regular assignment.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(some_global := <span class="hljs-string">"global"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():
    <span class="hljs-built_in">print</span>(some_closure := <span class="hljs-string">"closure"</span>)
</code></pre>
<p>However, an assignment expression inside a comprehension/generator works on the nearest <em>enclosing scope</em> of the comprehension/generator, not the scope of the comprehension/generator itself. When several comprehensions/generators are nested, the nearest function or global scope is used. Since the comprehension/generator scope can read closures and global variables, the assignment variable is readable in the comprehension as well. Assigning from a comprehension to a class scope is not valid.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(some_global := <span class="hljs-string">"global"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():
    <span class="hljs-built_in">print</span>(some_closure := <span class="hljs-string">"closure"</span>)
    steps = [
        <span class="hljs-comment"># v write to variable in containing scope</span>
        (some_closure := some_closure + comp_local)
        <span class="hljs-comment">#                 ^ read from variable in containing scope</span>
        <span class="hljs-keyword">for</span> comp_local <span class="hljs-keyword">in</span> some_global
    ]
    <span class="hljs-keyword">return</span> some_closure, steps
</code></pre>
<p>While the iteration variable is local to the comprehension in which it is bound, the target of the assignment expression does not create a local variable and is read from the outer scope:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"> builtins           [<span class="hljs-built_in">print</span>, ...]
 <span class="hljs-built_in">globals</span>            [some_global]
   outer_function     [some_closure]
     &lt;listcomp&gt;         [comp_local]
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Python, </p>

<blockquote>
  <p>any variable that is assigned a value is local to the block in which
  the assignment appears.</p>
</blockquote>

<p>If a variable can't be found in the current scope, please refer to the LEGB order.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Actually, a concise rule for Python Scope resolution, from \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0596513984\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Learning Python, 3rd. Ed.\u0026lt;/a\u0026gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;LEGB Rule\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;L\u0026lt;/strong\u0026gt;ocal  Names assigned in any way within a function (\u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt;), and not declared global in that function\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;E\u0026lt;/strong\u0026gt;nclosing-function  Names assigned in the local scope of any and all statically enclosing functions (\u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt;), from inner to outer\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;G\u0026lt;/strong\u0026gt;lobal (module)  Names assigned at the top-level of a module file, or by executing a \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; statement in a \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; within the file\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;B\u0026lt;/strong\u0026gt;uilt-in (Python)  Names preassigned in the built-in names module: \u0026lt;code\u0026gt;open\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;range\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;SyntaxError\u0026lt;/code\u0026gt;, etc\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So, in the case of\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;code1\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;:\n    code2\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;spam\u0026lt;/span\u0026gt;():\n        code3\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; code4:\n            code5\n            x()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop does not have its own namespace. In LEGB order, the scopes would be \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;L: Local in \u0026lt;code\u0026gt;def spam\u0026lt;/code\u0026gt; (in \u0026lt;code\u0026gt;code3\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;code4\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;code5\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;E: Any enclosing functions (if the whole example were in another \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;G: Were there any \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; declared globally in the module (in \u0026lt;code\u0026gt;code1\u0026lt;/code\u0026gt;)?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;B: Any builtin \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; in Python.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; will never be found in \u0026lt;code\u0026gt;code2\u0026lt;/code\u0026gt; (even in cases where you might expect it would, see \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/23471004/2810305\u0026quot;\u0026gt;Antti\u0026apos;s answer\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/13905741/2810305\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class\u0026apos;s namespace, but they are not directly accessible from within the methods (or nested classes) they contain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In your example there are only 3 scopes where x will be searched in:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;spam\u0026apos;s scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn\u0026apos;t be modified by any user code, so expect it to contain the standard functions and nothing else.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;More scopes only appear when you introduce a nested function (or lambda) into the picture.\nThese will behave pretty much as you\u0026apos;d expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function\u0026apos;s scope. eg.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;():\n    x=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Accesses x from foo\u0026apos;s scope\u0026lt;/span\u0026gt;\n    bar()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Prints 4\u0026lt;/span\u0026gt;\n    x=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n    bar()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Prints 5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Restrictions:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Variables in scopes other than the local function\u0026apos;s variables can be accessed, but can\u0026apos;t be rebound to new parameters without further syntax.  Instead, assignment will create a new \u0026lt;strong\u0026gt;local\u0026lt;/strong\u0026gt; variable instead of affecting the variable in the parent scope.  For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;global_var1 = []\nglobal_var2 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This is OK: It\u0026apos;s just accessing, not rebinding\u0026lt;/span\u0026gt;\n    global_var1.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;) \n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This won\u0026apos;t affect global_var2. Instead it creates a new variable\u0026lt;/span\u0026gt;\n    global_var2 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \n\n    local1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;embedded_func\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Again, this doen\u0026apos;t affect func\u0026apos;s local1 variable.  It creates a \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# new local variable also called local1 instead.\u0026lt;/span\u0026gt;\n        local1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; local1\n\n    embedded_func() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Prints 5\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; local1    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Prints 4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;global_var = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change_global\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; global_var\n    global_var = global_var + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Currently there is no way to do the same for variables in enclosing \u0026lt;em\u0026gt;function\u0026lt;/em\u0026gt; scopes, but Python 3 introduces a new keyword, \u0026quot;\u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt;\u0026quot; which will act in a similar way to global, but for nested function scopes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;4.2.2 Resolution of names\u0026lt;/a\u0026gt; of the Python 3 documentation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the \u0026lt;strong\u0026gt;class body\u0026lt;/strong\u0026gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Especially, \u0026lt;strong\u0026gt;no\u0026lt;/strong\u0026gt; block statement, besides \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To demonstrate the peculiarities of the class body\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    y = x\n    x = x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# x is now a variable\u0026lt;/span\u0026gt;\n    z = x\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(self.x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 1\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 0, the global x\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(y)      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; NameError: global name \u0026apos;y\u0026apos; is not defined\u0026lt;/span\u0026gt;\n\ninst = X()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(inst.x, inst.y, inst.z, x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; (1, 0, 1, 0)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve\nto the class variable instead.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;One of the greater surprises to many newcomers to Python is that a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;[ i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) ]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;i\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The global really means the module scope; the main python module is the \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;; all imported modules are accessible through the \u0026lt;code\u0026gt;sys.modules\u0026lt;/code\u0026gt; variable; to get access to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; one can use \u0026lt;code\u0026gt;sys.modules[\u0026apos;__main__\u0026apos;]\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;import __main__\u0026lt;/code\u0026gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in \u0026lt;code\u0026gt;UnboundLocalError\u0026lt;/code\u0026gt;, which is a subclass of \u0026lt;code\u0026gt;NameError\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foobar\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# causes UnboundLocalError!\u0026lt;/span\u0026gt;\n    x += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# because assignment here makes x a local variable within the function\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# call the function\u0026lt;/span\u0026gt;\nfoobar()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foobar\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; x\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n    x += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\nfoobar() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This also is possible even if it was shadowed in enclosing scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\ny = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_closure\u0026lt;/span\u0026gt;():\n    x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n    y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;911\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# sees the global value\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x, y)\n        x += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; func\n\nfunc = make_closure()\nfunc()      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 5 911\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x, y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 6 13\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_closure\u0026lt;/span\u0026gt;():\n    value = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_next_value\u0026lt;/span\u0026gt;():\n        value[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; value[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; get_next_value\n\nget_next = make_closure()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(get_next()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(get_next()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# -\u0026amp;gt; 2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However in python 3, the \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; comes to rescue:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_closure\u0026lt;/span\u0026gt;():\n    value = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_next_value\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nonlocal\u0026lt;/span\u0026gt; value\n        value += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; value\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; get_next_value\n\nget_next = make_closure() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# identical behavior to the previous example.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; documentation\u0026lt;/a\u0026gt; says that\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;i.e. \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; target variable, in the \u0026lt;code\u0026gt;with\u0026lt;/code\u0026gt; clause, or as a function parameter).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was \u0026lt;code\u0026gt;__builtin__\u0026lt;/code\u0026gt; and in python 3 it is now called \u0026lt;code\u0026gt;builtins\u0026lt;/code\u0026gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; function with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; __builtin__\n\nprint3 = __builtin__.__dict__[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;print\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;from __future__ import print_function\u0026lt;/code\u0026gt; actually does not import the \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; function anywhere in Python 2 - instead it just disables the parsing rules for \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; statement in the current module, handling \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; like any other variable identifier, and thus allowing the \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; the function be looked up in the builtins.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A slightly more complete example of scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; __future__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; print_function  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# for python 2 support\u0026lt;/span\u0026gt;\n\nx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1. Global x:\u0026quot;\u0026lt;/span\u0026gt;, x)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    y = x\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;2. Enclosed y:\u0026quot;\u0026lt;/span\u0026gt;, y)\n    x = x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3. Enclosed x:\u0026quot;\u0026lt;/span\u0026gt;, x)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4. Enclosed self.x\u0026quot;\u0026lt;/span\u0026gt;, self.x)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;5. Global x\u0026quot;\u0026lt;/span\u0026gt;, x)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(y)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; NameError \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; e:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;6.\u0026quot;\u0026lt;/span\u0026gt;, e)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method_local_ref\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; UnboundLocalError \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; e:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;7.\u0026quot;\u0026lt;/span\u0026gt;, e)\n        x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# causing 7 because has same name\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;8. Local x\u0026quot;\u0026lt;/span\u0026gt;, x)\n\ninst = Test()\ninst.method()\ninst.method_local_ref()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;1. Global x: 100\n2. Enclosed y: 100\n3. Enclosed x: 101\n4. Enclosed self.x 101\n5. Global x 100\n6. global name \u0026apos;y\u0026apos; is not defined\n7. local variable \u0026apos;x\u0026apos; referenced before assignment\n8. Local x 200\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the \u0026apos;nonlocal\u0026apos; keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT: Here\u0026apos;s the \u0026lt;a href=\u0026quot;http://www.python.org/dev/peps/pep-3104/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP\u0026lt;/a\u0026gt; with more information on this.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python resolves your variables with -- generally -- three namespaces available.  \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;At any time during execution, there\n  are at least three nested scopes whose\n  namespaces are directly accessible:\n  the innermost scope, which is searched\n  first, contains the local names; the\n  namespaces of any enclosing functions,\n  which are searched starting with the\n  nearest enclosing scope; the middle\n  scope, searched next, contains the\n  current module\u0026apos;s global names; and the\n  outermost scope (searched last) is the\n  namespace containing built-in names.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;There are two functions: \u0026lt;code\u0026gt;globals\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;locals\u0026lt;/code\u0026gt; which show you the contents two of these namespaces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Namespaces are created by packages, modules, classes, object construction and functions.  There aren\u0026apos;t any other flavors of namespaces.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, the call to a function named \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; has to be resolved in the local name space or the global namespace.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Local in this case, is the body of the method function \u0026lt;code\u0026gt;Foo.spam\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Global is -- well -- global. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That\u0026apos;s it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are no other scopes.  The \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; statement (and other compound statements like \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;try\u0026lt;/code\u0026gt;) don\u0026apos;t create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inside a class definition, the names are part of the class namespace.  \u0026lt;code\u0026gt;code2\u0026lt;/code\u0026gt;, for instance, must be qualified by the class name.  Generally \u0026lt;code\u0026gt;Foo.code2\u0026lt;/code\u0026gt;.  However, \u0026lt;code\u0026gt;self.code2\u0026lt;/code\u0026gt; will also work because Python objects look at the containing class as a fall-back.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An object (an instance of a class) has instance variables.  These names are in the object\u0026apos;s namespace.  They must be qualified by the object.  (\u0026lt;code\u0026gt;variable.instance\u0026lt;/code\u0026gt;.)  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From within a class method, you have locals and globals.  You say \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt; to pick the instance as the namespace.  You\u0026apos;ll note that \u0026lt;code\u0026gt;self\u0026lt;/code\u0026gt; is an argument to every class member function, making it part of the local namespace.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Python Scope Rules\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/146359/python-scope\u0026quot;\u0026gt;Python Scope\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://showmedo.com/videos/video?name=2800020\u0026amp;amp;fromSeriesID=280\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Variable Scope\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Where is x found?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;x is not found as you haven\u0026apos;t defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;code2 (class members) aren\u0026apos;t visible to code inside methods of the same classyou would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Python is statically scoped, so if you pass spam to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;lambda is no different to def. If you have a lambda used inside a function, it\u0026apos;s the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fun1\u0026lt;/span\u0026gt;():\n    x= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fun2\u0026lt;/span\u0026gt;():\n        x= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fun3\u0026lt;/span\u0026gt;():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fun3()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fun2()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; fun1(), x\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Before nested_scopesin Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-importfun1 and fun2\u0026apos;s scopes are not visible to fun3, so S.Lott\u0026apos;s answer holds and you would get the global x:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Python name resolution\u0026lt;/a\u0026gt; only knows the following kinds of scope:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;builtins scope which provides the \u0026lt;a href=\u0026quot;https://docs.python.org/3/library/functions.html#built-in-funcs\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Builtin Functions\u0026lt;/a\u0026gt;, such as \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;zip\u0026lt;/code\u0026gt;,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;module\u0026lt;/em\u0026gt; global scope which is always the top-level of the current module,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;three user-defined scopes that can be nested into each other, namely\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;function\u0026lt;/em\u0026gt; closure scope, from any enclosing \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; block, \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; expression or comprehension.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;function\u0026lt;/em\u0026gt; local scope, inside a \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; block, \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; expression or comprehension,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;class\u0026lt;/em\u0026gt; scope, inside a \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; block.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Notably, other constructs such as \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;with\u0026lt;/code\u0026gt; statements do not have their own scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The scoping TLDR\u0026lt;/strong\u0026gt;: The \u0026lt;em\u0026gt;lookup\u0026lt;/em\u0026gt; of a name begins at the scope in which the name is used, then any enclosing scopes (excluding class scopes), to the module globals, and finally the builtins  the first match in this search order is used.\nThe \u0026lt;em\u0026gt;assignment\u0026lt;/em\u0026gt; to a scope is by default to the current scope  the special forms \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; must be used to \u0026lt;em\u0026gt;assign\u0026lt;/em\u0026gt; to a name from an outer scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Finally, comprehensions and generator expressions as well as \u0026lt;code\u0026gt;:=\u0026lt;/code\u0026gt; asignment expressions have one special rule when combined.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Nested Scopes and Name Resolution\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;These different scopes build a hierarchy, with builtins then global always forming the base, and closures, locals and class scope being nested as \u0026lt;em\u0026gt;lexically\u0026lt;/em\u0026gt; defined. That is, only the nesting in the source code matters, not for example the call stack.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;builtins are available without definition\u0026quot;\u0026lt;/span\u0026gt;)\n\nsome_global = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# global variables are at module scope\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer_function\u0026lt;/span\u0026gt;():\n    some_closure = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.1\u0026quot;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# locals and closure are defined the same, at function scope\u0026lt;/span\u0026gt;\n    some_local = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.2\u0026quot;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a variable becomes a closure if a nested scope uses it\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;InnerClass\u0026lt;/span\u0026gt;:\n         some_classvar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.3\u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# class variables exist *only* at class scope\u0026lt;/span\u0026gt;\n\n         \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;nested_function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n             some_local = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.2\u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# locals can replace outer names\u0026lt;/span\u0026gt;\n             \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(some_closure)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# closures are always readable\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; InnerClass\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Even though \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; creates a scope and may have nested classes, functions and comprehensions, the names of the \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; scope are not visible to enclosed scopes. This creates the following hierarchy:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; builtins           [\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;, ...]\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;globals\u0026lt;/span\u0026gt;            [some_global]\n   outer_function     [some_local, some_closure]\n     InnerClass         [some_classvar]\n     inner_function     [some_local]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Name resolution always starts at the \u0026lt;em\u0026gt;current scope\u0026lt;/em\u0026gt; in which a name is accessed, then goes up the hierarchy until a match is found. For example, looking up \u0026lt;code\u0026gt;some_local\u0026lt;/code\u0026gt; inside \u0026lt;code\u0026gt;outer_function\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;inner_function\u0026lt;/code\u0026gt; starts at the respective function - and immediately finds the \u0026lt;code\u0026gt;some_local\u0026lt;/code\u0026gt; defined in \u0026lt;code\u0026gt;outer_function\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;inner_function\u0026lt;/code\u0026gt;, respectively. When a name is not local, it is fetched from the nearest enclosing scope that defines it  looking up \u0026lt;code\u0026gt;some_closure\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; inside \u0026lt;code\u0026gt;inner_function\u0026lt;/code\u0026gt; searches until \u0026lt;code\u0026gt;outer_function\u0026lt;/code\u0026gt; and builtins, respectively.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Scope Declarations and Name Binding\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;By default, a name belongs to any scope in which it is bound to a value. Binding the same name again in an inner scope creates a new variable with the same name - for example, \u0026lt;code\u0026gt;some_local\u0026lt;/code\u0026gt; exists separately in both \u0026lt;code\u0026gt;outer_function\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;inner_function\u0026lt;/code\u0026gt;. As far as scoping is concerned, binding includes any statement that sets the value of a name  assignment statements, but also the iteration variable of a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop, or the name of a \u0026lt;code\u0026gt;with\u0026lt;/code\u0026gt; context manager. Notably, \u0026lt;code\u0026gt;del\u0026lt;/code\u0026gt; also counts as name binding.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When a name must refer to an outer variable \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; be bound in an inner scope, the name must be declared as not local. Separate declarations exists for the different kinds of enclosing scopes: \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; always refers to the nearest closure, and \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; always refers to a global name. Notably, \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; never refers to a global name and \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; ignores all closures of the same name. There is no declaration to refer to the builtin scope.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\nsome_global = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer_function\u0026lt;/span\u0026gt;():\n    some_closure = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.2\u0026quot;\u0026lt;/span\u0026gt;\n    some_global = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;this is ignored by a nested global declaration\u0026quot;\u0026lt;/span\u0026gt;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inner_function\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; some_global     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# declare variable from global scope\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nonlocal\u0026lt;/span\u0026gt; some_closure  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# declare variable from enclosing scope\u0026lt;/span\u0026gt;\n        message = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; bound by an inner scope\u0026quot;\u0026lt;/span\u0026gt;\n        some_global = some_global + message\n        some_closure = some_closure + message\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; inner_function\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Of note is that function local and \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; are resolved at compile time. A \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; name \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; exist in some outer scope. In contrast, a \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; name can be defined dynamically and may be added or removed from the global scope at any time.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Comprehensions and Assignment Expressions\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The scoping rules of list, set and dict comprehensions and generator expressions are \u0026lt;em\u0026gt;almost\u0026lt;/em\u0026gt; the same as for functions. Likewise, the scoping rules for assignment expressions are \u0026lt;em\u0026gt;almost\u0026lt;/em\u0026gt; the same as for regular name binding.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The scope of comprehensions and generator expressions is of the same kind as function scope. All names bound in the scope, namely the iteration variables, are locals or closures to the comprehensions/generator and nested scopes. All names, including iterables, are resolved using name resolution as applicable inside functions.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;some_global = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer_function\u0026lt;/span\u0026gt;():\n    some_closure = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;closure\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; [            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# new function-like scope started by comprehension\u0026lt;/span\u0026gt;\n        comp_local      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# names resolved using regular name resolution\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; comp_local  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# iteration targets are local\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;iterable\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; comp_local \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; some_global \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; comp_local \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; some_global\n    ]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;code\u0026gt;:=\u0026lt;/code\u0026gt; assignment expression works on the nearest function, class or global scope. Notably, if the target of an assignment expression has been declared \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; in the nearest scope, the assignment expression honors this like a regular assignment.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(some_global := \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer_function\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(some_closure := \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;closure\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;However, an assignment expression inside a comprehension/generator works on the nearest \u0026lt;em\u0026gt;enclosing scope\u0026lt;/em\u0026gt; of the comprehension/generator, not the scope of the comprehension/generator itself. When several comprehensions/generators are nested, the nearest function or global scope is used. Since the comprehension/generator scope can read closures and global variables, the assignment variable is readable in the comprehension as well. Assigning from a comprehension to a class scope is not valid.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(some_global := \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;global\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outer_function\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(some_closure := \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;closure\u0026quot;\u0026lt;/span\u0026gt;)\n    steps = [\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# v write to variable in containing scope\u0026lt;/span\u0026gt;\n        (some_closure := some_closure + comp_local)\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#                 ^ read from variable in containing scope\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; comp_local \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; some_global\n    ]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; some_closure, steps\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;While the iteration variable is local to the comprehension in which it is bound, the target of the assignment expression does not create a local variable and is read from the outer scope:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; builtins           [\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;, ...]\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;globals\u0026lt;/span\u0026gt;            [some_global]\n   outer_function     [some_closure]\n     \u0026amp;lt;listcomp\u0026amp;gt;         [comp_local]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Python, \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;any variable that is assigned a value is local to the block in which\n  the assignment appears.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;If a variable can\u0026apos;t be found in the current scope, please refer to the LEGB order.\u0026lt;/p\u0026gt;\n    "],"id":172,"title":"Short description of the scoping rules?","content":"\n                \n\u0026lt;p\u0026gt;What \u0026lt;strong\u0026gt;exactly\u0026lt;/strong\u0026gt; are the Python scoping rules?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I have some code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;code1\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;:\n   code2\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;spam\u0026lt;/span\u0026gt;.....\n      code3\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; code4..:\n       code5\n       x()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Where is \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; found?  Some possible choices include the list below:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;In the enclosing source file\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the class namespace\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the function definition\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the for loop index variable\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Inside the for loop\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Also there is the context during execution, when the function \u0026lt;code\u0026gt;spam\u0026lt;/code\u0026gt; is passed somewhere else. And maybe \u0026lt;a href=\u0026quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;lambda functions\u0026lt;/a\u0026gt; pass a bit differently?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There must be a simple reference or algorithm somewhere.  It\u0026apos;s a confusing world for intermediate Python programmers.\u0026lt;/p\u0026gt;\n    ","slug":"short-description-of-the-scoping-rules-1657384853121","postType":"QUESTION","createdAt":"2022-07-09T16:40:53.000Z","updatedAt":"2022-07-09T16:40:53.000Z","tags":[{"id":634,"name":"dynamic-languages","slug":"dynamic-languages","createdAt":"2022-07-09T16:40:53.000Z","updatedAt":"2022-07-09T16:40:53.000Z","Questions_Tags":{"questionId":172,"tagId":634}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"short-description-of-the-scoping-rules-1657384853121"},"buildId":"8pZkyd0U8-Y2Qf3QK9j7l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>