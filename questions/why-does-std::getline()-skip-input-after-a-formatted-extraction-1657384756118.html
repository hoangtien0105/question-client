<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-bf26e92d2540e305.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_buildManifest.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-does-std%3A%3Agetline()-skip-input-after-a-formatted-extraction-1657384756118#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118">Why does std::getline() skip input after a formatted extraction?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/istream">istream</a></div></div><div class="question-content mt-5">
                
<p>I have the following piece of code that prompts the user for their cat's age and name:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> age;
    std::string name;

    std::cin &gt;&gt; age;
    std::<span class="hljs-built_in">getline</span>(std::cin, name);
    
    <span class="hljs-keyword">if</span> (std::cin)
    {
        std::cout &lt;&lt; <span class="hljs-string">"My cat is "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years old and their name is "</span> &lt;&lt; name &lt;&lt; std::endl;
    }
}
</code></pre>
<p>What I find is that the age has been successfully read, but not the name. Here is the input and output:</p>
<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Input:

<span class="hljs-string">"10"</span>
<span class="hljs-string">"Mr. Whiskers"</span>

Output:

<span class="hljs-string">"My cat is 10 years old and their name is "</span>
</code></pre>
</blockquote>
<p>Why has the name been omitted from the output? I've given the proper input, but the code somehow ignores it. Why does this happen?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Why does this happen?</h1>
<p>This has little to do with the input you provided yourself but rather with the default behavior <code>std::getline()</code> has. When you provided your input for the age (<code>std::cin &gt;&gt; age</code>), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed <kbd>Enter</kbd>:</p>
<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-string">"10\n"</span>
</code></pre>
</blockquote>
<p>A newline is always appended to your input when you select <kbd>Enter</kbd> or <kbd>Return</kbd> when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into <code>age</code> until the next I/O operation where it is either discarded or read. When the flow of control reaches <code>std::getline()</code>, it will see <code>"\nMr. Whiskers"</code> and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of <code>std::getline()</code> is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.</p>
<h1>Solution</h1>
<h2><code>cin.ignore()</code></h2>
<p>To fix this, one option is to skip over the newline before doing <code>std::getline()</code>. You can do this by calling <code>std::cin.ignore()</code> after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cin &gt;&gt; age;
std::cin.<span class="hljs-built_in">ignore</span>();
std::<span class="hljs-built_in">getline</span>(std::cin, name);

<span class="hljs-built_in">assert</span>(std::cin); 
<span class="hljs-comment">// Success!</span>
</code></pre>
<h2><code>std::ws</code></h2>
<p>Another way to discard the whitespace is to use the <code>std::ws</code> function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cin &gt;&gt; age;
std::<span class="hljs-built_in">getline</span>(std::cin &gt;&gt; std::ws, name);

<span class="hljs-built_in">assert</span>(std::cin);
<span class="hljs-comment">// Success!</span>
</code></pre>
<p>The <code>std::cin &gt;&gt; std::ws</code> expression is executed before the <code>std::getline()</code> call (and after the <code>std::cin &gt;&gt; age</code> call) so that the newline character is removed.</p>
<p>The difference is that <code>ignore()</code> discards only 1 character (or N characters when given a parameter), and <code>std::ws</code> continues to ignore whitespace until it finds a non-whitespace character. So if you don't know how much whitespace will precede the next token you should consider using this.</p>
<h2>Match the operations</h2>
<p>When you run into an issue like this it's usually because you're combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That's what <code>operator&gt;&gt;()</code> is for. Unformatted input operations are anything other than that, like <code>std::getline()</code>, <code>std::cin.read()</code>, <code>std::cin.get()</code>, etc. Those functions don't care about the format of the input and only process raw text.</p>
<p>If you stick to using a single type of formatting then you can avoid this annoying issue:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Unformatted I/O</span>
std::string age, name;
std::<span class="hljs-built_in">getline</span>(std::cin, age);
std::<span class="hljs-built_in">getline</span>(std::cin, name);
</code></pre>
<p>or</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Formatted I/O</span>
<span class="hljs-type">int</span> age;
std::string firstName, lastName;
std::cin &gt;&gt; age &gt;&gt; firstName &gt;&gt; lastName;
</code></pre>
<p>If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Everything will be OK if you change your initial code in the following way:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span> ((cin &gt;&gt; name).<span class="hljs-built_in">get</span>() &amp;&amp; std::<span class="hljs-built_in">getline</span>(cin, state))
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This happens because an implicit line feed also known as newline character <code>\n</code> is appended to all user input from a terminal as it's telling the stream to start a new line. You can safely account for this by using <a href="http://en.cppreference.com/w/cpp/string/basic_string/getline" rel="nofollow noreferrer"><code>std::getline</code></a> when checking for multiple lines of user input. The default behavior of <code>std::getline</code> will read everything up to and including the newline character <code>\n</code> from the input stream object which is <code>std::cin</code> in this case.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name;
    std::string state;

    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">getline</span>(std::cin, name) &amp;&amp; std::<span class="hljs-built_in">getline</span>(std::cin, state))
    {
        std::cout &lt;&lt; <span class="hljs-string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" and you live in "</span> &lt;&lt; state;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<blockquote>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Input:

<span class="hljs-string">"John"</span>
<span class="hljs-string">"New Hampshire"</span>

Output:

<span class="hljs-string">"Your name is John and you live in New Hampshire"</span>
</code></pre>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since everyone above has answered the problem for input <code>10\nMr Whisker\n</code>, I would like to answer a different approach. all the solution above published the code for if the buffer is like <code>10\nMr Whisker\n</code>. but what if we don't know how user will behave giving input. the user might type <code>10\n\nMr. Whisker\n</code> or <code>10 \n\n Mr. whisker\n</code> by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">StringInput</span><span class="hljs-params">()</span>  <span class="hljs-comment">//returns null-terminated string</span>
</span>{
    string input;
    <span class="hljs-built_in">getline</span>(cin, input);
    <span class="hljs-keyword">while</span>(input.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>)<span class="hljs-comment">//keep taking input until valid string is taken</span>
    {
        <span class="hljs-built_in">getline</span>(cin, input);
    }
    <span class="hljs-keyword">return</span> input.<span class="hljs-built_in">c_str</span>();
}
</code></pre>
<p>So, the answer would be:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> age;
    std::string name;

    std::cin &gt;&gt; age;
    name = <span class="hljs-built_in">StringInput</span>();
    
    std::cout &lt;&lt; <span class="hljs-string">"My cat is "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years old and their name is "</span> &lt;&lt; name &lt;&lt; std::endl;
    
}
</code></pre>
<p><strong>Extra:</strong></p>
<p>If user inputs <code>a \n10\n \nmr. whiskey</code>;
To check whether <code>int</code> input is valid or not, this function can be used to check <code>int</code> input (program will have undefined behavior if <code>char</code> is given as input instead of <code>int</code>):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">
<span class="hljs-comment">//instead of "std::cin&gt;&gt;age;" use "get_untill_int(&amp;age);" in main function.</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_Untill_Int</span><span class="hljs-params">(<span class="hljs-type">int</span>* pInput)</span><span class="hljs-comment">//keep taking input untill input is `int or float`</span>
</span>{
    cin&gt;&gt; *pInput;
    <span class="hljs-comment">/*-----------check input validation----------------*/</span>
    <span class="hljs-keyword">while</span> (!cin) 
    {
        cin.<span class="hljs-built_in">clear</span>();
        cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">100</span>, <span class="hljs-string">'\n'</span>);
        cout&lt;&lt;<span class="hljs-string">"Invalid Input Type.\nEnter again: "</span>;
        cin &gt;&gt;*pInput;
    }
    <span class="hljs-comment">/*-----------checked input validation-------------*/</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called <a href="https://en.cppreference.com/w/cpp/io/manip/ws" rel="nofollow noreferrer">std::ws</a>. And then, you can simply use</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::<span class="hljs-built_in">getline</span>(std::cin &gt;&gt; std::ws, name);
</code></pre>
<p>That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.</p>
<p>If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use</p>
<p><code>.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code> to eliminate the wrong stuff.</p>
<p>Please read <a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore" rel="nofollow noreferrer">here</a></p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Why does this happen?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;This has little to do with the input you provided yourself but rather with the default behavior \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; has. When you provided your input for the age (\u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age\u0026lt;/code\u0026gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed \u0026lt;kbd\u0026gt;Enter\u0026lt;/kbd\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;10\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;A newline is always appended to your input when you select \u0026lt;kbd\u0026gt;Enter\u0026lt;/kbd\u0026gt; or \u0026lt;kbd\u0026gt;Return\u0026lt;/kbd\u0026gt; when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; until the next I/O operation where it is either discarded or read. When the flow of control reaches \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;, it will see \u0026lt;code\u0026gt;\u0026quot;\\nMr. Whiskers\u0026quot;\u0026lt;/code\u0026gt; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Solution\u0026lt;/h1\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;cin.ignore()\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;To fix this, one option is to skip over the newline before doing \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;. You can do this by calling \u0026lt;code\u0026gt;std::cin.ignore()\u0026lt;/code\u0026gt; after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age;\nstd::cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ignore\u0026lt;/span\u0026gt;();\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(std::cin); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Success!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Another way to discard the whitespace is to use the \u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age;\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin \u0026amp;gt;\u0026amp;gt; std::ws, name);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(std::cin);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Success!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; std::ws\u0026lt;/code\u0026gt; expression is executed before the \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt; call (and after the \u0026lt;code\u0026gt;std::cin \u0026amp;gt;\u0026amp;gt; age\u0026lt;/code\u0026gt; call) so that the newline character is removed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The difference is that \u0026lt;code\u0026gt;ignore()\u0026lt;/code\u0026gt; discards only 1 character (or N characters when given a parameter), and \u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; continues to ignore whitespace until it finds a non-whitespace character. So if you don\u0026apos;t know how much whitespace will precede the next token you should consider using this.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Match the operations\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When you run into an issue like this it\u0026apos;s usually because you\u0026apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That\u0026apos;s what \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;()\u0026lt;/code\u0026gt; is for. Unformatted input operations are anything other than that, like \u0026lt;code\u0026gt;std::getline()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::cin.read()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::cin.get()\u0026lt;/code\u0026gt;, etc. Those functions don\u0026apos;t care about the format of the input and only process raw text.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you stick to using a single type of formatting then you can avoid this annoying issue:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Unformatted I/O\u0026lt;/span\u0026gt;\nstd::string age, name;\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, age);\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Formatted I/O\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\nstd::string firstName, lastName;\nstd::cin \u0026amp;gt;\u0026amp;gt; age \u0026amp;gt;\u0026amp;gt; firstName \u0026amp;gt;\u0026amp;gt; lastName;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Everything will be OK if you change your initial code in the following way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((cin \u0026amp;gt;\u0026amp;gt; name).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;() \u0026amp;amp;\u0026amp;amp; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, state))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This happens because an implicit line feed also known as newline character \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; is appended to all user input from a terminal as it\u0026apos;s telling the stream to start a new line. You can safely account for this by using \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/string/basic_string/getline\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::getline\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when checking for multiple lines of user input. The default behavior of \u0026lt;code\u0026gt;std::getline\u0026lt;/code\u0026gt; will read everything up to and including the newline character \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; from the input stream object which is \u0026lt;code\u0026gt;std::cin\u0026lt;/code\u0026gt; in this case.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::string name;\n    std::string state;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name) \u0026amp;amp;\u0026amp;amp; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, state))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Your name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; and you live in \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; state;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Input:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;New Hampshire\u0026quot;\u0026lt;/span\u0026gt;\n\nOutput:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Your name is John and you live in New Hampshire\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since everyone above has answered the problem for input \u0026lt;code\u0026gt;10\\nMr Whisker\\n\u0026lt;/code\u0026gt;, I would like to answer a different approach. all the solution above published the code for if the buffer is like \u0026lt;code\u0026gt;10\\nMr Whisker\\n\u0026lt;/code\u0026gt;. but what if we don\u0026apos;t know how user will behave giving input. the user might type \u0026lt;code\u0026gt;10\\n\\nMr. Whisker\\n\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;10 \\n\\n Mr. whisker\\n\u0026lt;/code\u0026gt; by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringInput\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//returns null-terminated string\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    string input;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, input);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(input.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;()==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//keep taking input until valid string is taken\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(cin, input);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; input.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So, the answer would be:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n    std::string name;\n\n    std::cin \u0026amp;gt;\u0026amp;gt; age;\n    name = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringInput\u0026lt;/span\u0026gt;();\n    \n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; age \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; years old and their name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; std::endl;\n    \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Extra:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If user inputs \u0026lt;code\u0026gt;a \\n10\\n \\nmr. whiskey\u0026lt;/code\u0026gt;;\nTo check whether \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; input is valid or not, this function can be used to check \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; input (program will have undefined behavior if \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; is given as input instead of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//instead of \u0026quot;std::cin\u0026amp;gt;\u0026amp;gt;age;\u0026quot; use \u0026quot;get_untill_int(\u0026amp;amp;age);\u0026quot; in main function.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get_Untill_Int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* pInput)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//keep taking input untill input is `int or float`\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    cin\u0026amp;gt;\u0026amp;gt; *pInput;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------check input validation----------------*/\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!cin) \n    {\n        cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        cin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ignore\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n        cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Invalid Input Type.\\nEnter again: \u0026quot;\u0026lt;/span\u0026gt;;\n        cin \u0026amp;gt;\u0026amp;gt;*pInput;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------checked input validation-------------*/\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/io/manip/ws\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;std::ws\u0026lt;/a\u0026gt;. And then, you can simply use\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin \u0026amp;gt;\u0026amp;gt; std::ws, name);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;.ignore(std::numeric_limits\u0026amp;lt;std::streamsize\u0026amp;gt;::max(), \u0026apos;\\n\u0026apos;);\u0026lt;/code\u0026gt; to eliminate the wrong stuff.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please read \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/io/basic_istream/ignore\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":145,"title":"Why does std::getline() skip input after a formatted extraction?","content":"\n                \n\u0026lt;p\u0026gt;I have the following piece of code that prompts the user for their cat\u0026apos;s age and name:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n    std::string name;\n\n    std::cin \u0026amp;gt;\u0026amp;gt; age;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, name);\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::cin)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; age \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; years old and their name is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; name \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What I find is that the age has been successfully read, but not the name. Here is the input and output:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Input:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;10\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mr. Whiskers\u0026quot;\u0026lt;/span\u0026gt;\n\nOutput:\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My cat is 10 years old and their name is \u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Why has the name been omitted from the output? I\u0026apos;ve given the proper input, but the code somehow ignores it. Why does this happen?\u0026lt;/p\u0026gt;\n    ","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","postType":"QUESTION","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","tags":[{"id":528,"name":"istream","slug":"istream","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","Questions_Tags":{"questionId":145,"tagId":528}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},"buildId":"9SrIo1zGFc3tF1E8on9-4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>