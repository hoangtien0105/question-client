<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The &quot;N+1 selects problem&quot; is generally stated as a problem in Object-Relational mapping (ORM) discussions, and I understand that it has something to do with having to make a lot of database queries for something that seems simple in the object world.

Does anybody have a more detailed explanation of the problem?
    "/><meta property="og:title" content="What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)? | Solutions Checker"/><meta property="og:description" content="The &quot;N+1 selects problem&quot; is generally stated as a problem in Object-Relational mapping (ORM) discussions, and I understand that it has something to do with having to make a lot of database queries for something that seems simple in the object world.

Does anybody have a more detailed explanation of the problem?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)?","text":"The &quot;N+1 selects problem&quot; is generally stated as a problem in Object-Relational mapping (ORM) discussions, and I understand that it has something to do with having to make a lot of database queries for something that seems simple in the object world.\n\nDoes anybody have a more detailed explanation of the problem?\n    ","answerCount":19,"upVoteCount":500,"suggestedAnswer":[{"text":"Let&apos;s say you have a collection of Car objects (database rows), and each Car has a collection of Wheel objects (also rows).  In other words, Car  Wheel is a 1-to-many relationship.\nNow, let&apos;s say you need to iterate through all the cars, and for each one, print out a list of the wheels. The naive O/R implementation would do the following:\nSELECT * FROM Cars;\n\nAnd then for each Car:\nSELECT * FROM Wheel WHERE CarId = ?\n\nIn other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars.\nAlternatively, one could get all wheels and perform the lookups in memory:\nSELECT * FROM Wheel\n\nThis reduces the number of round-trips to the database from N+1 to 2.\nMost ORM tools give you several ways to prevent N+1 selects.\nReference: Java Persistence with Hibernate, chapter 13.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"What is the N+1 query problem\nThe N+1 query problem happens when the data access framework executed N additional SQL statements to fetch the same data that could have been retrieved when executing the primary SQL query.\nThe larger the value of N, the more queries will be executed, the larger the performance impact. And, unlike the slow query log that can help you find slow running queries, the N+1 issue wont be spot because each individual additional query runs sufficiently fast to not trigger the slow query log.\nThe problem is executing a large number of additional queries that, overall, take sufficient time to slow down response time.\nLets consider we have the following post and post_comments database tables which form a one-to-many table relationship:\n\nWe are going to create the following 4 post rows:\nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 1&apos;, 1)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 2&apos;, 2)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 3&apos;, 3)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 4&apos;, 4)\n\nAnd, we will also create 4 post_comment child records:\nINSERT INTO post_comment (post_id, review, id)\nVALUES (1, &apos;Excellent book to understand Java Persistence&apos;, 1)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (2, &apos;Must-read for Java developers&apos;, 2)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (3, &apos;Five Stars&apos;, 3)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (4, &apos;A great reference book&apos;, 4)\n\nN+1 query problem with plain SQL\nIf you select the post_comments using this SQL query:\nList&lt;Tuple&gt; comments = entityManager.createNativeQuery(&quot;&quot;&quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        pc.post_id AS postId\n    FROM post_comment pc\n    &quot;&quot;&quot;, Tuple.class)\n.getResultList();\n\nAnd, later, you decide to fetch the associated post title for each post_comment:\nfor (Tuple comment : comments) {\n    String review = (String) comment.get(&quot;review&quot;);\n    Long postId = ((Number) comment.get(&quot;postId&quot;)).longValue();\n \n    String postTitle = (String) entityManager.createNativeQuery(&quot;&quot;&quot;\n        SELECT\n            p.title\n        FROM post p\n        WHERE p.id = :postId\n        &quot;&quot;&quot;)\n    .setParameter(&quot;postId&quot;, postId)\n    .getSingleResult();\n \n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;,\n        postTitle,\n        review\n    );\n}\n\nYou are going to trigger the N+1 query issue because, instead of one SQL query, you executed 5 (1 + 4):\nSELECT\n    pc.id AS id,\n    pc.review AS review,\n    pc.post_id AS postId\nFROM post_comment pc\n \nSELECT p.title FROM post p WHERE p.id = 1\n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review\n-- &apos;Excellent book to understand Java Persistence&apos;\n    \nSELECT p.title FROM post p WHERE p.id = 2\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review\n-- &apos;Must-read for Java developers&apos;\n     \nSELECT p.title FROM post p WHERE p.id = 3\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review\n-- &apos;Five Stars&apos;\n     \nSELECT p.title FROM post p WHERE p.id = 4\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review\n-- &apos;A great reference book&apos;\n\nFixing the N+1 query issue is very easy. All you need to do is extract all the data you need in the original SQL query, like this:\nList&lt;Tuple&gt; comments = entityManager.createNativeQuery(&quot;&quot;&quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        p.title AS postTitle\n    FROM post_comment pc\n    JOIN post p ON pc.post_id = p.id\n    &quot;&quot;&quot;, Tuple.class)\n.getResultList();\n \nfor (Tuple comment : comments) {\n    String review = (String) comment.get(&quot;review&quot;);\n    String postTitle = (String) comment.get(&quot;postTitle&quot;);\n \n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;,\n        postTitle,\n        review\n    );\n}\n\nThis time, only one SQL query is executed to fetch all the data we are further interested in using.\nN+1 query problem with JPA and Hibernate\nWhen using JPA and Hibernate, there are several ways you can trigger the N+1 query issue, so its very important to know how you can avoid these situations.\nFor the next examples, consider we are mapping the post and post_comments tables to the following entities:\n\nThe JPA mappings look like this:\n@Entity(name = &quot;Post&quot;)\n@Table(name = &quot;post&quot;)\npublic class Post {\n \n    @Id\n    private Long id;\n \n    private String title;\n \n    //Getters and setters omitted for brevity\n}\n \n@Entity(name = &quot;PostComment&quot;)\n@Table(name = &quot;post_comment&quot;)\npublic class PostComment {\n \n    @Id\n    private Long id;\n \n    @ManyToOne\n    private Post post;\n \n    private String review;\n \n    //Getters and setters omitted for brevity\n}\n\nFetchType.EAGER\nUsing FetchType.EAGER either implicitly or explicitly for your JPA associations is a bad idea because you are going to fetch way more data that you need. More, the FetchType.EAGER strategy is also prone to N+1 query issues.\nUnfortunately, the @ManyToOne and @OneToOne associations use FetchType.EAGER by default, so if your mappings look like this:\n@ManyToOne\nprivate Post post;\n\nYou are using the FetchType.EAGER strategy, and, every time you forget to use JOIN FETCH when loading some PostComment entities with a JPQL or Criteria API query:\nList&lt;PostComment&gt; comments = entityManager\n.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nYou are going to trigger the N+1 query issue:\nSELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n\nNotice the additional SELECT statements that are executed because the post association has to be fetched prior to returning the List of PostComment entities.\nUnlike the default fetch plan, which you are using when calling the find method of the EntityManager, a JPQL or Criteria API query defines an explicit plan that Hibernate cannot change by injecting a JOIN FETCH automatically. So, you need to do it manually.\nIf you didn&apos;t need the post association at all, you are out of luck when using FetchType.EAGER because there is no way to avoid fetching it. That&apos;s why it&apos;s better to use FetchType.LAZY by default.\nBut, if you wanted to use post association, then you can use JOIN FETCH to avoid the N+1 query problem:\nList&lt;PostComment&gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\nThis time, Hibernate will execute a single SQL statement:\nSELECT \n    pc.id as id1_1_0_, \n    pc.post_id as post_id3_1_0_, \n    pc.review as review2_1_0_, \n    p.id as id1_0_1_, \n    p.title as title2_0_1_ \nFROM \n    post_comment pc \nINNER JOIN \n    post p ON pc.post_id = p.id\n    \n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review \n-- &apos;Excellent book to understand Java Persistence&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review \n-- &apos;Must-read for Java developers&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review \n-- &apos;Five Stars&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review \n-- &apos;A great reference book&apos;\n\nFetchType.LAZY\nEven if you switch to using FetchType.LAZY explicitly for all associations, you can still bump into the N+1 issue.\nThis time, the post association is mapped like this:\n@ManyToOne(fetch = FetchType.LAZY)\nprivate Post post;\n\nNow, when you fetch the PostComment entities:\nList&lt;PostComment&gt; comments = entityManager\n.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nHibernate will execute a single SQL statement:\nSELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n\nBut, if afterward, you are going to reference the lazy-loaded post association:\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\nYou will get the N+1 query issue:\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review \n-- &apos;Excellent book to understand Java Persistence&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review \n-- &apos;Must-read for Java developers&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review \n-- &apos;Five Stars&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review \n-- &apos;A great reference book&apos;\n\nBecause the post association is fetched lazily, a secondary SQL statement will be executed when accessing the lazy association in order to build the log message.\nAgain, the fix consists in adding a JOIN FETCH clause to the JPQL query:\nList&lt;PostComment&gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\nAnd, just like in the FetchType.EAGER example, this JPQL query will generate a single SQL statement.\n\nEven if you are using FetchType.LAZY and don&apos;t reference the child association of a bidirectional @OneToOne JPA relationship, you can still trigger the N+1 query issue.\n\nHow to automatically detect the N+1 query issue\nIf you want to automatically detect N+1 query issue in your data access layer, you can use the db-util open-source project.\nFirst, you need to add the following Maven dependency:\n&lt;dependency&gt;\n    &lt;groupId&gt;com.vladmihalcea&lt;/groupId&gt;\n    &lt;artifactId&gt;db-util&lt;/artifactId&gt;\n    &lt;version&gt;${db-util.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\nAfterward, you just have to use SQLStatementCountValidator utility to assert the underlying SQL statements that get generated:\nSQLStatementCountValidator.reset();\n\nList&lt;PostComment&gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nSQLStatementCountValidator.assertSelectCount(1);\n\nIn case you are using FetchType.EAGER and run the above test case, you will get the following test case failure:\nSELECT \n    pc.id as id1_1_, \n    pc.post_id as post_id3_1_, \n    pc.review as review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 1\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 2\n\n\n-- SQLStatementCountMismatchException: Expected 1 statement(s) but recorded 3 instead!\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"SELECT \ntable1.*\n, table2.*\nINNER JOIN table2 ON table2.SomeFkId = table1.SomeId\n\n\nThat gets you a result set where child rows in table2 cause duplication by returning the table1 results for each child row in table2.  O/R mappers should differentiate table1 instances based on a unique key field, then use all the table2 columns to populate child instances.\n\nSELECT table1.*\n\nSELECT table2.* WHERE SomeFkId = #\n\n\nThe N+1 is where the first query populates the primary object and the second query populates all the child objects for each of the unique primary objects returned.\n\nConsider:\n\nclass House\n{\n    int Id { get; set; }\n    string Address { get; set; }\n    Person[] Inhabitants { get; set; }\n}\n\nclass Person\n{\n    string Name { get; set; }\n    int HouseId { get; set; }\n}\n\n\nand tables with a similar structure.  A single query for the address &quot;22 Valley St&quot; may return:\n\nId Address      Name HouseId\n1  22 Valley St Dave 1\n1  22 Valley St John 1\n1  22 Valley St Mike 1\n\n\nThe O/RM should fill an instance of Home with ID=1, Address=&quot;22 Valley St&quot; and then populate the Inhabitants array with People instances for Dave, John, and Mike with just one query.\n\nA N+1 query for the same address used above would result in:\n\nId Address\n1  22 Valley St\n\n\nwith a separate query like\n\nSELECT * FROM Person WHERE HouseId = 1\n\n\nand resulting in a separate data set like\n\nName    HouseId\nDave    1\nJohn    1\nMike    1\n\n\nand the final result being the same as above with the single query.\n\nThe advantages to single select is that you get all the data up front which may be what you ultimately desire.  The advantages to N+1 is query complexity is reduced and you can use lazy loading where the child result sets are only loaded upon first request.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Supplier with a one-to-many relationship with Product. One Supplier has (supplies) many Products.\n\n***** Table: Supplier *****\n+-----+-------------------+\n| ID  |       NAME        |\n+-----+-------------------+\n|  1  |  Supplier Name 1  |\n|  2  |  Supplier Name 2  |\n|  3  |  Supplier Name 3  |\n|  4  |  Supplier Name 4  |\n+-----+-------------------+\n\n***** Table: Product *****\n+-----+-----------+--------------------+-------+------------+\n| ID  |   NAME    |     DESCRIPTION    | PRICE | SUPPLIERID |\n+-----+-----------+--------------------+-------+------------+\n|1    | Product 1 | Name for Product 1 |  2.0  |     1      |\n|2    | Product 2 | Name for Product 2 | 22.0  |     1      |\n|3    | Product 3 | Name for Product 3 | 30.0  |     2      |\n|4    | Product 4 | Name for Product 4 |  7.0  |     3      |\n+-----+-----------+--------------------+-------+------------+\n\n\nFactors:\n\n\nLazy mode for Supplier set to true (default)\nFetch mode used for querying on Product is Select\nFetch mode (default): Supplier information is accessed\nCaching does not play a role for the first time the\nSupplier is accessed\n\n\nFetch mode is Select Fetch (default)\n\n// It takes Select fetch mode as a default\nQuery query = session.createQuery( &quot;from Product p&quot;);\nList list = query.list();\n// Supplier is being accessed\ndisplayProductsListWithSupplierName(results);\n\nselect ... various field names ... from PRODUCT\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\n\n\nResult:\n\n\n1 select statement for Product\nN select statements for Supplier\n\n\nThis is N+1 select problem!\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I can&apos;t comment directly on other answers, because I don&apos;t have enough reputation. But it&apos;s worth noting that the problem essentially only arises because, historically, a lot of dbms have been quite poor when it comes to handling joins (MySQL being a particularly noteworthy example). So n+1 has, often, been notably faster than a join. And then there are ways to improve on n+1 but still without needing a join, which is what the original problem relates to.\n\nHowever, MySQL is now a lot better than it used to be when it comes to joins. When I first learned MySQL, I used joins a lot. Then I discovered how slow they are, and switched to n+1 in the code instead. But, recently, I&apos;ve been moving back to joins, because MySQL is now a heck of a lot better at handling them than it was when I first started using it.\n\nThese days, a simple join on a properly indexed set of tables is rarely a problem, in performance terms. And if it does give a performance hit, then the use of index hints often solves them.\n\nThis is discussed here by one of the MySQL development team:\n\nhttp://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html\n\nSo the summary is: If you&apos;ve been avoiding joins in the past because of MySQL&apos;s abysmal performance with them, then try again on the latest versions. You&apos;ll probably be pleasantly surprised.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"We moved away from the ORM in Django because of this problem. Basically, if you try and do\n\nfor p in person:\n    print p.car.colour\n\n\nThe ORM will happily return all people (typically as instances of a Person object), but then it will need to query the car table for each Person.\n\nA simple and very effective approach to this is something I call &quot;fanfolding&quot;, which avoids the nonsensical idea that query results from a relational database should map back to the original tables from which the query is composed.\n\nStep 1: Wide select\n\n  select * from people_car_colour; # this is a view or sql function\n\n\nThis will return something like\n\n  p.id | p.name | p.telno | car.id | car.type | car.colour\n  -----+--------+---------+--------+----------+-----------\n  2    | jones  | 2145    | 77     | ford     | red\n  2    | jones  | 2145    | 1012   | toyota   | blue\n  16   | ashby  | 124     | 99     | bmw      | yellow\n\n\nStep 2: Objectify\n\nSuck the results into a generic object creator with an argument to split after the third item. This means that &quot;jones&quot; object won&apos;t be made more than once.\n\nStep 3: Render\n\nfor p in people:\n    print p.car.colour # no more car queries\n\n\nSee this web page for an implementation of fanfolding for python.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s a good description of the problem\n\nNow that you understand the problem it can typically be avoided by doing a join fetch in your query. This basically forces the fetch of the lazy loaded object so the data is retrieved in one query instead of n+1 queries.  Hope this helps.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Suppose you have COMPANY and EMPLOYEE. COMPANY has many EMPLOYEES (i.e. EMPLOYEE has a field COMPANY_ID).\n\nIn some O/R configurations, when you have a mapped Company object and go to access its Employee objects, the O/R tool will do one select for every employee, wheras if you were just doing things in straight SQL, you could select * from employees where company_id = XX.  Thus N (# of employees) plus 1 (company)\n\nThis is how the initial versions of EJB Entity Beans worked.  I believe things like Hibernate have done away with this, but I&apos;m not too sure.  Most tools usually include info as to their strategy for mapping.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Check Ayende post on the topic: Combating the Select N + 1 Problem In NHibernate.\n\nBasically, when using an ORM like NHibernate or EntityFramework, if you have a one-to-many (master-detail) relationship, and want to list all the details per each master record, you have to make N + 1 query calls to the database, &quot;N&quot; being the number of master records: 1 query to get all the master records, and N queries, one per master record, to get all the details per master record.\n\nMore database query calls  more latency time  decreased application/database performance.\n\nHowever, ORMs have options to avoid this problem, mainly using JOINs.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"It is much faster to issue 1 query which returns 100 results than to issue 100 queries which each return 1 result.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"In my opinion the article written in Hibernate Pitfall: Why Relationships Should Be Lazy is exactly opposite of real N+1 issue is.\n\nIf you need correct explanation please refer Hibernate - Chapter 19: Improving Performance - Fetching Strategies\n\n\n  Select fetching (the default) is\n  extremely vulnerable to N+1 selects\n  problems, so we might want to enable\n  join fetching\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"The supplied link has a very simply example of the n + 1 problem. If you apply it to Hibernate it&apos;s basically talking about the same thing. When you query for an object, the entity is loaded but any associations (unless configured otherwise) will be lazy loaded. Hence one query for the root objects and another query to load the associations for each of these. 100 objects returned means one initial query and then 100 additional queries to get the association for each, n + 1.\n\nhttp://pramatr.com/2009/02/05/sql-n-1-selects-explained/\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"N+1 select issue is a pain, and it makes sense to detect such cases in unit tests.\nI have developed a small library for verifying the number of queries executed by a given test method or just an arbitrary block of code - JDBC Sniffer\n\nJust add a special JUnit rule to your test class and place annotation with expected number of queries on your test methods:\n\n@Rule\npublic final QueryCounter queryCounter = new QueryCounter();\n\n@Expectation(atMost = 3)\n@Test\npublic void testInvokingDatabase() {\n    // your JDBC or JPA code\n}\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"N+1 problem in Hibernate &amp; Spring Data JPA\nN+1 problem is a performance issue in Object Relational Mapping that fires multiple select queries (N+1 to be exact, where N = number of records in table) in database for a single select query at application layer. Hibernate &amp; Spring Data JPA provides multiple ways to catch and address this performance problem.\nWhat is N+1 Problem?\nTo understand N+1 problem, lets consider with a scenario. Lets say we have a collection of User objects mapped to DB_USER table in database, and each user has collection or Role mapped to DB_ROLE table using a joining table DB_USER_ROLE. At the ORM level a User has many to many relationship with Role.\nEntity Model\n@Entity\n@Table(name = &quot;DB_USER&quot;)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private String name;\n\n    @ManyToMany(fetch = FetchType.LAZY)                   \n    private Set&lt;Role&gt; roles;\n    //Getter and Setters \n }\n\n@Entity\n@Table(name = &quot;DB_ROLE&quot;)\npublic class Role {\n\n    @Id\n    @GeneratedValue(strategy= GenerationType.AUTO)\n    private Long id;\n\n    private String name;\n    //Getter and Setters\n }\n\nA user can have many roles. Roles are loaded Lazily. Now lets say we want to fetch all users from this table and print roles for each one. Very naive Object Relational implementation could be -\nUserRepository with findAllBy method\npublic interface UserRepository extends CrudRepository&lt;User, Long&gt; {\n\n    List&lt;User&gt; findAllBy();\n}\n\nThe equivalent SQL queries executed by ORM will be:\nFirst Get All User (1)\nSelect * from DB_USER;\n\nThen get roles for each user executed N times (where N is number of users)\nSelect * from DB_USER_ROLE where userid = &lt;userid&gt;;\n\nSo we need one select for User and N additional selects for fetching roles for each user, where N is total number of users. This is a classic N+1 problem in ORM.\nHow to identify it?\nHibernate provide tracing option that enables SQL logging in the console/logs. using logs you can easily see if hibernate is issuing N+1 queries for a given call.\nIf you see multiple entries for SQL for a given select query, then there are high chances that its due to N+1 problem.\nN+1 Resolution\nAt SQL level, what ORM needs to achieve to avoid N+1 is to fire a query that joins the two tables and get the combined results in single query.\nFetch Join SQL that retrieves everything (user and roles) in Single Query\nOR Plain SQL\nselect user0_.id, role2_.id, user0_.name, role2_.name, roles1_.user_id, roles1_.roles_id from db_user user0_ left outer join db_user_roles roles1_ on user0_.id=roles1_.user_id left outer join db_role role2_ on roles1_.roles_id=role2_.id\n\nHibernate &amp; Spring Data JPA provide mechanism to solve the N+1 ORM issue.\n1. Spring Data JPA Approach:\nIf we are using Spring Data JPA, then we have two options to achieve this - using EntityGraph or using select query with fetch join.\npublic interface UserRepository extends CrudRepository&lt;User, Long&gt; {\n\n    List&lt;User&gt; findAllBy();             \n\n    @Query(&quot;SELECT p FROM User p LEFT JOIN FETCH p.roles&quot;)  \n    List&lt;User&gt; findWithoutNPlusOne();\n\n    @EntityGraph(attributePaths = {&quot;roles&quot;})                \n    List&lt;User&gt; findAll();\n}\n\nN+1 queries are issued at database level using left join fetch, we resolve the N+1 problem using attributePaths, Spring Data JPA avoids N+1 problem\n2. Hibernate Approach:\nIf its pure Hibernate, then the following solutions will work.\nUsing HQL :\nfrom User u *join fetch* u.roles roles roles\n\nUsing Criteria API:\nCriteria criteria = session.createCriteria(User.class);\ncriteria.setFetchMode(&quot;roles&quot;, FetchMode.EAGER);\n\nAll these approaches work similar and they issue a similar database query with left join fetch\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"The issue as others have stated more elegantly is that you either have a Cartesian product of the OneToMany columns or you&apos;re doing N+1 Selects. Either possible gigantic resultset or chatty with the database, respectively.\n\nI&apos;m surprised this isn&apos;t mentioned but this how I have gotten around this issue... I make a semi-temporary ids table. I also do this when you have the IN () clause limitation. \n\nThis doesn&apos;t work for all cases (probably not even a majority) but it works particularly well if you have a lot of child objects such that the Cartesian product will get out of hand (ie lots of OneToMany columns the number of results will be a multiplication of the columns) and its more of a batch like job.\n\nFirst you insert your parent object ids as batch into an ids table.\nThis batch_id is something we generate in our app and hold onto.\n\nINSERT INTO temp_ids \n    (product_id, batch_id)\n    (SELECT p.product_id, ? \n    FROM product p ORDER BY p.product_id\n    LIMIT ? OFFSET ?);\n\n\nNow for each OneToMany column you just do a SELECT on the ids table INNER JOINing  the child table with a WHERE batch_id= (or vice versa). You just want to make sure you order by the id column as it will make merging result columns easier (otherwise you will need a HashMap/Table for the entire result set which may not be that bad).\n\nThen you just periodically clean the ids table.\n\nThis also works particularly well if the user selects say 100 or so distinct items for some sort of bulk processing. Put the 100 distinct ids in the temporary table.\n\nNow the number of queries you are doing is by the number of OneToMany columns.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Without going into tech stack implementation details, architecturally speaking there are at least two solutions to N + 1 Problem:\n\nHave Only 1 - big query - with Joins. This makes a lot of information be transported from the database to the application layer, especially if there are multiple child records. The typical result of a database is a set of rows, not graph of objects (there are solutions to that with different DB systems)\nHave Two(or more for more children needed to be joined) Queries - 1 for the parent and after you have them - query by IDs the children and map them. This will minimize data transfer between the DB and APP layers.\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Take Matt Solnit example, imagine that you define an association between Car and Wheels as LAZY and you need some Wheels fields. This means that after the first select, hibernate is going to do  &quot;Select * from Wheels where car_id = :id&quot; FOR EACH Car.\n\nThis makes the first select and more 1 select by each N car, that&apos;s why it&apos;s called n+1 problem.\n\nTo avoid this, make the association fetch as eager, so that hibernate loads data with a join.\n\nBut attention, if many times you don&apos;t access associated Wheels, it&apos;s better to keep it LAZY or change fetch type with Criteria.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"A generalisation of N+1\nThe N+1 problem is an ORM specific name of a problem where you move loops that could be reasonably executed on a server to the client. The generic problem isn&apos;t specific to ORMs, you can have it with any remote API. In this article, I&apos;ve shown how JDBC roundtrips are very costly, if you&apos;re calling an API N times instead of only 1 time. The difference in the example is whether you&apos;re calling the Oracle PL/SQL procedure:\n\ndbms_output.get_lines (call it once, receive N items)\ndbms_output.get_line (call it N times, receive 1 item each time)\n\nThey&apos;re logically equivalent, but due to the latency between server and client, you&apos;re adding N latency waits to your loop, instead of waiting only once.\nThe ORM case\nIn fact, the ORM-y N+1 problem isn&apos;t even ORM specific either, you can achieve it by running your own queries manually as well, e.g. when you do something like this in PL/SQL:\n-- This loop is executed once\nfor parent in (select * from parent) loop\n\n  -- This loop is executed N times\n  for child in (select * from child where parent_id = parent.id) loop\n    ...\n  end loop;\nend loop;\n\nIt would be much better to implement this using a join (in this case):\nfor rec in (\n  select *\n  from parent p\n  join child c on c.parent_id = p.id\n)\nloop\n  ...\nend loop;\n\nNow, the loop is executed only once, and the logic of the loop has been moved from the client (PL/SQL) to the server (SQL), which can even optimise it differently, e.g. by running a hash join (O(N)) rather than a nested loop join (O(N log N) with index)\nAuto-detecting N+1 problems\nIf you&apos;re using JDBC, you could use jOOQ as a JDBC proxy behind the scenes to auto-detect your N+1 problems. jOOQ&apos;s parser normalises your SQL queries and caches data about consecutive executions of parent and child queries. This even works if your queries aren&apos;t exactly the same, but semantically equivalent.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"N+1 SELECT problem is really hard to spot, especially in projects with large domain, to the moment when it starts degrading the performance. Even if the problem is fixed i.e. by adding eager loading, a further development may break the solution and/or introduce N+1 SELECT problem again in other places.\nI&apos;ve created open source library jplusone to address those problems in JPA based Spring Boot Java applications. The library provides two major features:\n\nGenerates reports correlating SQL statements with executions of JPA operations which triggered them and places in source code of your application which were involved in it\n\n2020-10-22 18:41:43.236 DEBUG 14913 --- [           main] c.a.j.core.report.ReportGenerator        :\n    ROOT\n        com.adgadev.jplusone.test.domain.bookshop.BookshopControllerTest.shouldGetBookDetailsLazily(BookshopControllerTest.java:65)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopController.getSampleBookUsingLazyLoading(BookshopController.java:31)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading [PROXY]\n            SESSION BOUNDARY\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:35)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.getName [PROXY]\n                    com.adgadev.jplusone.test.domain.bookshop.Author [FETCHING ENTITY]\n                        STATEMENT [READ]\n                            select [...] from\n                                author author0_\n                                left outer join genre genre1_ on author0_.genre_id=genre1_.id\n                            where\n                                author0_.id=1\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:36)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.countWrittenBooks(Author.java:53)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.books [FETCHING COLLECTION]\n                        STATEMENT [READ]\n                            select [...] from\n                                book books0_\n                            where\n                                books0_.author_id=1\n\n\nProvides API which allows to write tests checking how effectively your application is using JPA (i.e. assert amount of lazy loading operations )\n\n@SpringBootTest\nclass LazyLoadingTest {\n\n    @Autowired\n    private JPlusOneAssertionContext assertionContext;\n\n    @Autowired\n    private SampleService sampleService;\n\n    @Test\n    public void shouldBusinessCheckOperationAgainstJPlusOneAssertionRule() {\n        JPlusOneAssertionRule rule = JPlusOneAssertionRule\n                .within().lastSession()\n                .shouldBe().noImplicitOperations().exceptAnyOf(exclusions -&gt; exclusions\n                        .loadingEntity(Author.class).times(atMost(2))\n                        .loadingCollection(Author.class, &quot;books&quot;)\n                );\n\n        // trigger business operation which you wish to be asserted against the rule,\n        // i.e. calling a service or sending request to your API controller\n        sampleService.executeBusinessOperation();\n\n        rule.check(assertionContext);\n    }\n}\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-%22n%2B1-selects-problem%22-in-orm-(object-relational-mapping)-1657388055597#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-%22n+1-selects-problem%22-in-orm-(object-relational-mapping)-1657388055597">What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/orm">orm</a></div></div><div class="question-content mt-5">
                
<p>The "N+1 selects problem" is generally stated as a problem in Object-Relational mapping (ORM) discussions, and I understand that it has something to do with having to make a lot of database queries for something that seems simple in the object world.</p>

<p>Does anybody have a more detailed explanation of the problem?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let's say you have a collection of <code>Car</code> objects (database rows), and each <code>Car</code> has a collection of <code>Wheel</code> objects (also rows).  In other words, <code>Car</code>  <code>Wheel</code> is a 1-to-many relationship.</p>
<p>Now, let's say you need to iterate through all the cars, and for each one, print out a list of the wheels. The naive O/R implementation would do the following:</p>
<pre><code>SELECT * FROM Cars;
</code></pre>
<p>And then <strong>for each <code>Car</code>:</strong></p>
<pre><code>SELECT * FROM Wheel WHERE CarId = ?
</code></pre>
<p>In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars.</p>
<p>Alternatively, one could get all wheels and perform the lookups in memory:</p>
<pre><code>SELECT * FROM Wheel
</code></pre>
<p>This reduces the number of round-trips to the database from N+1 to 2.
Most ORM tools give you several ways to prevent N+1 selects.</p>
<p>Reference: <em><a href="http://www.manning.com/bauer2/" rel="noreferrer">Java Persistence with Hibernate</a></em>, chapter 13.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>What is the N+1 query problem</h2>
<p>The N+1 query problem happens when the data access framework executed N additional SQL statements to fetch the same data that could have been retrieved when executing the primary SQL query.</p>
<p>The larger the value of N, the more queries will be executed, the larger the performance impact. And, unlike the slow query log that can help you find slow running queries, the N+1 issue wont be spot because each individual additional query runs sufficiently fast to not trigger the slow query log.</p>
<p>The problem is executing a large number of additional queries that, overall, take sufficient time to slow down response time.</p>
<p>Lets consider we have the following post and post_comments database tables which form a one-to-many table relationship:</p>
<p><a href="https://i.stack.imgur.com/T1uWG.png" rel="noreferrer"><img src="https://i.stack.imgur.com/T1uWG.png" alt="The post and post_comments tables"></a></p>
<p>We are going to create the following 4 <code>post</code> rows:</p>
<pre><code>INSERT INTO post (title, id)
VALUES ('High-Performance Java Persistence - Part 1', 1)
 
INSERT INTO post (title, id)
VALUES ('High-Performance Java Persistence - Part 2', 2)
 
INSERT INTO post (title, id)
VALUES ('High-Performance Java Persistence - Part 3', 3)
 
INSERT INTO post (title, id)
VALUES ('High-Performance Java Persistence - Part 4', 4)
</code></pre>
<p>And, we will also create 4 <code>post_comment</code> child records:</p>
<pre><code>INSERT INTO post_comment (post_id, review, id)
VALUES (1, 'Excellent book to understand Java Persistence', 1)
 
INSERT INTO post_comment (post_id, review, id)
VALUES (2, 'Must-read for Java developers', 2)
 
INSERT INTO post_comment (post_id, review, id)
VALUES (3, 'Five Stars', 3)
 
INSERT INTO post_comment (post_id, review, id)
VALUES (4, 'A great reference book', 4)
</code></pre>
<h2>N+1 query problem with plain SQL</h2>
<p>If you select the <code>post_comments</code> using this SQL query:</p>
<pre><code>List&lt;Tuple&gt; comments = entityManager.createNativeQuery("""
    SELECT
        pc.id AS id,
        pc.review AS review,
        pc.post_id AS postId
    FROM post_comment pc
    """, Tuple.class)
.getResultList();
</code></pre>
<p>And, later, you decide to fetch the associated <code>post</code> <code>title</code> for each <code>post_comment</code>:</p>
<pre><code>for (Tuple comment : comments) {
    String review = (String) comment.get("review");
    Long postId = ((Number) comment.get("postId")).longValue();
 
    String postTitle = (String) entityManager.createNativeQuery("""
        SELECT
            p.title
        FROM post p
        WHERE p.id = :postId
        """)
    .setParameter("postId", postId)
    .getSingleResult();
 
    LOGGER.info(
        "The Post '{}' got this review '{}'",
        postTitle,
        review
    );
}
</code></pre>
<p>You are going to trigger the N+1 query issue because, instead of one SQL query, you executed 5 (1 + 4):</p>
<pre><code>SELECT
    pc.id AS id,
    pc.review AS review,
    pc.post_id AS postId
FROM post_comment pc
 
SELECT p.title FROM post p WHERE p.id = 1
-- The Post 'High-Performance Java Persistence - Part 1' got this review
-- 'Excellent book to understand Java Persistence'
    
SELECT p.title FROM post p WHERE p.id = 2
-- The Post 'High-Performance Java Persistence - Part 2' got this review
-- 'Must-read for Java developers'
     
SELECT p.title FROM post p WHERE p.id = 3
-- The Post 'High-Performance Java Persistence - Part 3' got this review
-- 'Five Stars'
     
SELECT p.title FROM post p WHERE p.id = 4
-- The Post 'High-Performance Java Persistence - Part 4' got this review
-- 'A great reference book'
</code></pre>
<p>Fixing the N+1 query issue is very easy. All you need to do is extract all the data you need in the original SQL query, like this:</p>
<pre><code>List&lt;Tuple&gt; comments = entityManager.createNativeQuery("""
    SELECT
        pc.id AS id,
        pc.review AS review,
        p.title AS postTitle
    FROM post_comment pc
    JOIN post p ON pc.post_id = p.id
    """, Tuple.class)
.getResultList();
 
for (Tuple comment : comments) {
    String review = (String) comment.get("review");
    String postTitle = (String) comment.get("postTitle");
 
    LOGGER.info(
        "The Post '{}' got this review '{}'",
        postTitle,
        review
    );
}
</code></pre>
<p>This time, only one SQL query is executed to fetch all the data we are further interested in using.</p>
<h2>N+1 query problem with JPA and Hibernate</h2>
<p>When using JPA and Hibernate, there are several ways you can trigger the N+1 query issue, so its very important to know how you can avoid these situations.</p>
<p>For the next examples, consider we are mapping the <code>post</code> and <code>post_comments</code> tables to the following entities:</p>
<p><a href="https://i.stack.imgur.com/rZJne.png" rel="noreferrer"><img src="https://i.stack.imgur.com/rZJne.png" alt="Post and PostComment entities"></a></p>
<p>The JPA mappings look like this:</p>
<pre><code>@Entity(name = "Post")
@Table(name = "post")
public class Post {
 
    @Id
    private Long id;
 
    private String title;
 
    //Getters and setters omitted for brevity
}
 
@Entity(name = "PostComment")
@Table(name = "post_comment")
public class PostComment {
 
    @Id
    private Long id;
 
    @ManyToOne
    private Post post;
 
    private String review;
 
    //Getters and setters omitted for brevity
}
</code></pre>
<h2><code>FetchType.EAGER</code></h2>
<p>Using <code>FetchType.EAGER</code> either implicitly or explicitly for your JPA associations is a bad idea because you are going to fetch way more data that you need. More, the <code>FetchType.EAGER</code> strategy is also prone to N+1 query issues.</p>
<p>Unfortunately, the <code>@ManyToOne</code> and <code>@OneToOne</code> associations use <code>FetchType.EAGER</code> by default, so if your mappings look like this:</p>
<pre><code>@ManyToOne
private Post post;
</code></pre>
<p>You are using the <code>FetchType.EAGER</code> strategy, and, every time you forget to use <code>JOIN FETCH</code> when loading some <code>PostComment</code> entities with a JPQL or Criteria API query:</p>
<pre><code>List&lt;PostComment&gt; comments = entityManager
.createQuery("""
    select pc
    from PostComment pc
    """, PostComment.class)
.getResultList();
</code></pre>
<p>You are going to trigger the N+1 query issue:</p>
<pre><code>SELECT 
    pc.id AS id1_1_, 
    pc.post_id AS post_id3_1_, 
    pc.review AS review2_1_ 
FROM 
    post_comment pc

SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4
</code></pre>
<p>Notice the additional SELECT statements that are executed because the <code>post</code> association has to be fetched prior to returning the <code>List</code> of <code>PostComment</code> entities.</p>
<p>Unlike the default fetch plan, which you are using when calling the <code>find</code> method of the <code>EntityManager</code>, a JPQL or Criteria API query defines an explicit plan that Hibernate cannot change by injecting a JOIN FETCH automatically. So, you need to do it manually.</p>
<p>If you didn't need the <code>post</code> association at all, you are out of luck when using <code>FetchType.EAGER</code> because there is no way to avoid fetching it. That's why it's better to use <code>FetchType.LAZY</code> by default.</p>
<p>But, if you wanted to use <code>post</code> association, then you can use <code>JOIN FETCH</code> to avoid the N+1 query problem:</p>
<pre><code>List&lt;PostComment&gt; comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    join fetch pc.post p
    """, PostComment.class)
.getResultList();

for(PostComment comment : comments) {
    LOGGER.info(
        "The Post '{}' got this review '{}'", 
        comment.getPost().getTitle(), 
        comment.getReview()
    );
}
</code></pre>
<p>This time, Hibernate will execute a single SQL statement:</p>
<pre><code>SELECT 
    pc.id as id1_1_0_, 
    pc.post_id as post_id3_1_0_, 
    pc.review as review2_1_0_, 
    p.id as id1_0_1_, 
    p.title as title2_0_1_ 
FROM 
    post_comment pc 
INNER JOIN 
    post p ON pc.post_id = p.id
    
-- The Post 'High-Performance Java Persistence - Part 1' got this review 
-- 'Excellent book to understand Java Persistence'

-- The Post 'High-Performance Java Persistence - Part 2' got this review 
-- 'Must-read for Java developers'

-- The Post 'High-Performance Java Persistence - Part 3' got this review 
-- 'Five Stars'

-- The Post 'High-Performance Java Persistence - Part 4' got this review 
-- 'A great reference book'
</code></pre>
<h2><code>FetchType.LAZY</code></h2>
<p>Even if you switch to using <code>FetchType.LAZY</code> explicitly for all associations, you can still bump into the N+1 issue.</p>
<p>This time, the <code>post</code> association is mapped like this:</p>
<pre><code>@ManyToOne(fetch = FetchType.LAZY)
private Post post;
</code></pre>
<p>Now, when you fetch the <code>PostComment</code> entities:</p>
<pre><code>List&lt;PostComment&gt; comments = entityManager
.createQuery("""
    select pc
    from PostComment pc
    """, PostComment.class)
.getResultList();
</code></pre>
<p>Hibernate will execute a single SQL statement:</p>
<pre><code>SELECT 
    pc.id AS id1_1_, 
    pc.post_id AS post_id3_1_, 
    pc.review AS review2_1_ 
FROM 
    post_comment pc
</code></pre>
<p>But, if afterward, you are going to reference the lazy-loaded <code>post</code> association:</p>
<pre><code>for(PostComment comment : comments) {
    LOGGER.info(
        "The Post '{}' got this review '{}'", 
        comment.getPost().getTitle(), 
        comment.getReview()
    );
}
</code></pre>
<p>You will get the N+1 query issue:</p>
<pre><code>SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1
-- The Post 'High-Performance Java Persistence - Part 1' got this review 
-- 'Excellent book to understand Java Persistence'

SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2
-- The Post 'High-Performance Java Persistence - Part 2' got this review 
-- 'Must-read for Java developers'

SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3
-- The Post 'High-Performance Java Persistence - Part 3' got this review 
-- 'Five Stars'

SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4
-- The Post 'High-Performance Java Persistence - Part 4' got this review 
-- 'A great reference book'
</code></pre>
<p>Because the <code>post</code> association is fetched lazily, a secondary SQL statement will be executed when accessing the lazy association in order to build the log message.</p>
<p>Again, the fix consists in adding a <code>JOIN FETCH</code> clause to the JPQL query:</p>
<pre><code>List&lt;PostComment&gt; comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    join fetch pc.post p
    """, PostComment.class)
.getResultList();

for(PostComment comment : comments) {
    LOGGER.info(
        "The Post '{}' got this review '{}'", 
        comment.getPost().getTitle(), 
        comment.getReview()
    );
}
</code></pre>
<p>And, just like in the <code>FetchType.EAGER</code> example, this JPQL query will generate a single SQL statement.</p>
<blockquote>
<p>Even if you are using <code>FetchType.LAZY</code> and don't reference the child association of a bidirectional <code>@OneToOne</code> JPA relationship, you can still trigger the N+1 query issue.</p>
</blockquote>
<h2>How to automatically detect the N+1 query issue</h2>
<p>If you want to automatically detect N+1 query issue in your data access layer, you can use the <a href="https://github.com/vladmihalcea/db-util" rel="noreferrer"><code>db-util</code></a> open-source project.</p>
<p>First, you need to add the following Maven dependency:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.vladmihalcea&lt;/groupId&gt;
    &lt;artifactId&gt;db-util&lt;/artifactId&gt;
    &lt;version&gt;${db-util.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Afterward, you just have to use <code>SQLStatementCountValidator</code> utility to assert the underlying SQL statements that get generated:</p>
<pre><code>SQLStatementCountValidator.reset();

List&lt;PostComment&gt; comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    """, PostComment.class)
.getResultList();

SQLStatementCountValidator.assertSelectCount(1);
</code></pre>
<p>In case you are using <code>FetchType.EAGER</code> and run the above test case, you will get the following test case failure:</p>
<pre><code>SELECT 
    pc.id as id1_1_, 
    pc.post_id as post_id3_1_, 
    pc.review as review2_1_ 
FROM 
    post_comment pc

SELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 1

SELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 2


-- SQLStatementCountMismatchException: Expected 1 statement(s) but recorded 3 instead!
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre><code>SELECT 
table1.*
, table2.*
INNER JOIN table2 ON table2.SomeFkId = table1.SomeId
</code></pre>

<p>That gets you a result set where child rows in table2 cause duplication by returning the table1 results for each child row in table2.  O/R mappers should differentiate table1 instances based on a unique key field, then use all the table2 columns to populate child instances.</p>

<pre><code>SELECT table1.*

SELECT table2.* WHERE SomeFkId = #
</code></pre>

<p>The N+1 is where the first query populates the primary object and the second query populates all the child objects for each of the unique primary objects returned.</p>

<p>Consider:</p>

<pre><code>class House
{
    int Id { get; set; }
    string Address { get; set; }
    Person[] Inhabitants { get; set; }
}

class Person
{
    string Name { get; set; }
    int HouseId { get; set; }
}
</code></pre>

<p>and tables with a similar structure.  A single query for the address "22 Valley St" may return:</p>

<pre><code>Id Address      Name HouseId
1  22 Valley St Dave 1
1  22 Valley St John 1
1  22 Valley St Mike 1
</code></pre>

<p>The O/RM should fill an instance of Home with ID=1, Address="22 Valley St" and then populate the Inhabitants array with People instances for Dave, John, and Mike with just one query.</p>

<p>A N+1 query for the same address used above would result in:</p>

<pre><code>Id Address
1  22 Valley St
</code></pre>

<p>with a separate query like</p>

<pre><code>SELECT * FROM Person WHERE HouseId = 1
</code></pre>

<p>and resulting in a separate data set like</p>

<pre><code>Name    HouseId
Dave    1
John    1
Mike    1
</code></pre>

<p>and the final result being the same as above with the single query.</p>

<p>The advantages to single select is that you get all the data up front which may be what you ultimately desire.  The advantages to N+1 is query complexity is reduced and you can use lazy loading where the child result sets are only loaded upon first request.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Supplier with a one-to-many relationship with Product. One Supplier has (supplies) many Products.</p>

<pre><code>***** Table: Supplier *****
+-----+-------------------+
| ID  |       NAME        |
+-----+-------------------+
|  1  |  Supplier Name 1  |
|  2  |  Supplier Name 2  |
|  3  |  Supplier Name 3  |
|  4  |  Supplier Name 4  |
+-----+-------------------+

***** Table: Product *****
+-----+-----------+--------------------+-------+------------+
| ID  |   NAME    |     DESCRIPTION    | PRICE | SUPPLIERID |
+-----+-----------+--------------------+-------+------------+
|1    | Product 1 | Name for Product 1 |  2.0  |     1      |
|2    | Product 2 | Name for Product 2 | 22.0  |     1      |
|3    | Product 3 | Name for Product 3 | 30.0  |     2      |
|4    | Product 4 | Name for Product 4 |  7.0  |     3      |
+-----+-----------+--------------------+-------+------------+
</code></pre>

<p>Factors:</p>

<ul>
<li><p>Lazy mode for Supplier set to true (default)</p></li>
<li><p>Fetch mode used for querying on Product is Select</p></li>
<li><p>Fetch mode (default): Supplier information is accessed</p></li>
<li><p>Caching does not play a role for the first time the</p></li>
<li><p>Supplier is accessed</p></li>
</ul>

<p>Fetch mode is Select Fetch (default)</p>

<pre><code>// It takes Select fetch mode as a default
Query query = session.createQuery( "from Product p");
List list = query.list();
// Supplier is being accessed
displayProductsListWithSupplierName(results);

select ... various field names ... from PRODUCT
select ... various field names ... from SUPPLIER where SUPPLIER.id=?
select ... various field names ... from SUPPLIER where SUPPLIER.id=?
select ... various field names ... from SUPPLIER where SUPPLIER.id=?
</code></pre>

<p>Result:</p>

<ul>
<li>1 select statement for Product</li>
<li>N select statements for Supplier</li>
</ul>

<p>This is N+1 select problem!</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I can't comment directly on other answers, because I don't have enough reputation. But it's worth noting that the problem essentially only arises because, historically, a lot of dbms have been quite poor when it comes to handling joins (MySQL being a particularly noteworthy example). So n+1 has, often, been notably faster than a join. And then there are ways to improve on n+1 but still without needing a join, which is what the original problem relates to.</p>

<p>However, MySQL is now a lot better than it used to be when it comes to joins. When I first learned MySQL, I used joins a lot. Then I discovered how slow they are, and switched to n+1 in the code instead. But, recently, I've been moving back to joins, because MySQL is now a heck of a lot better at handling them than it was when I first started using it.</p>

<p>These days, a simple join on a properly indexed set of tables is rarely a problem, in performance terms. And if it does give a performance hit, then the use of index hints often solves them.</p>

<p>This is discussed here by one of the MySQL development team:</p>

<p><a href="http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html" rel="noreferrer">http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html</a></p>

<p>So the summary is: If you've been avoiding joins in the past because of MySQL's abysmal performance with them, then try again on the latest versions. You'll probably be pleasantly surprised.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We moved away from the ORM in Django because of this problem. Basically, if you try and do</p>

<pre><code>for p in person:
    print p.car.colour
</code></pre>

<p>The ORM will happily return all people (typically as instances of a Person object), but then it will need to query the car table for each Person.</p>

<p>A simple and very effective approach to this is something I call "<strong>fanfolding</strong>", which avoids the nonsensical idea that query results from a relational database should map back to the original tables from which the query is composed.</p>

<p>Step 1: Wide select</p>

<pre><code>  select * from people_car_colour; # this is a view or sql function
</code></pre>

<p>This will return something like</p>

<pre><code>  p.id | p.name | p.telno | car.id | car.type | car.colour
  -----+--------+---------+--------+----------+-----------
  2    | jones  | 2145    | 77     | ford     | red
  2    | jones  | 2145    | 1012   | toyota   | blue
  16   | ashby  | 124     | 99     | bmw      | yellow
</code></pre>

<p>Step 2: Objectify</p>

<p>Suck the results into a generic object creator with an argument to split after the third item. This means that "jones" object won't be made more than once.</p>

<p>Step 3: Render</p>

<pre><code>for p in people:
    print p.car.colour # no more car queries
</code></pre>

<p>See <a href="http://campbell-lange.net/company/articles/dbwrapper/" rel="noreferrer">this web page</a> for an implementation of <strong>fanfolding</strong> for python.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://web.archive.org/web/20160310145416/http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy" rel="noreferrer">Here's a good description of the problem</a></p>

<p>Now that you understand the problem it can typically be avoided by doing a join fetch in your query. This basically forces the fetch of the lazy loaded object so the data is retrieved in one query instead of n+1 queries.  Hope this helps.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Suppose you have COMPANY and EMPLOYEE. COMPANY has many EMPLOYEES (i.e. EMPLOYEE has a field COMPANY_ID).</p>

<p>In some O/R configurations, when you have a mapped Company object and go to access its Employee objects, the O/R tool will do one select for every employee, wheras if you were just doing things in straight SQL, you could <code>select * from employees where company_id = XX</code>.  Thus N (# of employees) plus 1 (company)</p>

<p>This is how the initial versions of EJB Entity Beans worked.  I believe things like Hibernate have done away with this, but I'm not too sure.  Most tools usually include info as to their strategy for mapping.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Check Ayende post on the topic: <a href="http://ayende.com/blog/1328/combating-the-select-n-1-problem-in-nhibernate" rel="nofollow noreferrer">Combating the Select N + 1 Problem In NHibernate</a>.</p>

<p>Basically, when using an ORM like NHibernate or EntityFramework, if you have a one-to-many (master-detail) relationship, and want to list all the details per each master record, you have to make N + 1 query calls to the database, "N" being the number of master records: 1 query to get all the master records, and N queries, one per master record, to get all the details per master record.</p>

<p>More database query calls  more latency time  decreased application/database performance.</p>

<p>However, ORMs have options to avoid this problem, mainly using JOINs.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is much faster to issue 1 query which returns 100 results than to issue 100 queries which each return 1 result.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In my opinion the article written in <a href="http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy" rel="noreferrer">Hibernate Pitfall: Why Relationships Should Be Lazy</a> is exactly opposite of real N+1 issue is.</p>

<p>If you need correct explanation please refer <a href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-fetching" rel="noreferrer">Hibernate - Chapter 19: Improving Performance - Fetching Strategies</a></p>

<blockquote>
  <p>Select fetching (the default) is
  extremely vulnerable to N+1 selects
  problems, so we might want to enable
  join fetching</p>
</blockquote>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The supplied link has a very simply example of the n + 1 problem. If you apply it to Hibernate it's basically talking about the same thing. When you query for an object, the entity is loaded but any associations (unless configured otherwise) will be lazy loaded. Hence one query for the root objects and another query to load the associations for each of these. 100 objects returned means one initial query and then 100 additional queries to get the association for each, n + 1.</p>

<p><a href="http://pramatr.com/2009/02/05/sql-n-1-selects-explained/" rel="noreferrer">http://pramatr.com/2009/02/05/sql-n-1-selects-explained/</a></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>N+1 select issue is a pain, and it makes sense to detect such cases in unit tests.
I have developed a small library for verifying the number of queries executed by a given test method or just an arbitrary block of code - <a href="https://github.com/bedrin/jdbc-sniffer" rel="noreferrer">JDBC Sniffer</a></p>

<p>Just add a special JUnit rule to your test class and place annotation with expected number of queries on your test methods:</p>

<pre><code>@Rule
public final QueryCounter queryCounter = new QueryCounter();

@Expectation(atMost = 3)
@Test
public void testInvokingDatabase() {
    // your JDBC or JPA code
}
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>N+1 problem in Hibernate &amp; Spring Data JPA</strong></p>
<p>N+1 problem is a performance issue in Object Relational Mapping that fires multiple select queries (N+1 to be exact, where N = number of records in table) in database for a single select query at application layer. Hibernate &amp; Spring Data JPA provides multiple ways to catch and address this performance problem.</p>
<p><strong>What is N+1 Problem?</strong></p>
<p>To understand N+1 problem, lets consider with a scenario. Lets say we have a collection of <em>User</em> objects mapped to <em>DB_USER</em> table in database, and each user has collection or <em>Role</em> mapped to <em>DB_ROLE</em> table using a joining table <em>DB_USER_ROLE</em>. At the ORM level a <strong>User</strong> has <strong>many to many</strong> relationship with <strong>Role</strong>.</p>
<pre><code>Entity Model
@Entity
@Table(name = "DB_USER")
public class User {

    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String name;

    @ManyToMany(fetch = FetchType.LAZY)                   
    private Set&lt;Role&gt; roles;
    //Getter and Setters 
 }

@Entity
@Table(name = "DB_ROLE")
public class Role {

    @Id
    @GeneratedValue(strategy= GenerationType.AUTO)
    private Long id;

    private String name;
    //Getter and Setters
 }
</code></pre>
<p><strong>A user can have many roles. Roles are loaded Lazily.</strong> Now lets say we want to <em>fetch all users from this table and print roles for each one</em>. Very naive Object Relational implementation could be -
<strong>UserRepository</strong> with <strong>findAllBy</strong> method</p>
<pre><code>public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

    List&lt;User&gt; findAllBy();
}
</code></pre>
<p><strong>The equivalent SQL queries executed by ORM will be:</strong></p>
<p>First Get <strong>All User</strong> (1)</p>
<pre><code>Select * from DB_USER;
</code></pre>
<p>Then get <strong>roles for each user</strong> executed N times (where N is number of users)</p>
<pre><code>Select * from DB_USER_ROLE where userid = &lt;userid&gt;;
</code></pre>
<p>So we need <strong>one select for User</strong> and <strong>N additional selects for fetching roles for each user</strong>, where <em>N is total number of users</em>. <em><strong>This is a classic N+1 problem in ORM</strong></em>.</p>
<p><strong>How to identify it?</strong></p>
<p>Hibernate provide tracing option that enables SQL logging in the console/logs. <em><strong>using logs you can easily see if hibernate is issuing N+1 queries for a given call</strong></em>.</p>
<p>If you see multiple entries for SQL for a given select query, then there are high chances that its due to N+1 problem.</p>
<p><strong>N+1 Resolution</strong></p>
<p><strong>At SQL level</strong>, what ORM needs to achieve to avoid N+1 is to <em>fire a query that joins the two tables and get the combined results in single query</em>.</p>
<p><em><strong>Fetch Join SQL that retrieves everything (user and roles) in Single Query</strong></em></p>
<p><strong>OR Plain SQL</strong></p>
<pre><code>select user0_.id, role2_.id, user0_.name, role2_.name, roles1_.user_id, roles1_.roles_id from db_user user0_ left outer join db_user_roles roles1_ on user0_.id=roles1_.user_id left outer join db_role role2_ on roles1_.roles_id=role2_.id
</code></pre>
<p><strong>Hibernate &amp; Spring Data JPA provide mechanism to solve the N+1 ORM issue.</strong></p>
<p><strong>1. Spring Data JPA Approach:</strong></p>
<p>If we are using Spring Data JPA, then we have two options to achieve this - using <em><strong>EntityGraph</strong></em> or using <em><strong>select query with fetch join.</strong></em></p>
<pre><code>public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

    List&lt;User&gt; findAllBy();             

    @Query("SELECT p FROM User p LEFT JOIN FETCH p.roles")  
    List&lt;User&gt; findWithoutNPlusOne();

    @EntityGraph(attributePaths = {"roles"})                
    List&lt;User&gt; findAll();
}
</code></pre>
<p>N+1 queries are issued at database level using left join fetch, we resolve the N+1 problem using attributePaths, Spring Data JPA avoids N+1 problem</p>
<p><strong>2. Hibernate Approach:</strong></p>
<p>If its pure Hibernate, then the following solutions will work.</p>
<p>Using <strong>HQL</strong> :</p>
<pre><code>from User u *join fetch* u.roles roles roles
</code></pre>
<p>Using <strong>Criteria</strong> API:</p>
<pre><code>Criteria criteria = session.createCriteria(User.class);
criteria.setFetchMode("roles", FetchMode.EAGER);
</code></pre>
<p>All these approaches work similar and they issue a similar database query with left join fetch</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The issue as others have stated more elegantly is that you either have a Cartesian product of the OneToMany columns or you're doing N+1 Selects. Either possible gigantic resultset or chatty with the database, respectively.</p>

<p>I'm surprised this isn't mentioned but this how I have gotten around this issue... <strong>I make a semi-temporary ids table</strong>. <a href="https://stackoverflow.com/a/11119642/318174">I also do this when you have the <code>IN ()</code> clause limitation</a>. </p>

<p>This doesn't work for all cases (probably not even a majority) but it works particularly well if you have a lot of child objects such that the Cartesian product will get out of hand (ie lots of <code>OneToMany</code> columns the number of results will be a multiplication of the columns) and its more of a batch like job.</p>

<p>First you insert your parent object ids as batch into an ids table.
This batch_id is something we generate in our app and hold onto.</p>

<pre><code>INSERT INTO temp_ids 
    (product_id, batch_id)
    (SELECT p.product_id, ? 
    FROM product p ORDER BY p.product_id
    LIMIT ? OFFSET ?);
</code></pre>

<p>Now for each <code>OneToMany</code> column you just do a <code>SELECT</code> on the ids table <code>INNER JOIN</code>ing  the child table with a <code>WHERE batch_id=</code> (or vice versa). You just want to make sure you order by the id column as it will make merging result columns easier (otherwise you will need a HashMap/Table for the entire result set which may not be that bad).</p>

<p>Then you just periodically clean the ids table.</p>

<p>This also works particularly well if the user selects say 100 or so distinct items for some sort of bulk processing. Put the 100 distinct ids in the temporary table.</p>

<p>Now the number of queries you are doing is by the number of OneToMany columns.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Without going into tech stack implementation details, architecturally speaking there are at least two solutions to N + 1 Problem:</p>
<ul>
<li>Have Only 1 - big query - with Joins. This makes a lot of information be transported from the database to the application layer, especially if there are multiple child records. The typical result of a database is a set of rows, not graph of objects (there are solutions to that with different DB systems)</li>
<li>Have Two(or more for more children needed to be joined) Queries - 1 for the parent and after you have them - query by IDs the children and map them. This will minimize data transfer between the DB and APP layers.</li>
</ul>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Take Matt Solnit example, imagine that you define an association between Car and Wheels as LAZY and you need some Wheels fields. This means that after the first select, hibernate is going to do  "Select * from Wheels where car_id = :id" FOR EACH Car.</p>

<p>This makes the first select and more 1 select by each N car, that's why it's called n+1 problem.</p>

<p>To avoid this, make the association fetch as eager, so that hibernate loads data with a join.</p>

<p>But attention, if many times you don't access associated Wheels, it's better to keep it LAZY or change fetch type with Criteria.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>A generalisation of N+1</h3>
<p>The N+1 problem is an ORM specific name of a problem where you move loops that could be reasonably executed on a server to the client. The generic problem isn't specific to ORMs, you can have it with any remote API. <a href="https://blog.jooq.org/the-cost-of-jdbc-server-roundtrips/" rel="nofollow noreferrer">In this article, I've shown how JDBC roundtrips are very costly</a>, if you're calling an API N times instead of only 1 time. The difference in the example is whether you're calling the Oracle PL/SQL procedure:</p>
<ul>
<li><code>dbms_output.get_lines</code> (call it once, receive N items)</li>
<li><code>dbms_output.get_line</code> (call it N times, receive 1 item each time)</li>
</ul>
<p>They're logically equivalent, but due to the latency between server and client, you're adding N latency waits to your loop, instead of waiting only once.</p>
<h3>The ORM case</h3>
<p>In fact, the ORM-y N+1 problem isn't even ORM specific either, you can achieve it by running your own queries manually as well, e.g. when you do something like this in PL/SQL:</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-comment">-- This loop is executed once</span>
<span class="hljs-keyword">for</span> parent <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> parent) loop

  <span class="hljs-comment">-- This loop is executed N times</span>
  <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> child <span class="hljs-keyword">where</span> parent_id <span class="hljs-operator">=</span> parent.id) loop
    ...
  <span class="hljs-keyword">end</span> loop;
<span class="hljs-keyword">end</span> loop;
</code></pre>
<p>It would be much better to implement this using a join (in this case):</p>
<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> (
  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">from</span> parent p
  <span class="hljs-keyword">join</span> child c <span class="hljs-keyword">on</span> c.parent_id <span class="hljs-operator">=</span> p.id
)
loop
  ...
<span class="hljs-keyword">end</span> loop;
</code></pre>
<p>Now, the loop is executed only once, and the logic of the loop has been moved from the client (PL/SQL) to the server (SQL), which can even optimise it differently, e.g. by running a hash join (<code>O(N)</code>) rather than a nested loop join (<code>O(N log N)</code> with index)</p>
<h3>Auto-detecting N+1 problems</h3>
<p>If you're using JDBC, <a href="https://blog.jooq.org/using-jooqs-diagnosticsconnection-to-detect-n1-queries/" rel="nofollow noreferrer">you could use jOOQ as a JDBC proxy behind the scenes to auto-detect your N+1 problems</a>. jOOQ's parser normalises your SQL queries and caches data about consecutive executions of parent and child queries. This even works if your queries aren't exactly the same, but semantically equivalent.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>N+1 SELECT problem is really hard to spot, especially in projects with large domain, to the moment when it starts degrading the performance. Even if the problem is fixed i.e. by adding eager loading, a further development may break the solution and/or introduce N+1 SELECT problem again in other places.</p>
<p>I've created open source library <a href="https://github.com/adgadev/jplusone" rel="nofollow noreferrer">jplusone</a> to address those problems in JPA based Spring Boot Java applications. The library provides two major features:</p>
<ol>
<li>Generates reports correlating SQL statements with executions of JPA operations which triggered them and places in source code of your application which were involved in it</li>
</ol>
<pre>2020-10-22 18:41:43.236 DEBUG 14913 --- [           main] c.a.j.core.report.ReportGenerator        :
    ROOT
        com.adgadev.jplusone.test.domain.bookshop.BookshopControllerTest.shouldGetBookDetailsLazily(BookshopControllerTest.java:65)
        com.adgadev.jplusone.test.domain.bookshop.BookshopController.getSampleBookUsingLazyLoading(BookshopController.java:31)
        com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading [PROXY]
            SESSION BOUNDARY
                OPERATION [IMPLICIT]
                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:35)
                    com.adgadev.jplusone.test.domain.bookshop.Author.getName [PROXY]
                    com.adgadev.jplusone.test.domain.bookshop.Author [FETCHING ENTITY]
                        STATEMENT [READ]
                            select [...] from
                                author author0_
                                left outer join genre genre1_ on author0_.genre_id=genre1_.id
                            where
                                author0_.id=1
                OPERATION [IMPLICIT]
                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:36)
                    com.adgadev.jplusone.test.domain.bookshop.Author.countWrittenBooks(Author.java:53)
                    com.adgadev.jplusone.test.domain.bookshop.Author.books [FETCHING COLLECTION]
                        STATEMENT [READ]
                            select [...] from
                                book books0_
                            where
                                books0_.author_id=1
</pre>
<ol start="2">
<li>Provides API which allows to write tests checking how effectively your application is using JPA (i.e. assert amount of lazy loading operations )</li>
</ol>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyLoadingTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> JPlusOneAssertionContext assertionContext;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SampleService sampleService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldBusinessCheckOperationAgainstJPlusOneAssertionRule</span><span class="hljs-params">()</span> {
        <span class="hljs-type">JPlusOneAssertionRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> JPlusOneAssertionRule
                .within().lastSession()
                .shouldBe().noImplicitOperations().exceptAnyOf(exclusions -&gt; exclusions
                        .loadingEntity(Author.class).times(atMost(<span class="hljs-number">2</span>))
                        .loadingCollection(Author.class, <span class="hljs-string">"books"</span>)
                );

        <span class="hljs-comment">// trigger business operation which you wish to be asserted against the rule,</span>
        <span class="hljs-comment">// i.e. calling a service or sending request to your API controller</span>
        sampleService.executeBusinessOperation();

        rule.check(assertionContext);
    }
}
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Let\u0026apos;s say you have a collection of \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; objects (database rows), and each \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; has a collection of \u0026lt;code\u0026gt;Wheel\u0026lt;/code\u0026gt; objects (also rows).  In other words, \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Wheel\u0026lt;/code\u0026gt; is a 1-to-many relationship.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, let\u0026apos;s say you need to iterate through all the cars, and for each one, print out a list of the wheels. The naive O/R implementation would do the following:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT * FROM Cars;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And then \u0026lt;strong\u0026gt;for each \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT * FROM Wheel WHERE CarId = ?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, one could get all wheels and perform the lookups in memory:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT * FROM Wheel\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This reduces the number of round-trips to the database from N+1 to 2.\nMost ORM tools give you several ways to prevent N+1 selects.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Reference: \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://www.manning.com/bauer2/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java Persistence with Hibernate\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;, chapter 13.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;What is the N+1 query problem\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The N+1 query problem happens when the data access framework executed N additional SQL statements to fetch the same data that could have been retrieved when executing the primary SQL query.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The larger the value of N, the more queries will be executed, the larger the performance impact. And, unlike the slow query log that can help you find slow running queries, the N+1 issue wont be spot because each individual additional query runs sufficiently fast to not trigger the slow query log.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The problem is executing a large number of additional queries that, overall, take sufficient time to slow down response time.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Lets consider we have the following post and post_comments database tables which form a one-to-many table relationship:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/T1uWG.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/T1uWG.png\u0026quot; alt=\u0026quot;The post and post_comments tables\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We are going to create the following 4 \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; rows:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;INSERT INTO post (title, id)\nVALUES (\u0026apos;High-Performance Java Persistence - Part 1\u0026apos;, 1)\n \nINSERT INTO post (title, id)\nVALUES (\u0026apos;High-Performance Java Persistence - Part 2\u0026apos;, 2)\n \nINSERT INTO post (title, id)\nVALUES (\u0026apos;High-Performance Java Persistence - Part 3\u0026apos;, 3)\n \nINSERT INTO post (title, id)\nVALUES (\u0026apos;High-Performance Java Persistence - Part 4\u0026apos;, 4)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And, we will also create 4 \u0026lt;code\u0026gt;post_comment\u0026lt;/code\u0026gt; child records:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;INSERT INTO post_comment (post_id, review, id)\nVALUES (1, \u0026apos;Excellent book to understand Java Persistence\u0026apos;, 1)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (2, \u0026apos;Must-read for Java developers\u0026apos;, 2)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (3, \u0026apos;Five Stars\u0026apos;, 3)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (4, \u0026apos;A great reference book\u0026apos;, 4)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;N+1 query problem with plain SQL\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If you select the \u0026lt;code\u0026gt;post_comments\u0026lt;/code\u0026gt; using this SQL query:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;Tuple\u0026amp;gt; comments = entityManager.createNativeQuery(\u0026quot;\u0026quot;\u0026quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        pc.post_id AS postId\n    FROM post_comment pc\n    \u0026quot;\u0026quot;\u0026quot;, Tuple.class)\n.getResultList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And, later, you decide to fetch the associated \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;title\u0026lt;/code\u0026gt; for each \u0026lt;code\u0026gt;post_comment\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for (Tuple comment : comments) {\n    String review = (String) comment.get(\u0026quot;review\u0026quot;);\n    Long postId = ((Number) comment.get(\u0026quot;postId\u0026quot;)).longValue();\n \n    String postTitle = (String) entityManager.createNativeQuery(\u0026quot;\u0026quot;\u0026quot;\n        SELECT\n            p.title\n        FROM post p\n        WHERE p.id = :postId\n        \u0026quot;\u0026quot;\u0026quot;)\n    .setParameter(\u0026quot;postId\u0026quot;, postId)\n    .getSingleResult();\n \n    LOGGER.info(\n        \u0026quot;The Post \u0026apos;{}\u0026apos; got this review \u0026apos;{}\u0026apos;\u0026quot;,\n        postTitle,\n        review\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You are going to trigger the N+1 query issue because, instead of one SQL query, you executed 5 (1 + 4):\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT\n    pc.id AS id,\n    pc.review AS review,\n    pc.post_id AS postId\nFROM post_comment pc\n \nSELECT p.title FROM post p WHERE p.id = 1\n-- The Post \u0026apos;High-Performance Java Persistence - Part 1\u0026apos; got this review\n-- \u0026apos;Excellent book to understand Java Persistence\u0026apos;\n    \nSELECT p.title FROM post p WHERE p.id = 2\n-- The Post \u0026apos;High-Performance Java Persistence - Part 2\u0026apos; got this review\n-- \u0026apos;Must-read for Java developers\u0026apos;\n     \nSELECT p.title FROM post p WHERE p.id = 3\n-- The Post \u0026apos;High-Performance Java Persistence - Part 3\u0026apos; got this review\n-- \u0026apos;Five Stars\u0026apos;\n     \nSELECT p.title FROM post p WHERE p.id = 4\n-- The Post \u0026apos;High-Performance Java Persistence - Part 4\u0026apos; got this review\n-- \u0026apos;A great reference book\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Fixing the N+1 query issue is very easy. All you need to do is extract all the data you need in the original SQL query, like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;Tuple\u0026amp;gt; comments = entityManager.createNativeQuery(\u0026quot;\u0026quot;\u0026quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        p.title AS postTitle\n    FROM post_comment pc\n    JOIN post p ON pc.post_id = p.id\n    \u0026quot;\u0026quot;\u0026quot;, Tuple.class)\n.getResultList();\n \nfor (Tuple comment : comments) {\n    String review = (String) comment.get(\u0026quot;review\u0026quot;);\n    String postTitle = (String) comment.get(\u0026quot;postTitle\u0026quot;);\n \n    LOGGER.info(\n        \u0026quot;The Post \u0026apos;{}\u0026apos; got this review \u0026apos;{}\u0026apos;\u0026quot;,\n        postTitle,\n        review\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This time, only one SQL query is executed to fetch all the data we are further interested in using.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;N+1 query problem with JPA and Hibernate\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When using JPA and Hibernate, there are several ways you can trigger the N+1 query issue, so its very important to know how you can avoid these situations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For the next examples, consider we are mapping the \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;post_comments\u0026lt;/code\u0026gt; tables to the following entities:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/rZJne.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/rZJne.png\u0026quot; alt=\u0026quot;Post and PostComment entities\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The JPA mappings look like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@Entity(name = \u0026quot;Post\u0026quot;)\n@Table(name = \u0026quot;post\u0026quot;)\npublic class Post {\n \n    @Id\n    private Long id;\n \n    private String title;\n \n    //Getters and setters omitted for brevity\n}\n \n@Entity(name = \u0026quot;PostComment\u0026quot;)\n@Table(name = \u0026quot;post_comment\u0026quot;)\npublic class PostComment {\n \n    @Id\n    private Long id;\n \n    @ManyToOne\n    private Post post;\n \n    private String review;\n \n    //Getters and setters omitted for brevity\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; either implicitly or explicitly for your JPA associations is a bad idea because you are going to fetch way more data that you need. More, the \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; strategy is also prone to N+1 query issues.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately, the \u0026lt;code\u0026gt;@ManyToOne\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;@OneToOne\u0026lt;/code\u0026gt; associations use \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; by default, so if your mappings look like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@ManyToOne\nprivate Post post;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You are using the \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; strategy, and, every time you forget to use \u0026lt;code\u0026gt;JOIN FETCH\u0026lt;/code\u0026gt; when loading some \u0026lt;code\u0026gt;PostComment\u0026lt;/code\u0026gt; entities with a JPQL or Criteria API query:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;PostComment\u0026amp;gt; comments = entityManager\n.createQuery(\u0026quot;\u0026quot;\u0026quot;\n    select pc\n    from PostComment pc\n    \u0026quot;\u0026quot;\u0026quot;, PostComment.class)\n.getResultList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You are going to trigger the N+1 query issue:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Notice the additional SELECT statements that are executed because the \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association has to be fetched prior to returning the \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;PostComment\u0026lt;/code\u0026gt; entities.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unlike the default fetch plan, which you are using when calling the \u0026lt;code\u0026gt;find\u0026lt;/code\u0026gt; method of the \u0026lt;code\u0026gt;EntityManager\u0026lt;/code\u0026gt;, a JPQL or Criteria API query defines an explicit plan that Hibernate cannot change by injecting a JOIN FETCH automatically. So, you need to do it manually.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you didn\u0026apos;t need the \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association at all, you are out of luck when using \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; because there is no way to avoid fetching it. That\u0026apos;s why it\u0026apos;s better to use \u0026lt;code\u0026gt;FetchType.LAZY\u0026lt;/code\u0026gt; by default.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But, if you wanted to use \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association, then you can use \u0026lt;code\u0026gt;JOIN FETCH\u0026lt;/code\u0026gt; to avoid the N+1 query problem:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;PostComment\u0026amp;gt; comments = entityManager.createQuery(\u0026quot;\u0026quot;\u0026quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    \u0026quot;\u0026quot;\u0026quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        \u0026quot;The Post \u0026apos;{}\u0026apos; got this review \u0026apos;{}\u0026apos;\u0026quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This time, Hibernate will execute a single SQL statement:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT \n    pc.id as id1_1_0_, \n    pc.post_id as post_id3_1_0_, \n    pc.review as review2_1_0_, \n    p.id as id1_0_1_, \n    p.title as title2_0_1_ \nFROM \n    post_comment pc \nINNER JOIN \n    post p ON pc.post_id = p.id\n    \n-- The Post \u0026apos;High-Performance Java Persistence - Part 1\u0026apos; got this review \n-- \u0026apos;Excellent book to understand Java Persistence\u0026apos;\n\n-- The Post \u0026apos;High-Performance Java Persistence - Part 2\u0026apos; got this review \n-- \u0026apos;Must-read for Java developers\u0026apos;\n\n-- The Post \u0026apos;High-Performance Java Persistence - Part 3\u0026apos; got this review \n-- \u0026apos;Five Stars\u0026apos;\n\n-- The Post \u0026apos;High-Performance Java Persistence - Part 4\u0026apos; got this review \n-- \u0026apos;A great reference book\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;FetchType.LAZY\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Even if you switch to using \u0026lt;code\u0026gt;FetchType.LAZY\u0026lt;/code\u0026gt; explicitly for all associations, you can still bump into the N+1 issue.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This time, the \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association is mapped like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@ManyToOne(fetch = FetchType.LAZY)\nprivate Post post;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, when you fetch the \u0026lt;code\u0026gt;PostComment\u0026lt;/code\u0026gt; entities:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;PostComment\u0026amp;gt; comments = entityManager\n.createQuery(\u0026quot;\u0026quot;\u0026quot;\n    select pc\n    from PostComment pc\n    \u0026quot;\u0026quot;\u0026quot;, PostComment.class)\n.getResultList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Hibernate will execute a single SQL statement:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But, if afterward, you are going to reference the lazy-loaded \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for(PostComment comment : comments) {\n    LOGGER.info(\n        \u0026quot;The Post \u0026apos;{}\u0026apos; got this review \u0026apos;{}\u0026apos;\u0026quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You will get the N+1 query issue:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\n-- The Post \u0026apos;High-Performance Java Persistence - Part 1\u0026apos; got this review \n-- \u0026apos;Excellent book to understand Java Persistence\u0026apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\n-- The Post \u0026apos;High-Performance Java Persistence - Part 2\u0026apos; got this review \n-- \u0026apos;Must-read for Java developers\u0026apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\n-- The Post \u0026apos;High-Performance Java Persistence - Part 3\u0026apos; got this review \n-- \u0026apos;Five Stars\u0026apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n-- The Post \u0026apos;High-Performance Java Persistence - Part 4\u0026apos; got this review \n-- \u0026apos;A great reference book\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Because the \u0026lt;code\u0026gt;post\u0026lt;/code\u0026gt; association is fetched lazily, a secondary SQL statement will be executed when accessing the lazy association in order to build the log message.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Again, the fix consists in adding a \u0026lt;code\u0026gt;JOIN FETCH\u0026lt;/code\u0026gt; clause to the JPQL query:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;PostComment\u0026amp;gt; comments = entityManager.createQuery(\u0026quot;\u0026quot;\u0026quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    \u0026quot;\u0026quot;\u0026quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        \u0026quot;The Post \u0026apos;{}\u0026apos; got this review \u0026apos;{}\u0026apos;\u0026quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And, just like in the \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; example, this JPQL query will generate a single SQL statement.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Even if you are using \u0026lt;code\u0026gt;FetchType.LAZY\u0026lt;/code\u0026gt; and don\u0026apos;t reference the child association of a bidirectional \u0026lt;code\u0026gt;@OneToOne\u0026lt;/code\u0026gt; JPA relationship, you can still trigger the N+1 query issue.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;How to automatically detect the N+1 query issue\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If you want to automatically detect N+1 query issue in your data access layer, you can use the \u0026lt;a href=\u0026quot;https://github.com/vladmihalcea/db-util\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;db-util\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; open-source project.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First, you need to add the following Maven dependency:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;dependency\u0026amp;gt;\n    \u0026amp;lt;groupId\u0026amp;gt;com.vladmihalcea\u0026amp;lt;/groupId\u0026amp;gt;\n    \u0026amp;lt;artifactId\u0026amp;gt;db-util\u0026amp;lt;/artifactId\u0026amp;gt;\n    \u0026amp;lt;version\u0026amp;gt;${db-util.version}\u0026amp;lt;/version\u0026amp;gt;\n\u0026amp;lt;/dependency\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Afterward, you just have to use \u0026lt;code\u0026gt;SQLStatementCountValidator\u0026lt;/code\u0026gt; utility to assert the underlying SQL statements that get generated:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SQLStatementCountValidator.reset();\n\nList\u0026amp;lt;PostComment\u0026amp;gt; comments = entityManager.createQuery(\u0026quot;\u0026quot;\u0026quot;\n    select pc\n    from PostComment pc\n    \u0026quot;\u0026quot;\u0026quot;, PostComment.class)\n.getResultList();\n\nSQLStatementCountValidator.assertSelectCount(1);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In case you are using \u0026lt;code\u0026gt;FetchType.EAGER\u0026lt;/code\u0026gt; and run the above test case, you will get the following test case failure:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT \n    pc.id as id1_1_, \n    pc.post_id as post_id3_1_, \n    pc.review as review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 1\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 2\n\n\n-- SQLStatementCountMismatchException: Expected 1 statement(s) but recorded 3 instead!\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT \ntable1.*\n, table2.*\nINNER JOIN table2 ON table2.SomeFkId = table1.SomeId\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That gets you a result set where child rows in table2 cause duplication by returning the table1 results for each child row in table2.  O/R mappers should differentiate table1 instances based on a unique key field, then use all the table2 columns to populate child instances.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT table1.*\n\nSELECT table2.* WHERE SomeFkId = #\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The N+1 is where the first query populates the primary object and the second query populates all the child objects for each of the unique primary objects returned.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class House\n{\n    int Id { get; set; }\n    string Address { get; set; }\n    Person[] Inhabitants { get; set; }\n}\n\nclass Person\n{\n    string Name { get; set; }\n    int HouseId { get; set; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and tables with a similar structure.  A single query for the address \u0026quot;22 Valley St\u0026quot; may return:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Id Address      Name HouseId\n1  22 Valley St Dave 1\n1  22 Valley St John 1\n1  22 Valley St Mike 1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The O/RM should fill an instance of Home with ID=1, Address=\u0026quot;22 Valley St\u0026quot; and then populate the Inhabitants array with People instances for Dave, John, and Mike with just one query.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A N+1 query for the same address used above would result in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Id Address\n1  22 Valley St\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;with a separate query like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT * FROM Person WHERE HouseId = 1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and resulting in a separate data set like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Name    HouseId\nDave    1\nJohn    1\nMike    1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and the final result being the same as above with the single query.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The advantages to single select is that you get all the data up front which may be what you ultimately desire.  The advantages to N+1 is query complexity is reduced and you can use lazy loading where the child result sets are only loaded upon first request.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Supplier with a one-to-many relationship with Product. One Supplier has (supplies) many Products.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;***** Table: Supplier *****\n+-----+-------------------+\n| ID  |       NAME        |\n+-----+-------------------+\n|  1  |  Supplier Name 1  |\n|  2  |  Supplier Name 2  |\n|  3  |  Supplier Name 3  |\n|  4  |  Supplier Name 4  |\n+-----+-------------------+\n\n***** Table: Product *****\n+-----+-----------+--------------------+-------+------------+\n| ID  |   NAME    |     DESCRIPTION    | PRICE | SUPPLIERID |\n+-----+-----------+--------------------+-------+------------+\n|1    | Product 1 | Name for Product 1 |  2.0  |     1      |\n|2    | Product 2 | Name for Product 2 | 22.0  |     1      |\n|3    | Product 3 | Name for Product 3 | 30.0  |     2      |\n|4    | Product 4 | Name for Product 4 |  7.0  |     3      |\n+-----+-----------+--------------------+-------+------------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Factors:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Lazy mode for Supplier set to true (default)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Fetch mode used for querying on Product is Select\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Fetch mode (default): Supplier information is accessed\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Caching does not play a role for the first time the\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Supplier is accessed\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Fetch mode is Select Fetch (default)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// It takes Select fetch mode as a default\nQuery query = session.createQuery( \u0026quot;from Product p\u0026quot;);\nList list = query.list();\n// Supplier is being accessed\ndisplayProductsListWithSupplierName(results);\n\nselect ... various field names ... from PRODUCT\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Result:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;1 select statement for Product\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;N select statements for Supplier\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;This is N+1 select problem!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I can\u0026apos;t comment directly on other answers, because I don\u0026apos;t have enough reputation. But it\u0026apos;s worth noting that the problem essentially only arises because, historically, a lot of dbms have been quite poor when it comes to handling joins (MySQL being a particularly noteworthy example). So n+1 has, often, been notably faster than a join. And then there are ways to improve on n+1 but still without needing a join, which is what the original problem relates to.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, MySQL is now a lot better than it used to be when it comes to joins. When I first learned MySQL, I used joins a lot. Then I discovered how slow they are, and switched to n+1 in the code instead. But, recently, I\u0026apos;ve been moving back to joins, because MySQL is now a heck of a lot better at handling them than it was when I first started using it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These days, a simple join on a properly indexed set of tables is rarely a problem, in performance terms. And if it does give a performance hit, then the use of index hints often solves them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is discussed here by one of the MySQL development team:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the summary is: If you\u0026apos;ve been avoiding joins in the past because of MySQL\u0026apos;s abysmal performance with them, then try again on the latest versions. You\u0026apos;ll probably be pleasantly surprised.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We moved away from the ORM in Django because of this problem. Basically, if you try and do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for p in person:\n    print p.car.colour\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The ORM will happily return all people (typically as instances of a Person object), but then it will need to query the car table for each Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A simple and very effective approach to this is something I call \u0026quot;\u0026lt;strong\u0026gt;fanfolding\u0026lt;/strong\u0026gt;\u0026quot;, which avoids the nonsensical idea that query results from a relational database should map back to the original tables from which the query is composed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Step 1: Wide select\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;  select * from people_car_colour; # this is a view or sql function\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will return something like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;  p.id | p.name | p.telno | car.id | car.type | car.colour\n  -----+--------+---------+--------+----------+-----------\n  2    | jones  | 2145    | 77     | ford     | red\n  2    | jones  | 2145    | 1012   | toyota   | blue\n  16   | ashby  | 124     | 99     | bmw      | yellow\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Step 2: Objectify\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suck the results into a generic object creator with an argument to split after the third item. This means that \u0026quot;jones\u0026quot; object won\u0026apos;t be made more than once.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Step 3: Render\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for p in people:\n    print p.car.colour # no more car queries\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;http://campbell-lange.net/company/articles/dbwrapper/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this web page\u0026lt;/a\u0026gt; for an implementation of \u0026lt;strong\u0026gt;fanfolding\u0026lt;/strong\u0026gt; for python.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.archive.org/web/20160310145416/http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Here\u0026apos;s a good description of the problem\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now that you understand the problem it can typically be avoided by doing a join fetch in your query. This basically forces the fetch of the lazy loaded object so the data is retrieved in one query instead of n+1 queries.  Hope this helps.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Suppose you have COMPANY and EMPLOYEE. COMPANY has many EMPLOYEES (i.e. EMPLOYEE has a field COMPANY_ID).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In some O/R configurations, when you have a mapped Company object and go to access its Employee objects, the O/R tool will do one select for every employee, wheras if you were just doing things in straight SQL, you could \u0026lt;code\u0026gt;select * from employees where company_id = XX\u0026lt;/code\u0026gt;.  Thus N (# of employees) plus 1 (company)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is how the initial versions of EJB Entity Beans worked.  I believe things like Hibernate have done away with this, but I\u0026apos;m not too sure.  Most tools usually include info as to their strategy for mapping.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Check Ayende post on the topic: \u0026lt;a href=\u0026quot;http://ayende.com/blog/1328/combating-the-select-n-1-problem-in-nhibernate\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Combating the Select N + 1 Problem In NHibernate\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, when using an ORM like NHibernate or EntityFramework, if you have a one-to-many (master-detail) relationship, and want to list all the details per each master record, you have to make N + 1 query calls to the database, \u0026quot;N\u0026quot; being the number of master records: 1 query to get all the master records, and N queries, one per master record, to get all the details per master record.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More database query calls  more latency time  decreased application/database performance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, ORMs have options to avoid this problem, mainly using JOINs.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is much faster to issue 1 query which returns 100 results than to issue 100 queries which each return 1 result.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my opinion the article written in \u0026lt;a href=\u0026quot;http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hibernate Pitfall: Why Relationships Should Be Lazy\u0026lt;/a\u0026gt; is exactly opposite of real N+1 issue is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you need correct explanation please refer \u0026lt;a href=\u0026quot;http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-fetching\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hibernate - Chapter 19: Improving Performance - Fetching Strategies\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Select fetching (the default) is\n  extremely vulnerable to N+1 selects\n  problems, so we might want to enable\n  join fetching\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The supplied link has a very simply example of the n + 1 problem. If you apply it to Hibernate it\u0026apos;s basically talking about the same thing. When you query for an object, the entity is loaded but any associations (unless configured otherwise) will be lazy loaded. Hence one query for the root objects and another query to load the associations for each of these. 100 objects returned means one initial query and then 100 additional queries to get the association for each, n + 1.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pramatr.com/2009/02/05/sql-n-1-selects-explained/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://pramatr.com/2009/02/05/sql-n-1-selects-explained/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;N+1 select issue is a pain, and it makes sense to detect such cases in unit tests.\nI have developed a small library for verifying the number of queries executed by a given test method or just an arbitrary block of code - \u0026lt;a href=\u0026quot;https://github.com/bedrin/jdbc-sniffer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JDBC Sniffer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just add a special JUnit rule to your test class and place annotation with expected number of queries on your test methods:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@Rule\npublic final QueryCounter queryCounter = new QueryCounter();\n\n@Expectation(atMost = 3)\n@Test\npublic void testInvokingDatabase() {\n    // your JDBC or JPA code\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;N+1 problem in Hibernate \u0026amp;amp; Spring Data JPA\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;N+1 problem is a performance issue in Object Relational Mapping that fires multiple select queries (N+1 to be exact, where N = number of records in table) in database for a single select query at application layer. Hibernate \u0026amp;amp; Spring Data JPA provides multiple ways to catch and address this performance problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is N+1 Problem?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To understand N+1 problem, lets consider with a scenario. Lets say we have a collection of \u0026lt;em\u0026gt;User\u0026lt;/em\u0026gt; objects mapped to \u0026lt;em\u0026gt;DB_USER\u0026lt;/em\u0026gt; table in database, and each user has collection or \u0026lt;em\u0026gt;Role\u0026lt;/em\u0026gt; mapped to \u0026lt;em\u0026gt;DB_ROLE\u0026lt;/em\u0026gt; table using a joining table \u0026lt;em\u0026gt;DB_USER_ROLE\u0026lt;/em\u0026gt;. At the ORM level a \u0026lt;strong\u0026gt;User\u0026lt;/strong\u0026gt; has \u0026lt;strong\u0026gt;many to many\u0026lt;/strong\u0026gt; relationship with \u0026lt;strong\u0026gt;Role\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Entity Model\n@Entity\n@Table(name = \u0026quot;DB_USER\u0026quot;)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private String name;\n\n    @ManyToMany(fetch = FetchType.LAZY)                   \n    private Set\u0026amp;lt;Role\u0026amp;gt; roles;\n    //Getter and Setters \n }\n\n@Entity\n@Table(name = \u0026quot;DB_ROLE\u0026quot;)\npublic class Role {\n\n    @Id\n    @GeneratedValue(strategy= GenerationType.AUTO)\n    private Long id;\n\n    private String name;\n    //Getter and Setters\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A user can have many roles. Roles are loaded Lazily.\u0026lt;/strong\u0026gt; Now lets say we want to \u0026lt;em\u0026gt;fetch all users from this table and print roles for each one\u0026lt;/em\u0026gt;. Very naive Object Relational implementation could be -\n\u0026lt;strong\u0026gt;UserRepository\u0026lt;/strong\u0026gt; with \u0026lt;strong\u0026gt;findAllBy\u0026lt;/strong\u0026gt; method\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public interface UserRepository extends CrudRepository\u0026amp;lt;User, Long\u0026amp;gt; {\n\n    List\u0026amp;lt;User\u0026amp;gt; findAllBy();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The equivalent SQL queries executed by ORM will be:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First Get \u0026lt;strong\u0026gt;All User\u0026lt;/strong\u0026gt; (1)\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Select * from DB_USER;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then get \u0026lt;strong\u0026gt;roles for each user\u0026lt;/strong\u0026gt; executed N times (where N is number of users)\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Select * from DB_USER_ROLE where userid = \u0026amp;lt;userid\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So we need \u0026lt;strong\u0026gt;one select for User\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;N additional selects for fetching roles for each user\u0026lt;/strong\u0026gt;, where \u0026lt;em\u0026gt;N is total number of users\u0026lt;/em\u0026gt;. \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;This is a classic N+1 problem in ORM\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How to identify it?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Hibernate provide tracing option that enables SQL logging in the console/logs. \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;using logs you can easily see if hibernate is issuing N+1 queries for a given call\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you see multiple entries for SQL for a given select query, then there are high chances that its due to N+1 problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;N+1 Resolution\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;At SQL level\u0026lt;/strong\u0026gt;, what ORM needs to achieve to avoid N+1 is to \u0026lt;em\u0026gt;fire a query that joins the two tables and get the combined results in single query\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Fetch Join SQL that retrieves everything (user and roles) in Single Query\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OR Plain SQL\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;select user0_.id, role2_.id, user0_.name, role2_.name, roles1_.user_id, roles1_.roles_id from db_user user0_ left outer join db_user_roles roles1_ on user0_.id=roles1_.user_id left outer join db_role role2_ on roles1_.roles_id=role2_.id\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Hibernate \u0026amp;amp; Spring Data JPA provide mechanism to solve the N+1 ORM issue.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. Spring Data JPA Approach:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If we are using Spring Data JPA, then we have two options to achieve this - using \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;EntityGraph\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; or using \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;select query with fetch join.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public interface UserRepository extends CrudRepository\u0026amp;lt;User, Long\u0026amp;gt; {\n\n    List\u0026amp;lt;User\u0026amp;gt; findAllBy();             \n\n    @Query(\u0026quot;SELECT p FROM User p LEFT JOIN FETCH p.roles\u0026quot;)  \n    List\u0026amp;lt;User\u0026amp;gt; findWithoutNPlusOne();\n\n    @EntityGraph(attributePaths = {\u0026quot;roles\u0026quot;})                \n    List\u0026amp;lt;User\u0026amp;gt; findAll();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;N+1 queries are issued at database level using left join fetch, we resolve the N+1 problem using attributePaths, Spring Data JPA avoids N+1 problem\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. Hibernate Approach:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If its pure Hibernate, then the following solutions will work.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;strong\u0026gt;HQL\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;from User u *join fetch* u.roles roles roles\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;strong\u0026gt;Criteria\u0026lt;/strong\u0026gt; API:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Criteria criteria = session.createCriteria(User.class);\ncriteria.setFetchMode(\u0026quot;roles\u0026quot;, FetchMode.EAGER);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;All these approaches work similar and they issue a similar database query with left join fetch\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The issue as others have stated more elegantly is that you either have a Cartesian product of the OneToMany columns or you\u0026apos;re doing N+1 Selects. Either possible gigantic resultset or chatty with the database, respectively.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m surprised this isn\u0026apos;t mentioned but this how I have gotten around this issue... \u0026lt;strong\u0026gt;I make a semi-temporary ids table\u0026lt;/strong\u0026gt;. \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/11119642/318174\u0026quot;\u0026gt;I also do this when you have the \u0026lt;code\u0026gt;IN ()\u0026lt;/code\u0026gt; clause limitation\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This doesn\u0026apos;t work for all cases (probably not even a majority) but it works particularly well if you have a lot of child objects such that the Cartesian product will get out of hand (ie lots of \u0026lt;code\u0026gt;OneToMany\u0026lt;/code\u0026gt; columns the number of results will be a multiplication of the columns) and its more of a batch like job.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First you insert your parent object ids as batch into an ids table.\nThis batch_id is something we generate in our app and hold onto.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;INSERT INTO temp_ids \n    (product_id, batch_id)\n    (SELECT p.product_id, ? \n    FROM product p ORDER BY p.product_id\n    LIMIT ? OFFSET ?);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now for each \u0026lt;code\u0026gt;OneToMany\u0026lt;/code\u0026gt; column you just do a \u0026lt;code\u0026gt;SELECT\u0026lt;/code\u0026gt; on the ids table \u0026lt;code\u0026gt;INNER JOIN\u0026lt;/code\u0026gt;ing  the child table with a \u0026lt;code\u0026gt;WHERE batch_id=\u0026lt;/code\u0026gt; (or vice versa). You just want to make sure you order by the id column as it will make merging result columns easier (otherwise you will need a HashMap/Table for the entire result set which may not be that bad).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then you just periodically clean the ids table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This also works particularly well if the user selects say 100 or so distinct items for some sort of bulk processing. Put the 100 distinct ids in the temporary table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now the number of queries you are doing is by the number of OneToMany columns.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Without going into tech stack implementation details, architecturally speaking there are at least two solutions to N + 1 Problem:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Have Only 1 - big query - with Joins. This makes a lot of information be transported from the database to the application layer, especially if there are multiple child records. The typical result of a database is a set of rows, not graph of objects (there are solutions to that with different DB systems)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Have Two(or more for more children needed to be joined) Queries - 1 for the parent and after you have them - query by IDs the children and map them. This will minimize data transfer between the DB and APP layers.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take Matt Solnit example, imagine that you define an association between Car and Wheels as LAZY and you need some Wheels fields. This means that after the first select, hibernate is going to do  \u0026quot;Select * from Wheels where car_id = :id\u0026quot; FOR EACH Car.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This makes the first select and more 1 select by each N car, that\u0026apos;s why it\u0026apos;s called n+1 problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To avoid this, make the association fetch as eager, so that hibernate loads data with a join.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But attention, if many times you don\u0026apos;t access associated Wheels, it\u0026apos;s better to keep it LAZY or change fetch type with Criteria.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;A generalisation of N+1\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The N+1 problem is an ORM specific name of a problem where you move loops that could be reasonably executed on a server to the client. The generic problem isn\u0026apos;t specific to ORMs, you can have it with any remote API. \u0026lt;a href=\u0026quot;https://blog.jooq.org/the-cost-of-jdbc-server-roundtrips/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;In this article, I\u0026apos;ve shown how JDBC roundtrips are very costly\u0026lt;/a\u0026gt;, if you\u0026apos;re calling an API N times instead of only 1 time. The difference in the example is whether you\u0026apos;re calling the Oracle PL/SQL procedure:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;dbms_output.get_lines\u0026lt;/code\u0026gt; (call it once, receive N items)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;dbms_output.get_line\u0026lt;/code\u0026gt; (call it N times, receive 1 item each time)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;They\u0026apos;re logically equivalent, but due to the latency between server and client, you\u0026apos;re adding N latency waits to your loop, instead of waiting only once.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;The ORM case\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In fact, the ORM-y N+1 problem isn\u0026apos;t even ORM specific either, you can achieve it by running your own queries manually as well, e.g. when you do something like this in PL/SQL:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- This loop is executed once\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; parent \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; parent) loop\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;-- This loop is executed N times\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; child \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; child \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; parent_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; parent.id) loop\n    ...\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt; loop;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt; loop;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It would be much better to implement this using a join (in this case):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; rec \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; parent p\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt; child c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; c.parent_id \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; p.id\n)\nloop\n  ...\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt; loop;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, the loop is executed only once, and the logic of the loop has been moved from the client (PL/SQL) to the server (SQL), which can even optimise it differently, e.g. by running a hash join (\u0026lt;code\u0026gt;O(N)\u0026lt;/code\u0026gt;) rather than a nested loop join (\u0026lt;code\u0026gt;O(N log N)\u0026lt;/code\u0026gt; with index)\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Auto-detecting N+1 problems\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;If you\u0026apos;re using JDBC, \u0026lt;a href=\u0026quot;https://blog.jooq.org/using-jooqs-diagnosticsconnection-to-detect-n1-queries/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;you could use jOOQ as a JDBC proxy behind the scenes to auto-detect your N+1 problems\u0026lt;/a\u0026gt;. jOOQ\u0026apos;s parser normalises your SQL queries and caches data about consecutive executions of parent and child queries. This even works if your queries aren\u0026apos;t exactly the same, but semantically equivalent.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;N+1 SELECT problem is really hard to spot, especially in projects with large domain, to the moment when it starts degrading the performance. Even if the problem is fixed i.e. by adding eager loading, a further development may break the solution and/or introduce N+1 SELECT problem again in other places.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;ve created open source library \u0026lt;a href=\u0026quot;https://github.com/adgadev/jplusone\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;jplusone\u0026lt;/a\u0026gt; to address those problems in JPA based Spring Boot Java applications. The library provides two major features:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Generates reports correlating SQL statements with executions of JPA operations which triggered them and places in source code of your application which were involved in it\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;pre\u0026gt;2020-10-22 18:41:43.236 DEBUG 14913 --- [           main] c.a.j.core.report.ReportGenerator        :\n    ROOT\n        com.adgadev.jplusone.test.domain.bookshop.BookshopControllerTest.shouldGetBookDetailsLazily(BookshopControllerTest.java:65)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopController.getSampleBookUsingLazyLoading(BookshopController.java:31)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading [PROXY]\n            SESSION BOUNDARY\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:35)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.getName [PROXY]\n                    com.adgadev.jplusone.test.domain.bookshop.Author [FETCHING ENTITY]\n                        STATEMENT [READ]\n                            select [...] from\n                                author author0_\n                                left outer join genre genre1_ on author0_.genre_id=genre1_.id\n                            where\n                                author0_.id=1\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:36)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.countWrittenBooks(Author.java:53)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.books [FETCHING COLLECTION]\n                        STATEMENT [READ]\n                            select [...] from\n                                book books0_\n                            where\n                                books0_.author_id=1\n\u0026lt;/pre\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;Provides API which allows to write tests checking how effectively your application is using JPA (i.e. assert amount of lazy loading operations )\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@SpringBootTest\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LazyLoadingTest\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Autowired\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; JPlusOneAssertionContext assertionContext;\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Autowired\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; SampleService sampleService;\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Test\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;shouldBusinessCheckOperationAgainstJPlusOneAssertionRule\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JPlusOneAssertionRule\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rule\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; JPlusOneAssertionRule\n                .within().lastSession()\n                .shouldBe().noImplicitOperations().exceptAnyOf(exclusions -\u0026amp;gt; exclusions\n                        .loadingEntity(Author.class).times(atMost(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;))\n                        .loadingCollection(Author.class, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;books\u0026quot;\u0026lt;/span\u0026gt;)\n                );\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// trigger business operation which you wish to be asserted against the rule,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i.e. calling a service or sending request to your API controller\u0026lt;/span\u0026gt;\n        sampleService.executeBusinessOperation();\n\n        rule.check(assertionContext);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":460,"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","content":"\n                \n\u0026lt;p\u0026gt;The \u0026quot;N+1 selects problem\u0026quot; is generally stated as a problem in Object-Relational mapping (ORM) discussions, and I understand that it has something to do with having to make a lot of database queries for something that seems simple in the object world.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Does anybody have a more detailed explanation of the problem?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597","postType":"QUESTION","createdAt":"2022-07-09T17:34:15.000Z","updatedAt":"2022-07-09T17:34:15.000Z","tags":[{"id":2356,"name":"orm","slug":"orm","createdAt":"2022-07-09T17:34:15.000Z","updatedAt":"2022-07-09T17:34:15.000Z","Questions_Tags":{"questionId":460,"tagId":2356}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>