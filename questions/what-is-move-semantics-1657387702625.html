<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is move semantics? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I just finished listening to the Software Engineering radio podcast interview with Scott Meyers regarding C++0x. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don&#x27;t get move semantics... What is it exactly?
    "/><meta property="og:title" content="What is move semantics? | Solutions Checker"/><meta property="og:description" content="I just finished listening to the Software Engineering radio podcast interview with Scott Meyers regarding C++0x. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don&#x27;t get move semantics... What is it exactly?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is move semantics?","text":"I just finished listening to the Software Engineering radio podcast interview with Scott Meyers regarding C++0x. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don&apos;t get move semantics... What is it exactly?\n    ","answerCount":11,"upVoteCount":500,"suggestedAnswer":[{"text":"I find it easiest to understand move semantics with example code. Let&apos;s start with a very simple string class which only holds a pointer to a heap-allocated block of memory:\n\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nclass string\n{\n    char* data;\n\npublic:\n\n    string(const char* p)\n    {\n        size_t size = std::strlen(p) + 1;\n        data = new char[size];\n        std::memcpy(data, p, size);\n    }\n\n\nSince we chose to manage the memory ourselves, we need to follow the rule of three. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:\n\n    ~string()\n    {\n        delete[] data;\n    }\n\n    string(const string&amp; that)\n    {\n        size_t size = std::strlen(that.data) + 1;\n        data = new char[size];\n        std::memcpy(data, that.data, size);\n    }\n\n\nThe copy constructor defines what it means to copy string objects. The parameter const string&amp; that binds to all expressions of type string which allows you to make copies in the following examples:\n\nstring a(x);                                    // Line 1\nstring b(x + y);                                // Line 2\nstring c(some_function_returning_a_string());   // Line 3\n\n\nNow comes the key insight into move semantics. Note that only in the first line where we copy x is this deep copy really necessary, because we might want to inspect x later and would be very surprised if x had changed somehow. Did you notice how I just said x three times (four times if you include this sentence) and meant the exact same object every time? We call expressions such as x &quot;lvalues&quot;.\n\nThe arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.\nrvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of b and c, we could do whatever we wanted with the source string, and the client couldn&apos;t tell a difference!\n\nC++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,\nallows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do anything we want with the source, as long as we leave it in some valid state:\n\n    string(string&amp;&amp; that)   // string&amp;&amp; is an rvalue reference to a string\n    {\n        data = that.data;\n        that.data = nullptr;\n    }\n\n\nWhat have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent &apos;delete[]&apos; from source object&apos;s destructor from releasing our &apos;just stolen data&apos;). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don&apos;t really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.\n\nCongratulations, you now understand the basics of move semantics! Let&apos;s continue by implementing the assignment operator. If you&apos;re unfamiliar with the copy and swap idiom, learn it and come back, because it&apos;s an awesome C++ idiom related to exception safety.\n\n    string&amp; operator=(string that)\n    {\n        std::swap(data, that.data);\n        return *this;\n    }\n};\n\n\nHuh, that&apos;s it? &quot;Where&apos;s the rvalue reference?&quot; you might ask. &quot;We don&apos;t need it here!&quot; is my answer :)\n\nNote that we pass the parameter that by value, so that has to be initialized just like any other string object. Exactly how is that going to be initialized? In the olden days of C++98, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.\n\nSo if you say a = b, the copy constructor will initialize that (because the expression b is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.\n\nBut if you say a = x + y, the move constructor will initialize that (because the expression x + y is an rvalue), so there is no deep copy involved, only an efficient move.\nthat is still an independent object from the argument, but its construction was trivial,\nsince the heap data didn&apos;t have to be copied, just moved. It wasn&apos;t necessary to copy it because x + y is an rvalue, and again, it is okay to move from string objects denoted by rvalues.\n\nTo summarize, the copy constructor makes a deep copy, because the source must remain untouched.\nThe move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.\n\nI hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see my supplementary answer.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.\nHowever, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.\nThe first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)\n\nStephan T. Lavavej took the time to provide valuable feedback. Thank you very much, Stephan!\n\nIntroduction\n\nMove semantics allows an object, under certain conditions, to take ownership of some other object&apos;s external resources. This is important in two ways:\n\n\nTurning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:\n\nclass cannot_benefit_from_move_semantics\n{\n    int a;        // moving an int means copying an int\n    float b;      // moving a float means copying a float\n    double c;     // moving a double means copying a double\n    char d[64];   // moving a char array means copying a char array\n\n    // ...\n};\n\nImplementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses std::auto_ptr, a deprecated C++98 standard library template, which was replaced by std::unique_ptr in C++11. Intermediate C++ programmers are probably at least somewhat familiar with std::auto_ptr, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.\n\n\nWhat is a move?\n\nThe C++98 standard library offers a smart pointer with unique ownership semantics called std::auto_ptr&lt;T&gt;. In case you are unfamiliar with auto_ptr, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:\n\n{\n    std::auto_ptr&lt;Shape&gt; a(new Triangle);\n    // ...\n    // arbitrary code, could throw exceptions\n    // ...\n}   // &lt;--- when a goes out of scope, the triangle is deleted automatically\n\n\nThe unusual thing about auto_ptr is its &quot;copying&quot; behavior:\n\nauto_ptr&lt;Shape&gt; a(new Triangle);\n\n      +---------------+\n      | triangle data |\n      +---------------+\n        ^\n        |\n        |\n        |\n  +-----|---+\n  |   +-|-+ |\na | p | | | |\n  |   +---+ |\n  +---------+\n\nauto_ptr&lt;Shape&gt; b(a);\n\n      +---------------+\n      | triangle data |\n      +---------------+\n        ^\n        |\n        +----------------------+\n                               |\n  +---------+            +-----|---+\n  |   +---+ |            |   +-|-+ |\na | p |   | |          b | p | | | |\n  |   +---+ |            |   +---+ |\n  +---------+            +---------+\n\n\nNote how the initialization of b with a does not copy the triangle, but instead transfers the ownership of the triangle from a to b. We also say &quot;a is moved into b&quot; or &quot;the triangle is moved from a to b&quot;. This may sound confusing because the triangle itself always stays at the same place in memory.\n\n\n  To move an object means to transfer ownership of some resource it manages to another object.\n\n\nThe copy constructor of auto_ptr probably looks something like this (somewhat simplified):\n\nauto_ptr(auto_ptr&amp; source)   // note the missing const\n{\n    p = source.p;\n    source.p = 0;   // now the source no longer owns the object\n}\n\n\nDangerous and harmless moves\n\nThe dangerous thing about auto_ptr is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from auto_ptr will invoke undefined behavior, so you have to be very careful not to use an auto_ptr after it has been moved from:\n\nauto_ptr&lt;Shape&gt; a(new Triangle);   // create triangle\nauto_ptr&lt;Shape&gt; b(a);              // move a into b\ndouble area = a-&gt;area();           // undefined behavior\n\n\nBut auto_ptr is not always dangerous. Factory functions are a perfectly fine use case for auto_ptr:\n\nauto_ptr&lt;Shape&gt; make_triangle()\n{\n    return auto_ptr&lt;Shape&gt;(new Triangle);\n}\n\nauto_ptr&lt;Shape&gt; c(make_triangle());      // move temporary into c\ndouble area = make_triangle()-&gt;area();   // perfectly safe\n\n\nNote how both examples follow the same syntactic pattern:\n\nauto_ptr&lt;Shape&gt; variable(expression);\ndouble area = expression-&gt;area();\n\n\nAnd yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions a and make_triangle()? Aren&apos;t they both of the same type? Indeed they are, but they have different value categories.\n\nValue categories\n\nObviously, there must be some profound difference between the expression a which denotes an auto_ptr variable, and the expression make_triangle() which denotes the call of a function that returns an auto_ptr by value, thus creating a fresh temporary auto_ptr object every time it is called. a is an example of an lvalue, whereas make_triangle() is an example of an rvalue.\n\nMoving from lvalues such as a is dangerous, because we could later try to call a member function via a, invoking undefined behavior. On the other hand, moving from rvalues such as make_triangle() is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write make_triangle() again, we get a different temporary. In fact, the moved-from temporary is already gone on the next line:\n\nauto_ptr&lt;Shape&gt; c(make_triangle());\n                                  ^ the moved-from temporary dies right here\n\n\nNote that the letters l and r have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues that cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).\n\n\n  An rvalue of class type is an expression whose evaluation creates a temporary object.\n  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.\n\n\nRvalue references\n\nWe now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues explicit at call site, so that we no longer move by accident.\n\nC++11&apos;s answer to this problem is rvalue references. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is X&amp;&amp;. The good old reference X&amp; is now known as an lvalue reference. (Note that X&amp;&amp; is not a reference to a reference; there is no such thing in C++.)\n\nIf we throw const into the mix, we already have four different kinds of references. What kinds of expressions of type X can they bind to?\n\n            lvalue   const lvalue   rvalue   const rvalue\n---------------------------------------------------------              \nX&amp;          yes\nconst X&amp;    yes      yes            yes      yes\nX&amp;&amp;                                 yes\nconst X&amp;&amp;                           yes      yes\n\n\nIn practice, you can forget about const X&amp;&amp;. Being restricted to read from rvalues is not very useful.\n\n\n  An rvalue reference X&amp;&amp; is a new kind of reference that only binds to rvalues.\n\n\nImplicit conversions\n\nRvalue references went through several versions. Since version 2.1, an rvalue reference X&amp;&amp; also binds to all value categories of a different type Y, provided there is an implicit conversion from Y to X. In that case, a temporary of type X is created, and the rvalue reference is bound to that temporary:\n\nvoid some_function(std::string&amp;&amp; r);\n\nsome_function(&quot;hello world&quot;);\n\n\nIn the above example, &quot;hello world&quot; is an lvalue of type const char[12]. Since there is an implicit conversion from const char[12] through const char* to std::string, a temporary of type std::string is created, and r is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.\n\nMove constructors\n\nA useful example of a function with an X&amp;&amp; parameter is the move constructor X::X(X&amp;&amp; source). Its purpose is to transfer ownership of the managed resource from the source into the current object.\n\nIn C++11, std::auto_ptr&lt;T&gt; has been replaced by std::unique_ptr&lt;T&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of unique_ptr. First, we encapsulate a raw pointer and overload the operators -&gt; and *, so our class feels like a pointer:\n\ntemplate&lt;typename T&gt;\nclass unique_ptr\n{\n    T* ptr;\n\npublic:\n\n    T* operator-&gt;() const\n    {\n        return ptr;\n    }\n\n    T&amp; operator*() const\n    {\n        return *ptr;\n    }\n\n\nThe constructor takes ownership of the object, and the destructor deletes it:\n\n    explicit unique_ptr(T* p = nullptr)\n    {\n        ptr = p;\n    }\n\n    ~unique_ptr()\n    {\n        delete ptr;\n    }\n\n\nNow comes the interesting part, the move constructor:\n\n    unique_ptr(unique_ptr&amp;&amp; source)   // note the rvalue reference\n    {\n        ptr = source.ptr;\n        source.ptr = nullptr;\n    }\n\n\nThis move constructor does exactly what the auto_ptr copy constructor did, but it can only be supplied with rvalues:\n\nunique_ptr&lt;Shape&gt; a(new Triangle);\nunique_ptr&lt;Shape&gt; b(a);                 // error\nunique_ptr&lt;Shape&gt; c(make_triangle());   // okay\n\n\nThe second line fails to compile, because a is an lvalue, but the parameter unique_ptr&amp;&amp; source can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because make_triangle() is an rvalue. The move constructor will transfer ownership from the temporary to c. Again, this is exactly what we wanted.\n\n\n  The move constructor transfers ownership of a managed resource into the current object.\n\n\nMove assignment operators\n\nThe last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:\n\n    unique_ptr&amp; operator=(unique_ptr&amp;&amp; source)   // note the rvalue reference\n    {\n        if (this != &amp;source)    // beware of self-assignment\n        {\n            delete ptr;         // release the old resource\n\n            ptr = source.ptr;   // acquire the new resource\n            source.ptr = nullptr;\n        }\n        return *this;\n    }\n};\n\n\nNote how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:\n\n    unique_ptr&amp; operator=(unique_ptr source)   // note the missing reference\n    {\n        std::swap(ptr, source.ptr);\n        return *this;\n    }\n};\n\n\nNow that source is a variable of type unique_ptr, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of operator=, source goes out of scope, releasing the old resource automatically.\n\n\n  The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.\n  The move-and-swap idiom simplifies the implementation.\n\n\nMoving from lvalues\n\nSometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.\nFor this purpose, C++11 offers a standard library function template called std::move inside the header &lt;utility&gt;.\nThis name is a bit unfortunate, because std::move simply casts an lvalue to an rvalue; it does not move anything by itself. It merely enables moving. Maybe it should have been named std::cast_to_rvalue or std::enable_move, but we are stuck with the name by now.\n\nHere is how you explicitly move from an lvalue:\n\nunique_ptr&lt;Shape&gt; a(new Triangle);\nunique_ptr&lt;Shape&gt; b(a);              // still an error\nunique_ptr&lt;Shape&gt; c(std::move(a));   // okay\n\n\nNote that after the third line, a no longer owns a triangle. That&apos;s okay, because by explicitly writing std::move(a), we made our intentions clear: &quot;Dear constructor, do whatever you want with a in order to initialize c; I don&apos;t care about a anymore. Feel free to have your way with a.&quot;\n\n\n  std::move(some_lvalue) casts an lvalue to an rvalue, thus enabling a subsequent move.\n\n\nXvalues\n\nNote that even though std::move(a) is an rvalue, its evaluation does not create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an xvalue (eXpiring value). The traditional rvalues were renamed to prvalues (Pure rvalues).\n\nBoth prvalues and xvalues are rvalues. Xvalues and lvalues are both glvalues (Generalized lvalues). The relationships are easier to grasp with a diagram:\n\n        expressions\n          /     \\\n         /       \\\n        /         \\\n    glvalues   rvalues\n      /  \\       /  \\\n     /    \\     /    \\\n    /      \\   /      \\\nlvalues   xvalues   prvalues\n\n\nNote that only xvalues are really new; the rest is just due to renaming and grouping.\n\n\n  C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.\n\n\nMoving out of functions\n\nSo far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the return statement as an argument to the move constructor:\n\nunique_ptr&lt;Shape&gt; make_triangle()\n{\n    return unique_ptr&lt;Shape&gt;(new Triangle);\n}          \\-----------------------------/\n                  |\n                  | temporary is moved into c\n                  |\n                  v\nunique_ptr&lt;Shape&gt; c(make_triangle());\n\n\nPerhaps surprisingly, automatic objects (local variables that are not declared as static) can also be implicitly moved out of functions:\n\nunique_ptr&lt;Shape&gt; make_square()\n{\n    unique_ptr&lt;Shape&gt; result(new Square);\n    return result;   // note the missing std::move\n}\n\n\nHow come the move constructor accepts the lvalue result as an argument? The scope of result is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterward that result had changed somehow; when control flow is back at the caller, result does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write std::move. In fact, you should never use std::move to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).\n\n\n  Never use std::move to move automatic objects out of functions.\n\n\nNote that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:\n\nunique_ptr&lt;Shape&gt;&amp;&amp; flawed_attempt()   // DO NOT DO THIS!\n{\n    unique_ptr&lt;Shape&gt; very_bad_idea(new Square);\n    return std::move(very_bad_idea);   // WRONG!\n}\n\n\n\n  Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by std::move, and not by merely binding an rvalue to an rvalue reference.\n\n\nMoving into members\n\nSooner or later, you are going to write code like this:\n\nclass Foo\n{\n    unique_ptr&lt;Shape&gt; member;\n\npublic:\n\n    Foo(unique_ptr&lt;Shape&gt;&amp;&amp; parameter)\n    : member(parameter)   // error\n    {}\n};\n\n\nBasically, the compiler will complain that parameter is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does not mean that the reference itself is an rvalue! Indeed, parameter is just an ordinary variable with a name. You can use parameter as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.\n\n\n  A named rvalue reference is an lvalue, just like any other variable.\n\n\nThe solution is to manually enable the move:\n\nclass Foo\n{\n    unique_ptr&lt;Shape&gt; member;\n\npublic:\n\n    Foo(unique_ptr&lt;Shape&gt;&amp;&amp; parameter)\n    : member(std::move(parameter))   // note the std::move\n    {}\n};\n\n\nYou could argue that parameter is not used anymore after the initialization of member. Why is there no special rule to silently insert std::move just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the return keyword denotes an automatic object.\n\nYou can also pass the parameter by value. For move-only types like unique_ptr, it seems there is no established idiom yet. Personally, I prefer to pass by value, as it causes less clutter in the interface.\n\nSpecial member functions\n\nC++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator, and the destructor.\n\nX::X(const X&amp;);              // copy constructor\nX&amp; X::operator=(const X&amp;);   // copy assignment operator\nX::~X();                     // destructor\n\n\nRvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conforms to version 3.0 yet, so you will have to implement them yourself.\n\nX::X(X&amp;&amp;);                   // move constructor\nX&amp; X::operator=(X&amp;&amp;);        // move assignment operator\n\n\nThese two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.\n\nWhat do these rules mean in practice?\n\n\n  If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.\n\n\nNote that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:\n\nX&amp; X::operator=(X source)    // unified assignment operator\n{\n    swap(source);            // see my first answer for an explanation\n    return *this;\n}\n\n\nThis way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.\n\nForwarding references (previously known as Universal references)\n\nConsider the following function template:\n\ntemplate&lt;typename T&gt;\nvoid foo(T&amp;&amp;);\n\n\nYou might expect T&amp;&amp; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, T&amp;&amp; also binds to lvalues:\n\nfoo(make_triangle());   // T is unique_ptr&lt;Shape&gt;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;&amp;\nunique_ptr&lt;Shape&gt; a(new Triangle);\nfoo(a);                 // T is unique_ptr&lt;Shape&gt;&amp;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;\n\n\nIf the argument is an rvalue of type X, T is deduced to be X, hence T&amp;&amp; means X&amp;&amp;. This is what anyone would expect.\nBut if the argument is an lvalue of type X, due to a special rule, T is deduced to be X&amp;, hence T&amp;&amp; would mean something like X&amp; &amp;&amp;. But since C++ still has no notion of references to references, the type X&amp; &amp;&amp; is collapsed into X&amp;. This may sound confusing and useless at first, but reference collapsing is essential for perfect forwarding (which will not be discussed here).\n\n\n  T&amp;&amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case T and T&amp;&amp; are both lvalue references.\n\n\nIf you want to constrain a function template to rvalues, you can combine SFINAE with type traits:\n\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value, void&gt;::type\nfoo(T&amp;&amp;);\n\n\nImplementation of move\n\nNow that you understand reference collapsing, here is how std::move is implemented:\n\ntemplate&lt;typename T&gt;\ntypename std::remove_reference&lt;T&gt;::type&amp;&amp;\nmove(T&amp;&amp; t)\n{\n    return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);\n}\n\n\nAs you can see, move accepts any kind of parameter thanks to the forwarding reference T&amp;&amp;, and it returns an rvalue reference. The std::remove_reference&lt;T&gt;::type meta-function call is necessary because otherwise, for lvalues of type X, the return type would be X&amp; &amp;&amp;, which would collapse into X&amp;. Since t is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind t to an rvalue reference, we have to explicitly cast t to the correct return type.\nThe call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)\n\n\n  The call of a function that returns an rvalue reference, such as std::move, is an xvalue.\n\n\nNote that returning by rvalue reference is fine in this example, because t does not denote an automatic object, but instead an object that was passed in by the caller.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Suppose you have a function that returns a substantial object:\n\nMatrix multiply(const Matrix &amp;a, const Matrix &amp;b);\n\n\nWhen you write code like this:\n\nMatrix r = multiply(a, b);\n\n\nthen an ordinary C++ compiler will create a temporary object for the result of multiply(), call the copy constructor to initialise r, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise r by copying its contents, and then discard the temporary value without having to destruct it.\n\nThis is especially important if (like perhaps the Matrix example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the Matrix object.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Move semantics is about transferring resources rather than copying them when nobody needs the source value anymore.\n\nIn C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a functionunless RVO kicks inthe value you&apos;re returning is copied to the caller&apos;s stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like sort that just rearrange items, reallocation in vector when its capacity() is exceeded, etc.\n\nWhen such copy/destroy pairs are expensive, it&apos;s typically because the object owns some heavyweight resource. For example, vector&lt;string&gt; may own a dynamically-allocated memory block containing an array of string objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  Then you need deallocate all that memory you just copied.  However, moving a large vector&lt;string&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"If you are really interested in a good, in-depth explanation of move semantics, I&apos;d highly recommend reading the original paper on them, &quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;  \n\nIt&apos;s very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on the WG21 website, but this one is probably the most straightforward since it approaches things from a top-level view and doesn&apos;t get very much into the gritty language details.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In easy (practical) terms:\n\nCopying an object means copying its &quot;static&quot; members and calling the new operator for its dynamic objects. Right?\n\nclass A\n{\n   int i, *p;\n\npublic:\n   A(const A&amp; a) : i(a.i), p(new int(*a.p)) {}\n   ~A() { delete p; }\n};\n\n\nHowever, to move an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.\n\nBut, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:\n\nclass A\n{\n   int i, *p;\n\npublic:\n   // Movement of an object inside a copy constructor.\n   A(const A&amp; a) : i(a.i), p(a.p)\n   {\n     a.p = nullptr; // pointer invalidated.\n   }\n\n   ~A() { delete p; }\n   // Deleting NULL, 0 or nullptr (address 0x0) is safe. \n};\n\n\nOk, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that&apos;s very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):\n\nvoid heavyFunction(HeavyType());\n\n\nIn that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don&apos;t need the anonymous object and you can save time and memory.\n\nThis leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the = operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So: \n\nclass A\n{\n   int i, *p;\n\npublic:\n   // Copy\n   A(const A&amp; a) : i(a.i), p(new int(*a.p)) {}\n\n   // Movement (&amp;&amp; means &quot;rvalue reference to&quot;)\n   A(A&amp;&amp; a) : i(a.i), p(a.p)\n   {\n      a.p = nullptr;\n   }\n\n   ~A() { delete p; }\n};\n\n\nIn this case, when an object of type A should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.\n\nIt is important to remember that &quot;static&quot; objects are always copied. There&apos;s no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.\n\nIf your object is complex and the destructor has other secondary effects, like calling to a library&apos;s function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:\n\nclass Heavy\n{\n   bool b_moved;\n   // staff\n\npublic:\n   A(const A&amp; a) { /* definition */ }\n   A(A&amp;&amp; a) : // initialization list\n   {\n      a.b_moved = true;\n   }\n\n   ~A() { if (!b_moved) /* destruct object */ }\n};\n\n\nSo, your code is shorter (you don&apos;t need to do a nullptr assignment for each dynamic member) and more general.\n\nOther typical question: what is the difference between A&amp;&amp; and const A&amp;&amp;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can&apos;t modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.\n\nAnd what is perfect forwarding? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller&apos;s scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn&apos;t received like a temporal object.\n\nvoid some_function(A&amp;&amp; a)\n{\n   other_function(a);\n}\n\n\nThe object a would be copied to the actual parameter of other_function. If you want the object a continues being treated as a temporary object, you should use the std::move function:\n\nother_function(std::move(a));\n\n\nWith this line, std::move will cast a to an rvalue and other_function will receive the object as a unnamed object. Of course, if other_function has not specific overloading to work with unnamed objects, this distinction is not important.\n\nIs that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:\n\ntemplate&lt;typename T&gt;\nvoid some_function(T&amp;&amp; a)\n{\n   other_function(std::forward&lt;T&gt;(a));\n}\n\n\nThat&apos;s the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of std::forward. This function exploits some rules of template instantiation:\n\n `A&amp; &amp;&amp; == A&amp;`\n `A&amp;&amp; &amp;&amp; == A&amp;&amp;`\n\n\nSo, if T is a lvalue reference to A (T = A&amp;), a also (A&amp; &amp;&amp; =&gt; A&amp;). If T is a rvalue reference to A, a also (A&amp;&amp; &amp;&amp; =&gt; A&amp;&amp;). In both cases, a is a named object in the actual scope, but T contains the information of its &quot;reference type&quot; from the caller scope&apos;s point of view. This information (T) is passed as template parameter to forward and &apos;a&apos; is moved or not according to the type of T.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"It&apos;s like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp; assignment operator or the compiler generates them implicitly. This will do a copy.\n\nMove semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;&amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it&apos;s source argument it &apos;moves&apos; memory from the source to the destination.\n\nWhen would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:\n\nstd::vector&lt;foo&gt; get_foos();\n\n\nYou&apos;re going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it&apos;s pointers and &apos;move&apos; dynamically allocated memory to the new instance. It&apos;s kind of like transfer-of-ownership semantics with std::auto_ptr.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I&apos;m writing this to make sure I understand it properly.\n\nMove semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.\n\nSwapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.\n\nReturning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.\n\nIn languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"To illustrate the need for move semantics, let&apos;s consider this example without move semantics:\n\nHere&apos;s a function that takes an object of type T and returns an object of the same type T:\n\nT f(T o) { return o; }\n  //^^^ new object constructed\n\n\nThe above function uses call by value which means that when this function is called an object must be constructed to be used by the function.\nBecause the function also returns by value, another new object is constructed for the return value:\n\nT b = f(a);\n  //^ new object constructed\n\n\nTwo new objects have been constructed, one of which is a temporary object that&apos;s only used for the duration of the function.\n\nWhen the new object is created from the return value, the copy constructor is called to copy the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.\n\n\n\nNow, let&apos;s consider what a copy constructor does.\n\nIt must first initialize the object, then copy all the relevant data from the old object to the new one.\nDepending on the class, maybe its a container with very much data, then that could represent much time and memory usage \n\n// Copy constructor\nT::T(T &amp;old) {\n    copy_data(m_a, old.m_a);\n    copy_data(m_b, old.m_b);\n    copy_data(m_c, old.m_c);\n}\n\n\nWith move semantics it&apos;s now possible to make most of this work less unpleasant by simply moving the data rather than copying.\n\n// Move constructor\nT::T(T &amp;&amp;old) noexcept {\n    m_a = std::move(old.m_a);\n    m_b = std::move(old.m_b);\n    m_c = std::move(old.m_c);\n}\n\n\nMoving the data involves re-associating the data with the new object. And no copy takes place at all.\n\nThis is accomplished with an rvalue reference.\nAn rvalue reference works pretty much like an lvalue reference with one important difference: \nan rvalue reference can be moved and an lvalue cannot.\n\nFrom cppreference.com:\n\n\n  To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.\n  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.\n  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.\n  A constructor is called a &apos;move constructor&apos; when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a &apos;move constructor&apos; may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;&amp;).\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s an answer from the book &quot;The C++ Programming Language&quot; by Bjarne Stroustrup. If you don&apos;t want to see the video, you can see the text below:\n\nConsider this snippet. Returning from an operator+ involves copying the result out of the local variable res and into someplace where the caller can access it. \n\nVector operator+(const Vector&amp; a, const Vector&amp; b)\n{\n    if (a.size()!=b.size())\n        throw Vector_siz e_mismatch{};\n    Vector res(a.size());\n        for (int i=0; i!=a.size(); ++i)\n            res[i]=a[i]+b[i];\n    return res;\n}\n\n\nWe didnt really want a copy; we just wanted to get the result out of a function. So we need to move a Vector rather than to copy it. We can define move constructor as follows:\n\nclass Vector {\n    // ...\n    Vector(const Vector&amp; a); // copy constructor\n    Vector&amp; operator=(const Vector&amp; a); // copy assignment\n    Vector(Vector&amp;&amp; a); // move constructor\n    Vector&amp; operator=(Vector&amp;&amp; a); // move assignment\n};\n\nVector::Vector(Vector&amp;&amp; a)\n    :elem{a.elem}, // &quot;grab the elements&quot; from a\n    sz{a.sz}\n{\n    a.elem = nullptr; // now a has no elements\n    a.sz = 0;\n}\n\n\nThe &amp;&amp; means &quot;rvalue reference&quot; and is a reference to which we can bind an rvalue. &quot;rvalue&quot; is intended to complement &quot;lvalue&quot; which roughly means &quot;something that can appear on the left-hand side of an assignment.&quot; So an rvalue means roughly &quot;a value that you cant assign to&quot;, such as an integer returned by a function call, and the res local variable in operator+() for Vectors. \n\nNow, the statement return res; will not copy!\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-move-semantics-1657387702625#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/c++11">c++11</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/move-semantics">move-semantics</a></div></div><div class="question-content mt-5">
                
<p>I just finished listening to the Software Engineering radio <a href="http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/" rel="noreferrer">podcast interview with Scott Meyers</a> regarding <a href="http://en.wikipedia.org/wiki/C++11" rel="noreferrer">C++0x</a>. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get <em>move semantics</em>... What is it exactly?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>
{
    <span class="hljs-type">char</span>* data;

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p)
    {
        <span class="hljs-type">size_t</span> size = std::<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>;
        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size];
        std::<span class="hljs-built_in">memcpy</span>(data, p, size);
    }
</code></pre>

<p>Since we chose to manage the memory ourselves, we need to follow the <a href="http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29" rel="noreferrer">rule of three</a>. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    ~<span class="hljs-built_in">string</span>()
    {
        <span class="hljs-keyword">delete</span>[] data;
    }

    <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; that)
    {
        <span class="hljs-type">size_t</span> size = std::<span class="hljs-built_in">strlen</span>(that.data) + <span class="hljs-number">1</span>;
        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size];
        std::<span class="hljs-built_in">memcpy</span>(data, that.data, size);
    }
</code></pre>

<p>The copy constructor defines what it means to copy string objects. The parameter <code>const string&amp; that</code> binds to all expressions of type string which allows you to make copies in the following examples:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">a</span><span class="hljs-params">(x)</span></span>;                                    <span class="hljs-comment">// Line 1</span>
<span class="hljs-function">string <span class="hljs-title">b</span><span class="hljs-params">(x + y)</span></span>;                                <span class="hljs-comment">// Line 2</span>
<span class="hljs-function">string <span class="hljs-title">c</span><span class="hljs-params">(some_function_returning_a_string())</span></span>;   <span class="hljs-comment">// Line 3</span>
</code></pre>

<p>Now comes the key insight into move semantics. Note that only in the first line where we copy <code>x</code> is this deep copy really necessary, because we might want to inspect <code>x</code> later and would be very surprised if <code>x</code> had changed somehow. Did you notice how I just said <code>x</code> three times (four times if you include this sentence) and meant the <em>exact same object</em> every time? We call expressions such as <code>x</code> "lvalues".</p>

<p>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of <code>b</code> and <code>c</code>, we could do whatever we wanted with the source string, and <em>the client couldn't tell a difference</em>!</p>

<p>C++0x introduces a new mechanism called "rvalue reference" which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do <em>anything we want</em> with the source, as long as we leave it in <em>some</em> valid state:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-built_in">string</span>(string&amp;&amp; that)   <span class="hljs-comment">// string&amp;&amp; is an rvalue reference to a string</span>
    {
        data = that.data;
        that.data = <span class="hljs-literal">nullptr</span>;
    }
</code></pre>

<p>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have "stolen" the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a "move constructor". Its job is to move resources from one object to another instead of copying them.</p>

<p>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">copy and swap idiom</a>, learn it and come back, because it's an awesome C++ idiom related to exception safety.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    string&amp; <span class="hljs-keyword">operator</span>=(string that)
    {
        std::<span class="hljs-built_in">swap</span>(data, that.data);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>

<p>Huh, that's it? "Where's the rvalue reference?" you might ask. "We don't need it here!" is my answer :)</p>

<p>Note that we pass the parameter <code>that</code> <em>by value</em>, so <code>that</code> has to be initialized just like any other string object. Exactly how is <code>that</code> going to be initialized? In the olden days of <a href="http://en.wikipedia.org/wiki/C++#Standardization" rel="noreferrer">C++98</a>, the answer would have been "by the copy constructor". In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</p>

<p>So if you say <code>a = b</code>, the <em>copy constructor</em> will initialize <code>that</code> (because the expression <code>b</code> is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</p>

<p>But if you say <code>a = x + y</code>, the <em>move constructor</em> will initialize <code>that</code> (because the expression <code>x + y</code> is an rvalue), so there is no deep copy involved, only an efficient move.
<code>that</code> is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because <code>x + y</code> is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</p>

<p>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to "nullify" the source object in this manner, because the client has no way of inspecting the object again.</p>

<p>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see <a href="https://stackoverflow.com/a/11540204/179917">my supplementary answer</a>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</p>

<p>Stephan T. Lavavej took the time to provide valuable feedback. Thank you very much, Stephan!</p>

<h2>Introduction</h2>

<p>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</p>

<ol>
<li><p>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cannot_benefit_from_move_semantics</span>
{
    <span class="hljs-type">int</span> a;        <span class="hljs-comment">// moving an int means copying an int</span>
    <span class="hljs-type">float</span> b;      <span class="hljs-comment">// moving a float means copying a float</span>
    <span class="hljs-type">double</span> c;     <span class="hljs-comment">// moving a double means copying a double</span>
    <span class="hljs-type">char</span> d[<span class="hljs-number">64</span>];   <span class="hljs-comment">// moving a char array means copying a char array</span>

    <span class="hljs-comment">// ...</span>
};
</code></pre></li>
<li><p>Implementing safe "move-only" types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses <code>std::auto_ptr</code>, a deprecated C++98 standard library template, which was replaced by <code>std::unique_ptr</code> in C++11. Intermediate C++ programmers are probably at least somewhat familiar with <code>std::auto_ptr</code>, and because of the "move semantics" it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</p></li>
</ol>

<h2>What is a move?</h2>

<p>The C++98 standard library offers a smart pointer with unique ownership semantics called <code>std::auto_ptr&lt;T&gt;</code>. In case you are unfamiliar with <code>auto_ptr</code>, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">{
    <span class="hljs-function">std::auto_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// arbitrary code, could throw exceptions</span>
    <span class="hljs-comment">// ...</span>
}   <span class="hljs-comment">// &lt;--- when a goes out of scope, the triangle is deleted automatically</span>
</code></pre>

<p>The unusual thing about <code>auto_ptr</code> is its "copying" behavior:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        |
        |
  +-----|---+
  |   +-|-+ |
a | p | | | |
  |   +---+ |
  +---------+

<span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        +----------------------+
                               |
  +---------+            +-----|---+
  |   +---+ |            |   +-|-+ |
a | p |   | |          b | p | | | |
  |   +---+ |            |   +---+ |
  +---------+            +---------+
</code></pre>

<p>Note how the initialization of <code>b</code> with <code>a</code> does <em>not</em> copy the triangle, but instead transfers the ownership of the triangle from <code>a</code> to <code>b</code>. We also say "<code>a</code> is <em>moved into</em> <code>b</code>" or "the triangle is <em>moved</em> from <code>a</code> <em>to</em> <code>b</code>". This may sound confusing because the triangle itself always stays at the same place in memory.</p>

<blockquote>
  <p>To move an object means to transfer ownership of some resource it manages to another object.</p>
</blockquote>

<p>The copy constructor of <code>auto_ptr</code> probably looks something like this (somewhat simplified):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">auto_ptr</span>(auto_ptr&amp; source)   <span class="hljs-comment">// note the missing const</span>
{
    p = source.p;
    source.p = <span class="hljs-number">0</span>;   <span class="hljs-comment">// now the source no longer owns the object</span>
}
</code></pre>

<h2>Dangerous and harmless moves</h2>

<p>The dangerous thing about <code>auto_ptr</code> is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from <code>auto_ptr</code> will invoke undefined behavior, so you have to be very careful not to use an <code>auto_ptr</code> after it has been moved from:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;   <span class="hljs-comment">// create triangle</span>
<span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;              <span class="hljs-comment">// move a into b</span>
<span class="hljs-type">double</span> area = a-&gt;<span class="hljs-built_in">area</span>();           <span class="hljs-comment">// undefined behavior</span>
</code></pre>

<p>But <code>auto_ptr</code> is not <em>always</em> dangerous. Factory functions are a perfectly fine use case for <code>auto_ptr</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">make_triangle</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">auto_ptr</span>&lt;Shape&gt;(<span class="hljs-keyword">new</span> Triangle);
}

<span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">c</span><span class="hljs-params">(make_triangle())</span></span>;      <span class="hljs-comment">// move temporary into c</span>
<span class="hljs-type">double</span> area = <span class="hljs-built_in">make_triangle</span>()-&gt;<span class="hljs-built_in">area</span>();   <span class="hljs-comment">// perfectly safe</span>
</code></pre>

<p>Note how both examples follow the same syntactic pattern:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">variable</span><span class="hljs-params">(expression)</span></span>;
<span class="hljs-type">double</span> area = expression-&gt;<span class="hljs-built_in">area</span>();
</code></pre>

<p>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions <code>a</code> and <code>make_triangle()</code>? Aren't they both of the same type? Indeed they are, but they have different <em>value categories</em>.</p>

<h2>Value categories</h2>

<p>Obviously, there must be some profound difference between the expression <code>a</code> which denotes an <code>auto_ptr</code> variable, and the expression <code>make_triangle()</code> which denotes the call of a function that returns an <code>auto_ptr</code> by value, thus creating a fresh temporary <code>auto_ptr</code> object every time it is called. <code>a</code> is an example of an <em>lvalue</em>, whereas <code>make_triangle()</code> is an example of an <em>rvalue</em>.</p>

<p>Moving from lvalues such as <code>a</code> is dangerous, because we could later try to call a member function via <code>a</code>, invoking undefined behavior. On the other hand, moving from rvalues such as <code>make_triangle()</code> is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write <code>make_triangle()</code> again, we get a <em>different</em> temporary. In fact, the moved-from temporary is already gone on the next line:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">auto_ptr&lt;Shape&gt; <span class="hljs-title">c</span><span class="hljs-params">(make_triangle())</span></span>;
                                  ^ the moved-from temporary dies right here
</code></pre>

<p>Note that the letters <code>l</code> and <code>r</code> have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues that cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</p>

<blockquote>
  <p>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</p>
</blockquote>

<h2>Rvalue references</h2>

<p>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues <em>explicit</em> at call site, so that we no longer move by accident.</p>

<p>C++11's answer to this problem is <em>rvalue references</em>. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is <code>X&amp;&amp;</code>. The good old reference <code>X&amp;</code> is now known as an <em>lvalue reference</em>. (Note that <code>X&amp;&amp;</code> is <em>not</em> a reference to a reference; there is no such thing in C++.)</p>

<p>If we throw <code>const</code> into the mix, we already have four different kinds of references. What kinds of expressions of type <code>X</code> can they bind to?</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">            lvalue   <span class="hljs-type">const</span> lvalue   rvalue   <span class="hljs-type">const</span> rvalue
---------------------------------------------------------              
X&amp;          yes
<span class="hljs-type">const</span> X&amp;    yes      yes            yes      yes
X&amp;&amp;                                 yes
<span class="hljs-type">const</span> X&amp;&amp;                           yes      yes
</code></pre>

<p>In practice, you can forget about <code>const X&amp;&amp;</code>. Being restricted to read from rvalues is not very useful.</p>

<blockquote>
  <p>An rvalue reference <code>X&amp;&amp;</code> is a new kind of reference that only binds to rvalues.</p>
</blockquote>

<h2>Implicit conversions</h2>

<p>Rvalue references went through several versions. Since version 2.1, an rvalue reference <code>X&amp;&amp;</code> also binds to all value categories of a different type <code>Y</code>, provided there is an implicit conversion from <code>Y</code> to <code>X</code>. In that case, a temporary of type <code>X</code> is created, and the rvalue reference is bound to that temporary:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">(std::string&amp;&amp; r)</span></span>;

<span class="hljs-built_in">some_function</span>(<span class="hljs-string">"hello world"</span>);
</code></pre>

<p>In the above example, <code>"hello world"</code> is an lvalue of type <code>const char[12]</code>. Since there is an implicit conversion from <code>const char[12]</code> through <code>const char*</code> to <code>std::string</code>, a temporary of type <code>std::string</code> is created, and <code>r</code> is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</p>

<h2>Move constructors</h2>

<p>A useful example of a function with an <code>X&amp;&amp;</code> parameter is the <em>move constructor</em> <code>X::X(X&amp;&amp; source)</code>. Its purpose is to transfer ownership of the managed resource from the source into the current object.</p>

<p>In C++11, <code>std::auto_ptr&lt;T&gt;</code> has been replaced by <code>std::unique_ptr&lt;T&gt;</code> which takes advantage of rvalue references. I will develop and discuss a simplified version of <code>unique_ptr</code>. First, we encapsulate a raw pointer and overload the operators <code>-&gt;</code> and <code>*</code>, so our class feels like a pointer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span>
{
    T* ptr;

<span class="hljs-keyword">public</span>:

    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>
    {
        <span class="hljs-keyword">return</span> ptr;
    }

    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>
    {
        <span class="hljs-keyword">return</span> *ptr;
    }
</code></pre>

<p>The constructor takes ownership of the object, and the destructor deletes it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_ptr</span><span class="hljs-params">(T* p = <span class="hljs-literal">nullptr</span>)</span>
    </span>{
        ptr = p;
    }

    ~<span class="hljs-built_in">unique_ptr</span>()
    {
        <span class="hljs-keyword">delete</span> ptr;
    }
</code></pre>

<p>Now comes the interesting part, the move constructor:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; source)   <span class="hljs-comment">// note the rvalue reference</span>
    {
        ptr = source.ptr;
        source.ptr = <span class="hljs-literal">nullptr</span>;
    }
</code></pre>

<p>This move constructor does exactly what the <code>auto_ptr</code> copy constructor did, but it can only be supplied with rvalues:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;
<span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;                 <span class="hljs-comment">// error</span>
<span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">c</span><span class="hljs-params">(make_triangle())</span></span>;   <span class="hljs-comment">// okay</span>
</code></pre>

<p>The second line fails to compile, because <code>a</code> is an lvalue, but the parameter <code>unique_ptr&amp;&amp; source</code> can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because <code>make_triangle()</code> is an rvalue. The move constructor will transfer ownership from the temporary to <code>c</code>. Again, this is exactly what we wanted.</p>

<blockquote>
  <p>The move constructor transfers ownership of a managed resource into the current object.</p>
</blockquote>

<h2>Move assignment operators</h2>

<p>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; source)   <span class="hljs-comment">// note the rvalue reference</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;source)    <span class="hljs-comment">// beware of self-assignment</span>
        {
            <span class="hljs-keyword">delete</span> ptr;         <span class="hljs-comment">// release the old resource</span>

            ptr = source.ptr;   <span class="hljs-comment">// acquire the new resource</span>
            source.ptr = <span class="hljs-literal">nullptr</span>;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>

<p>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr source)   <span class="hljs-comment">// note the missing reference</span>
    {
        std::<span class="hljs-built_in">swap</span>(ptr, source.ptr);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>

<p>Now that <code>source</code> is a variable of type <code>unique_ptr</code>, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of <code>operator=</code>, <code>source</code> goes out of scope, releasing the old resource automatically.</p>

<blockquote>
  <p>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</p>
</blockquote>

<h2>Moving from lvalues</h2>

<p>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called <code>std::move</code> inside the header <code>&lt;utility&gt;</code>.
This name is a bit unfortunate, because <code>std::move</code> simply casts an lvalue to an rvalue; it does <em>not</em> move anything by itself. It merely <em>enables</em> moving. Maybe it should have been named <code>std::cast_to_rvalue</code> or <code>std::enable_move</code>, but we are stuck with the name by now.</p>

<p>Here is how you explicitly move from an lvalue:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;
<span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;              <span class="hljs-comment">// still an error</span>
<span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">c</span><span class="hljs-params">(std::move(a))</span></span>;   <span class="hljs-comment">// okay</span>
</code></pre>

<p>Note that after the third line, <code>a</code> no longer owns a triangle. That's okay, because by <em>explicitly</em> writing <code>std::move(a)</code>, we made our intentions clear: "Dear constructor, do whatever you want with <code>a</code> in order to initialize <code>c</code>; I don't care about <code>a</code> anymore. Feel free to have your way with <code>a</code>."</p>

<blockquote>
  <p><code>std::move(some_lvalue)</code> casts an lvalue to an rvalue, thus enabling a subsequent move.</p>
</blockquote>

<h2>Xvalues</h2>

<p>Note that even though <code>std::move(a)</code> is an rvalue, its evaluation does <em>not</em> create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an <em>xvalue</em> (eXpiring value). The traditional rvalues were renamed to <em>prvalues</em> (Pure rvalues).</p>

<p>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both <em>glvalues</em> (Generalized lvalues). The relationships are easier to grasp with a diagram:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">        expressions
          /     \
         /       \
        /         \
    glvalues   rvalues
      /  \       /  \
     /    \     /    \
    /      \   /      \
lvalues   xvalues   prvalues
</code></pre>

<p>Note that only xvalues are really new; the rest is just due to renaming and grouping.</p>

<blockquote>
  <p>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of "rvalue" in the preceding paragraphs with "prvalue".</p>
</blockquote>

<h2>Moving out of functions</h2>

<p>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the <code>return</code> statement as an argument to the move constructor:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">make_triangle</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;Shape&gt;(<span class="hljs-keyword">new</span> Triangle);
}          \-----------------------------/
                  |
                  | temporary is moved into c
                  |
                  <span class="hljs-function">v
unique_ptr&lt;Shape&gt; <span class="hljs-title">c</span><span class="hljs-params">(make_triangle())</span></span>;
</code></pre>

<p>Perhaps surprisingly, automatic objects (local variables that are not declared as <code>static</code>) can also be <em>implicitly</em> moved out of functions:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">make_square</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Square)</span></span>;
    <span class="hljs-keyword">return</span> result;   <span class="hljs-comment">// note the missing std::move</span>
}
</code></pre>

<p>How come the move constructor accepts the lvalue <code>result</code> as an argument? The scope of <code>result</code> is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterward that <code>result</code> had changed somehow; when control flow is back at the caller, <code>result</code> does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write <code>std::move</code>. In fact, you should <em>never</em> use <code>std::move</code> to move automatic objects out of functions, as this inhibits the "named return value optimization" (NRVO).</p>

<blockquote>
  <p>Never use <code>std::move</code> to move automatic objects out of functions.</p>
</blockquote>

<p>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;Shape&gt;&amp;&amp; <span class="hljs-title">flawed_attempt</span><span class="hljs-params">()</span>   <span class="hljs-comment">// DO NOT DO THIS!</span>
</span>{
    <span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">very_bad_idea</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Square)</span></span>;
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(very_bad_idea);   <span class="hljs-comment">// WRONG!</span>
}
</code></pre>

<blockquote>
  <p>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by <code>std::move</code>, and not by merely binding an rvalue to an rvalue reference.</p>
</blockquote>

<h2>Moving into members</h2>

<p>Sooner or later, you are going to write code like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>
{
    unique_ptr&lt;Shape&gt; member;

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Foo</span>(unique_ptr&lt;Shape&gt;&amp;&amp; parameter)
    : <span class="hljs-built_in">member</span>(parameter)   <span class="hljs-comment">// error</span>
    {}
};
</code></pre>

<p>Basically, the compiler will complain that <code>parameter</code> is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means "a reference that is bound to an rvalue"; it does <em>not</em> mean that the reference itself is an rvalue! Indeed, <code>parameter</code> is just an ordinary variable with a name. You can use <code>parameter</code> as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</p>

<blockquote>
  <p>A named rvalue reference is an lvalue, just like any other variable.</p>
</blockquote>

<p>The solution is to manually enable the move:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>
{
    unique_ptr&lt;Shape&gt; member;

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Foo</span>(unique_ptr&lt;Shape&gt;&amp;&amp; parameter)
    : <span class="hljs-built_in">member</span>(std::<span class="hljs-built_in">move</span>(parameter))   <span class="hljs-comment">// note the std::move</span>
    {}
};
</code></pre>

<p>You could argue that <code>parameter</code> is not used anymore after the initialization of <code>member</code>. Why is there no special rule to silently insert <code>std::move</code> just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the <code>return</code> keyword denotes an automatic object.</p>

<p>You can also pass the <code>parameter</code> by value. For move-only types like <code>unique_ptr</code>, it seems there is no established idiom yet. Personally, I prefer to pass by value, as it causes less clutter in the interface.</p>

<h2>Special member functions</h2>

<p>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator, and the destructor.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">X::<span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;);              <span class="hljs-comment">// copy constructor</span>
X&amp; X::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> X&amp;);   <span class="hljs-comment">// copy assignment operator</span>
X::~<span class="hljs-built_in">X</span>();                     <span class="hljs-comment">// destructor</span>
</code></pre>

<p>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conforms to version 3.0 yet, so you will have to implement them yourself.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">X::<span class="hljs-built_in">X</span>(X&amp;&amp;);                   <span class="hljs-comment">// move constructor</span>
X&amp; X::<span class="hljs-keyword">operator</span>=(X&amp;&amp;);        <span class="hljs-comment">// move assignment operator</span>
</code></pre>

<p>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</p>

<p>What do these rules mean in practice?</p>

<blockquote>
  <p>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</p>
</blockquote>

<p>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X source)    <span class="hljs-comment">// unified assignment operator</span>
{
    <span class="hljs-built_in">swap</span>(source);            <span class="hljs-comment">// see my first answer for an explanation</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>

<p>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</p>

<h2>Forwarding references (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf" rel="noreferrer">previously</a> known as <em>Universal references</em>)</h2>

<p>Consider the following function template:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp;)</span></span>;
</code></pre>

<p>You might expect <code>T&amp;&amp;</code> to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, <code>T&amp;&amp;</code> also binds to lvalues:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">foo</span>(<span class="hljs-built_in">make_triangle</span>());   <span class="hljs-comment">// T is unique_ptr&lt;Shape&gt;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;&amp;</span>
<span class="hljs-function">unique_ptr&lt;Shape&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Triangle)</span></span>;
<span class="hljs-built_in">foo</span>(a);                 <span class="hljs-comment">// T is unique_ptr&lt;Shape&gt;&amp;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;</span>
</code></pre>

<p>If the argument is an rvalue of type <code>X</code>, <code>T</code> is deduced to be <code>X</code>, hence <code>T&amp;&amp;</code> means <code>X&amp;&amp;</code>. This is what anyone would expect.
But if the argument is an lvalue of type <code>X</code>, due to a special rule, <code>T</code> is deduced to be <code>X&amp;</code>, hence <code>T&amp;&amp;</code> would mean something like <code>X&amp; &amp;&amp;</code>. But since C++ still has no notion of references to references, the type <code>X&amp; &amp;&amp;</code> is <em>collapsed</em> into <code>X&amp;</code>. This may sound confusing and useless at first, but reference collapsing is essential for <em>perfect forwarding</em> (which will not be discussed here).</p>

<blockquote>
  <p>T&amp;&amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case <code>T</code> and <code>T&amp;&amp;</code> are both lvalue references.</p>
</blockquote>

<p>If you want to constrain a function template to rvalues, you can combine <a href="http://en.cppreference.com/w/cpp/language/sfinae" rel="noreferrer">SFINAE</a> with type traits:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value, <span class="hljs-type">void</span>&gt;::<span class="hljs-function">type
<span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp;)</span></span>;
</code></pre>

<h2>Implementation of move</h2>

<p>Now that you understand reference collapsing, here is how <code>std::move</code> is implemented:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp;
<span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
}
</code></pre>

<p>As you can see, <code>move</code> accepts any kind of parameter thanks to the forwarding reference <code>T&amp;&amp;</code>, and it returns an rvalue reference. The <code>std::remove_reference&lt;T&gt;::type</code> meta-function call is necessary because otherwise, for lvalues of type <code>X</code>, the return type would be <code>X&amp; &amp;&amp;</code>, which would collapse into <code>X&amp;</code>. Since <code>t</code> is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind <code>t</code> to an rvalue reference, we have to explicitly cast <code>t</code> to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</p>

<blockquote>
  <p>The call of a function that returns an rvalue reference, such as <code>std::move</code>, is an xvalue.</p>
</blockquote>

<p>Note that returning by rvalue reference is fine in this example, because <code>t</code> does not denote an automatic object, but instead an object that was passed in by the caller.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Suppose you have a function that returns a substantial object:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">Matrix <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix &amp;a, <span class="hljs-type">const</span> Matrix &amp;b)</span></span>;
</code></pre>

<p>When you write code like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Matrix r = <span class="hljs-built_in">multiply</span>(a, b);
</code></pre>

<p>then an ordinary C++ compiler will create a temporary object for the result of <code>multiply()</code>, call the copy constructor to initialise <code>r</code>, and then destruct the temporary return value. Move semantics in C++0x allow the "move constructor" to be called to initialise <code>r</code> by copying its contents, and then discard the temporary value without having to destruct it.</p>

<p>This is especially important if (like perhaps the <code>Matrix</code> example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the <code>Matrix</code> object.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Move semantics</strong> is about <strong>transferring resources rather than copying them</strong> when nobody needs the source value anymore.</p>

<p>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a functionunless RVO kicks inthe value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like <code>sort</code> that just rearrange items, reallocation in <code>vector</code> when its <code>capacity()</code> is exceeded, etc.</p>

<p>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, <code>vector&lt;string&gt;</code> may own a dynamically-allocated memory block containing an array of <code>string</code> objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  <em>Then</em> you need deallocate all that memory you just copied.  However, <em>moving</em> a large <code>vector&lt;string&gt;</code> means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm" rel="noreferrer">"A Proposal to Add Move Semantics Support to the C++ Language."</a>  </p>

<p>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/" rel="noreferrer">the WG21 website</a>, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In easy (practical) terms:</p>

<p>Copying an object means copying its "static" members and calling the <code>new</code> operator for its dynamic objects. Right?</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
{
   <span class="hljs-type">int</span> i, *p;

<span class="hljs-keyword">public</span>:
   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) : <span class="hljs-built_in">i</span>(a.i), <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*a.p)) {}
   ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> p; }
};
</code></pre>

<p>However, to <strong>move</strong> an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</p>

<p>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should "invalidate" the source pointers to avoid destructing them twice:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
{
   <span class="hljs-type">int</span> i, *p;

<span class="hljs-keyword">public</span>:
   <span class="hljs-comment">// Movement of an object inside a copy constructor.</span>
   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) : <span class="hljs-built_in">i</span>(a.i), <span class="hljs-built_in">p</span>(a.p)
   {
     a.p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// pointer invalidated.</span>
   }

   ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> p; }
   <span class="hljs-comment">// Deleting NULL, 0 or nullptr (address 0x0) is safe. </span>
};
</code></pre>

<p>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heavyFunction</span><span class="hljs-params">(HeavyType())</span></span>;
</code></pre>

<p>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</p>

<p>This leads to the concept of an "rvalue" reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an "lvalue" is an assignable entity (the left part of the <code>=</code> operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
{
   <span class="hljs-type">int</span> i, *p;

<span class="hljs-keyword">public</span>:
   <span class="hljs-comment">// Copy</span>
   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) : <span class="hljs-built_in">i</span>(a.i), <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*a.p)) {}

   <span class="hljs-comment">// Movement (&amp;&amp; means "rvalue reference to")</span>
   <span class="hljs-built_in">A</span>(A&amp;&amp; a) : <span class="hljs-built_in">i</span>(a.i), <span class="hljs-built_in">p</span>(a.p)
   {
      a.p = <span class="hljs-literal">nullptr</span>;
   }

   ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> p; }
};
</code></pre>

<p>In this case, when an object of type <code>A</code> should be "copied", the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</p>

<p>It is important to remember that "static" objects are always copied. There's no ways to "move" a static object (object in stack and not on heap). So, the distinction "move"/ "copy" when an object has no dynamic members (directly or indirectly) is irrelevant.</p>

<p>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Heavy</span>
{
   <span class="hljs-type">bool</span> b_moved;
   <span class="hljs-comment">// staff</span>

<span class="hljs-keyword">public</span>:
   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) { <span class="hljs-comment">/* definition */</span> }
   <span class="hljs-built_in">A</span>(A&amp;&amp; a) : <span class="hljs-comment">// initialization list</span>
   {
      a.b_moved = <span class="hljs-literal">true</span>;
   }

   ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">if</span> (!b_moved) <span class="hljs-comment">/* destruct object */</span> }
};
</code></pre>

<p>So, your code is shorter (you don't need to do a <code>nullptr</code> assignment for each dynamic member) and more general.</p>

<p>Other typical question: what is the difference between <code>A&amp;&amp;</code> and <code>const A&amp;&amp;</code>? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</p>

<p>And what is <strong>perfect forwarding</strong>? It is important to know that a "rvalue reference" is a reference to a named object in the "caller's scope". But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">(A&amp;&amp; a)</span>
</span>{
   <span class="hljs-built_in">other_function</span>(a);
}
</code></pre>

<p>The object <code>a</code> would be copied to the actual parameter of <code>other_function</code>. If you want the object <code>a</code> continues being treated as a temporary object, you should use the <code>std::move</code> function:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">other_function</span>(std::<span class="hljs-built_in">move</span>(a));
</code></pre>

<p>With this line, <code>std::move</code> will cast <code>a</code> to an rvalue and <code>other_function</code> will receive the object as a unnamed object. Of course, if <code>other_function</code> has not specific overloading to work with unnamed objects, this distinction is not important.</p>

<p>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">(T&amp;&amp; a)</span>
</span>{
   <span class="hljs-built_in">other_function</span>(std::forward&lt;T&gt;(a));
}
</code></pre>

<p>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of <code>std::forward</code>. This function exploits some rules of template instantiation:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> `A&amp; &amp;&amp; == A&amp;`
 `A&amp;&amp; &amp;&amp; == A&amp;&amp;`
</code></pre>

<p>So, if <code>T</code> is a lvalue reference to <code>A</code> (<strong>T</strong> = A&amp;), <code>a</code> also (<strong>A&amp;</strong> &amp;&amp; =&gt; A&amp;). If <code>T</code> is a rvalue reference to <code>A</code>, <code>a</code> also (A&amp;&amp; &amp;&amp; =&gt; A&amp;&amp;). In both cases, <code>a</code> is a named object in the actual scope, but <code>T</code> contains the information of its "reference type" from the caller scope's point of view. This information (<code>T</code>) is passed as template parameter to <code>forward</code> and 'a' is moved or not according to the type of <code>T</code>.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being "moved" from.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp; assignment operator or the compiler generates them implicitly. This will do a copy.</p>

<p>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;&amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</p>

<p>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;foo&gt; <span class="hljs-title">get_foos</span><span class="hljs-params">()</span></span>;
</code></pre>

<p>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm writing this to make sure I understand it properly.</p>

<p>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book "The C++ Programming Language" uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</p>

<p>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A "move assignment" allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</p>

<p>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead "reuse" the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</p>

<p>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To illustrate the need for <em>move semantics</em>, let's consider this example without move semantics:</p>

<p>Here's a function that takes an object of type <code>T</code> and returns an object of the same type <code>T</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">T <span class="hljs-title">f</span><span class="hljs-params">(T o)</span> </span>{ <span class="hljs-keyword">return</span> o; }
  <span class="hljs-comment">//^^^ new object constructed</span>
</code></pre>

<p>The above function uses <em>call by value</em> which means that when this function is called an object must be <em>constructed</em> to be used by the function.<br>
Because the function also <em>returns by value</em>, another new object is constructed for the return value:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T b = <span class="hljs-built_in">f</span>(a);
  <span class="hljs-comment">//^ new object constructed</span>
</code></pre>

<p><strong>Two</strong> new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</p>

<p>When the new object is created from the return value, the copy constructor is called to <em>copy</em> the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</p>

<hr>

<p>Now, let's consider what a <em>copy constructor</em> does.</p>

<p>It must first initialize the object, then copy all the relevant data from the old object to the new one.<br>
Depending on the class, maybe its a container with very much data, then that could represent much <em>time</em> and <em>memory usage</em> </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Copy constructor</span>
T::<span class="hljs-built_in">T</span>(T &amp;old) {
    <span class="hljs-built_in">copy_data</span>(m_a, old.m_a);
    <span class="hljs-built_in">copy_data</span>(m_b, old.m_b);
    <span class="hljs-built_in">copy_data</span>(m_c, old.m_c);
}
</code></pre>

<p>With <strong>move semantics</strong> it's now possible to make most of this work less unpleasant by simply <em>moving</em> the data rather than copying.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Move constructor</span>
T::<span class="hljs-built_in">T</span>(T &amp;&amp;old) <span class="hljs-keyword">noexcept</span> {
    m_a = std::<span class="hljs-built_in">move</span>(old.m_a);
    m_b = std::<span class="hljs-built_in">move</span>(old.m_b);
    m_c = std::<span class="hljs-built_in">move</span>(old.m_c);
}
</code></pre>

<p>Moving the data involves re-associating the data with the new object. And <em>no copy takes place</em> at all.</p>

<p>This is accomplished with an <code>rvalue</code> reference.<br>
An <code>rvalue</code> reference works pretty much like an <code>lvalue</code> reference with one important difference: <br>
an <em>rvalue reference can be moved</em> and an <em>lvalue</em> cannot.</p>

<p>From <a href="http://en.cppreference.com/w/cpp/language/move_constructor" rel="noreferrer">cppreference.com</a>:</p>

<blockquote>
  <p>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;&amp;).</p>
</blockquote>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's <a href="https://www.youtube.com/watch?v=06HKceSDiKE&amp;t=135s" rel="nofollow noreferrer">an answer</a> from the book "The C++ Programming Language" by Bjarne Stroustrup. If you don't want to see the video, you can see the text below:</p>

<p>Consider this snippet. Returning from an operator+ involves copying the result out of the local variable <code>res</code> and into someplace where the caller can access it. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Vector <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector&amp; a, <span class="hljs-type">const</span> Vector&amp; b)
{
    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())
        <span class="hljs-keyword">throw</span> Vector_siz e_mismatch{};
    <span class="hljs-function">Vector <span class="hljs-title">res</span><span class="hljs-params">(a.size())</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i!=a.<span class="hljs-built_in">size</span>(); ++i)
            res[i]=a[i]+b[i];
    <span class="hljs-keyword">return</span> res;
}
</code></pre>

<p>We didnt really want a copy; we just wanted to get the result out of a function. So we need to move a Vector rather than to copy it. We can define move constructor as follows:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">const</span> Vector&amp; a); <span class="hljs-comment">// copy constructor</span>
    Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; a); <span class="hljs-comment">// copy assignment</span>
    <span class="hljs-built_in">Vector</span>(Vector&amp;&amp; a); <span class="hljs-comment">// move constructor</span>
    Vector&amp; <span class="hljs-keyword">operator</span>=(Vector&amp;&amp; a); <span class="hljs-comment">// move assignment</span>
};

Vector::<span class="hljs-built_in">Vector</span>(Vector&amp;&amp; a)
    :elem{a.elem}, <span class="hljs-comment">// "grab the elements" from a</span>
    sz{a.sz}
{
    a.elem = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// now a has no elements</span>
    a.sz = <span class="hljs-number">0</span>;
}
</code></pre>

<p>The &amp;&amp; means "rvalue reference" and is a reference to which we can bind an rvalue. "rvalue" is intended to complement "lvalue" which roughly means "something that can appear on the left-hand side of an assignment." So an rvalue means roughly "a value that you cant assign to", such as an integer returned by a function call, and the <code>res</code> local variable in operator+() for Vectors. </p>

<p>Now, the statement <code>return res;</code> will not copy!</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;I find it easiest to understand move semantics with example code. Let\u0026apos;s start with a very simple string class which only holds a pointer to a heap-allocated block of memory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;cstring\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* data;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* p)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(p) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[size];\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memcpy\u0026lt;/span\u0026gt;(data, p, size);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since we chose to manage the memory ourselves, we need to follow the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;rule of three\u0026lt;/a\u0026gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] data;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; that)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(that.data) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        data = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[size];\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memcpy\u0026lt;/span\u0026gt;(data, that.data, size);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The copy constructor defines what it means to copy string objects. The parameter \u0026lt;code\u0026gt;const string\u0026amp;amp; that\u0026lt;/code\u0026gt; binds to all expressions of type string which allows you to make copies in the following examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(x)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;                                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Line 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(x + y)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Line 2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(some_function_returning_a_string())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Line 3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now comes the key insight into move semantics. Note that only in the first line where we copy \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is this deep copy really necessary, because we might want to inspect \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; later and would be very surprised if \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; had changed somehow. Did you notice how I just said \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; three times (four times if you include this sentence) and meant the \u0026lt;em\u0026gt;exact same object\u0026lt;/em\u0026gt; every time? We call expressions such as \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; \u0026quot;lvalues\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.\nrvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;, we could do whatever we wanted with the source string, and \u0026lt;em\u0026gt;the client couldn\u0026apos;t tell a difference\u0026lt;/em\u0026gt;!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C++0x introduces a new mechanism called \u0026quot;rvalue reference\u0026quot; which, among other things,\nallows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do \u0026lt;em\u0026gt;anything we want\u0026lt;/em\u0026gt; with the source, as long as we leave it in \u0026lt;em\u0026gt;some\u0026lt;/em\u0026gt; valid state:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(string\u0026amp;amp;\u0026amp;amp; that)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// string\u0026amp;amp;\u0026amp;amp; is an rvalue reference to a string\u0026lt;/span\u0026gt;\n    {\n        data = that.data;\n        that.data = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent \u0026apos;delete[]\u0026apos; from source object\u0026apos;s destructor from releasing our \u0026apos;just stolen data\u0026apos;). In effect, we have \u0026quot;stolen\u0026quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don\u0026apos;t really do a copy here, we call this constructor a \u0026quot;move constructor\u0026quot;. Its job is to move resources from one object to another instead of copying them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Congratulations, you now understand the basics of move semantics! Let\u0026apos;s continue by implementing the assignment operator. If you\u0026apos;re unfamiliar with the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\u0026quot;\u0026gt;copy and swap idiom\u0026lt;/a\u0026gt;, learn it and come back, because it\u0026apos;s an awesome C++ idiom related to exception safety.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    string\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(string that)\n    {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(data, that.data);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Huh, that\u0026apos;s it? \u0026quot;Where\u0026apos;s the rvalue reference?\u0026quot; you might ask. \u0026quot;We don\u0026apos;t need it here!\u0026quot; is my answer :)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that we pass the parameter \u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;, so \u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; has to be initialized just like any other string object. Exactly how is \u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; going to be initialized? In the olden days of \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/C++#Standardization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++98\u0026lt;/a\u0026gt;, the answer would have been \u0026quot;by the copy constructor\u0026quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if you say \u0026lt;code\u0026gt;a = b\u0026lt;/code\u0026gt;, the \u0026lt;em\u0026gt;copy constructor\u0026lt;/em\u0026gt; will initialize \u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; (because the expression \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But if you say \u0026lt;code\u0026gt;a = x + y\u0026lt;/code\u0026gt;, the \u0026lt;em\u0026gt;move constructor\u0026lt;/em\u0026gt; will initialize \u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; (because the expression \u0026lt;code\u0026gt;x + y\u0026lt;/code\u0026gt; is an rvalue), so there is no deep copy involved, only an efficient move.\n\u0026lt;code\u0026gt;that\u0026lt;/code\u0026gt; is still an independent object from the argument, but its construction was trivial,\nsince the heap data didn\u0026apos;t have to be copied, just moved. It wasn\u0026apos;t necessary to copy it because \u0026lt;code\u0026gt;x + y\u0026lt;/code\u0026gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize, the copy constructor makes a deep copy, because the source must remain untouched.\nThe move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to \u0026quot;nullify\u0026quot; the source object in this manner, because the client has no way of inspecting the object again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/11540204/179917\u0026quot;\u0026gt;my supplementary answer\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.\nHowever, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.\nThe first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Stephan T. Lavavej took the time to provide valuable feedback. Thank you very much, Stephan!\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Introduction\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Move semantics allows an object, under certain conditions, to take ownership of some other object\u0026apos;s external resources. This is important in two ways:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;cannot_benefit_from_move_semantics\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// moving an int means copying an int\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; b;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// moving a float means copying a float\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; c;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// moving a double means copying a double\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; d[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;64\u0026lt;/span\u0026gt;];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// moving a char array means copying a char array\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Implementing safe \u0026quot;move-only\u0026quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;, a deprecated C++98 standard library template, which was replaced by \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;, and because of the \u0026quot;move semantics\u0026quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;h2\u0026gt;What is a move?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The C++98 standard library offers a smart pointer with unique ownership semantics called \u0026lt;code\u0026gt;std::auto_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;. In case you are unfamiliar with \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// arbitrary code, could throw exceptions\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n}   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026amp;lt;--- when a goes out of scope, the triangle is deleted automatically\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The unusual thing about \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; is its \u0026quot;copying\u0026quot; behavior:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n      +---------------+\n      | triangle data |\n      +---------------+\n        ^\n        |\n        |\n        |\n  +-----|---+\n  |   +-|-+ |\na | p | | | |\n  |   +---+ |\n  +---------+\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n      +---------------+\n      | triangle data |\n      +---------------+\n        ^\n        |\n        +----------------------+\n                               |\n  +---------+            +-----|---+\n  |   +---+ |            |   +-|-+ |\na | p |   | |          b | p | | | |\n  |   +---+ |            |   +---+ |\n  +---------+            +---------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note how the initialization of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; copy the triangle, but instead transfers the ownership of the triangle from \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;. We also say \u0026quot;\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;moved into\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;\u0026quot; or \u0026quot;the triangle is \u0026lt;em\u0026gt;moved\u0026lt;/em\u0026gt; from \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;to\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;\u0026quot;. This may sound confusing because the triangle itself always stays at the same place in memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;To move an object means to transfer ownership of some resource it manages to another object.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The copy constructor of \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; probably looks something like this (somewhat simplified):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;auto_ptr\u0026lt;/span\u0026gt;(auto_ptr\u0026amp;amp; source)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the missing const\u0026lt;/span\u0026gt;\n{\n    p = source.p;\n    source.p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now the source no longer owns the object\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Dangerous and harmless moves\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The dangerous thing about \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; will invoke undefined behavior, so you have to be very careful not to use an \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; after it has been moved from:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create triangle\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move a into b\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; area = a-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;area\u0026lt;/span\u0026gt;();           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined behavior\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; is not \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; dangerous. Factory functions are a perfectly fine use case for \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;make_triangle\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;auto_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;Shape\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(make_triangle())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move temporary into c\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; area = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_triangle\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;area\u0026lt;/span\u0026gt;();   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// perfectly safe\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note how both examples follow the same syntactic pattern:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;variable\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(expression)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; area = expression-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;area\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt;? Aren\u0026apos;t they both of the same type? Indeed they are, but they have different \u0026lt;em\u0026gt;value categories\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Value categories\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, there must be some profound difference between the expression \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; which denotes an \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; variable, and the expression \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt; which denotes the call of a function that returns an \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; by value, thus creating a fresh temporary \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; object every time it is called. \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is an example of an \u0026lt;em\u0026gt;lvalue\u0026lt;/em\u0026gt;, whereas \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt; is an example of an \u0026lt;em\u0026gt;rvalue\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Moving from lvalues such as \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is dangerous, because we could later try to call a member function via \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, invoking undefined behavior. On the other hand, moving from rvalues such as \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt; again, we get a \u0026lt;em\u0026gt;different\u0026lt;/em\u0026gt; temporary. In fact, the moved-from temporary is already gone on the next line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;auto_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(make_triangle())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n                                  ^ the moved-from temporary dies right here\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the letters \u0026lt;code\u0026gt;l\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;r\u0026lt;/code\u0026gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues that cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An rvalue of class type is an expression whose evaluation creates a temporary object.\n  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Rvalue references\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues \u0026lt;em\u0026gt;explicit\u0026lt;/em\u0026gt; at call site, so that we no longer move by accident.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C++11\u0026apos;s answer to this problem is \u0026lt;em\u0026gt;rvalue references\u0026lt;/em\u0026gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;. The good old reference \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026lt;/code\u0026gt; is now known as an \u0026lt;em\u0026gt;lvalue reference\u0026lt;/em\u0026gt;. (Note that \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a reference to a reference; there is no such thing in C++.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we throw \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; into the mix, we already have four different kinds of references. What kinds of expressions of type \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt; can they bind to?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;            lvalue   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; lvalue   rvalue   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; rvalue\n---------------------------------------------------------              \nX\u0026amp;amp;          yes\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp;    yes      yes            yes      yes\nX\u0026amp;amp;\u0026amp;amp;                                 yes\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp;\u0026amp;amp;                           yes      yes\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In practice, you can forget about \u0026lt;code\u0026gt;const X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;. Being restricted to read from rvalues is not very useful.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An rvalue reference \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; is a new kind of reference that only binds to rvalues.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Implicit conversions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Rvalue references went through several versions. Since version 2.1, an rvalue reference \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; also binds to all value categories of a different type \u0026lt;code\u0026gt;Y\u0026lt;/code\u0026gt;, provided there is an implicit conversion from \u0026lt;code\u0026gt;Y\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt;. In that case, a temporary of type \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt; is created, and the rvalue reference is bound to that temporary:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string\u0026amp;amp;\u0026amp;amp; r)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the above example, \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt; is an lvalue of type \u0026lt;code\u0026gt;const char[12]\u0026lt;/code\u0026gt;. Since there is an implicit conversion from \u0026lt;code\u0026gt;const char[12]\u0026lt;/code\u0026gt; through \u0026lt;code\u0026gt;const char*\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;, a temporary of type \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt; is created, and \u0026lt;code\u0026gt;r\u0026lt;/code\u0026gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Move constructors\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;A useful example of a function with an \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; parameter is the \u0026lt;em\u0026gt;move constructor\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;X::X(X\u0026amp;amp;\u0026amp;amp; source)\u0026lt;/code\u0026gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C++11, \u0026lt;code\u0026gt;std::auto_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; has been replaced by \u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of \u0026lt;code\u0026gt;unique_ptr\u0026lt;/code\u0026gt;. First, we encapsulate a raw pointer and overload the operators \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt;, so our class feels like a pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;unique_ptr\u0026lt;/span\u0026gt;\n{\n    T* ptr;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    T* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ptr;\n    }\n\n    T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *ptr;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The constructor takes ownership of the object, and the destructor deletes it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;explicit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;unique_ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* p = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        ptr = p;\n    }\n\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;unique_ptr\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; ptr;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now comes the interesting part, the move constructor:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;unique_ptr\u0026lt;/span\u0026gt;(unique_ptr\u0026amp;amp;\u0026amp;amp; source)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the rvalue reference\u0026lt;/span\u0026gt;\n    {\n        ptr = source.ptr;\n        source.ptr = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This move constructor does exactly what the \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; copy constructor did, but it can only be supplied with rvalues:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(make_triangle())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// okay\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The second line fails to compile, because \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is an lvalue, but the parameter \u0026lt;code\u0026gt;unique_ptr\u0026amp;amp;\u0026amp;amp; source\u0026lt;/code\u0026gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because \u0026lt;code\u0026gt;make_triangle()\u0026lt;/code\u0026gt; is an rvalue. The move constructor will transfer ownership from the temporary to \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;. Again, this is exactly what we wanted.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The move constructor transfers ownership of a managed resource into the current object.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Move assignment operators\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    unique_ptr\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(unique_ptr\u0026amp;amp;\u0026amp;amp; source)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the rvalue reference\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; != \u0026amp;amp;source)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// beware of self-assignment\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; ptr;         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// release the old resource\u0026lt;/span\u0026gt;\n\n            ptr = source.ptr;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// acquire the new resource\u0026lt;/span\u0026gt;\n            source.ptr = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    unique_ptr\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(unique_ptr source)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the missing reference\u0026lt;/span\u0026gt;\n    {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(ptr, source.ptr);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now that \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt; is a variable of type \u0026lt;code\u0026gt;unique_ptr\u0026lt;/code\u0026gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt; goes out of scope, releasing the old resource automatically.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.\n  The move-and-swap idiom simplifies the implementation.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Moving from lvalues\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.\nFor this purpose, C++11 offers a standard library function template called \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; inside the header \u0026lt;code\u0026gt;\u0026amp;lt;utility\u0026amp;gt;\u0026lt;/code\u0026gt;.\nThis name is a bit unfortunate, because \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; simply casts an lvalue to an rvalue; it does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; move anything by itself. It merely \u0026lt;em\u0026gt;enables\u0026lt;/em\u0026gt; moving. Maybe it should have been named \u0026lt;code\u0026gt;std::cast_to_rvalue\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::enable_move\u0026lt;/code\u0026gt;, but we are stuck with the name by now.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is how you explicitly move from an lvalue:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// still an error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::move(a))\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// okay\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that after the third line, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; no longer owns a triangle. That\u0026apos;s okay, because by \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt; writing \u0026lt;code\u0026gt;std::move(a)\u0026lt;/code\u0026gt;, we made our intentions clear: \u0026quot;Dear constructor, do whatever you want with \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; in order to initialize \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;; I don\u0026apos;t care about \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; anymore. Feel free to have your way with \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::move(some_lvalue)\u0026lt;/code\u0026gt; casts an lvalue to an rvalue, thus enabling a subsequent move.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Xvalues\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Note that even though \u0026lt;code\u0026gt;std::move(a)\u0026lt;/code\u0026gt; is an rvalue, its evaluation does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an \u0026lt;em\u0026gt;xvalue\u0026lt;/em\u0026gt; (eXpiring value). The traditional rvalues were renamed to \u0026lt;em\u0026gt;prvalues\u0026lt;/em\u0026gt; (Pure rvalues).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Both prvalues and xvalues are rvalues. Xvalues and lvalues are both \u0026lt;em\u0026gt;glvalues\u0026lt;/em\u0026gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;        expressions\n          /     \\\n         /       \\\n        /         \\\n    glvalues   rvalues\n      /  \\       /  \\\n     /    \\     /    \\\n    /      \\   /      \\\nlvalues   xvalues   prvalues\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that only xvalues are really new; the rest is just due to renaming and grouping.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of \u0026quot;rvalue\u0026quot; in the preceding paragraphs with \u0026quot;prvalue\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Moving out of functions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the \u0026lt;code\u0026gt;return\u0026lt;/code\u0026gt; statement as an argument to the move constructor:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;make_triangle\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;unique_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;Shape\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle);\n}          \\-----------------------------/\n                  |\n                  | temporary is moved into c\n                  |\n                  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;v\nunique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(make_triangle())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Perhaps surprisingly, automatic objects (local variables that are not declared as \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt;) can also be \u0026lt;em\u0026gt;implicitly\u0026lt;/em\u0026gt; moved out of functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;make_square\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Square)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the missing std::move\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;How come the move constructor accepts the lvalue \u0026lt;code\u0026gt;result\u0026lt;/code\u0026gt; as an argument? The scope of \u0026lt;code\u0026gt;result\u0026lt;/code\u0026gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterward that \u0026lt;code\u0026gt;result\u0026lt;/code\u0026gt; had changed somehow; when control flow is back at the caller, \u0026lt;code\u0026gt;result\u0026lt;/code\u0026gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt;. In fact, you should \u0026lt;em\u0026gt;never\u0026lt;/em\u0026gt; use \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; to move automatic objects out of functions, as this inhibits the \u0026quot;named return value optimization\u0026quot; (NRVO).\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Never use \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; to move automatic objects out of functions.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;flawed_attempt\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// DO NOT DO THIS!\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;very_bad_idea\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Square)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(very_bad_idea);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// WRONG!\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt;, and not by merely binding an rvalue to an rvalue reference.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Moving into members\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Sooner or later, you are going to write code like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    unique_ptr\u0026amp;lt;Shape\u0026amp;gt; member;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;\u0026amp;amp; parameter)\n    : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;(parameter)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n    {}\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, the compiler will complain that \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means \u0026quot;a reference that is bound to an rvalue\u0026quot;; it does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; mean that the reference itself is an rvalue! Indeed, \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; is just an ordinary variable with a name. You can use \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A named rvalue reference is an lvalue, just like any other variable.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The solution is to manually enable the move:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    unique_ptr\u0026amp;lt;Shape\u0026amp;gt; member;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;\u0026amp;amp; parameter)\n    : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(parameter))   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the std::move\u0026lt;/span\u0026gt;\n    {}\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You could argue that \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; is not used anymore after the initialization of \u0026lt;code\u0026gt;member\u0026lt;/code\u0026gt;. Why is there no special rule to silently insert \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the \u0026lt;code\u0026gt;return\u0026lt;/code\u0026gt; keyword denotes an automatic object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can also pass the \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; by value. For move-only types like \u0026lt;code\u0026gt;unique_ptr\u0026lt;/code\u0026gt;, it seems there is no established idiom yet. Personally, I prefer to pass by value, as it causes less clutter in the interface.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Special member functions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator, and the destructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;X::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp;);              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy constructor\u0026lt;/span\u0026gt;\nX\u0026amp;amp; X::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp;);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy assignment operator\u0026lt;/span\u0026gt;\nX::~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;();                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// destructor\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conforms to version 3.0 yet, so you will have to implement them yourself.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;X::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(X\u0026amp;amp;\u0026amp;amp;);                   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move constructor\u0026lt;/span\u0026gt;\nX\u0026amp;amp; X::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(X\u0026amp;amp;\u0026amp;amp;);        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move assignment operator\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What do these rules mean in practice?\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;X\u0026amp;amp; X::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(X source)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// unified assignment operator\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(source);            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// see my first answer for an explanation\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Forwarding references (\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;previously\u0026lt;/a\u0026gt; known as \u0026lt;em\u0026gt;Universal references\u0026lt;/em\u0026gt;)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following function template:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp;\u0026amp;amp;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might expect \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; also binds to lvalues:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_triangle\u0026lt;/span\u0026gt;());   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// T is unique_ptr\u0026amp;lt;Shape\u0026amp;gt;, T\u0026amp;amp;\u0026amp;amp; is unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;Shape\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Triangle)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(a);                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// T is unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;, T\u0026amp;amp;\u0026amp;amp; is unique_ptr\u0026amp;lt;Shape\u0026amp;gt;\u0026amp;amp;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If the argument is an rvalue of type \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is deduced to be \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt;, hence \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; means \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;. This is what anyone would expect.\nBut if the argument is an lvalue of type \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt;, due to a special rule, \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is deduced to be \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026lt;/code\u0026gt;, hence \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; would mean something like \u0026lt;code\u0026gt;X\u0026amp;amp; \u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;. But since C++ still has no notion of references to references, the type \u0026lt;code\u0026gt;X\u0026amp;amp; \u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;collapsed\u0026lt;/em\u0026gt; into \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026lt;/code\u0026gt;. This may sound confusing and useless at first, but reference collapsing is essential for \u0026lt;em\u0026gt;perfect forwarding\u0026lt;/em\u0026gt; (which will not be discussed here).\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;T\u0026amp;amp;\u0026amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; are both lvalue references.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;If you want to constrain a function template to rvalues, you can combine \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/language/sfinae\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SFINAE\u0026lt;/a\u0026gt; with type traits:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;std::is_rvalue_reference\u0026amp;lt;T\u0026amp;amp;\u0026amp;amp;\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp;\u0026amp;amp;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Implementation of move\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now that you understand reference collapsing, here is how \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; is implemented:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\u0026amp;amp;\u0026amp;amp;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp;\u0026amp;amp; t)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type\u0026amp;amp;\u0026amp;amp;\u0026amp;gt;(t);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see, \u0026lt;code\u0026gt;move\u0026lt;/code\u0026gt; accepts any kind of parameter thanks to the forwarding reference \u0026lt;code\u0026gt;T\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, and it returns an rvalue reference. The \u0026lt;code\u0026gt;std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type\u0026lt;/code\u0026gt; meta-function call is necessary because otherwise, for lvalues of type \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt;, the return type would be \u0026lt;code\u0026gt;X\u0026amp;amp; \u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, which would collapse into \u0026lt;code\u0026gt;X\u0026amp;amp;\u0026lt;/code\u0026gt;. Since \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; to an rvalue reference, we have to explicitly cast \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; to the correct return type.\nThe call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The call of a function that returns an rvalue reference, such as \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt;, is an xvalue.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Note that returning by rvalue reference is fine in this example, because \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; does not denote an automatic object, but instead an object that was passed in by the caller.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Suppose you have a function that returns a substantial object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Matrix \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;multiply\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Matrix \u0026amp;amp;a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Matrix \u0026amp;amp;b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When you write code like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Matrix r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;multiply\u0026lt;/span\u0026gt;(a, b);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then an ordinary C++ compiler will create a temporary object for the result of \u0026lt;code\u0026gt;multiply()\u0026lt;/code\u0026gt;, call the copy constructor to initialise \u0026lt;code\u0026gt;r\u0026lt;/code\u0026gt;, and then destruct the temporary return value. Move semantics in C++0x allow the \u0026quot;move constructor\u0026quot; to be called to initialise \u0026lt;code\u0026gt;r\u0026lt;/code\u0026gt; by copying its contents, and then discard the temporary value without having to destruct it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is especially important if (like perhaps the \u0026lt;code\u0026gt;Matrix\u0026lt;/code\u0026gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the \u0026lt;code\u0026gt;Matrix\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Move semantics\u0026lt;/strong\u0026gt; is about \u0026lt;strong\u0026gt;transferring resources rather than copying them\u0026lt;/strong\u0026gt; when nobody needs the source value anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a functionunless RVO kicks inthe value you\u0026apos;re returning is copied to the caller\u0026apos;s stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like \u0026lt;code\u0026gt;sort\u0026lt;/code\u0026gt; that just rearrange items, reallocation in \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; when its \u0026lt;code\u0026gt;capacity()\u0026lt;/code\u0026gt; is exceeded, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When such copy/destroy pairs are expensive, it\u0026apos;s typically because the object owns some heavyweight resource. For example, \u0026lt;code\u0026gt;vector\u0026amp;lt;string\u0026amp;gt;\u0026lt;/code\u0026gt; may own a dynamically-allocated memory block containing an array of \u0026lt;code\u0026gt;string\u0026lt;/code\u0026gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  \u0026lt;em\u0026gt;Then\u0026lt;/em\u0026gt; you need deallocate all that memory you just copied.  However, \u0026lt;em\u0026gt;moving\u0026lt;/em\u0026gt; a large \u0026lt;code\u0026gt;vector\u0026amp;lt;string\u0026amp;gt;\u0026lt;/code\u0026gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are really interested in a good, in-depth explanation of move semantics, I\u0026apos;d highly recommend reading the original paper on them, \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;A Proposal to Add Move Semantics Support to the C++ Language.\u0026quot;\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the WG21 website\u0026lt;/a\u0026gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn\u0026apos;t get very much into the gritty language details.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In easy (practical) terms:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Copying an object means copying its \u0026quot;static\u0026quot; members and calling the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator for its dynamic objects. Right?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, *p;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(a.i), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*a.p)) {}\n   ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; p; }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, to \u0026lt;strong\u0026gt;move\u0026lt;/strong\u0026gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should \u0026quot;invalidate\u0026quot; the source pointers to avoid destructing them twice:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, *p;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Movement of an object inside a copy constructor.\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(a.i), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;(a.p)\n   {\n     a.p = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer invalidated.\u0026lt;/span\u0026gt;\n   }\n\n   ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; p; }\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Deleting NULL, 0 or nullptr (address 0x0) is safe. \u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that\u0026apos;s very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;heavyFunction\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(HeavyType())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don\u0026apos;t need the anonymous object and you can save time and memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This leads to the concept of an \u0026quot;rvalue\u0026quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an \u0026quot;lvalue\u0026quot; is an assignable entity (the left part of the \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, *p;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(a.i), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*a.p)) {}\n\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Movement (\u0026amp;amp;\u0026amp;amp; means \u0026quot;rvalue reference to\u0026quot;)\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(A\u0026amp;amp;\u0026amp;amp; a) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(a.i), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;(a.p)\n   {\n      a.p = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n   }\n\n   ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; p; }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, when an object of type \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; should be \u0026quot;copied\u0026quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is important to remember that \u0026quot;static\u0026quot; objects are always copied. There\u0026apos;s no ways to \u0026quot;move\u0026quot; a static object (object in stack and not on heap). So, the distinction \u0026quot;move\u0026quot;/ \u0026quot;copy\u0026quot; when an object has no dynamic members (directly or indirectly) is irrelevant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your object is complex and the destructor has other secondary effects, like calling to a library\u0026apos;s function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Heavy\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; b_moved;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// staff\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* definition */\u0026lt;/span\u0026gt; }\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(A\u0026amp;amp;\u0026amp;amp; a) : \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialization list\u0026lt;/span\u0026gt;\n   {\n      a.b_moved = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n   }\n\n   ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!b_moved) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* destruct object */\u0026lt;/span\u0026gt; }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, your code is shorter (you don\u0026apos;t need to do a \u0026lt;code\u0026gt;nullptr\u0026lt;/code\u0026gt; assignment for each dynamic member) and more general.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Other typical question: what is the difference between \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const A\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can\u0026apos;t modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And what is \u0026lt;strong\u0026gt;perfect forwarding\u0026lt;/strong\u0026gt;? It is important to know that a \u0026quot;rvalue reference\u0026quot; is a reference to a named object in the \u0026quot;caller\u0026apos;s scope\u0026quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn\u0026apos;t received like a temporal object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A\u0026amp;amp;\u0026amp;amp; a)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;other_function\u0026lt;/span\u0026gt;(a);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The object \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; would be copied to the actual parameter of \u0026lt;code\u0026gt;other_function\u0026lt;/code\u0026gt;. If you want the object \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; continues being treated as a temporary object, you should use the \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;other_function\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(a));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With this line, \u0026lt;code\u0026gt;std::move\u0026lt;/code\u0026gt; will cast \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to an rvalue and \u0026lt;code\u0026gt;other_function\u0026lt;/code\u0026gt; will receive the object as a unnamed object. Of course, if \u0026lt;code\u0026gt;other_function\u0026lt;/code\u0026gt; has not specific overloading to work with unnamed objects, this distinction is not important.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp;\u0026amp;amp; a)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;other_function\u0026lt;/span\u0026gt;(std::forward\u0026amp;lt;T\u0026amp;gt;(a));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of \u0026lt;code\u0026gt;std::forward\u0026lt;/code\u0026gt;. This function exploits some rules of template instantiation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; `A\u0026amp;amp; \u0026amp;amp;\u0026amp;amp; == A\u0026amp;amp;`\n `A\u0026amp;amp;\u0026amp;amp; \u0026amp;amp;\u0026amp;amp; == A\u0026amp;amp;\u0026amp;amp;`\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, if \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a lvalue reference to \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; (\u0026lt;strong\u0026gt;T\u0026lt;/strong\u0026gt; = A\u0026amp;amp;), \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; also (\u0026lt;strong\u0026gt;A\u0026amp;amp;\u0026lt;/strong\u0026gt; \u0026amp;amp;\u0026amp;amp; =\u0026amp;gt; A\u0026amp;amp;). If \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a rvalue reference to \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; also (A\u0026amp;amp;\u0026amp;amp; \u0026amp;amp;\u0026amp;amp; =\u0026amp;gt; A\u0026amp;amp;\u0026amp;amp;). In both cases, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a named object in the actual scope, but \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; contains the information of its \u0026quot;reference type\u0026quot; from the caller scope\u0026apos;s point of view. This information (\u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;) is passed as template parameter to \u0026lt;code\u0026gt;forward\u0026lt;/code\u0026gt; and \u0026apos;a\u0026apos; is moved or not according to the type of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being \u0026quot;moved\u0026quot; from.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor \u0026amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using \u0026amp;amp;\u0026amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it\u0026apos;s source argument it \u0026apos;moves\u0026apos; memory from the source to the destination.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;foo\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get_foos\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;re going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it\u0026apos;s pointers and \u0026apos;move\u0026apos; dynamically allocated memory to the new instance. It\u0026apos;s kind of like transfer-of-ownership semantics with std::auto_ptr.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m writing this to make sure I understand it properly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book \u0026quot;The C++ Programming Language\u0026quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A \u0026quot;move assignment\u0026quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead \u0026quot;reuse\u0026quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To illustrate the need for \u0026lt;em\u0026gt;move semantics\u0026lt;/em\u0026gt;, let\u0026apos;s consider this example without move semantics:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a function that takes an object of type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; and returns an object of the same type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T o)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; o; }\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//^^^ new object constructed\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above function uses \u0026lt;em\u0026gt;call by value\u0026lt;/em\u0026gt; which means that when this function is called an object must be \u0026lt;em\u0026gt;constructed\u0026lt;/em\u0026gt; to be used by the function.\u0026lt;br\u0026gt;\nBecause the function also \u0026lt;em\u0026gt;returns by value\u0026lt;/em\u0026gt;, another new object is constructed for the return value:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T b = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(a);\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//^ new object constructed\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Two\u0026lt;/strong\u0026gt; new objects have been constructed, one of which is a temporary object that\u0026apos;s only used for the duration of the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When the new object is created from the return value, the copy constructor is called to \u0026lt;em\u0026gt;copy\u0026lt;/em\u0026gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now, let\u0026apos;s consider what a \u0026lt;em\u0026gt;copy constructor\u0026lt;/em\u0026gt; does.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It must first initialize the object, then copy all the relevant data from the old object to the new one.\u0026lt;br\u0026gt;\nDepending on the class, maybe its a container with very much data, then that could represent much \u0026lt;em\u0026gt;time\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;memory usage\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy constructor\u0026lt;/span\u0026gt;\nT::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(T \u0026amp;amp;old) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_data\u0026lt;/span\u0026gt;(m_a, old.m_a);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_data\u0026lt;/span\u0026gt;(m_b, old.m_b);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_data\u0026lt;/span\u0026gt;(m_c, old.m_c);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With \u0026lt;strong\u0026gt;move semantics\u0026lt;/strong\u0026gt; it\u0026apos;s now possible to make most of this work less unpleasant by simply \u0026lt;em\u0026gt;moving\u0026lt;/em\u0026gt; the data rather than copying.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Move constructor\u0026lt;/span\u0026gt;\nT::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(T \u0026amp;amp;\u0026amp;amp;old) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;noexcept\u0026lt;/span\u0026gt; {\n    m_a = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(old.m_a);\n    m_b = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(old.m_b);\n    m_c = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(old.m_c);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Moving the data involves re-associating the data with the new object. And \u0026lt;em\u0026gt;no copy takes place\u0026lt;/em\u0026gt; at all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is accomplished with an \u0026lt;code\u0026gt;rvalue\u0026lt;/code\u0026gt; reference.\u0026lt;br\u0026gt;\nAn \u0026lt;code\u0026gt;rvalue\u0026lt;/code\u0026gt; reference works pretty much like an \u0026lt;code\u0026gt;lvalue\u0026lt;/code\u0026gt; reference with one important difference: \u0026lt;br\u0026gt;\nan \u0026lt;em\u0026gt;rvalue reference can be moved\u0026lt;/em\u0026gt; and an \u0026lt;em\u0026gt;lvalue\u0026lt;/em\u0026gt; cannot.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/language/move_constructor\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;cppreference.com\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.\n  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.\n  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.\n  A constructor is called a \u0026apos;move constructor\u0026apos; when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a \u0026apos;move constructor\u0026apos; may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T\u0026amp;amp;\u0026amp;amp;).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s \u0026lt;a href=\u0026quot;https://www.youtube.com/watch?v=06HKceSDiKE\u0026amp;amp;t=135s\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;an answer\u0026lt;/a\u0026gt; from the book \u0026quot;The C++ Programming Language\u0026quot; by Bjarne Stroustrup. If you don\u0026apos;t want to see the video, you can see the text below:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this snippet. Returning from an operator+ involves copying the result out of the local variable \u0026lt;code\u0026gt;res\u0026lt;/code\u0026gt; and into someplace where the caller can access it. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Vector \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;+(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Vector\u0026amp;amp; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Vector\u0026amp;amp; b)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()!=b.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; Vector_siz e_mismatch{};\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Vector \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;res\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(a.size())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i!=a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i)\n            res[i]=a[i]+b[i];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; res;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We didnt really want a copy; we just wanted to get the result out of a function. So we need to move a Vector rather than to copy it. We can define move constructor as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Vector\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Vector\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Vector\u0026amp;amp; a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy constructor\u0026lt;/span\u0026gt;\n    Vector\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Vector\u0026amp;amp; a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy assignment\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Vector\u0026lt;/span\u0026gt;(Vector\u0026amp;amp;\u0026amp;amp; a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move constructor\u0026lt;/span\u0026gt;\n    Vector\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(Vector\u0026amp;amp;\u0026amp;amp; a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// move assignment\u0026lt;/span\u0026gt;\n};\n\nVector::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Vector\u0026lt;/span\u0026gt;(Vector\u0026amp;amp;\u0026amp;amp; a)\n    :elem{a.elem}, \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;grab the elements\u0026quot; from a\u0026lt;/span\u0026gt;\n    sz{a.sz}\n{\n    a.elem = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now a has no elements\u0026lt;/span\u0026gt;\n    a.sz = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026amp;amp;\u0026amp;amp; means \u0026quot;rvalue reference\u0026quot; and is a reference to which we can bind an rvalue. \u0026quot;rvalue\u0026quot; is intended to complement \u0026quot;lvalue\u0026quot; which roughly means \u0026quot;something that can appear on the left-hand side of an assignment.\u0026quot; So an rvalue means roughly \u0026quot;a value that you cant assign to\u0026quot;, such as an integer returned by a function call, and the \u0026lt;code\u0026gt;res\u0026lt;/code\u0026gt; local variable in operator+() for Vectors. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, the statement \u0026lt;code\u0026gt;return res;\u0026lt;/code\u0026gt; will not copy!\u0026lt;/p\u0026gt;\n    "],"id":345,"title":"What is move semantics?","content":"\n                \n\u0026lt;p\u0026gt;I just finished listening to the Software Engineering radio \u0026lt;a href=\u0026quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;podcast interview with Scott Meyers\u0026lt;/a\u0026gt; regarding \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/C++11\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++0x\u0026lt;/a\u0026gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don\u0026apos;t get \u0026lt;em\u0026gt;move semantics\u0026lt;/em\u0026gt;... What is it exactly?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-move-semantics-1657387702625","postType":"QUESTION","createdAt":"2022-07-09T17:28:22.000Z","updatedAt":"2022-07-09T17:28:22.000Z","tags":[{"id":1953,"name":"c++11","slug":"c++11","createdAt":"2022-07-09T17:28:22.000Z","updatedAt":"2022-07-09T17:28:22.000Z","Questions_Tags":{"questionId":345,"tagId":1953}},{"id":1954,"name":"move-semantics","slug":"move-semantics","createdAt":"2022-07-09T17:28:22.000Z","updatedAt":"2022-07-09T17:28:22.000Z","Questions_Tags":{"questionId":345,"tagId":1954}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-move-semantics-1657387702625"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>