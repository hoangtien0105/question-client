<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why aren&#x27;t variable-length arrays part of the C++ standard? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I haven&#x27;t used C very much in the last few years. When I read this question today I came across some C syntax which I wasn&#x27;t familiar with.

Apparently in C99 the following syntax is valid:

void foo(int n) {
    int values[n]; //Declare a variable length array
}


This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?

Some potential reasons:


Hairy for compiler vendors to implement
Incompatible with some other part of the standard
Functionality can be emulated with other C++ constructs


The C++ standard states that array size must be a constant expression (8.3.4.1).

Yes, of course I realize that in the toy example one could use std::vector&lt;int&gt; values(m);, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:

void foo(int x, int y, int z) {
    int values[x][y][z]; // Declare a variable length array
}


the vector version becomes pretty clumsy:

void foo(int x, int y, int z) {
    vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; values( /* Really painful expression here. */);
}


The slices, rows and columns will also potentially be spread all over memory.

Looking at the discussion at comp.std.c++ it&#x27;s clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It&#x27;s certainly not obvious that a std::vector is always a better solution.
    "/><meta property="og:title" content="Why aren&#x27;t variable-length arrays part of the C++ standard? | Solutions Checker"/><meta property="og:description" content="I haven&#x27;t used C very much in the last few years. When I read this question today I came across some C syntax which I wasn&#x27;t familiar with.

Apparently in C99 the following syntax is valid:

void foo(int n) {
    int values[n]; //Declare a variable length array
}


This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?

Some potential reasons:


Hairy for compiler vendors to implement
Incompatible with some other part of the standard
Functionality can be emulated with other C++ constructs


The C++ standard states that array size must be a constant expression (8.3.4.1).

Yes, of course I realize that in the toy example one could use std::vector&lt;int&gt; values(m);, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:

void foo(int x, int y, int z) {
    int values[x][y][z]; // Declare a variable length array
}


the vector version becomes pretty clumsy:

void foo(int x, int y, int z) {
    vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; values( /* Really painful expression here. */);
}


The slices, rows and columns will also potentially be spread all over memory.

Looking at the discussion at comp.std.c++ it&#x27;s clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It&#x27;s certainly not obvious that a std::vector is always a better solution.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why aren&apos;t variable-length arrays part of the C++ standard?","text":"I haven&apos;t used C very much in the last few years. When I read this question today I came across some C syntax which I wasn&apos;t familiar with.\n\nApparently in C99 the following syntax is valid:\n\nvoid foo(int n) {\n    int values[n]; //Declare a variable length array\n}\n\n\nThis seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?\n\nSome potential reasons:\n\n\nHairy for compiler vendors to implement\nIncompatible with some other part of the standard\nFunctionality can be emulated with other C++ constructs\n\n\nThe C++ standard states that array size must be a constant expression (8.3.4.1).\n\nYes, of course I realize that in the toy example one could use std::vector&lt;int&gt; values(m);, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:\n\nvoid foo(int x, int y, int z) {\n    int values[x][y][z]; // Declare a variable length array\n}\n\n\nthe vector version becomes pretty clumsy:\n\nvoid foo(int x, int y, int z) {\n    vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; values( /* Really painful expression here. */);\n}\n\n\nThe slices, rows and columns will also potentially be spread all over memory.\n\nLooking at the discussion at comp.std.c++ it&apos;s clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It&apos;s certainly not obvious that a std::vector is always a better solution.\n    ","answerCount":13,"upVoteCount":500,"suggestedAnswer":[{"text":"(Background: I have some experience implementing C and C++ compilers.)\n\nVariable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:\n\n\nsizeof x is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a sizeof-expression at runtime.\nAllowing two-dimensional VLAs (int A[x][y]) required a new syntax for declaring functions that take 2D VLAs as parameters: void foo(int n, int A[][*]).\nLess importantly in the C++ world, but extremely important for C&apos;s target audience of embedded-systems programmers, declaring a VLA means chomping an arbitrarily large chunk of your stack. This is a guaranteed stack-overflow and crash. (Anytime you declare int A[n], you&apos;re implicitly asserting that you have 2GB of stack to spare. After all, if you know &quot;n is definitely less than 1000 here&quot;, then you would just declare int A[1000]. Substituting the 32-bit integer n for 1000 is an admission that you have no idea what the behavior of your program ought to be.)\n\n\nOkay, so let&apos;s move to talking about C++ now. In C++, we have the same strong distinction between &quot;type system&quot; and &quot;value system&quot; that C89 does but we&apos;ve really started to rely on it in ways that C has not. For example:\n\ntemplate&lt;typename T&gt; struct S { ... };\nint A[n];\nS&lt;decltype(A)&gt; s;  // equivalently, S&lt;int[n]&gt; s;\n\n\nIf n weren&apos;t a compile-time constant (i.e., if A were of variably modified type), then what on earth would be the type of S? Would S&apos;s type also be determined only at runtime?\n\nWhat about this:\n\ntemplate&lt;typename T&gt; bool myfunc(T&amp; t1, T&amp; t2) { ... };\nint A1[n1], A2[n2];\nmyfunc(A1, A2);\n\n\nThe compiler must generate code for some instantiation of myfunc. What should that code look like? How can we statically generate that code, if we don&apos;t know the type of A1 at compile time?\n\nWorse, what if it turns out at runtime that n1 != n2, so that !std::is_same&lt;decltype(A1), decltype(A2)&gt;()? In that case, the call to myfunc shouldn&apos;t even compile, because template type deduction should fail! How could we possibly emulate that behavior at runtime?\n\nBasically, C++ is moving in the direction of pushing more and more decisions into compile-time: template code generation, constexpr function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally compile-time decisions (e.g. sizeof) into the runtime. With this in mind, does it really even make sense to expend any effort trying to integrate C99-style VLAs into C++?\n\nAs every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (std::unique_ptr&lt;int[]&gt; A = new int[n]; or std::vector&lt;int&gt; A(n); being the obvious ones) when you really want to convey the idea &quot;I have no idea how much RAM I might need.&quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully this answer gives you a good idea of why C99-style VLAs were not a good fit for C++  and not really even a good fit for C99. ;)\n\n\n\nFor more on the topic, see N3810 &quot;Alternatives for Array Extensions&quot;, Bjarne Stroustrup&apos;s October 2013 paper on VLAs. Bjarne&apos;s POV is very different from mine; N3810 focuses more on finding a good C++ish syntax for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don&apos;t know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.\n\n\n\nA good blog post that hits many of these same points is &quot;Legitimate Use of Variable Length Arrays&quot; (Chris Wellons, 2019-10-27).\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"There recently was a discussion about this kicked off in usenet: Why no VLAs in C++0x. \n\nI agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn&apos;t good. The argument is, if you know the size beforehand, you can use a static array. And if you don&apos;t know the size beforehand, you will write unsafe code. \n\nC99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for new operator type-specifiers, but they are treated specially, so that the runtime-ness doesn&apos;t escape the scope of the new operator).\n\nYou can use std::vector, but it is not quite the same, as it uses dynamic memory, and making it use one&apos;s own stack-allocator isn&apos;t exactly easy (alignment is an issue, too). It also doesn&apos;t solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The C++ Dynamic Array proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it&apos;s not going to be part of C++0x, as far as I know.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"You could always use alloca() to allocate memory on the stack at runtime, if you wished:\n\nvoid foo (int n)\n{\n    int *values = (int *)alloca(sizeof(int) * n);\n}\n\n\nBeing allocated on the stack implies that it will automatically be freed when the stack unwinds.\n\nQuick note: As mentioned in the Mac OS X man page for alloca(3), &quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.&quot;  Just so you know.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"In my own work, I&apos;ve realized that every time I&apos;ve wanted something like variable-length automatic arrays or alloca(), I didn&apos;t really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn&apos;t incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.\n\nI&apos;m not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn&apos;t standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements &quot;variable size&quot; and &quot;must be physically located on the cpu stack&quot; have never come up together.  It&apos;s been about speed, so I made my own sort of &quot;parallel stack for data buffers&quot;.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.\n\nI think that C++ is so unsafe in itself that the argument to &quot;try to not add more unsafe features&quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I&apos;m working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Seems it will be available in C++14:\nhttps://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays\nUpdate: It did not make it into C++14.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"This was considered for inclusion in C++/1x, but was dropped (this is a correction to what I said earlier).\n\nIt would be less useful in C++ anyway since we already have std::vector to fill this role.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).\n\nBTW, for questions on  &quot;why&quot; the C++ standard is the way it is, the moderated Usenet newsgroup comp.std.c++ is the place to go to.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Use std::vector for this. For example:\n\nstd::vector&lt;int&gt; values;\nvalues.resize(n);\n\n\nThe memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"VLAs are a part of a larger family of Variably Modified types.\nThis family of types is very special because they have runtime components.\nThe code:\nint A[n];\n\nIs seen by compiler as:\ntypedef int T[n];\nT A;\n\nNote that the runtime size of array is not bound to the variable A but to the type of the variable.\nNothing prevents one from making new variables of this type:\nT B,C,D;\n\nor the pointers or arrays\nT *p, Z[10];\n\nMoreover, pointers allow one to create VLAs with dynamic storage.\nT *p = malloc(sizeof(T));\n...\nfree(p);\n\nWhat dispels a popular myth that VLAs can only be allocated on stack.\nBack to the question.\nThis runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.\nC++ typing system is static, all types must be fully defined or deduced during compilation.\nVM types are completed only during program execution.\nAdditional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application\nare automatic VLAs (int A[n];) which have an alternative in form of std::vector.\nIt a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.\nIn C one can simply write:\nvoid foo(int n, int A[n][n][n]) {\n  for (int i = 0; i &lt; n; ++i)\n    for (int j = 0; j &lt; n; ++j)\n      for (int k = 0; k &lt; n; ++k)\n        A[i][j][k] = i * j * k;\n}\n\n...\n\nint A[5][5][5], B[10][10][10];\nfoo(5, A);\nfoo(10, B);\n\nNow try to provide as efficient and elegant solution in C++.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"If you know the value at compile time you can do the following:\n\ntemplate &lt;int X&gt;\nvoid foo(void)\n{\n   int values[X];\n\n}\n\n\nEdit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).\n\nvoid varTest(int iSz)\n{\n    char *varArray;\n    __asm {\n        sub esp, iSz       // Create space on the stack for the variable array here\n        mov varArray, esp  // save the end of it to our pointer\n    }\n\n    // Use the array called varArray here...  \n\n    __asm {\n        add esp, iSz       // Variable array is no longer accessible after this point\n    } \n}\n\n\nThe dangers here are many but I&apos;ll explain a few:\n1. Changing the variable size half way through would kill the stack position\n2. Overstepping the array bounds would destroy other variables and possible code\n3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).\n4. Compiler specific (may have trouble moving between compilers).  I haven&apos;t tried so I really don&apos;t know.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c%2B%2B-standard-1657384712975#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-length-array">variable-length-array</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-length">variable-length</a></div></div><div class="question-content mt-5">
                
<p>I haven't used C very much in the last few years. When I read <a href="https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c">this question</a> today I came across some C syntax which I wasn't familiar with.</p>

<p>Apparently in <a href="https://en.wikipedia.org/wiki/C99" rel="noreferrer">C99</a> the following syntax is valid:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-type">int</span> values[n]; <span class="hljs-comment">//Declare a variable length array</span>
}
</code></pre>

<p>This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?</p>

<p>Some potential reasons:</p>

<ul>
<li>Hairy for compiler vendors to implement</li>
<li>Incompatible with some other part of the standard</li>
<li>Functionality can be emulated with other C++ constructs</li>
</ul>

<p>The C++ standard states that array size must be a constant expression (8.3.4.1).</p>

<p>Yes, of course I realize that in the toy example one could use <code>std::vector&lt;int&gt; values(m);</code>, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
    <span class="hljs-type">int</span> values[x][y][z]; <span class="hljs-comment">// Declare a variable length array</span>
}
</code></pre>

<p>the <code>vector</code> version becomes pretty clumsy:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
    vector&lt; vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt; <span class="hljs-built_in">values</span>( <span class="hljs-comment">/* Really painful expression here. */</span>);
}
</code></pre>

<p>The slices, rows and columns will also potentially be spread all over memory.</p>

<p>Looking at the discussion at <code>comp.std.c++</code> it's clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It's certainly not obvious that a <code>std::vector</code> is always a better solution.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>(Background: I have some experience implementing C and C++ compilers.)</p>

<p>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</p>

<ul>
<li><p><code>sizeof x</code> is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a <code>sizeof</code>-expression at runtime.</p></li>
<li><p>Allowing two-dimensional VLAs (<code>int A[x][y]</code>) required a new syntax for declaring functions that take 2D VLAs as parameters: <code>void foo(int n, int A[][*])</code>.</p></li>
<li><p>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an <em>arbitrarily large</em> chunk of your stack. This is a <em>guaranteed</em> stack-overflow and crash. (Anytime you declare <code>int A[n]</code>, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know "<code>n</code> is definitely less than 1000 here", then you would just declare <code>int A[1000]</code>. Substituting the 32-bit integer <code>n</code> for <code>1000</code> is an admission that you have no idea what the behavior of your program ought to be.)</p></li>
</ul>

<p>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between "type system" and "value system" that C89 does but we've really started to rely on it in ways that C has not. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> { ... };
<span class="hljs-type">int</span> A[n];
S&lt;<span class="hljs-keyword">decltype</span>(A)&gt; s;  <span class="hljs-comment">// equivalently, S&lt;int[n]&gt; s;</span>
</code></pre>

<p>If <code>n</code> weren't a compile-time constant (i.e., if <code>A</code> were of variably modified type), then what on earth would be the type of <code>S</code>? Would <code>S</code>'s type <em>also</em> be determined only at runtime?</p>

<p>What about this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T&amp; t1, T&amp; t2)</span> </span>{ ... };
<span class="hljs-type">int</span> A1[n1], A2[n2];
<span class="hljs-built_in">myfunc</span>(A1, A2);
</code></pre>

<p>The compiler must generate code for some instantiation of <code>myfunc</code>. What should that code look like? How can we statically generate that code, if we don't know the type of <code>A1</code> at compile time?</p>

<p>Worse, what if it turns out at runtime that <code>n1 != n2</code>, so that <code>!std::is_same&lt;decltype(A1), decltype(A2)&gt;()</code>? In that case, the call to <code>myfunc</code> <strong>shouldn't even compile</strong>, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</p>

<p>Basically, C++ is moving in the direction of pushing more and more decisions into <em>compile-time</em>: template code generation, <code>constexpr</code> function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally <em>compile-time</em> decisions (e.g. <code>sizeof</code>) into the <em>runtime</em>. With this in mind, does it really even make sense to expend any effort <em>trying</em> to integrate C99-style VLAs into C++?</p>

<p>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (<code>std::unique_ptr&lt;int[]&gt; A = new int[n];</code> or <code>std::vector&lt;int&gt; A(n);</code> being the obvious ones) when you really want to convey the idea "I have no idea how much RAM I might need." And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully <em>this</em> answer gives you a good idea of why C99-style VLAs were <strong>not</strong> a good fit for C++  and not really even a good fit for C99. ;)</p>

<hr>

<p>For more on the topic, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf" rel="noreferrer">N3810 "Alternatives for Array Extensions"</a>, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish <em>syntax</em> for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</p>

<hr>

<p>A good blog post that hits many of these same points is <a href="https://nullprogram.com/blog/2019/10/27/" rel="noreferrer">"Legitimate Use of Variable Length Arrays"</a> (Chris Wellons, 2019-10-27).</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There recently was a discussion about this kicked off in usenet: <a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa" rel="noreferrer">Why no VLAs in C++0x</a>. </p>

<p>I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good. The argument is, if you know the size beforehand, you can use a static array. And if you don't know the size beforehand, you will write unsafe code. </p>

<p>C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for <code>new</code> operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the <code>new</code> operator).</p>

<p>You can use <code>std::vector</code>, but it is not quite the same, as it uses dynamic memory, and making it use one's own stack-allocator isn't exactly easy (alignment is an issue, too). It also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html" rel="noreferrer">C++ Dynamic Array</a> proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it's not going to be part of C++0x, as far as I know.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could always use alloca() to allocate memory on the stack at runtime, if you wished:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-type">int</span> *values = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">alloca</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);
}
</code></pre>

<p>Being allocated on the stack implies that it will automatically be freed when the stack unwinds.</p>

<p>Quick note: As mentioned in the Mac OS X man page for alloca(3), "The alloca() function is machine and compiler dependent; its use is dis-couraged."  Just so you know.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In my own work, I've realized that every time I've wanted something like variable-length automatic arrays or alloca(), I didn't really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn't incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.</p>

<p>I'm not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn't standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements "variable size" and "must be physically located on the cpu stack" have never come up together.  It's been about speed, so I made my own sort of "parallel stack for data buffers".</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.</p>

<p>I think that C++ is so unsafe in itself that the argument to "try to not add more unsafe features" is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I'm working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Seems it will be available in C++14:</p>
<p><a href="https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays" rel="noreferrer">https://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays</a></p>
<p><em>Update: It did not make it into C++14.</em></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This was considered for inclusion in C++/1x, <a href="http://www.stroustrup.com/C++11FAQ.html#C99" rel="noreferrer">but was dropped</a> (this is a correction to what I said earlier).</p>

<p>It would be less useful in C++ anyway since we already have <code>std::vector</code> to fill this role.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).</p>

<p>BTW, for questions on  "why" the C++ standard is the way it is, the moderated Usenet newsgroup <a href="http://groups.google.com/group/comp.std.c++/topics?lnk=rgh" rel="nofollow noreferrer">comp.std.c++</a> is the place to go to.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Use std::vector for this. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; values;
values.<span class="hljs-built_in">resize</span>(n);
</code></pre>

<p>The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>VLAs are a part of a larger family of Variably Modified types.
This family of types is very special because they have <em>runtime</em> components.</p>
<p>The code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> A[n];
</code></pre>
<p>Is seen by compiler as:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T[n];
T A;
</code></pre>
<p>Note that the runtime size of array is not bound to the variable <code>A</code> but to the <strong>type</strong> of the variable.</p>
<p>Nothing prevents one from making new variables of this type:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T B,C,D;
</code></pre>
<p>or the pointers or arrays</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T *p, Z[<span class="hljs-number">10</span>];
</code></pre>
<p>Moreover, pointers allow one to create VLAs with dynamic storage.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T));
...
<span class="hljs-built_in">free</span>(p);
</code></pre>
<p>What dispels a <strong>popular myth</strong> that VLAs can only be allocated on stack.</p>
<p>Back to the question.</p>
<p>This runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.</p>
<p>C++ typing system is static, all types must be fully defined or deduced during <em>compilation</em>.
VM types are completed only during program <em>execution</em>.
Additional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application
are automatic VLAs (<code>int A[n];</code>) which have an alternative in form of <code>std::vector</code>.</p>
<p>It a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.</p>
<p>In C one can simply write:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> A[n][n][n])</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)
      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)
        A[i][j][k] = i * j * k;
}

...

<span class="hljs-type">int</span> A[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>][<span class="hljs-number">5</span>], B[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
<span class="hljs-built_in">foo</span>(<span class="hljs-number">5</span>, A);
<span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>, B);
</code></pre>
<p>Now try to provide as efficient and elegant solution in C++.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you know the value at compile time you can do the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> X&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
   <span class="hljs-type">int</span> values[X];

}
</code></pre>

<p>Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">varTest</span><span class="hljs-params">(<span class="hljs-type">int</span> iSz)</span>
</span>{
    <span class="hljs-type">char</span> *varArray;
    __asm {
        sub esp, iSz       <span class="hljs-comment">// Create space on the stack for the variable array here</span>
        mov varArray, esp  <span class="hljs-comment">// save the end of it to our pointer</span>
    }

    <span class="hljs-comment">// Use the array called varArray here...  </span>

    __asm {
        add esp, iSz       <span class="hljs-comment">// Variable array is no longer accessible after this point</span>
    } 
}
</code></pre>

<p>The dangers here are many but I'll explain a few:
1. Changing the variable size half way through would kill the stack position
2. Overstepping the array bounds would destroy other variables and possible code
3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).
4. Compiler specific (may have trouble moving between compilers).  I haven't tried so I really don't know.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;(Background: I have some experience implementing C and C++ compilers.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sizeof x\u0026lt;/code\u0026gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;-expression at runtime.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Allowing two-dimensional VLAs (\u0026lt;code\u0026gt;int A[x][y]\u0026lt;/code\u0026gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: \u0026lt;code\u0026gt;void foo(int n, int A[][*])\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Less importantly in the C++ world, but extremely important for C\u0026apos;s target audience of embedded-systems programmers, declaring a VLA means chomping an \u0026lt;em\u0026gt;arbitrarily large\u0026lt;/em\u0026gt; chunk of your stack. This is a \u0026lt;em\u0026gt;guaranteed\u0026lt;/em\u0026gt; stack-overflow and crash. (Anytime you declare \u0026lt;code\u0026gt;int A[n]\u0026lt;/code\u0026gt;, you\u0026apos;re implicitly asserting that you have 2GB of stack to spare. After all, if you know \u0026quot;\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is definitely less than 1000 here\u0026quot;, then you would just declare \u0026lt;code\u0026gt;int A[1000]\u0026lt;/code\u0026gt;. Substituting the 32-bit integer \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;1000\u0026lt;/code\u0026gt; is an admission that you have no idea what the behavior of your program ought to be.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Okay, so let\u0026apos;s move to talking about C++ now. In C++, we have the same strong distinction between \u0026quot;type system\u0026quot; and \u0026quot;value system\u0026quot; that C89 does but we\u0026apos;ve really started to rely on it in ways that C has not. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; { ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\nS\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(A)\u0026amp;gt; s;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// equivalently, S\u0026amp;lt;int[n]\u0026amp;gt; s;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; weren\u0026apos;t a compile-time constant (i.e., if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; were of variably modified type), then what on earth would be the type of \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;? Would \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;\u0026apos;s type \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; be determined only at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What about this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp; t1, T\u0026amp;amp; t2)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A1[n1], A2[n2];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;(A1, A2);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler must generate code for some instantiation of \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt;. What should that code look like? How can we statically generate that code, if we don\u0026apos;t know the type of \u0026lt;code\u0026gt;A1\u0026lt;/code\u0026gt; at compile time?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Worse, what if it turns out at runtime that \u0026lt;code\u0026gt;n1 != n2\u0026lt;/code\u0026gt;, so that \u0026lt;code\u0026gt;!std::is_same\u0026amp;lt;decltype(A1), decltype(A2)\u0026amp;gt;()\u0026lt;/code\u0026gt;? In that case, the call to \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;shouldn\u0026apos;t even compile\u0026lt;/strong\u0026gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, C++ is moving in the direction of pushing more and more decisions into \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt;: template code generation, \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt; decisions (e.g. \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;) into the \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt;. With this in mind, does it really even make sense to expend any effort \u0026lt;em\u0026gt;trying\u0026lt;/em\u0026gt; to integrate C99-style VLAs into C++?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (\u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;int[]\u0026amp;gt; A = new int[n];\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; A(n);\u0026lt;/code\u0026gt; being the obvious ones) when you really want to convey the idea \u0026quot;I have no idea how much RAM I might need.\u0026quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; answer gives you a good idea of why C99-style VLAs were \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; a good fit for C++  and not really even a good fit for C99. ;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For more on the topic, see \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;N3810 \u0026quot;Alternatives for Array Extensions\u0026quot;\u0026lt;/a\u0026gt;, Bjarne Stroustrup\u0026apos;s October 2013 paper on VLAs. Bjarne\u0026apos;s POV is very different from mine; N3810 focuses more on finding a good C++ish \u0026lt;em\u0026gt;syntax\u0026lt;/em\u0026gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don\u0026apos;t know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;A good blog post that hits many of these same points is \u0026lt;a href=\u0026quot;https://nullprogram.com/blog/2019/10/27/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;Legitimate Use of Variable Length Arrays\u0026quot;\u0026lt;/a\u0026gt; (Chris Wellons, 2019-10-27).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There recently was a discussion about this kicked off in usenet: \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Why no VLAs in C++0x\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn\u0026apos;t good. The argument is, if you know the size beforehand, you can use a static array. And if you don\u0026apos;t know the size beforehand, you will write unsafe code. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn\u0026apos;t escape the scope of the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;, but it is not quite the same, as it uses dynamic memory, and making it use one\u0026apos;s own stack-allocator isn\u0026apos;t exactly easy (alignment is an issue, too). It also doesn\u0026apos;t solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++ Dynamic Array\u0026lt;/a\u0026gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it\u0026apos;s not going to be part of C++0x, as far as I know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could always use alloca() to allocate memory on the stack at runtime, if you wished:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *values = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;alloca\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) * n);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Being allocated on the stack implies that it will automatically be freed when the stack unwinds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quick note: As mentioned in the Mac OS X man page for alloca(3), \u0026quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.\u0026quot;  Just so you know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my own work, I\u0026apos;ve realized that every time I\u0026apos;ve wanted something like variable-length automatic arrays or alloca(), I didn\u0026apos;t really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn\u0026apos;t incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn\u0026apos;t standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements \u0026quot;variable size\u0026quot; and \u0026quot;must be physically located on the cpu stack\u0026quot; have never come up together.  It\u0026apos;s been about speed, so I made my own sort of \u0026quot;parallel stack for data buffers\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think that C++ is so unsafe in itself that the argument to \u0026quot;try to not add more unsafe features\u0026quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I\u0026apos;m working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Seems it will be available in C++14:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Update: It did not make it into C++14.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This was considered for inclusion in C++/1x, \u0026lt;a href=\u0026quot;http://www.stroustrup.com/C++11FAQ.html#C99\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;but was dropped\u0026lt;/a\u0026gt; (this is a correction to what I said earlier).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would be less useful in C++ anyway since we already have \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; to fill this role.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BTW, for questions on  \u0026quot;why\u0026quot; the C++ standard is the way it is, the moderated Usenet newsgroup \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;comp.std.c++\u0026lt;/a\u0026gt; is the place to go to.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Use std::vector for this. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; values;\nvalues.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;resize\u0026lt;/span\u0026gt;(n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;VLAs are a part of a larger family of Variably Modified types.\nThis family of types is very special because they have \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt; components.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Is seen by compiler as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; T[n];\nT A;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the runtime size of array is not bound to the variable \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; but to the \u0026lt;strong\u0026gt;type\u0026lt;/strong\u0026gt; of the variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Nothing prevents one from making new variables of this type:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T B,C,D;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or the pointers or arrays\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p, Z[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Moreover, pointers allow one to create VLAs with dynamic storage.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(T));\n...\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(p);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What dispels a \u0026lt;strong\u0026gt;popular myth\u0026lt;/strong\u0026gt; that VLAs can only be allocated on stack.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Back to the question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C++ typing system is static, all types must be fully defined or deduced during \u0026lt;em\u0026gt;compilation\u0026lt;/em\u0026gt;.\nVM types are completed only during program \u0026lt;em\u0026gt;execution\u0026lt;/em\u0026gt;.\nAdditional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application\nare automatic VLAs (\u0026lt;code\u0026gt;int A[n];\u0026lt;/code\u0026gt;) which have an alternative in form of \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C one can simply write:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n][n][n])\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; ++i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; n; ++j)\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k \u0026amp;lt; n; ++k)\n        A[i][j][k] = i * j * k;\n}\n\n...\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;], B[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, A);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, B);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now try to provide as efficient and elegant solution in C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you know the value at compile time you can do the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[X];\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;varTest\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; iSz)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *varArray;\n    __asm {\n        sub esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create space on the stack for the variable array here\u0026lt;/span\u0026gt;\n        mov varArray, esp  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// save the end of it to our pointer\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the array called varArray here...  \u0026lt;/span\u0026gt;\n\n    __asm {\n        add esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Variable array is no longer accessible after this point\u0026lt;/span\u0026gt;\n    } \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The dangers here are many but I\u0026apos;ll explain a few:\n1. Changing the variable size half way through would kill the stack position\n2. Overstepping the array bounds would destroy other variables and possible code\n3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).\n4. Compiler specific (may have trouble moving between compilers).  I haven\u0026apos;t tried so I really don\u0026apos;t know.\u0026lt;/p\u0026gt;\n    "],"id":130,"title":"Why aren't variable-length arrays part of the C++ standard?","content":"\n                \n\u0026lt;p\u0026gt;I haven\u0026apos;t used C very much in the last few years. When I read \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt; today I came across some C syntax which I wasn\u0026apos;t familiar with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Apparently in \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C99\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99\u0026lt;/a\u0026gt; the following syntax is valid:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[n]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Declare a variable length array\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some potential reasons:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Hairy for compiler vendors to implement\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Incompatible with some other part of the standard\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functionality can be emulated with other C++ constructs\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The C++ standard states that array size must be a constant expression (8.3.4.1).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, of course I realize that in the toy example one could use \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; values(m);\u0026lt;/code\u0026gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[x][y][z]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Declare a variable length array\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; version becomes pretty clumsy:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt; vector\u0026amp;lt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;values\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Really painful expression here. */\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The slices, rows and columns will also potentially be spread all over memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Looking at the discussion at \u0026lt;code\u0026gt;comp.std.c++\u0026lt;/code\u0026gt; it\u0026apos;s clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It\u0026apos;s certainly not obvious that a \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; is always a better solution.\u0026lt;/p\u0026gt;\n    ","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975","postType":"QUESTION","createdAt":"2022-07-09T16:38:32.000Z","updatedAt":"2022-07-09T16:38:32.000Z","tags":[{"id":475,"name":"variable-length-array","slug":"variable-length-array","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":475}},{"id":476,"name":"variable-length","slug":"variable-length","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":476}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>