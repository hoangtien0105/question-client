<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Removing trailing newline character from fgets() input | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am trying to get some data from the user and send it to another function in gcc. The code is something like this.

printf(&quot;Enter your Name: &quot;);
if (!(fgets(Name, sizeof Name, stdin) != NULL)) {
    fprintf(stderr, &quot;Error reading Name.\n&quot;);
    exit(1);
}


However, I find that it has a newline \n character in the end. So if I enter John it ends up sending John\n. How do I remove that \n and send a proper string.
    "/><meta property="og:title" content="Removing trailing newline character from fgets() input | Solutions Checker"/><meta property="og:description" content="I am trying to get some data from the user and send it to another function in gcc. The code is something like this.

printf(&quot;Enter your Name: &quot;);
if (!(fgets(Name, sizeof Name, stdin) != NULL)) {
    fprintf(stderr, &quot;Error reading Name.\n&quot;);
    exit(1);
}


However, I find that it has a newline \n character in the end. So if I enter John it ends up sending John\n. How do I remove that \n and send a proper string.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Removing trailing newline character from fgets() input","text":"I am trying to get some data from the user and send it to another function in gcc. The code is something like this.\n\nprintf(&quot;Enter your Name: &quot;);\nif (!(fgets(Name, sizeof Name, stdin) != NULL)) {\n    fprintf(stderr, &quot;Error reading Name.\\n&quot;);\n    exit(1);\n}\n\n\nHowever, I find that it has a newline \\n character in the end. So if I enter John it ends up sending John\\n. How do I remove that \\n and send a proper string.\n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"Perhaps the simplest solution uses one of my favorite little-known functions, strcspn():\n\nbuffer[strcspn(buffer, &quot;\\n&quot;)] = 0;\n\n\nIf you want it to also handle &apos;\\r&apos; (say, if the stream is binary):\n\nbuffer[strcspn(buffer, &quot;\\r\\n&quot;)] = 0; // works for LF, CR, CRLF, LFCR, ...\n\n\nThe function counts the number of characters until it hits a &apos;\\r&apos; or a &apos;\\n&apos; (in other words, it finds the first &apos;\\r&apos; or &apos;\\n&apos;). If it doesn&apos;t hit anything, it stops at the &apos;\\0&apos; (returning the length of the string).\n\nNote that this works fine even if there is no newline, because strcspn stops at a &apos;\\0&apos;. In that case, the entire line is simply replacing &apos;\\0&apos; with &apos;\\0&apos;.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The elegant way:\nName[strcspn(Name, &quot;\\n&quot;)] = 0;\n\nThe slightly ugly way:\nchar *pos;\nif ((pos=strchr(Name, &apos;\\n&apos;)) != NULL)\n    *pos = &apos;\\0&apos;;\nelse\n    /* input too long for buffer, flag error */\n\nThe slightly strange way:\nstrtok(Name, &quot;\\n&quot;);\n\nNote that the strtok function doesn&apos;t work as expected if the user enters an empty string (i.e. presses only Enter). It leaves the \\n character intact.\nThere are others as well, of course.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"size_t ln = strlen(name) - 1;\nif (*name &amp;&amp; name[ln] == &apos;\\n&apos;) \n    name[ln] = &apos;\\0&apos;;\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Below is a fast approach to remove a potential &apos;\\n&apos; from a string saved by fgets().\nIt uses strlen(), with 2 tests.\n\nchar buffer[100];\nif (fgets(buffer, sizeof buffer, stdin) != NULL) {\n\n  size_t len = strlen(buffer);\n  if (len &gt; 0 &amp;&amp; buffer[len-1] == &apos;\\n&apos;) {\n    buffer[--len] = &apos;\\0&apos;;\n  }\n\n\nNow use buffer and len as needed.\n\nThis method has the side benefit of a len value for subsequent code.  It can be easily faster than strchr(Name, &apos;\\n&apos;).  Ref  YMMV, but both methods work.\n\n\n\nbuffer, from the original fgets() will not contain in &quot;\\n&quot; under some circumstances:\nA) The line was too long for buffer so only char preceding the &apos;\\n&apos; is saved in buffer. The unread characters remain in the stream.\nB) The last line in the file did not end with a &apos;\\n&apos;.  \n\nIf input has embedded null characters &apos;\\0&apos; in it somewhere, the length reported by strlen() will not include the &apos;\\n&apos; location.\n\n\n\nSome other answers&apos; issues: \n\n\nstrtok(buffer, &quot;\\n&quot;); fails to remove the &apos;\\n&apos; when buffer is &quot;\\n&quot;.  From this answer - amended after this answer to warn of this limitation. \nThe following fails on rare occasions when the first char read by fgets() is &apos;\\0&apos;.  This happens when input begins with an embedded &apos;\\0&apos;.  Then buffer[len -1] becomes buffer[SIZE_MAX] accessing memory certainly outside the legitimate range of buffer. Something a hacker may try or found in foolishly reading UTF16 text files.  This was the state of an answer when this answer was written.  Later a non-OP edited it to include code like this answer&apos;s check for &quot;&quot;.\n\nsize_t len = strlen(buffer);\nif (buffer[len - 1] == &apos;\\n&apos;) {  // FAILS when len == 0\n  buffer[len -1] = &apos;\\0&apos;;\n}\n\nsprintf(buffer,&quot;%s&quot;,buffer); is undefined behavior: Ref.  Further, it does not save any leading, separating or trailing whitespace.  Now deleted.\n[Edit due to good later answer] There are no problems with the 1 liner buffer[strcspn(buffer, &quot;\\n&quot;)] = 0; other than performance as compared to the strlen() approach.  Performance in trimming is usually not an issue given code is doing I/O - a black hole of CPU time.  Should following code need the string&apos;s length or is highly performance conscious, use this strlen() approach.  Else the strcspn() is a fine alternative.\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Direct to remove the &apos;\\n&apos; from the fgets output if every line has &apos;\\n&apos;\n\nline[strlen(line) - 1] = &apos;\\0&apos;;\n\n\nOtherwise:\n\nvoid remove_newline_ch(char *line)\n{\n    int new_line = strlen(line) -1;\n    if (line[new_line] == &apos;\\n&apos;)\n        line[new_line] = &apos;\\0&apos;;\n}\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"For single &apos;\\n&apos; trimming,\n\nvoid remove_new_line(char* string)\n{\n    size_t length = strlen(string);\n    if((length &gt; 0) &amp;&amp; (string[length-1] == &apos;\\n&apos;))\n    {\n        string[length-1] =&apos;\\0&apos;;\n    }\n}\n\n\nfor multiple &apos;\\n&apos; trimming,\n\nvoid remove_multi_new_line(char* string)\n{\n  size_t length = strlen(string);\n  while((length&gt;0) &amp;&amp; (string[length-1] == &apos;\\n&apos;))\n  {\n      --length;\n      string[length] =&apos;\\0&apos;;\n  }\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"My Newbie way ;-) Please let me know if that&apos;s correct. It seems to be working for all my cases:\n\n#define IPT_SIZE 5\n\nint findNULL(char* arr)\n{\n    for (int i = 0; i &lt; strlen(arr); i++)\n    {\n        if (*(arr+i) == &apos;\\n&apos;)\n        {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    char *input = malloc(IPT_SIZE + 1 * sizeof(char)), buff;\n    int counter = 0;\n\n    //prompt user for the input:\n    printf(&quot;input string no longer than %i characters: &quot;, IPT_SIZE);\n    do\n    {\n        fgets(input, 1000, stdin);\n        *(input + findNULL(input)) = &apos;\\0&apos;;\n        if (strlen(input) &gt; IPT_SIZE)\n        {\n            printf(&quot;error! the given string is too large. try again...\\n&quot;);\n            counter++;\n        }\n        //if the counter exceeds 3, exit the program (custom function):\n        errorMsgExit(counter, 3); \n    }\n    while (strlen(input) &gt; IPT_SIZE);\n\n//rest of the program follows\n\nfree(input)\nreturn 0;\n}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The steps to remove the newline character in the perhaps most obvious way:\n\n\nDetermine the length of the string inside NAME by using strlen(), header string.h. Note that strlen() does not count the terminating \\0.\n\n\nsize_t sl = strlen(NAME);\n\n\n\n\n\nLook if the string begins with or only includes one \\0 character (empty string). In this case sl would be 0 since strlen() as I said above doesnÂ´t count the \\0 and stops at the first occurrence of it: \n\n\nif(sl == 0)\n{\n   // Skip the newline replacement process.\n}\n\n\n\n\n\nCheck if the last character of the proper string is a newline character &apos;\\n&apos;.  If this is the case, replace \\n with a \\0. Note that index counts start at 0 so we will need to do NAME[sl - 1]:\n\n\nif(NAME[sl - 1] == &apos;\\n&apos;)\n{\n   NAME[sl - 1] = &apos;\\0&apos;;\n}\n\n\nNote if you only pressed Enter at the fgets() string request (the string content was only consisted of a newline character) the string in NAME will be an empty string thereafter.\n\n\n\n\nWe can combine step 2. and 3. together in just one if-statement by using the logic operator &amp;&amp;:\n\n\nif(sl &gt; 0 &amp;&amp; NAME[sl - 1] == &apos;\\n&apos;)\n{\n   NAME[sl - 1] = &apos;\\0&apos;;\n}\n\n\n\n\n\nThe finished code:\n\n\nsize_t sl = strlen(NAME);\nif(sl &gt; 0 &amp;&amp; NAME[sl - 1] == &apos;\\n&apos;)\n{\n   NAME[sl - 1] = &apos;\\0&apos;;\n}\n\n\n\n\nIf you rather like a function for use this technique by handling fgets output strings in general without retyping each and every time, here is fgets_newline_kill:\n\nvoid fgets_newline_kill(char a[])\n{\n    size_t sl = strlen(a);\n\n    if(sl &gt; 0 &amp;&amp; a[sl - 1] == &apos;\\n&apos;)\n    {\n       a[sl - 1] = &apos;\\0&apos;;\n    }\n}\n\n\nIn your provided example, it would be:\n\nprintf(&quot;Enter your Name: &quot;);\n\nif (fgets(Name, sizeof Name, stdin) == NULL) {\n    fprintf(stderr, &quot;Error reading Name.\\n&quot;);\n    exit(1);\n}\nelse {\n    fgets_newline_kill(NAME);\n}\n\n\nNote that this method does not work if the input string has embedded \\0s in it. If that would be the case strlen() would only return the amount of characters until the first \\0. But this isnÂ´t quite a common approach, since the most string-reading functions usually stop at the first \\0 and take the string until that null character.\n\nAside from the question on its own. Try to avoid double negations that make your code unclearer: if (!(fgets(Name, sizeof Name, stdin) != NULL) {}. You can simply do if (fgets(Name, sizeof Name, stdin) == NULL) {}.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"If using getline is an option - Not neglecting its security issues and if you wish to brace pointers - you can avoid string functions as the getline returns the number of characters. Something like below\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main()\n{\n    char *fname, *lname;\n    size_t size = 32, nchar; // Max size of strings and number of characters read\n    fname = malloc(size * sizeof *fname);\n    lname = malloc(size * sizeof *lname);\n    if (NULL == fname || NULL == lname)\n    {\n        printf(&quot;Error in memory allocation.&quot;);\n        exit(1);\n    }\n    printf(&quot;Enter first name &quot;);\n    nchar = getline(&amp;fname, &amp;size, stdin);\n    if (nchar == -1) // getline return -1 on failure to read a line.\n    {\n        printf(&quot;Line couldn&apos;t be read..&quot;);\n        // This if block could be repeated for next getline too\n        exit(1);\n    }\n    printf(&quot;Number of characters read :%zu\\n&quot;, nchar);\n    fname[nchar - 1] = &apos;\\0&apos;;\n    printf(&quot;Enter last name &quot;);\n    nchar = getline(&amp;lname, &amp;size, stdin);\n    printf(&quot;Number of characters read :%zu\\n&quot;, nchar);\n    lname[nchar - 1] = &apos;\\0&apos;;\n    printf(&quot;Name entered %s %s\\n&quot;, fname, lname);\n    return 0;\n}\n\nNote: The [ security issues ] with getline shouldn&apos;t be neglected though.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"In general, rather than trimming data that you don&apos;t want, avoid writing it in the first place.  If you don&apos;t want the newline in the buffer, don&apos;t use fgets.  Instead, use getc or fgetc or scanf.  Perhaps something like:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint\nmain(void)\n{\n        char Name[256];\n        char fmt[32];\n        if( snprintf(fmt, sizeof fmt, &quot;%%%zd[^\\n]&quot;, sizeof Name - 1) &gt;= (int)sizeof fmt ){\n                fprintf(stderr, &quot;Unable to write format\\n&quot;);\n                return EXIT_FAILURE;\n        }\n        if( scanf(fmt, Name) == 1 ) {\n                printf(&quot;Name = %s\\n&quot;, Name);\n        }\n        return 0;\n}\n\nNote that this particular approach will leave the newline unread, so you may want to use a format string like &quot;%255[^\\n]%*c&quot; to discard it (eg, sprintf(fmt, &quot;%%%zd[^\\n]%%*c&quot;, sizeof Name - 1);), or perhaps follow the scanf with a getchar().\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Tim Äas one liner is amazing for strings obtained by a call to fgets, because you know they contain a single newline at the end. \n\nIf you are in a different context and want to handle strings that may contain more than one newline, you might be looking for strrspn. It is not POSIX, meaning you will not find it on all Unices. I wrote one for my own needs.\n\n/* Returns the length of the segment leading to the last \n   characters of s in accept. */\nsize_t strrspn (const char *s, const char *accept)\n{\n  const char *ch;\n  size_t len = strlen(s);\n\nmore: \n  if (len &gt; 0) {\n    for (ch = accept ; *ch != 0 ; ch++) {\n      if (s[len - 1] == *ch) {\n        len--;\n        goto more;\n      }\n    }\n  }\n  return len;\n}\n\n\nFor those looking for a Perl chomp equivalent in C, I think this is it (chomp only removes the trailing newline).\n\nline[strrspn(string, &quot;\\r\\n&quot;)] = 0;\n\n\nThe strrcspn function:\n\n/* Returns the length of the segment leading to the last \n   character of reject in s. */\nsize_t strrcspn (const char *s, const char *reject)\n{\n  const char *ch;\n  size_t len = strlen(s);\n  size_t origlen = len;\n\n  while (len &gt; 0) {\n    for (ch = reject ; *ch != 0 ; ch++) {\n      if (s[len - 1] == *ch) {\n        return len;\n      }\n    }\n    len--;\n  }\n  return origlen;\n}\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This is my solution. Very simple.\n// Delete new line\n// char preDelete[256]  include &quot;\\n&quot; as newline after fgets\n\nchar deletedWords[256];\nint iLeng = strlen(preDelete);\nint iFinal = 0;\nfor (int i = 0; i &lt; iLeng; i++) {\n    if (preDelete[i] == &apos;\\n&apos;) {\n\n    }\n    else {\n        deletedWords[iFinal]  = preDelete[i];\n        iFinal++;\n    }\n    if (i == iLeng -1 ) {\n        deletedWords[iFinal] = &apos;\\0&apos;;\n    }\n}\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"The function below is a part of string processing library I am maintaining on Github. It removes and unwanted characters from a string, exactly what you want\n\nint zstring_search_chr(const char *token,char s){\n    if (!token || s==&apos;\\0&apos;)\n        return 0;\n\n    for (;*token; token++)\n        if (*token == s)\n            return 1;\n\n    return 0;\n}\n\nchar *zstring_remove_chr(char *str,const char *bad) {\n    char *src = str , *dst = str;\n    while(*src)\n        if(zstring_search_chr(bad,*src))\n            src++;\n        else\n            *dst++ = *src++;  /* assign first, then incement */\n\n    *dst=&apos;\\0&apos;;\n        return str;\n}\n\n\nAn example usage could be \n\nExample Usage\n      char s[]=&quot;this is a trial string to test the function.&quot;;\n      char const *d=&quot; .&quot;;\n      printf(&quot;%s\\n&quot;,zstring_remove_chr(s,d));\n\n  Example Output\n      thisisatrialstringtotestthefunction\n\n\nYou may want to check other available functions, or even contribute to the project :)\nhttps://github.com/fnoyanisi/zString\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":" for(int i = 0; i &lt; strlen(Name); i++ )\n{\n    if(Name[i] == &apos;\\n&apos;) Name[i] = &apos;\\0&apos;;\n}\n\n\nYou should give it a try. This code basically loop through the string until it finds the &apos;\\n&apos;. When it&apos;s found the &apos;\\n&apos; will be replaced by the null character terminator &apos;\\0&apos;\n\nNote that you are comparing characters and not strings in this line, then there&apos;s no need to use strcmp():\n\nif(Name[i] == &apos;\\n&apos;) Name[i] = &apos;\\0&apos;;\n\n\nsince you will be using single quotes and not double quotes. Here&apos;s a link about single vs double quotes if you want to know more\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/removing-trailing-newline-character-from-fgets()-input-1657387308069#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/removing-trailing-newline-character-from-fgets()-input-1657387308069">Removing trailing newline character from fgets() input</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/gcc">gcc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/newline">newline</a></div></div><div class="question-content mt-5">
                
<p>I am trying to get some data from the user and send it to another function in gcc. The code is something like this.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter your Name: "</span>);
<span class="hljs-keyword">if</span> (!(fgets(Name, <span class="hljs-keyword">sizeof</span> Name, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error reading Name.\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}
</code></pre>

<p>However, I find that it has a newline <code>\n</code> character in the end. So if I enter <code>John</code> it ends up sending <code>John\n</code>. How do I remove that <code>\n</code> and send a proper string.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Perhaps the simplest solution uses one of my favorite little-known functions, <a href="http://www.freebsd.org/cgi/man.cgi?query=strcspn&amp;sektion=3" rel="noreferrer" title="strcspn manpage"><code>strcspn()</code></a>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">buffer[<span class="hljs-built_in">strcspn</span>(buffer, <span class="hljs-string">"\n"</span>)] = <span class="hljs-number">0</span>;
</code></pre>

<p>If you want it to also handle <code>'\r'</code> (say, if the stream is binary):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">buffer[<span class="hljs-built_in">strcspn</span>(buffer, <span class="hljs-string">"\r\n"</span>)] = <span class="hljs-number">0</span>; <span class="hljs-comment">// works for LF, CR, CRLF, LFCR, ...</span>
</code></pre>

<p>The function counts the number of characters until it hits a <code>'\r'</code> or a <code>'\n'</code> (in other words, it finds the first <code>'\r'</code> or <code>'\n'</code>). If it doesn't hit anything, it stops at the <code>'\0'</code> (returning the length of the string).</p>

<p>Note that this works fine even if there is no newline, because <code>strcspn</code> stops at a <code>'\0'</code>. In that case, the entire line is simply replacing <code>'\0'</code> with <code>'\0'</code>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The elegant way:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">Name[<span class="hljs-built_in">strcspn</span>(Name, <span class="hljs-string">"\n"</span>)] = <span class="hljs-number">0</span>;
</code></pre>
<p>The slightly ugly way:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *pos;
<span class="hljs-keyword">if</span> ((pos=<span class="hljs-built_in">strchr</span>(Name, <span class="hljs-string">'\n'</span>)) != <span class="hljs-literal">NULL</span>)
    *pos = <span class="hljs-string">'\0'</span>;
<span class="hljs-keyword">else</span>
    <span class="hljs-comment">/* input too long for buffer, flag error */</span>
</code></pre>
<p>The slightly strange way:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">strtok(Name, <span class="hljs-string">"\n"</span>);
</code></pre>
<p>Note that the <code>strtok</code> function doesn't work as expected if the user enters an empty string (i.e. presses only Enter). It leaves the <code>\n</code> character intact.</p>
<p>There are others as well, of course.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">size_t</span> ln = <span class="hljs-built_in">strlen</span>(name) - <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (*name &amp;&amp; name[ln] == <span class="hljs-string">'\n'</span>) 
    name[ln] = <span class="hljs-string">'\0'</span>;
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Below is a fast approach to remove a potential <code>'\n'</code> from a string saved by <code>fgets()</code>.<br>
It uses <code>strlen()</code>, with 2 tests.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];
<span class="hljs-keyword">if</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span> buffer, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) {

  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(buffer);
  <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span> &amp;&amp; buffer[len<span class="hljs-number">-1</span>] == <span class="hljs-string">'\n'</span>) {
    buffer[--len] = <span class="hljs-string">'\0'</span>;
  }
</code></pre>

<p>Now use <code>buffer</code> and <code>len</code> as needed.</p>

<p>This method has the side benefit of a <code>len</code> value for subsequent code.  It can be easily faster than <code>strchr(Name, '\n')</code>.  <a href="https://codereview.stackexchange.com/a/67844/29485">Ref</a>  YMMV, but both methods work.</p>

<hr>

<p><code>buffer</code>, from the original <code>fgets()</code> will not contain in <code>"\n"</code> under some circumstances:<br>
A) The line was too long for <code>buffer</code> so only <code>char</code> preceding the <code>'\n'</code> is saved in <code>buffer</code>. The unread characters remain in the stream.<br>
B) The last line in the file did not end with a <code>'\n'</code>.  </p>

<p>If input has embedded null characters <code>'\0'</code> in it somewhere, the length reported by <code>strlen()</code> will not include the <code>'\n'</code> location.</p>

<hr>

<p>Some other answers' issues: </p>

<ol>
<li><p><code>strtok(buffer, "\n");</code> fails to remove the <code>'\n'</code> when <code>buffer</code> is <code>"\n"</code>.  From this <a href="https://stackoverflow.com/a/2693826/2410359">answer</a> - amended after this answer to warn of this limitation. </p></li>
<li><p>The following fails on rare occasions when the first <code>char</code> read by <code>fgets()</code> is <code>'\0'</code>.  This happens when input begins with an embedded <code>'\0'</code>.  Then <code>buffer[len -1]</code> becomes <code>buffer[SIZE_MAX]</code> accessing memory certainly outside the legitimate range of <code>buffer</code>. Something a hacker may try or found in foolishly reading UTF16 text files.  This was the state of an <a href="https://stackoverflow.com/a/2693827/2410359">answer</a> when this answer was written.  Later a non-OP edited it to include code like this answer's check for <code>""</code>.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(buffer);
<span class="hljs-keyword">if</span> (buffer[len - <span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>) {  <span class="hljs-comment">// FAILS when len == 0</span>
  buffer[len <span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;
}
</code></pre></li>
<li><p><code>sprintf(buffer,"%s",buffer);</code> is undefined behavior: <a href="https://stackoverflow.com/questions/1283354/is-sprintfbuffer-s-buffer-safe">Ref</a>.  Further, it does not save any leading, separating or trailing whitespace.  Now <a href="https://stackoverflow.com/a/23695411/2410359">deleted</a>.</p></li>
<li><p>[Edit due to good later <a href="https://stackoverflow.com/a/28462221/2410359">answer</a>] There are no problems with the 1 liner <code>buffer[strcspn(buffer, "\n")] = 0;</code> other than performance as compared to the <code>strlen()</code> approach.  Performance in trimming is usually not an issue given code is doing I/O - a black hole of CPU time.  Should following code need the string's length or is highly performance conscious, use this <code>strlen()</code> approach.  Else the <code>strcspn()</code> is a fine alternative.</p></li>
</ol>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Direct to remove the '\n' from the fgets output if every line has '\n'</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">line[<span class="hljs-built_in">strlen</span>(line) - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
</code></pre>

<p>Otherwise:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">remove_newline_ch</span><span class="hljs-params">(<span class="hljs-type">char</span> *line)</span>
{
    <span class="hljs-type">int</span> new_line = <span class="hljs-built_in">strlen</span>(line) <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span> (line[new_line] == <span class="hljs-string">'\n'</span>)
        line[new_line] = <span class="hljs-string">'\0'</span>;
}
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For single '\n' trimming,</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">remove_new_line</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>)</span>
{
    <span class="hljs-type">size_t</span> length = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>);
    <span class="hljs-keyword">if</span>((length &gt; <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">string</span>[length<span class="hljs-number">-1</span>] == <span class="hljs-string">'\n'</span>))
    {
        <span class="hljs-built_in">string</span>[length<span class="hljs-number">-1</span>] =<span class="hljs-string">'\0'</span>;
    }
}
</code></pre>

<p>for multiple '\n' trimming,</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">remove_multi_new_line</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>)</span>
{
  <span class="hljs-type">size_t</span> length = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>);
  <span class="hljs-keyword">while</span>((length&gt;<span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">string</span>[length<span class="hljs-number">-1</span>] == <span class="hljs-string">'\n'</span>))
  {
      --length;
      <span class="hljs-built_in">string</span>[length] =<span class="hljs-string">'\0'</span>;
  }
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My Newbie way ;-) Please let me know if that's correct. It seems to be working for all my cases:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPT_SIZE 5</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">findNULL</span><span class="hljs-params">(<span class="hljs-type">char</span>* arr)</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(arr); i++)
    {
        <span class="hljs-keyword">if</span> (*(arr+i) == <span class="hljs-string">'\n'</span>)
        {
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> *input = <span class="hljs-built_in">malloc</span>(IPT_SIZE + <span class="hljs-number">1</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)), buff;
    <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//prompt user for the input:</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"input string no longer than %i characters: "</span>, IPT_SIZE);
    <span class="hljs-keyword">do</span>
    {
        fgets(input, <span class="hljs-number">1000</span>, <span class="hljs-built_in">stdin</span>);
        *(input + findNULL(input)) = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(input) &gt; IPT_SIZE)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error! the given string is too large. try again...\n"</span>);
            counter++;
        }
        <span class="hljs-comment">//if the counter exceeds 3, exit the program (custom function):</span>
        errorMsgExit(counter, <span class="hljs-number">3</span>); 
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">strlen</span>(input) &gt; IPT_SIZE);

<span class="hljs-comment">//rest of the program follows</span>

<span class="hljs-built_in">free</span>(input)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The steps to remove the newline character in the perhaps most obvious way:</p>

<ol>
<li>Determine the length of the string inside <code>NAME</code> by using <code>strlen()</code>, header <code>string.h</code>. Note that <code>strlen()</code> does not count the terminating <code>\0</code>.</li>
</ol>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">size_t</span> sl = <span class="hljs-built_in">strlen</span>(NAME);
</code></pre>

<hr>

<ol start="2">
<li>Look if the string begins with or only includes one <code>\0</code> character (empty string). In this case <code>sl</code> would be <code>0</code> since <code>strlen()</code> as I said above doesnÂ´t count the <code>\0</code> and stops at the first occurrence of it: </li>
</ol>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">if</span>(sl == <span class="hljs-number">0</span>)
{
   <span class="hljs-comment">// Skip the newline replacement process.</span>
}
</code></pre>

<hr>

<ol start="3">
<li>Check if the last character of the proper string is a newline character <code>'\n'</code>.  If this is the case, replace <code>\n</code> with a <code>\0</code>. Note that index counts start at <code>0</code> so we will need to do <code>NAME[sl - 1]</code>:</li>
</ol>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">if</span>(NAME[sl - <span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
{
   NAME[sl - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
}
</code></pre>

<p>Note if you only pressed Enter at the <code>fgets()</code> string request (the string content was only consisted of a newline character) the string in <code>NAME</code> will be an empty string thereafter.</p>

<hr>

<ol start="4">
<li>We can combine step 2. and 3. together in just one <code>if</code>-statement by using the logic operator <code>&amp;&amp;</code>:</li>
</ol>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">if</span>(sl &gt; <span class="hljs-number">0</span> &amp;&amp; NAME[sl - <span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
{
   NAME[sl - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
}
</code></pre>

<hr>

<ol start="5">
<li>The finished code:</li>
</ol>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">size_t</span> sl = <span class="hljs-built_in">strlen</span>(NAME);
<span class="hljs-keyword">if</span>(sl &gt; <span class="hljs-number">0</span> &amp;&amp; NAME[sl - <span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
{
   NAME[sl - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
}
</code></pre>

<hr>

<p>If you rather like a function for use this technique by handling <code>fgets</code> output strings in general without retyping each and every time, here is <code>fgets_newline_kill</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">fgets_newline_kill</span><span class="hljs-params">(<span class="hljs-type">char</span> a[])</span>
{
    <span class="hljs-type">size_t</span> sl = <span class="hljs-built_in">strlen</span>(a);

    <span class="hljs-keyword">if</span>(sl &gt; <span class="hljs-number">0</span> &amp;&amp; a[sl - <span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
    {
       a[sl - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
    }
}
</code></pre>

<p>In your provided example, it would be:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter your Name: "</span>);

<span class="hljs-keyword">if</span> (fgets(Name, <span class="hljs-keyword">sizeof</span> Name, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error reading Name.\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">else</span> {
    fgets_newline_kill(NAME);
}
</code></pre>

<p>Note that this method does not work if the input string has embedded <code>\0</code>s in it. If that would be the case <code>strlen()</code> would only return the amount of characters until the first <code>\0</code>. But this isnÂ´t quite a common approach, since the most string-reading functions usually stop at the first <code>\0</code> and take the string until that null character.</p>

<p>Aside from the question on its own. Try to avoid double negations that make your code unclearer: <code>if (!(fgets(Name, sizeof Name, stdin) != NULL) {}</code>. You can simply do <code>if (fgets(Name, sizeof Name, stdin) == NULL) {}</code>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If using <code>getline</code> is an option - Not neglecting its security issues and if you wish to brace pointers - you can avoid string functions as the <code>getline</code> returns the number of characters. Something like below</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> *fname, *lname;
    <span class="hljs-type">size_t</span> size = <span class="hljs-number">32</span>, nchar; <span class="hljs-comment">// Max size of strings and number of characters read</span>
    fname = <span class="hljs-built_in">malloc</span>(size * <span class="hljs-keyword">sizeof</span> *fname);
    lname = <span class="hljs-built_in">malloc</span>(size * <span class="hljs-keyword">sizeof</span> *lname);
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == fname || <span class="hljs-literal">NULL</span> == lname)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error in memory allocation."</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter first name "</span>);
    nchar = getline(&amp;fname, &amp;size, <span class="hljs-built_in">stdin</span>);
    <span class="hljs-keyword">if</span> (nchar == <span class="hljs-number">-1</span>) <span class="hljs-comment">// getline return -1 on failure to read a line.</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Line couldn't be read.."</span>);
        <span class="hljs-comment">// This if block could be repeated for next getline too</span>
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Number of characters read :%zu\n"</span>, nchar);
    fname[nchar - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter last name "</span>);
    nchar = getline(&amp;lname, &amp;size, <span class="hljs-built_in">stdin</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Number of characters read :%zu\n"</span>, nchar);
    lname[nchar - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Name entered %s %s\n"</span>, fname, lname);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><sup><strong>Note</strong>: The <a href="https://stackoverflow.com/questions/2008173/writing-secure-c-and-secure-c-idioms">[ <strong>security issues</strong> ]</a> with <code>getline</code> shouldn't be neglected though.</sup></p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In general, rather than trimming data that you don't want, avoid writing it in the first place.  If you don't want the newline in the buffer, don't use fgets.  Instead, use <code>getc</code> or <code>fgetc</code> or <code>scanf</code>.  Perhaps something like:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
        <span class="hljs-type">char</span> Name[<span class="hljs-number">256</span>];
        <span class="hljs-type">char</span> fmt[<span class="hljs-number">32</span>];
        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">snprintf</span>(fmt, <span class="hljs-keyword">sizeof</span> fmt, <span class="hljs-string">"%%%zd[^\n]"</span>, <span class="hljs-keyword">sizeof</span> Name - <span class="hljs-number">1</span>) &gt;= (<span class="hljs-type">int</span>)<span class="hljs-keyword">sizeof</span> fmt ){
                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unable to write format\n"</span>);
                <span class="hljs-keyword">return</span> EXIT_FAILURE;
        }
        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">scanf</span>(fmt, Name) == <span class="hljs-number">1</span> ) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Name = %s\n"</span>, Name);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Note that this particular approach will leave the newline unread, so you may want to use a format string like <code>"%255[^\n]%*c"</code> to discard it (eg, <code>sprintf(fmt, "%%%zd[^\n]%%*c", sizeof Name - 1);</code>), or perhaps follow the scanf with a <code>getchar()</code>.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Tim Äas one liner is amazing for strings obtained by a call to fgets, because you know they contain a single newline at the end. </p>

<p>If you are in a different context and want to handle strings that may contain more than one newline, you might be looking for strrspn. It is not POSIX, meaning you will not find it on all Unices. I wrote one for my own needs.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* Returns the length of the segment leading to the last 
   characters of s in accept. */</span>
<span class="hljs-type">size_t</span> <span class="hljs-title function_">strrspn</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *accept)</span>
{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ch;
  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);

more: 
  <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (ch = accept ; *ch != <span class="hljs-number">0</span> ; ch++) {
      <span class="hljs-keyword">if</span> (s[len - <span class="hljs-number">1</span>] == *ch) {
        len--;
        <span class="hljs-keyword">goto</span> more;
      }
    }
  }
  <span class="hljs-keyword">return</span> len;
}
</code></pre>

<p>For those looking for a Perl chomp equivalent in C, I think this is it (chomp only removes the trailing newline).</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">line[strrspn(<span class="hljs-built_in">string</span>, <span class="hljs-string">"\r\n"</span>)] = <span class="hljs-number">0</span>;
</code></pre>

<p>The strrcspn function:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* Returns the length of the segment leading to the last 
   character of reject in s. */</span>
<span class="hljs-type">size_t</span> <span class="hljs-title function_">strrcspn</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *reject)</span>
{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ch;
  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);
  <span class="hljs-type">size_t</span> origlen = len;

  <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (ch = reject ; *ch != <span class="hljs-number">0</span> ; ch++) {
      <span class="hljs-keyword">if</span> (s[len - <span class="hljs-number">1</span>] == *ch) {
        <span class="hljs-keyword">return</span> len;
      }
    }
    len--;
  }
  <span class="hljs-keyword">return</span> origlen;
}
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is my solution. Very simple.</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// Delete new line</span>
<span class="hljs-comment">// char preDelete[256]  include "\n" as newline after fgets</span>

<span class="hljs-type">char</span> deletedWords[<span class="hljs-number">256</span>];
<span class="hljs-type">int</span> iLeng = <span class="hljs-built_in">strlen</span>(preDelete);
<span class="hljs-type">int</span> iFinal = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iLeng; i++) {
    <span class="hljs-keyword">if</span> (preDelete[i] == <span class="hljs-string">'\n'</span>) {

    }
    <span class="hljs-keyword">else</span> {
        deletedWords[iFinal]  = preDelete[i];
        iFinal++;
    }
    <span class="hljs-keyword">if</span> (i == iLeng <span class="hljs-number">-1</span> ) {
        deletedWords[iFinal] = <span class="hljs-string">'\0'</span>;
    }
}
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The function below is a part of string processing library I am maintaining on Github. It removes and unwanted characters from a string, exactly what you want</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">zstring_search_chr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *token,<span class="hljs-type">char</span> s)</span>{
    <span class="hljs-keyword">if</span> (!token || s==<span class="hljs-string">'\0'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (;*token; token++)
        <span class="hljs-keyword">if</span> (*token == s)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">char</span> *<span class="hljs-title function_">zstring_remove_chr</span><span class="hljs-params">(<span class="hljs-type">char</span> *str,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *bad)</span> {
    <span class="hljs-type">char</span> *src = str , *dst = str;
    <span class="hljs-keyword">while</span>(*src)
        <span class="hljs-keyword">if</span>(zstring_search_chr(bad,*src))
            src++;
        <span class="hljs-keyword">else</span>
            *dst++ = *src++;  <span class="hljs-comment">/* assign first, then incement */</span>

    *dst=<span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> str;
}
</code></pre>

<p>An example usage could be </p>

<pre class="lang-c s-code-block"><code class="hljs language-c">Example Usage
      <span class="hljs-type">char</span> s[]=<span class="hljs-string">"this is a trial string to test the function."</span>;
      <span class="hljs-type">char</span> <span class="hljs-type">const</span> *d=<span class="hljs-string">" ."</span>;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,zstring_remove_chr(s,d));

  Example Output
      thisisatrialstringtotestthefunction
</code></pre>

<p>You may want to check other available functions, or even contribute to the project :)
<a href="https://github.com/fnoyanisi/zString" rel="nofollow">https://github.com/fnoyanisi/zString</a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(Name); i++ )
{
    <span class="hljs-keyword">if</span>(Name[i] == <span class="hljs-string">'\n'</span>) Name[i] = <span class="hljs-string">'\0'</span>;
}
</code></pre>

<p>You should give it a try. This code basically loop through the string until it finds the '\n'. When it's found the '\n' will be replaced by the null character terminator '\0'</p>

<p>Note that you are comparing characters and not strings in this line, then there's no need to use strcmp():</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">if</span>(Name[i] == <span class="hljs-string">'\n'</span>) Name[i] = <span class="hljs-string">'\0'</span>;
</code></pre>

<p>since you will be using single quotes and not double quotes. <a href="https://stackoverflow.com/questions/3683602/single-quotes-vs-double-quotes-in-c-or-c" title="Here's">Here's</a> a link about single vs double quotes if you want to know more</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Perhaps the simplest solution uses one of my favorite little-known functions, \u0026lt;a href=\u0026quot;http://www.freebsd.org/cgi/man.cgi?query=strcspn\u0026amp;amp;sektion=3\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;strcspn manpage\u0026quot;\u0026gt;\u0026lt;code\u0026gt;strcspn()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;buffer[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcspn\u0026lt;/span\u0026gt;(buffer, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you want it to also handle \u0026lt;code\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/code\u0026gt; (say, if the stream is binary):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;buffer[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcspn\u0026lt;/span\u0026gt;(buffer, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\r\\n\u0026quot;\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// works for LF, CR, CRLF, LFCR, ...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The function counts the number of characters until it hits a \u0026lt;code\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/code\u0026gt; or a \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; (in other words, it finds the first \u0026lt;code\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt;). If it doesn\u0026apos;t hit anything, it stops at the \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; (returning the length of the string).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this works fine even if there is no newline, because \u0026lt;code\u0026gt;strcspn\u0026lt;/code\u0026gt; stops at a \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;. In that case, the entire line is simply replacing \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The elegant way:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;Name[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcspn\u0026lt;/span\u0026gt;(Name, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The slightly ugly way:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pos;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((pos=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strchr\u0026lt;/span\u0026gt;(Name, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)) != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n    *pos = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* input too long for buffer, flag error */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The slightly strange way:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;strtok(Name, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the \u0026lt;code\u0026gt;strtok\u0026lt;/code\u0026gt; function doesn\u0026apos;t work as expected if the user enters an empty string (i.e. presses only Enter). It leaves the \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; character intact.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are others as well, of course.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; ln = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(name) - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*name \u0026amp;amp;\u0026amp;amp; name[ln] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) \n    name[ln] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Below is a fast approach to remove a potential \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; from a string saved by \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nIt uses \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt;, with 2 tests.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fgets(buffer, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; buffer, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;) != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;) {\n\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buffer);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; buffer[len\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) {\n    buffer[--len] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now use \u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;len\u0026lt;/code\u0026gt; as needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This method has the side benefit of a \u0026lt;code\u0026gt;len\u0026lt;/code\u0026gt; value for subsequent code.  It can be easily faster than \u0026lt;code\u0026gt;strchr(Name, \u0026apos;\\n\u0026apos;)\u0026lt;/code\u0026gt;.  \u0026lt;a href=\u0026quot;https://codereview.stackexchange.com/a/67844/29485\u0026quot;\u0026gt;Ref\u0026lt;/a\u0026gt;  YMMV, but both methods work.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt;, from the original \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; will not contain in \u0026lt;code\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/code\u0026gt; under some circumstances:\u0026lt;br\u0026gt;\nA) The line was too long for \u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt; so only \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; preceding the \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; is saved in \u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt;. The unread characters remain in the stream.\u0026lt;br\u0026gt;\nB) The last line in the file did not end with a \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If input has embedded null characters \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; in it somewhere, the length reported by \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; will not include the \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; location.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Some other answers\u0026apos; issues: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;strtok(buffer, \u0026quot;\\n\u0026quot;);\u0026lt;/code\u0026gt; fails to remove the \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; when \u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/code\u0026gt;.  From this \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2693826/2410359\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; - amended after this answer to warn of this limitation. \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The following fails on rare occasions when the first \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; read by \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.  This happens when input begins with an embedded \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.  Then \u0026lt;code\u0026gt;buffer[len -1]\u0026lt;/code\u0026gt; becomes \u0026lt;code\u0026gt;buffer[SIZE_MAX]\u0026lt;/code\u0026gt; accessing memory certainly outside the legitimate range of \u0026lt;code\u0026gt;buffer\u0026lt;/code\u0026gt;. Something a hacker may try or found in foolishly reading UTF16 text files.  This was the state of an \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2693827/2410359\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; when this answer was written.  Later a non-OP edited it to include code like this answer\u0026apos;s check for \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buffer);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (buffer[len - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// FAILS when len == 0\u0026lt;/span\u0026gt;\n  buffer[len \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sprintf(buffer,\u0026quot;%s\u0026quot;,buffer);\u0026lt;/code\u0026gt; is undefined behavior: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1283354/is-sprintfbuffer-s-buffer-safe\u0026quot;\u0026gt;Ref\u0026lt;/a\u0026gt;.  Further, it does not save any leading, separating or trailing whitespace.  Now \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/23695411/2410359\u0026quot;\u0026gt;deleted\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;[Edit due to good later \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/28462221/2410359\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt;] There are no problems with the 1 liner \u0026lt;code\u0026gt;buffer[strcspn(buffer, \u0026quot;\\n\u0026quot;)] = 0;\u0026lt;/code\u0026gt; other than performance as compared to the \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; approach.  Performance in trimming is usually not an issue given code is doing I/O - a black hole of CPU time.  Should following code need the string\u0026apos;s length or is highly performance conscious, use this \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; approach.  Else the \u0026lt;code\u0026gt;strcspn()\u0026lt;/code\u0026gt; is a fine alternative.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Direct to remove the \u0026apos;\\n\u0026apos; from the fgets output if every line has \u0026apos;\\n\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;line[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(line) - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Otherwise:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove_newline_ch\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *line)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; new_line = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(line) \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (line[new_line] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n        line[new_line] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For single \u0026apos;\\n\u0026apos; trimming,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove_new_line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; length = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((length \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[length\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;))\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[length\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;for multiple \u0026apos;\\n\u0026apos; trimming,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove_multi_new_line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; length = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((length\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[length\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;))\n  {\n      --length;\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[length] =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My Newbie way ;-) Please let me know if that\u0026apos;s correct. It seems to be working for all my cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; IPT_SIZE 5\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;findNULL\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* arr)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(arr); i++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*(arr+i) == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *input = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(IPT_SIZE + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)), buff;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; counter = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prompt user for the input:\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;input string no longer than %i characters: \u0026quot;\u0026lt;/span\u0026gt;, IPT_SIZE);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;\n    {\n        fgets(input, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n        *(input + findNULL(input)) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(input) \u0026amp;gt; IPT_SIZE)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;error! the given string is too large. try again...\\n\u0026quot;\u0026lt;/span\u0026gt;);\n            counter++;\n        }\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//if the counter exceeds 3, exit the program (custom function):\u0026lt;/span\u0026gt;\n        errorMsgExit(counter, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;); \n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(input) \u0026amp;gt; IPT_SIZE);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//rest of the program follows\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(input)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The steps to remove the newline character in the perhaps most obvious way:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Determine the length of the string inside \u0026lt;code\u0026gt;NAME\u0026lt;/code\u0026gt; by using \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt;, header \u0026lt;code\u0026gt;string.h\u0026lt;/code\u0026gt;. Note that \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; does not count the terminating \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sl = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(NAME);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;Look if the string begins with or only includes one \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt; character (empty string). In this case \u0026lt;code\u0026gt;sl\u0026lt;/code\u0026gt; would be \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; since \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; as I said above doesnÂ´t count the \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt; and stops at the first occurrence of it: \u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(sl == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip the newline replacement process.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;Check if the last character of the proper string is a newline character \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt;.  If this is the case, replace \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; with a \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt;. Note that index counts start at \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; so we will need to do \u0026lt;code\u0026gt;NAME[sl - 1]\u0026lt;/code\u0026gt;:\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n{\n   NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note if you only pressed Enter at the \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; string request (the string content was only consisted of a newline character) the string in \u0026lt;code\u0026gt;NAME\u0026lt;/code\u0026gt; will be an empty string thereafter.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;ol start=\u0026quot;4\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;We can combine step 2. and 3. together in just one \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt;-statement by using the logic operator \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;:\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(sl \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n{\n   NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;ol start=\u0026quot;5\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;The finished code:\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sl = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(NAME);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(sl \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n{\n   NAME[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;If you rather like a function for use this technique by handling \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; output strings in general without retyping each and every time, here is \u0026lt;code\u0026gt;fgets_newline_kill\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fgets_newline_kill\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[])\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sl = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(a);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(sl \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; a[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n    {\n       a[sl - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In your provided example, it would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter your Name: \u0026quot;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fgets(Name, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; Name, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;) == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error reading Name.\\n\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    fgets_newline_kill(NAME);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this method does not work if the input string has embedded \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt;s in it. If that would be the case \u0026lt;code\u0026gt;strlen()\u0026lt;/code\u0026gt; would only return the amount of characters until the first \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt;. But this isnÂ´t quite a common approach, since the most string-reading functions usually stop at the first \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt; and take the string until that null character.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Aside from the question on its own. Try to avoid double negations that make your code unclearer: \u0026lt;code\u0026gt;if (!(fgets(Name, sizeof Name, stdin) != NULL) {}\u0026lt;/code\u0026gt;. You can simply do \u0026lt;code\u0026gt;if (fgets(Name, sizeof Name, stdin) == NULL) {}\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If using \u0026lt;code\u0026gt;getline\u0026lt;/code\u0026gt; is an option - Not neglecting its security issues and if you wish to brace pointers - you can avoid string functions as the \u0026lt;code\u0026gt;getline\u0026lt;/code\u0026gt; returns the number of characters. Something like below\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *fname, *lname;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;, nchar; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Max size of strings and number of characters read\u0026lt;/span\u0026gt;\n    fname = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(size * \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *fname);\n    lname = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(size * \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *lname);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; == fname || \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; == lname)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error in memory allocation.\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter first name \u0026quot;\u0026lt;/span\u0026gt;);\n    nchar = getline(\u0026amp;amp;fname, \u0026amp;amp;size, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (nchar == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// getline return -1 on failure to read a line.\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Line couldn\u0026apos;t be read..\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This if block could be repeated for next getline too\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Number of characters read :%zu\\n\u0026quot;\u0026lt;/span\u0026gt;, nchar);\n    fname[nchar - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter last name \u0026quot;\u0026lt;/span\u0026gt;);\n    nchar = getline(\u0026amp;amp;lname, \u0026amp;amp;size, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Number of characters read :%zu\\n\u0026quot;\u0026lt;/span\u0026gt;, nchar);\n    lname[nchar - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Name entered %s %s\\n\u0026quot;\u0026lt;/span\u0026gt;, fname, lname);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt;: The \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2008173/writing-secure-c-and-secure-c-idioms\u0026quot;\u0026gt;[ \u0026lt;strong\u0026gt;security issues\u0026lt;/strong\u0026gt; ]\u0026lt;/a\u0026gt; with \u0026lt;code\u0026gt;getline\u0026lt;/code\u0026gt; shouldn\u0026apos;t be neglected though.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In general, rather than trimming data that you don\u0026apos;t want, avoid writing it in the first place.  If you don\u0026apos;t want the newline in the buffer, don\u0026apos;t use fgets.  Instead, use \u0026lt;code\u0026gt;getc\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;fgetc\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;.  Perhaps something like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; Name[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; fmt[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;snprintf\u0026lt;/span\u0026gt;(fmt, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; fmt, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%%%zd[^\\n]\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; Name - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \u0026amp;gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; fmt ){\n                \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Unable to write format\\n\u0026quot;\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; EXIT_FAILURE;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(fmt, Name) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ) {\n                \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Name = %s\\n\u0026quot;\u0026lt;/span\u0026gt;, Name);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that this particular approach will leave the newline unread, so you may want to use a format string like \u0026lt;code\u0026gt;\u0026quot;%255[^\\n]%*c\u0026quot;\u0026lt;/code\u0026gt; to discard it (eg, \u0026lt;code\u0026gt;sprintf(fmt, \u0026quot;%%%zd[^\\n]%%*c\u0026quot;, sizeof Name - 1);\u0026lt;/code\u0026gt;), or perhaps follow the scanf with a \u0026lt;code\u0026gt;getchar()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Tim Äas one liner is amazing for strings obtained by a call to fgets, because you know they contain a single newline at the end. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are in a different context and want to handle strings that may contain more than one newline, you might be looking for strrspn. It is not POSIX, meaning you will not find it on all Unices. I wrote one for my own needs.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Returns the length of the segment leading to the last \n   characters of s in accept. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;strrspn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *accept)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *ch;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(s);\n\nmore: \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (ch = accept ; *ch != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ; ch++) {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (s[len - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == *ch) {\n        len--;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;goto\u0026lt;/span\u0026gt; more;\n      }\n    }\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; len;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For those looking for a Perl chomp equivalent in C, I think this is it (chomp only removes the trailing newline).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;line[strrspn(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\r\\n\u0026quot;\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The strrcspn function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Returns the length of the segment leading to the last \n   character of reject in s. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;strrcspn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *reject)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *ch;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(s);\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; origlen = len;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (len \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (ch = reject ; *ch != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ; ch++) {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (s[len - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == *ch) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; len;\n      }\n    }\n    len--;\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; origlen;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is my solution. Very simple.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Delete new line\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// char preDelete[256]  include \u0026quot;\\n\u0026quot; as newline after fgets\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; deletedWords[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; iLeng = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(preDelete);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; iFinal = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; iLeng; i++) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (preDelete[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) {\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n        deletedWords[iFinal]  = preDelete[i];\n        iFinal++;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (i == iLeng \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt; ) {\n        deletedWords[iFinal] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The function below is a part of string processing library I am maintaining on Github. It removes and unwanted characters from a string, exactly what you want\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;zstring_search_chr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *token,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s)\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!token || s==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (;*token; token++)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*token == s)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;zstring_remove_chr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *bad)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *src = str , *dst = str;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(*src)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(zstring_search_chr(bad,*src))\n            src++;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            *dst++ = *src++;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* assign first, then incement */\u0026lt;/span\u0026gt;\n\n    *dst=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; str;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;An example usage could be \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;Example Usage\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[]=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;this is a trial string to test the function.\u0026quot;\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; *d=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; .\u0026quot;\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;,zstring_remove_chr(s,d));\n\n  Example Output\n      thisisatrialstringtotestthefunction\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You may want to check other available functions, or even contribute to the project :)\n\u0026lt;a href=\u0026quot;https://github.com/fnoyanisi/zString\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;https://github.com/fnoyanisi/zString\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(Name); i++ )\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(Name[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) Name[i] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You should give it a try. This code basically loop through the string until it finds the \u0026apos;\\n\u0026apos;. When it\u0026apos;s found the \u0026apos;\\n\u0026apos; will be replaced by the null character terminator \u0026apos;\\0\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that you are comparing characters and not strings in this line, then there\u0026apos;s no need to use strcmp():\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(Name[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) Name[i] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;since you will be using single quotes and not double quotes. \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3683602/single-quotes-vs-double-quotes-in-c-or-c\u0026quot; title=\u0026quot;Here\u0026apos;s\u0026quot;\u0026gt;Here\u0026apos;s\u0026lt;/a\u0026gt; a link about single vs double quotes if you want to know more\u0026lt;/p\u0026gt;\n    "],"id":218,"title":"Removing trailing newline character from fgets() input","content":"\n                \n\u0026lt;p\u0026gt;I am trying to get some data from the user and send it to another function in gcc. The code is something like this.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter your Name: \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!(fgets(Name, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; Name, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;) != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error reading Name.\\n\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, I find that it has a newline \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; character in the end. So if I enter \u0026lt;code\u0026gt;John\u0026lt;/code\u0026gt; it ends up sending \u0026lt;code\u0026gt;John\\n\u0026lt;/code\u0026gt;. How do I remove that \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; and send a proper string.\u0026lt;/p\u0026gt;\n    ","slug":"removing-trailing-newline-character-from-fgets()-input-1657387308069","postType":"QUESTION","createdAt":"2022-07-09T17:21:48.000Z","updatedAt":"2022-07-09T17:21:48.000Z","tags":[{"id":1501,"name":"gcc","slug":"gcc","createdAt":"2022-07-09T17:21:48.000Z","updatedAt":"2022-07-09T17:21:48.000Z","Questions_Tags":{"questionId":218,"tagId":1501}},{"id":1502,"name":"newline","slug":"newline","createdAt":"2022-07-09T17:21:48.000Z","updatedAt":"2022-07-09T17:21:48.000Z","Questions_Tags":{"questionId":218,"tagId":1502}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"removing-trailing-newline-character-from-fgets()-input-1657387308069"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>