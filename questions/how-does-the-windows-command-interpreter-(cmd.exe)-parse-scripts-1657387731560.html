<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How does the Windows Command Interpreter (CMD.EXE) parse scripts? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I ran into ss64.com which provides good help regarding how to write batch scripts that the Windows Command Interpreter will run.
However, I have been unable to find a good explanation of the grammar of batch scripts, how things expand or do not expand, and how to escape things.
Here are sample questions that I have not been able to solve:

How is the quote system managed? I made a TinyPerl script
( foreach $i (@ARGV) { print &#x27;*&#x27; . $i ; } ), compiled it and called it this way :

my_script.exe &quot;a &quot;&quot;b&quot;&quot; c&quot; → output is  *a &quot;b*c
my_script.exe &quot;&quot;&quot;a b c&quot;&quot;&quot; → output it *&quot;a*b*c&quot;


How does the internal echo command work? What is expanded inside that command?
Why do I have to use for [...] %%I in file scripts, but for [...] %I in interactive sessions?
What are the escape characters, and in what context? How to escape a percent sign? For example, how can I echo %PROCESSOR_ARCHITECTURE% literally? I found that echo.exe %&quot;&quot;PROCESSOR_ARCHITECTURE% works, is there a better solution?
How do pairs of % match? Example:

set b=a , echo %a %b% c% → %a a c%
set a =b, echo %a %b% c% → bb% c%


How do I ensure a variable passes to a command as a single argument if ever this variable contains double quotes?
How are variables stored when using the set command? For example, if I do set a=a&quot; b and then echo.%a% I obtain a&quot; b. If I however use echo.exe from the UnxUtils, I get a b. How comes %a% expands in a different way?

Thank you for your lights.
    "/><meta property="og:title" content="How does the Windows Command Interpreter (CMD.EXE) parse scripts? | Solutions Checker"/><meta property="og:description" content="I ran into ss64.com which provides good help regarding how to write batch scripts that the Windows Command Interpreter will run.
However, I have been unable to find a good explanation of the grammar of batch scripts, how things expand or do not expand, and how to escape things.
Here are sample questions that I have not been able to solve:

How is the quote system managed? I made a TinyPerl script
( foreach $i (@ARGV) { print &#x27;*&#x27; . $i ; } ), compiled it and called it this way :

my_script.exe &quot;a &quot;&quot;b&quot;&quot; c&quot; → output is  *a &quot;b*c
my_script.exe &quot;&quot;&quot;a b c&quot;&quot;&quot; → output it *&quot;a*b*c&quot;


How does the internal echo command work? What is expanded inside that command?
Why do I have to use for [...] %%I in file scripts, but for [...] %I in interactive sessions?
What are the escape characters, and in what context? How to escape a percent sign? For example, how can I echo %PROCESSOR_ARCHITECTURE% literally? I found that echo.exe %&quot;&quot;PROCESSOR_ARCHITECTURE% works, is there a better solution?
How do pairs of % match? Example:

set b=a , echo %a %b% c% → %a a c%
set a =b, echo %a %b% c% → bb% c%


How do I ensure a variable passes to a command as a single argument if ever this variable contains double quotes?
How are variables stored when using the set command? For example, if I do set a=a&quot; b and then echo.%a% I obtain a&quot; b. If I however use echo.exe from the UnxUtils, I get a b. How comes %a% expands in a different way?

Thank you for your lights.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How does the Windows Command Interpreter (CMD.EXE) parse scripts?","text":"I ran into ss64.com which provides good help regarding how to write batch scripts that the Windows Command Interpreter will run.\nHowever, I have been unable to find a good explanation of the grammar of batch scripts, how things expand or do not expand, and how to escape things.\nHere are sample questions that I have not been able to solve:\n\nHow is the quote system managed? I made a TinyPerl script\n( foreach $i (@ARGV) { print &apos;*&apos; . $i ; } ), compiled it and called it this way :\n\nmy_script.exe &quot;a &quot;&quot;b&quot;&quot; c&quot; → output is  *a &quot;b*c\nmy_script.exe &quot;&quot;&quot;a b c&quot;&quot;&quot; → output it *&quot;a*b*c&quot;\n\n\nHow does the internal echo command work? What is expanded inside that command?\nWhy do I have to use for [...] %%I in file scripts, but for [...] %I in interactive sessions?\nWhat are the escape characters, and in what context? How to escape a percent sign? For example, how can I echo %PROCESSOR_ARCHITECTURE% literally? I found that echo.exe %&quot;&quot;PROCESSOR_ARCHITECTURE% works, is there a better solution?\nHow do pairs of % match? Example:\n\nset b=a , echo %a %b% c% → %a a c%\nset a =b, echo %a %b% c% → bb% c%\n\n\nHow do I ensure a variable passes to a command as a single argument if ever this variable contains double quotes?\nHow are variables stored when using the set command? For example, if I do set a=a&quot; b and then echo.%a% I obtain a&quot; b. If I however use echo.exe from the UnxUtils, I get a b. How comes %a% expands in a different way?\n\nThank you for your lights.\n    ","answerCount":8,"upVoteCount":500,"suggestedAnswer":[{"text":"We performed experiments to investigate the grammar of batch scripts. We also investigated differences between batch and command line mode.\nBatch Line Parser:\nHere is a brief overview of phases in the batch file line parser:\nPhase 0) Read Line:\nPhase 1) Percent Expansion:\nPhase 2) Process special characters, tokenize, and build a cached command block: This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes.\nPhase 3) Echo the parsed command(s) Only if the command block did not begin with @, and ECHO was ON at the start of the preceding step.\nPhase 4) FOR %X variable expansion: Only if a FOR command is active and the commands after DO are being processed.\nPhase 5) Delayed Expansion: Only if delayed expansion is enabled\nPhase 5.3) Pipe processing: Only if commands are on either side of a pipe\nPhase 5.5) Execute Redirection:\nPhase 6) CALL processing/Caret doubling: Only if the command token is CALL\nPhase 7) Execute: The command is executed\n\n\nHere are details for each phase:\nNote that the phases described below are only a model of how the batch parser works. The actual cmd.exe internals may not reflect these phases. But this model is effective at predicting behavior of batch scripts.\nPhase 0) Read Line: Read line of input through first &lt;LF&gt;.\n\nWhen reading a line to be parsed as a command, &lt;Ctrl-Z&gt; (0x1A) is read as &lt;LF&gt; (LineFeed 0x0A)\nWhen GOTO or CALL reads lines while scanning for a :label, &lt;Ctrl-Z&gt;, is treated as itself - it is not converted to &lt;LF&gt;\n\nPhase 1) Percent Expansion:\n\nA double %% is replaced by a single %\nExpansion of arguments (%*, %1, %2, etc.)\nExpansion of %var%, if var does not exist replace it with nothing\nLine is truncated at first &lt;LF&gt; not within %var% expansion\nFor a complete explanation read the first half of this from dbenham Same thread: Percent Phase\n\nPhase 2) Process special characters, tokenize, and build a cached command block: This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes. What follows is an approximation of this process.\nThere are concepts that are important throughout this phase.\n\nA token is simply a string of characters that is treated as a unit.\nTokens are separated by token delimiters. The standard token delimiters are &lt;space&gt; &lt;tab&gt; ; , = &lt;0x0B&gt; &lt;0x0C&gt; and &lt;0xFF&gt;\nConsecutive token delimiters are treated as one - there are no empty tokens between token delimiters\nThere are no token delimiters within a quoted string. The entire quoted string is always treated as part of a single token. A single token may consist of a combination of quoted strings and unquoted characters.\n\nThe following characters may have special meaning in this phase, depending on context: &lt;CR&gt; ^ ( @ &amp; | &lt; &gt; &lt;LF&gt; &lt;space&gt; &lt;tab&gt; ; , = &lt;0x0B&gt; &lt;0x0C&gt; &lt;0xFF&gt;\nLook at each character from left to right:\n\nIf &lt;CR&gt; then remove it, as if it were never there (except for weird redirection behavior)\nIf a caret (^), the next character is escaped, and the escaping caret is removed. Escaped characters lose all special meaning (except for &lt;LF&gt;).\nIf a quote (&quot;), toggle the quote flag. If the quote flag is active, then only &quot; and &lt;LF&gt; are special. All other characters lose their special meaning until the next quote toggles the quote flag off. It is not possible to escape the closing quote. All quoted characters are always within the same token.\n&lt;LF&gt; always turns off the quote flag. Other behaviors vary depending on context, but quotes never alter the behavior of &lt;LF&gt;.\n\nEscaped &lt;LF&gt;\n\n&lt;LF&gt; is stripped\nThe next character is escaped. If at the end of line buffer, then the next line is read and processed by phases 1 and 1.5 and appended to the current one before escaping the next character. If the next character is &lt;LF&gt;, then it is treated as a literal, meaning this process is not recursive.\n\n\nUnescaped &lt;LF&gt; not within parentheses\n\n&lt;LF&gt; is stripped and parsing of the current line is terminated.\nAny remaining characters in the line buffer are simply ignored.\n\n\nUnescaped &lt;LF&gt; within a FOR IN parenthesized block\n\n&lt;LF&gt; is converted into a &lt;space&gt;\nIf at the end of the line buffer, then the next line is read and appended to the current one.\n\n\nUnescaped &lt;LF&gt; within a parenthesized command block\n\n&lt;LF&gt; is converted into &lt;LF&gt;&lt;space&gt;, and the &lt;space&gt; is treated as part of the next line of the command block.\nIf at the end of line buffer, then the next line is read and appended to the space.\n\n\n\n\nIf one of the special characters &amp; | &lt; or &gt;, split the line at this point in order to handle pipes, command concatenation, and redirection.\n\nIn the case of a pipe (|), each side is a separate command (or command block) that gets special handling in phase 5.3\nIn the case of &amp;, &amp;&amp;, or || command concatenation, each side of the concatenation is treated as a separate command.\nIn the case of &lt;, &lt;&lt;, &gt;, or &gt;&gt; redirection, the redirection clause is parsed, temporarily removed, and then appended to the end of the current command. A redirection clause consists of an optional file handle digit, the redirection operator, and the redirection destination token.\n\nIf the token that precedes the redirection operator is a single unescaped digit, then the digit specifies the file handle to be redirected. If the handle token is not found, then output redirection defaults to 1 (stdout), and input redirection defaults to 0 (stdin).\n\n\n\n\nIf the very first token for this command (prior to moving redirection to the end) begins with @, then the @ has special meaning. (@ is not special in any other context)\n\nThe special @ is removed.\nIf ECHO is ON, then this command, along with any following concatenated commands on this line, are excluded from the phase 3 echo. If the @ is before an opening (, then the entire parenthesized block is excluded from the phase 3 echo.\n\n\nProcess parenthesis (provides for compound statements across multiple lines):\n\nIf the parser is not looking for a command token, then ( is not special.\nIf the parser is looking for a command token and finds (, then start a new compound statement and increment the parenthesis counter\nIf the parenthesis counter is &gt; 0 then ) terminates the compound statement and decrements the parenthesis counter.\nIf the line end is reached and the parenthesis counter is &gt; 0 then the next line will be appended to the compound statement (starts again with phase 0)\nIf the parenthesis counter is 0 and the parser is looking for a command, then ) functions similar to a REM statement as long as it is immediately followed by a token delimiter, special character, newline, or end-of-file\n\nAll special characters lose their meaning except ^ (line concatenation is possible)\nOnce the end of the logical line is reached, the entire &quot;command&quot; is discarded.\n\n\n\n\nEach command is parsed into a series of tokens. The first token is always treated as a command token (after special @ have been stripped and redirection moved to the end).\n\nLeading token delimiters prior to the command token are stripped\nWhen parsing the command token, ( functions as a command token delimiter, in addition to the standard token delimiters\nThe handling of subsequent tokens depends on the command.\n\n\nMost commands simply concatenate all arguments after the command token into a single argument token. All argument token delimiters are preserved. Argument options are typically not parsed until phase 7.\nThree commands get special handling - IF, FOR, and REM\n\nIF is split into two or three distinct parts that are processed independently. A syntax error in the IF construction will result in a fatal syntax error.\n\nThe comparison operation is the actual command that flows all the way through to phase 7\n\nAll IF options are fully parsed in phase 2.\nConsecutive token delimiters collapse into a single space.\nDepending on the comparison operator, there will be one or two value tokens that are identified.\n\n\nThe True command block is the set of commands after the condition, and is parsed like any other command block. If ELSE is to be used, then the True block must be parenthesized.\nThe optional False command block is the set of commands after ELSE. Again, this command block is parsed normally.\nThe True and False command blocks do not automatically flow into the subsequent phases. Their subsequent processing is controled by phase 7.\n\n\nFOR is split in two after the DO. A syntax error in the FOR construction will result in a fatal syntax error.\n\nThe portion through DO is the actual FOR iteration command that flows all the way through phase 7\n\nAll FOR options are fully parsed in phase 2.\nThe IN parenthesized clause treats &lt;LF&gt; as &lt;space&gt;. After the IN clause is parsed, all tokens are concatenated together to form a single token.\nConsecutive unescaped/unquoted token delimiters collapse into a single space throughout the FOR command through DO.\n\n\nThe portion after DO is a command block that is parsed normally. Subsequent processing of the DO command block is controled by the iteration in phase 7.\n\n\nREM detected in phase 2 is treated dramatically different than all other commands.\n\nOnly one argument token is parsed - the parser ignores characters after the first argument token.\nThe REM command may appear in phase 3 output, but the command is never executed, and the original argument text is echoed - escaping carets are not removed, except...\n\nIf there is only one argument token that ends with an unescaped ^ that ends the line, then the argument token is thrown away, and the subsequent line is parsed and appended to the REM. This repeats until there is more than one token, or the last character is not ^.\n\n\n\n\n\n\nIf the command token begins with :, and this is the first round of phase 2 (not a restart due to CALL in phase 6) then\n\nThe token is normally treated as an Unexecuted Label.\n\nThe remainder of the line is parsed, however ), &lt;, &gt;, &amp; and | no longer have special meaning. The entire remainder of the line is considered to be part of the label &quot;command&quot;.\nThe ^ continues to be special, meaning that line continuation can be used to append the subsequent line to the label.\nAn Unexecuted Label within a parenthesized block will result in a fatal syntax error unless it is immediately followed by a command or Executed Label on the next line.\n\n( no longer has special meaning for the first command that follows the Unexecuted Label.\n\n\nThe command is aborted after label parsing is complete. Subsequent phases do not take place for the label\n\n\nThere are three exceptions that can cause a label found in phase 2 to be treated as an Executed Label that continues parsing through phase 7.\n\nThere is redirection that precedes the label token, and there is a | pipe or &amp;, &amp;&amp;, or || command concatenation on the line.\nThere is redirection that precedes the label token, and the command is within a parenthesized block.\nThe label token is the very first command on a line within a parenthesized block, and the line above ended with an Unexecuted Label.\n\n\nThe following occurs when an Executed Label is discovered in phase 2\n\nThe label, its arguments, and its redirection are all excluded from any echo output in phase 3\nAny subsequent concatenated commands on the line are fully parsed and executed.\n\n\nFor more information about Executed Labels vs. Unexecuted Labels, see https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=3803&amp;p=55405#p55405\n\n\n\nPhase 3) Echo the parsed command(s) Only if the command block did not begin with @, and ECHO was ON at the start of the preceding step.\nPhase 4) FOR %X variable expansion: Only if a FOR command is active and the commands after DO are being processed.\n\nAt this point, phase 1 of batch processing will have already converted a FOR variable like %%X into %X. The command line has different percent expansion rules for phase 1. This is the reason that command lines use %X but batch files use %%X for FOR variables.\nFOR variable names are case sensitive, but ~modifiers are not case sensitive.\n~modifiers take precedence over variable names. If a character following ~ is both a modifier and a valid FOR variable name, and there exists a subsequent character that is an active FOR variable name, then the character is interpreted as a modifier.\nFOR variable names are global, but only within the context of a DO clause. If a routine is CALLed from within a FOR DO clause, then the FOR variables are not expanded within the CALLed routine. But if the routine has its own FOR command, then all currently defined FOR variables are accessible to the inner DO commands.\nFOR variable names can be reused within nested FORs. The inner FOR value takes precedence, but once the INNER FOR closes, then the outer FOR value is restored.\nIf ECHO was ON at the start of this phase, then phase 3) is repeated to show the parsed DO commands after the FOR variables have been expanded.\n\n---- From this point onward, each command identified in phase 2 is processed separately.\n---- Phases 5 through 7 are completed for one command before moving on to the next.\nPhase 5) Delayed Expansion: Only if delayed expansion is on, the command is not in a parenthesized block on either side of a pipe, and the command is not a &quot;naked&quot; batch script (script name without parentheses, CALL, command concatenation, or pipe).\n\nEach token for a command is parsed for delayed expansion independently.\n\nMost commands parse two or more tokens - the command token, the arguments token, and each redirection destination token.\nThe FOR command parses the IN clause token only.\nThe IF command parses the comparison values only - either one or two, depending on the comparison operator.\n\n\nFor each parsed token, first check if it contains any !. If not, then the token is not parsed - important for ^ characters.\nIf the token does contain !, then scan each character from left to right:\n\nIf it is a caret (^) the next character has no special meaning, the caret itself is removed\nIf it is an exclamation mark, search for the next exclamation mark (carets are not observed anymore), expand to the value of the variable.\n\nConsecutive opening ! are collapsed into a single !\nAny remaining unpaired ! is removed\n\n\nExpanding vars at this stage is &quot;safe&quot;, because special characters are not detected anymore (even &lt;CR&gt; or &lt;LF&gt;)\nFor a more complete explanation, read the 2nd half of this from dbenham\nsame thread - Exclamation Point Phase\n\n\n\nPhase 5.3) Pipe processing: Only if commands are on either side of a pipe\nEach side of the pipe is processed independently and asynchronously.\n\nIf command is internal to cmd.exe, or it is a batch file, or if it is a parenthesized command block, then it is executed in a new cmd.exe thread via %comspec% /S /D /c&quot; commandBlock&quot;, so the command block gets a phase restart, but this time in command line mode.\n\nIf a parenthesized command block, then all &lt;LF&gt; with a command before and after are converted to &lt;space&gt;&amp;. Other &lt;LF&gt; are stripped.\n\n\nThis is the end of processing for the pipe commands.\nSee Why does delayed expansion fail when inside a piped block of code? for more about pipe parsing and processing\n\nPhase 5.5) Execute Redirection: Any redirection that was discovered in phase 2 is now executed.\n\nThe results of phases 4 and 5 can impact the redirection that was discovered in phase 2.\nIf the redirection fails, then the remainder of the command is aborted. Note that failed redirection does not set ERRORLEVEL to 1 unless || is used.\n\nPhase 6) CALL processing/Caret doubling: Only if the command token is CALL, or if the text before the first occurring standard token delimiter is CALL. If CALL is parsed from a larger command token, then the unused portion is prepended to the arguments token before proceeding.\n\nScan the arguments token for an unquoted /?. If found anywhere within the tokens, then abort phase 6 and proceed to Phase 7, where the HELP for CALL will be printed.\nRemove the first CALL, so multiple CALL&apos;s can be stacked\nDouble all carets\nRestart phases 1, 1.5, and 2, but do not continue to phase 3\n\nAny doubled carets are reduced back to one caret as long as they are not quoted. But unfortunately, quoted carets remain doubled.\nPhase 1 changes a bit\n- Expansion errors in step 1.2 or 1.3 abort the CALL, but the error is not fatal - batch processing continues.\nPhase 2 tasks are altered a bit\n\nAny newly appearing unquoted, unescaped redirection that was not detected in the first round of phase 2 is detected, but it is removed (including the file name) without actually performing the redirection\nAny newly appearing unquoted, unescaped caret at the end of the line is removed without performing line continuation\nThe CALL is aborted without error if any of the following are detected\n\nNewly appearing unquoted, unescaped &amp; or |\nThe resultant command token begins with unquoted, unescaped (\nThe very first token after the removed CALL began with @\n\n\nIf the resultant command is a seemingly valid IF or FOR, then execution will subsequently fail with an error stating that IF or FOR is not recognized as an internal or external command.\nOf course the CALL is not aborted in this 2nd round of phase 2 if the resultant command token is a label beginning with :.\n\n\n\n\nIf the resultant command token is CALL, then restart Phase 6 (repeats until no more CALL)\nIf the resultant command token is a batch script or a :label, then execution of the CALL is fully handled by the remainder of Phase 6.\n\nPush the current batch script file position on the call stack so that execution can resume from the correct position when the CALL is completed.\nSetup the %0, %1, %2, ...%N and %* argument tokens for the CALL, using all resultant tokens\nIf the command token is a label that begins with :, then\n\nRestart Phase 5. This can impact what :label is CALLed. But since the %0 etc. tokens have already been setup, it will not alter the arguments that are passed to the CALLed routine.\nExecute GOTO label to position the file pointer at the beginning of the subroutine (ignore any other tokens that may follow the :label) See Phase 7 for rules on how GOTO works.\n\nIf the :label token is missing, or the :label is not found, then the call stack is immediately popped to restore the saved file position, and the CALL is aborted.\nIf the :label happens to contain /?, then GOTO help is printed instead of searching for the :label. The file pointer does not move, such that code after the CALL is executed twice, once in the CALL context, and then again after the CALL return. See Why CALL prints the GOTO help message in this script?And why command after that are executed twice? for more info.\n\n\n\n\nElse transfer control to the specified batch script.\nExecution of the CALLed :label or script continues until either EXIT /B or end-of-file is reached, at which point the CALL stack is popped and execution resumes from the saved file position.\nPhase 7 is not executed for CALLed scripts or :labels.\n\n\nElse the result of phase 6 falls through into phase 7 for execution.\n\nPhase 7) Execute: The command is executed\n\n7.1 - Execute internal command - If the command token is quoted, then skip this step. Otherwise, attempt to parse out an internal command and execute.\n\nThe following tests are made to determine if an unquoted command token represents an internal command:\n\nIf the command token exactly matches an internal command, then execute it.\nElse break the command token before the first occurrence of + / [ ] &lt;space&gt; &lt;tab&gt; , ; or =\nIf the preceding text is an internal command, then remember that command\n\nIf in command line mode, or if the command is from a parenthesized block, IF true or false command block, FOR DO command block, or involved with command concatenation, then execute the internal command\nElse (must be a stand-alone command in batch mode) scan the current folder and the PATH for a .COM, .EXE, .BAT, or .CMD file whose base name matches the original command token\n\nIf the first matching file is a .BAT or .CMD, then goto 7.3.exec and execute that script\nElse (match not found or first match is .EXE or .COM) execute the remembered internal command\n\n\n\n\nElse break the command token before the first occurrence of . \\ or :\nIf the preceding text is not an internal command, then goto 7.2\nElse the preceding text may be an internal command. Remember this command.\nBreak the command token before the first occurrence of + / [ ] &lt;space&gt; &lt;tab&gt; , ; or =\nIf the preceding text is a path to an existing file, then goto 7.2\nElse execute the remembered internal command.\n\n\nIf an internal command is parsed from a larger command token, then the unused portion of the command token is included in the argument list\nJust because a command token is parsed as an internal command does not mean that it will execute successfully. Each internal command has its own rules as to how the arguments and options are parsed, and what syntax is allowed.\nAll internal commands will print help instead of performing their function if /? is detected. Most recognize /? if it appears anywhere in the arguments. But a few commands like ECHO and SET only print help if the first argument token begins with /?.\nSET has some interesting semantics:\n\nIf a SET command has a quote before the variable name and extensions are enabled\nset &quot;name=content&quot; ignored --&gt; value=content\nthen the text between the first equal sign and the last quote is used as the content (first equal and last quote excluded). Text after the last quote is ignored. If there is no quote after the equal sign, then the rest of the line is used as content.\nIf a SET command does not have a quote before the name\nset name=&quot;content&quot; not ignored --&gt; value=&quot;content&quot; not ignored\nthen the entire remainder of the line after the equal is used as content, including any and all quotes that may be present.\n\n\nAn IF comparison is evaluated, and depending on whether the condition is true or false, the appropriate already parsed dependent command block is processed, starting with phase 5.\nThe IN clause of a FOR command is iterated appropriately.\n\nIf this is a FOR /F that iterates the output of a command block, then:\n\nThe IN clause is executed in a new cmd.exe process via CMD /C.\nThe command block must go through the entire parsing process a second time, but this time in a command line context\nECHO will start out ON, and delayed expansion will usually start out disabled (dependent on the registry setting)\nAll environment changes made by the IN clause command block will be lost once the child cmd.exe process terminates\n\n\nFor each iteration:\n\nThe FOR variable values are defined\nThe already parsed DO command block is then processed, starting with phase 4.\n\n\n\n\nGOTO uses the following logic to locate the :label\n\nParse the label from the first argument token\nScan for the next occurrence of the label\n\nStart from the current file position\nIf end of file is reached, then loop back to the beginning of file and continue to the original starting point.\n\n\nThe scan stops at the first occurrence of the label that it finds, and the file pointer is set to the line immediately following the label. Execution of the script resumes from that point. Note that a successful true GOTO will immediately abort any parsed block of code, including FOR loops.\nIf the label is not found, or the label token is missing, then the GOTO fails, an error message is printed, and the call stack is popped. This effectively functions as an EXIT /B, except any already parsed commands in the current command block that follow the GOTO are still executed, but in the context of the CALLer (the context that exists after EXIT /B)\nSee https://www.dostips.com/forum/viewtopic.php?t=3803 for a more precise description of label parsing rules, and https://www.dostips.com/forum/viewtopic.php?t=8988 for label scanning rules.\n\n\nRENAME and COPY both accept wildcards for the source and target paths. But Microsoft does a terrible job documenting how the wildcards work, especially for the target path. A useful set of wildcard rules may be found at How does the Windows RENAME command interpret wildcards?\n\n\n7.2 - Execute volume change - Else if the command token does not begin with a quote, is exactly two characters long, and the 2nd character is a colon, then change the volume\n\nAll argument tokens are ignored\nIf the volume specified by the first character cannot be found, then abort with an error\nA command token of :: will always result in an error unless SUBST is used to define a volume for ::\nIf SUBST is used to define a volume for ::, then the volume will be changed, it will not be treated as a label.\n\n\n7.3 - Execute external command - Else try to treat the command as an external command.\n\nIf in command line mode and the command is not quoted and does not begin with a volume specification, white-space, ,, ;, = or + then break the command token at the first occurrence of &lt;space&gt; , ; or = and prepend the remainder to the argument token(s).\nIf the 2nd character of the command token is a colon, then verify the volume specified by the 1st character can be found.\nIf the volume cannot be found, then abort with an error.\nIf in batch mode and the command token begins with :, then goto 7.4\nNote that if the label token begins with ::, then this will not be reached because the preceding step will have aborted with an error unless SUBST is used to define a volume for ::.\nIdentify the external command to execute.\n\nThis is a complex process that may involve the current volume, current directory, PATH variable, PATHEXT variable, and or file associations.\nIf a valid external command cannot be identified, then abort with an error.\n\n\nIf in command line mode and the command token begins with :, then goto 7.4\nNote that this is rarely reached because the preceding step will have aborted with an error unless the command token begins with ::, and SUBST is used to define a volume for ::, and the entire command token is a valid path to an external command.\n7.3.exec - Execute the external command.\n\n\n7.4 - Ignore a label - Ignore the command and all its arguments if the command token begins with :.\nRules in 7.2 and 7.3 may prevent a label from reaching this point.\n\n\nCommand Line Parser:\nWorks like the BatchLine-Parser, except:\nPhase 1) Percent Expansion:\n\nNo %*, %1 etc. argument expansion\nIf var is undefined, then %var% is left unchanged.\nNo special handling of %%. If var=content, then %%var%% expands to %content%.\n\nPhase 3) Echo the parsed command(s)\n\nThis is not performed after phase 2. It is only performed after phase 4 for the FOR DO command block.\n\nPhase 5) Delayed Expansion: only if DelayedExpansion is enabled\n\nIf var is undefined, then !var! is left unchanged.\n\nPhase 7) Execute Command\n\nAttempts to CALL or GOTO a :label result in an error.\nAs already documented in phase 7, an executed label may result in an error under different scenarios.\n\nBatch executed labels can only cause an error if they begin with ::\nCommand line executed labels almost always result in an error\n\n\n\n\nParsing of integer values\nThere are many different contexts where cmd.exe parses integer values from strings, and the rules are inconsistent:\n\nSET /A\nIF\n%var:~n,m% (variable substring expansion)\nFOR /F &quot;TOKENS=n&quot;\nFOR /F &quot;SKIP=n&quot;\nFOR /L %%A in (n1 n2 n3)\nEXIT [/B] n\n\nDetails for these rules may be found at Rules for how CMD.EXE parses numbers\n\nFor anyone wishing to improve the cmd.exe parsing rules, there is a discussion topic on the DosTips forum where issues can be reported and suggestions made.\nHope it helps\nJan Erik (jeb) - Original author and discoverer of phases\nDave Benham (dbenham) - Much additional content and editing\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"When invoking a command from a command window, tokenization of the command line arguments is not done by cmd.exe (a.k.a. &quot;the shell&quot;).  Most often the tokenization is done by the newly formed processes&apos; C/C++ runtime, but this is not necessarily so -- for example, if the new process was not written in C/C++, or if the new process chooses to ignore argv and process the raw commandline for itself (e.g. with GetCommandLine()).  At the OS level, Windows passes command lines untokenized as a single string to new processes.  This is in contrast to most *nix shells, where the shell tokenizes arguments in a consistent, predictable way before passing them to the newly formed process.  All this means that you may experience wildly divergent argument tokenization behavior across different programs on Windows, as individual programs often take argument tokenization into their own hands.\n\nIf it sounds like anarchy, it kind of is.  However, since a large number of Windows programs do utilize the Microsoft C/C++ runtime&apos;s argv, it may be generally useful to understand how the MSVCRT tokenizes arguments.  Here is an excerpt:\n\n\nArguments are delimited by white space, which is either a space or a tab.\nA string surrounded by double quotation marks is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument. Note that the caret (^) is not recognized as an escape character or delimiter.\nA double quotation mark preceded by a backslash, \\&quot;, is interpreted as a literal double quotation mark (&quot;).\nBackslashes are interpreted literally, unless they immediately precede a double quotation mark.\nIf an even number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\), and the double quotation mark (&quot;) is interpreted as a string delimiter.\nIf an odd number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\) and the double quotation mark is interpreted as an escape sequence by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.\n\n\n\n\nThe Microsoft &quot;batch language&quot; (.bat) is no exception to this anarchic environment, and it has developed its own unique rules for tokenization and escaping. It also looks like cmd.exe&apos;s command prompt does do some preprocessing of the command line argument (mostly for variable substitution and escaping) before passing the argument off to the newly executing process.  You can read more about the low-level details of the batch language and cmd escaping in the excellent answers by jeb and dbenham on this page.  \n\n\n\nLet&apos;s build a simple command line utility in C and see what it says about your test cases:\n\nint main(int argc, char* argv[]) {\n    int i;\n    for (i = 0; i &lt; argc; i++) {\n        printf(&quot;argv[%d][%s]\\n&quot;, i, argv[i]);\n    }\n    return 0;\n}\n\n\n(Notes: argv[0] is always the name of the executable, and is omitted below for brevity.  Tested on Windows XP SP3. Compiled with Visual Studio 2005.)\n\n&gt; test.exe &quot;a &quot;&quot;b&quot;&quot; c&quot;\nargv[1][a &quot;b&quot; c]\n\n&gt; test.exe &quot;&quot;&quot;a b c&quot;&quot;&quot;\nargv[1][&quot;a b c&quot;]\n\n&gt; test.exe &quot;a&quot;&quot; b c\nargv[1][a&quot; b c]\n\n\nAnd a few of my own tests:\n\n&gt; test.exe a &quot;b&quot; c\nargv[1][a]\nargv[2][b]\nargv[3][c]\n\n&gt; test.exe a &quot;b c&quot; &quot;d e\nargv[1][a]\nargv[2][b c]\nargv[3][d e]\n\n&gt; test.exe a \\&quot;b\\&quot; c\nargv[1][a]\nargv[2][&quot;b&quot;]\nargv[3][c]\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Percent Expansion Rules\nHere is an expanded explanation of Phase 1 in jeb&apos;s answer (valid for both batch mode and command line mode).\nPhase 1) Percent Expansion\nStarting from left, scan each character for % or &lt;LF&gt;. If found then\n\n1.05 (truncate line at &lt;LF&gt;)\nIf the character is &lt;LF&gt; then\n\nDrop (ignore) the remainder of the line from the &lt;LF&gt; onward\nGoto Phase 2.0\n\n\nElse the character must be %, so proceed to 1.1\n1.1 (escape %) skipped if command line mode\nIf batch mode and followed by another % then\nReplace %% with single % and continue scan\n1.2 (expand argument) skipped if command line mode\nElse if batch mode then\n\nIf followed by * and command extensions are enabled then\nReplace %* with the text of all command line arguments (Replace with nothing if there are no arguments) and continue scan.\nElse if followed by &lt;digit&gt; then\nReplace %&lt;digit&gt; with argument value (replace with nothing if undefined) and continue scan.\nElse if followed by ~ and command extensions are enabled then\n\nIf followed by optional valid list of argument modifiers followed by required &lt;digit&gt; then\nReplace %~[modifiers]&lt;digit&gt; with modified argument value (replace with nothing if not defined or if specified $PATH: modifier is not defined) and continue scan.\nNote: modifiers are case insensitive and can appear multiple times in any order, except $PATH: modifier can only appear once and must be the last modifier before the &lt;digit&gt;\nElse invalid modified argument syntax raises fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\n\n\n\n\n1.3 (expand variable)\nElse if command extensions are disabled then\nLook at next string of characters, breaking before % or end of buffer, and call them VAR (may be an empty list)\n\nIf next character is % then\n\nIf VAR is defined then\nReplace %VAR% with value of VAR and continue scan\nElse if batch mode then\nRemove %VAR% and continue scan\nElse goto 1.4\n\n\nElse goto 1.4\n\n\nElse if command extensions are enabled then\nLook at next string of characters, breaking before % : or end of buffer, and call them VAR (may be an empty list). If VAR breaks before : and the subsequent character is % then include : as the last character in VAR and break before %.\n\nIf next character is % then\n\nIf VAR is defined then\nReplace %VAR% with value of VAR and continue scan\nElse if batch mode then\nRemove %VAR% and continue scan\nElse goto 1.4\n\n\nElse if next character is : then\n\nIf VAR is undefined then\n\nIf batch mode then\nRemove %VAR: and continue scan.\nElse goto 1.4\n\n\nElse if next character is ~ then\n\nIf next string of characters matches pattern of [integer][,[integer]]% then\nReplace %VAR:~[integer][,[integer]]% with substring of value of VAR (possibly resulting in empty string) and continue scan.\nElse goto 1.4\n\n\nElse if followed by = or *= then\nInvalid variable search and replace syntax raises fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\nElse if next string of characters matches pattern of [*]search=[replace]%, where search may include any set of characters except =, and replace may include any set of characters except %, then\nReplace %VAR:[*]search=[replace]% with value of VAR after performing search and replace (possibly resulting in empty string) and continue scan\nElse goto 1.4\n\n\n\n\n1.4 (strip %)\n\nElse If batch mode then\nRemove % and continue scan starting with the next character after the %\nElse preserve the leading % and continue scan starting with the next character after the preserved leading %\n\n\n\nThe above helps explain why this batch\n@echo off\nsetlocal enableDelayedExpansion\nset &quot;1var=varA&quot;\nset &quot;~f1var=varB&quot;\ncall :test &quot;arg1&quot;\nexit /b  \n::\n:test &quot;arg1&quot;\necho %%1var%% = %1var%\necho ^^^!1var^^^! = !1var!\necho --------\necho %%~f1var%% = %~f1var%\necho ^^^!~f1var^^^! = !~f1var!\nexit /b\n\nGives these results:\n%1var% = &quot;arg1&quot;var\n!1var! = varA\n--------\n%~f1var% = P:\\arg1var\n!~f1var! = varB\n\nNote 1 - Phase 1 occurs prior to the recognition of REM statements. This is very important because it means even a remark can generate a fatal error if it has invalid argument expansion syntax or invalid variable search and replace syntax!\n@echo off\nrem %~x This generates a fatal argument expansion error\necho this line is never reached\n\nNote 2 - Another interesting consequence of the % parsing rules: Variables containing : in the name can be defined, but they cannot be expanded unless command extensions are disabled. There is one exception - a variable name containing a single colon at the end can be expanded while command extensions are enabled. However, you cannot perform substring or search and replace operations on variable names ending with a colon. The batch file below (courtesy of jeb) demonstrates this behavior\n@echo off\nsetlocal\nset var=content\nset var:=Special\nset var::=double colon\nset var:~0,2=tricky\nset var::~0,2=unfortunate\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\necho Now with DisableExtensions\nsetlocal DisableExtensions\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\n\nNote 3 - An interesting outcome of the order of the parsing rules that jeb lays out in his post: When performing find and replace with delayed expansion, special characters in both the find and replace terms must be escaped or quoted. But the situation is different for percent expansion - the find term must not be escaped (though it can be quoted). The percent replace string may or may not require escape or quote, depending on your intent.\n@echo off\nsetlocal enableDelayedExpansion\nset &quot;var=this &amp; that&quot;\necho %var:&amp;=and%\necho &quot;%var:&amp;=and%&quot;\necho !var:^&amp;=and!\necho &quot;!var:&amp;=and!&quot;\n\n\n#Delayed Expansion Rules\nHere is an expanded, and more accurate explanation of Phase 5 in jeb&apos;s answer (Valid for both batch mode and command line mode)\nPhase 5) Delayed Expansion\nThis phase is skipped if any of the following conditions apply:\n\nDelayed expansion is disabled.\nThe command is within a parenthesized block on either side of a pipe.\nThe incoming command token is a &quot;naked&quot; batch script, meaning it is not associated with CALL, parenthesized block, any form of command concatenation (&amp;, &amp;&amp; or ||), or a pipe |.\n\nThe delayed expansion process is applied to tokens independently. A command may have multiple tokens:\n\nThe command token. For most commands the command name itself is a token. But a few commands have specialized regions that are considered a TOKEN for Phase 5.\n\nfor ... in(TOKEN) do\nif defined TOKEN\nif exists TOKEN\nif errorlevel TOKEN\nif cmdextversion TOKEN\nif TOKEN comparison TOKEN, where comparison is one of ==, equ, neq, lss, leq, gtr, or geq\n\n\nThe arguments token\nThe destination token of redirection (one per redirection)\n\nNo change is made to tokens that do not contain !.\nFor each token that does contain at least one !, scan each character from left to right for ^ or !, and if found, then\n\n5.1 (caret escape) Needed for ! or ^ literals\nIf character is a caret ^ then\n\nRemove the ^\nScan the next character and preserve it as a literal\nContinue the scan\n\n\n5.2 (expand variable)\nIf character is !, then\n\nIf command extensions are disabled then\nLook at next string of characters, breaking before ! or &lt;LF&gt;, and call them VAR (may be an empty list)\n\nIf next character is ! then\n\nIf VAR is defined, then\nReplace !VAR! with value of VAR and continue scan\nElse if batch mode then\nRemove !VAR! and continue scan\nElse goto 5.2.1\n\n\nElse goto 5.2.1\n\n\nElse if command extensions are enabled then\nLook at next string of characters, breaking before !, :, or &lt;LF&gt;, and call them VAR (may be an empty list). If VAR breaks before : and the subsequent character is ! then include : as the last character in VAR and break before !\n\nIf next character is ! then\n\nIf VAR exists, then\nReplace !VAR! with value of VAR and continue scan\nElse if batch mode then\nRemove !VAR! and continue scan\nElse goto 5.2.1\n\n\nElse if next character is : then\n\nIf VAR is undefined then\n\nIf batch mode then\nRemove !VAR: and continue scan\nElse goto 5.2.1\n\n\nElse if next character is ~ then\n\nIf next string of characters matches pattern of [integer][,[integer]]! then Replace !VAR:~[integer][,[integer]]! with substring of value of VAR (possibly resulting in empty string) and continue scan.\nElse goto 5.2.1\n\n\nElse if next string of characters matches pattern of [*]search=[replace]!, where search may include any set of characters except =, and replace may include any set of characters except !, then\nReplace !VAR:[*]search=[replace]! with value of VAR after performing search and replace (possibly resulting in an empty string) and continue scan\nElse goto 5.2.1\n\n\nElse goto 5.2.1\n\n\n5.2.1\n\nIf batch mode then remove the leading !\nElse preserve the leading !\nContinue the scan starting with the next character after the preserved leading !\n\n\n\n\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"As pointed out, commands are passed the entire argument string in μSoft land, and it is up to them to parse this into separate arguments for their own use. There is no consistencty in this between different programs, and therefore there is no one set of rules to describe this process. You really need to check each corner case for whatever C library your program uses.\n\nAs far as the system .bat files go, here is that test:\n\nc&gt; type args.cmd\n@echo off\necho cmdcmdline:[%cmdcmdline%]\necho 0:[%0]\necho *:[%*]\nset allargs=%*\nif not defined allargs goto :eof\nsetlocal\n@rem Wot about a nice for loop?\n@rem Then we are in the land of delayedexpansion, !n!, call, etc.\n@rem Plays havoc with args like %t%, a&quot;b etc. ugh!\nset n=1\n:loop\n    echo %n%:[%1]\n    set /a n+=1\n    shift\n    set param=%1\n    if defined param goto :loop\nendlocal\n\n\nNow we can run some tests. See if you can figure out just what μSoft are trying to do:\n\nC&gt;args a b c\ncmdcmdline:[cmd.exe ]\n0:[args]\n*:[a b c]\n1:[a]\n2:[b]\n3:[c]\n\n\nFine so far. (I&apos;ll leave out the uninteresting %cmdcmdline% and %0 from now on.)\n\nC&gt;args *.*\n*:[*.*]\n1:[*.*]\n\n\nNo filename expansion.\n\nC&gt;args &quot;a b&quot; c\n*:[&quot;a b&quot; c]\n1:[&quot;a b&quot;]\n2:[c]\n\n\nNo quote stripping, though quotes do prevent argument splitting.\n\nc&gt;args &quot;&quot;a b&quot; c\n*:[&quot;&quot;a b&quot; c]\n1:[&quot;&quot;a]\n2:[b&quot; c]\n\n\nConsecutive double quotes causes them to lose any special parsing abilities they may have had. @Beniot&apos;s example:\n\nC&gt;args &quot;a &quot;&quot;&quot; b &quot;&quot; c&quot;&quot;&quot;\n*:[&quot;a &quot;&quot;&quot; b &quot;&quot; c&quot;&quot;&quot;]\n1:[&quot;a &quot;&quot;&quot;]\n2:[b]\n3:[&quot;&quot;]\n4:[c&quot;&quot;&quot;]\n\n\nQuiz: How do you pass the value of any environment var as a single argument (i.e., as %1) to a bat file?\n\nc&gt;set t=a &quot;b c\nc&gt;set t\nt=a &quot;b c\nc&gt;args %t%\n1:[a]\n2:[&quot;b c]\nc&gt;args &quot;%t%&quot;\n1:[&quot;a &quot;b]\n2:[c&quot;]\nc&gt;Aaaaaargh!\n\n\nSane parsing seems forever broken.\n\nFor your entertainment, try adding miscellaneous ^, \\, &apos;, &amp; (&amp;c.) characters to these examples.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"You have some great answers above already, but to answer one part of your question:\n\nset a =b, echo %a %b% c%  bb c%\n\n\nWhat is happening there is that because you have a space before the =, a variable is created called %a&lt;space&gt;%\nso when you echo %a % that is evaluated correctly as b.\n\nThe remaining part b% c% is then evaluated as plain text + an undefined variable % c%, which should be echoed as typed, for me echo %a %b% c% returns bb% c%\n\nI suspect that the ability to include spaces in variable names is more of an oversight than a planned &apos;feature&apos;\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"FOR-Loop Meta-Variable Expansion\nThis is an extended explanation of Phase 4) in the accepted answer (applicable for both batch file mode and command line mode). Of course a for command must be active. The following describes the processing of the command line portion after the do clause. Note that in batch file mode, %% has already been converted to % due to the foregoing immediate %-expansion phase (Phase 1)).\n\nscan for %-sign, beginning from the left up to the end of the line; if one is found, then:\n\nif Command Extensions are enabled (default), check if next character is ~; if yes, then:\n\ntake as many as possible of the following characters in the case-insensitive set fdpnxsatz (even multiple times each) that are preceding a character that defines a for variable reference or a $-sign; if such a $-sign is encountered, then:\n\nscan for a :1; if found, then:\n\nif there is a character following the :, use it as a for variable reference and expand as expected, unless it is not defined, then do not expand and continue scan at that character position;\nif the : is the last character, cmd.exe will crash!\n\n\nelse (no : is found) do not expand anything;\n\n\nelse (if no $-sign is encountered) expand the for variable using all the modifiers, unless it is not defined, then do not expand and continue scan at that character position;\n\n\nelse (if no ~ is found or Command Extensions are disabled) check the next character:\n\nif there is no more character available, do not expand anything;\nif the next character is %, do not expand anything and go back to the beginning of the scan at this character position2;\nelse use the next character as a for variable reference and expand, unless such is not defined, then do not expand;\n\n\n\n\ngo back to the beginning of the scan at the next character position (as long as there still characters available);\n\n\n1)  The string between $ and : is considered as the name of an environment variable, which may even be empty; since an environment variable cannot have an empty name, the behaviour is just the same as for an undefined environment variable.\n\n2)  This implies that a for meta-variable named % cannot be expanded without a ~-modifier.\n\nOriginal source: How to safely echo FOR variable %%~p followed by a string literal\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"edit: see accepted answer, what follows is wrong and explains only how to pass a command line to TinyPerl.\n\n\n\nRegarding quotes, I have the feeling that the behaviour is the following:\n\n\nwhen a &quot; is found, string globbing begins\nwhen string globbing occurs:\n\nevery character that is not a &quot; is globbed\nwhen a &quot; is found:\n\nif it is followed by &quot;&quot; (thus a triple &quot;) then a double quote is added to the string\nif it is followed by &quot; (thus a double &quot;) then a double quote is added to the string and string globbing ends\nif the next character is not &quot;, string globbing ends\n\nwhen line ends, string globbing ends.\n\n\n\nIn short:\n\n&quot;a &quot;&quot;&quot; b &quot;&quot; c&quot;&quot;&quot; consists of two strings: a &quot; b &quot; and c&quot;\n\n&quot;a&quot;&quot;, &quot;a&quot;&quot;&quot; and&quot;a&quot;&quot;&quot;&quot; are all the same string if at the end of a line\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Note that Microsoft has published its Terminal&apos;s source code. It may work similar to the command line with respect to syntax parsing. Maybe someone is interested in testing the reverse-engineered parsing rules on accordance with the terminal&apos;s parsing rules.\n\nLink to the source code.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560">How does the Windows Command Interpreter (CMD.EXE) parse scripts?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-expansion">variable-expansion</a></div></div><div class="question-content mt-5">
                
<p>I ran into <a href="https://ss64.com" rel="nofollow noreferrer">ss64.com</a> which provides good help regarding how to write batch scripts that the Windows Command Interpreter will run.</p>
<p>However, I have been unable to find a good explanation of the <strong>grammar</strong> of batch scripts, how things expand or do not expand, and how to escape things.</p>
<p>Here are sample questions that I have not been able to solve:</p>
<ul>
<li>How is the quote system managed? I made a <a href="http://tinyperl.sourceforge.net/" rel="nofollow noreferrer">TinyPerl</a> script<br>
( <code>foreach $i (@ARGV) { print '*' . $i ; }</code> ), compiled it and called it this way :
<ul>
<li><code>my_script.exe "a ""b"" c"</code> → output is  <code>*a "b*c</code></li>
<li><code>my_script.exe """a b c"""</code> → output it <code>*"a*b*c"</code></li>
</ul>
</li>
<li>How does the internal <code>echo</code> command work? What is expanded inside that command?</li>
<li>Why do I have to use <code>for [...] %%I</code> in file scripts, but <code>for [...] %I</code> in interactive sessions?</li>
<li>What are the escape characters, and in what context? How to escape a percent sign? For example, how can I echo <code>%PROCESSOR_ARCHITECTURE%</code> literally? I found that <code>echo.exe %""PROCESSOR_ARCHITECTURE%</code> works, is there a better solution?</li>
<li>How do pairs of <code>%</code> match? Example:
<ul>
<li><code>set b=a</code> , <code>echo %a %b% c%</code> → <code>%a a c%</code></li>
<li><code>set a =b</code>, <code>echo %a %b% c%</code> → <code>bb% c%</code></li>
</ul>
</li>
<li>How do I ensure a variable passes to a command as a single argument if ever this variable contains double quotes?</li>
<li>How are variables stored when using the <code>set</code> command? For example, if I do <code>set a=a" b</code> and then <code>echo.%a%</code> I obtain <code>a" b</code>. If I however use <code>echo.exe</code> from the UnxUtils, I get <code>a b</code>. How comes <code>%a%</code> expands in a different way?</li>
</ul>
<p>Thank you for your lights.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We performed experiments to investigate the grammar of batch scripts. We also investigated differences between batch and command line mode.</p>
<h2>Batch Line Parser:</h2>
<p>Here is a brief overview of phases in the batch file line parser:</p>
<p><strong>Phase 0) Read Line:</strong></p>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<p><strong>Phase 2) Process special characters, tokenize, and build a cached command block:</strong> This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes.</p>
<p><strong>Phase 3) Echo the parsed command(s)</strong> Only if the command block did not begin with <code>@</code>, and ECHO was ON at the start of the preceding step.</p>
<p><strong>Phase 4) FOR <code>%X</code> variable expansion:</strong> Only if a FOR command is active and the commands after DO are being processed.</p>
<p><strong>Phase 5) Delayed Expansion:</strong> Only if delayed expansion is enabled</p>
<p><strong>Phase 5.3) Pipe processing:</strong> Only if commands are on either side of a pipe</p>
<p><strong>Phase 5.5) Execute Redirection:</strong></p>
<p><strong>Phase 6) CALL processing/Caret doubling:</strong> Only if the command token is CALL</p>
<p><strong>Phase 7) Execute:</strong> The command is executed
<br></p>
<hr>
<p>Here are details for each phase:</p>
<p>Note that the phases described below are only a model of how the batch parser works. The actual cmd.exe internals may not reflect these phases. But this model is effective at predicting behavior of batch scripts.</p>
<p><strong>Phase 0) Read Line:</strong> Read line of input through first <code>&lt;LF&gt;</code>.</p>
<ul>
<li>When reading a line to be parsed as a command, <code>&lt;Ctrl-Z&gt;</code> (0x1A) is read as <code>&lt;LF&gt;</code> (LineFeed 0x0A)</li>
<li>When GOTO or CALL reads lines while scanning for a :label, <code>&lt;Ctrl-Z&gt;</code>, is treated as itself - it is <em><strong>not</strong></em> converted to <code>&lt;LF&gt;</code></li>
</ul>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<ul>
<li>A double <code>%%</code> is replaced by a single <code>%</code></li>
<li>Expansion of arguments (<code>%*</code>, <code>%1</code>, <code>%2</code>, etc.)</li>
<li>Expansion of <code>%var%</code>, if var does not exist replace it with nothing</li>
<li>Line is truncated at first <code>&lt;LF&gt;</code> not within <code>%var%</code> expansion</li>
<li><em>For a complete explanation read the first half of this from dbenham <a href="https://stackoverflow.com/a/7970912/1012053">Same thread: Percent Phase</a></em></li>
</ul>
<p><strong>Phase 2) Process special characters, tokenize, and build a cached command block:</strong> This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes. What follows is an approximation of this process.</p>
<p>There are concepts that are important throughout this phase.</p>
<ul>
<li>A token is simply a string of characters that is treated as a unit.</li>
<li>Tokens are separated by token delimiters. The standard token delimiters are <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>;</code> <code>,</code> <code>=</code> <code>&lt;0x0B&gt;</code> <code>&lt;0x0C&gt;</code> and <code>&lt;0xFF&gt;</code><br>
Consecutive token delimiters are treated as one - there are no empty tokens between token delimiters</li>
<li>There are no token delimiters within a quoted string. The entire quoted string is always treated as part of a single token. A single token may consist of a combination of quoted strings and unquoted characters.</li>
</ul>
<p>The following characters may have special meaning in this phase, depending on context: <code>&lt;CR&gt;</code> <code>^</code> <code>(</code> <code>@</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;LF&gt;</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>;</code> <code>,</code> <code>=</code> <code>&lt;0x0B&gt;</code> <code>&lt;0x0C&gt;</code> <code>&lt;0xFF&gt;</code></p>
<p>Look at each character from left to right:</p>
<ul>
<li>If <code>&lt;CR&gt;</code> then remove it, as if it were never there (except for weird <a href="https://www.dostips.com/forum/viewtopic.php?t=9429" rel="noreferrer">redirection behavior</a>)</li>
<li>If a caret (<code>^</code>), the next character is escaped, and the escaping caret is removed. Escaped characters lose all special meaning (except for <code>&lt;LF&gt;</code>).</li>
<li>If a quote (<code>"</code>), toggle the quote flag. If the quote flag is active, then only <code>"</code> and <code>&lt;LF&gt;</code> are special. All other characters lose their special meaning until the next quote toggles the quote flag off. It is not possible to escape the closing quote. All quoted characters are always within the same token.</li>
<li><code>&lt;LF&gt;</code> always turns off the quote flag. Other behaviors vary depending on context, but quotes never alter the behavior of <code>&lt;LF&gt;</code>.
<ul>
<li>Escaped <code>&lt;LF&gt;</code>
<ul>
<li><code>&lt;LF&gt;</code> is stripped</li>
<li>The next character is escaped. If at the end of line buffer, then the next line is read and processed by phases 1 and 1.5 and appended to the current one before escaping the next character. If the next character is <code>&lt;LF&gt;</code>, then it is treated as a literal, meaning this process is not recursive.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> not within parentheses
<ul>
<li><code>&lt;LF&gt;</code> is stripped and parsing of the current line is terminated.</li>
<li>Any remaining characters in the line buffer are simply ignored.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> within a FOR IN parenthesized block
<ul>
<li><code>&lt;LF&gt;</code> is converted into a <code>&lt;space&gt;</code></li>
<li>If at the end of the line buffer, then the next line is read and appended to the current one.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> within a parenthesized command block
<ul>
<li><code>&lt;LF&gt;</code> is converted into <code>&lt;LF&gt;&lt;space&gt;</code>, and the <code>&lt;space&gt;</code> is treated as part of the next line of the command block.</li>
<li>If at the end of line buffer, then the next line is read and appended to the space.</li>
</ul>
</li>
</ul>
</li>
<li>If one of the special characters <code>&amp;</code> <code>|</code> <code>&lt;</code> or <code>&gt;</code>, split the line at this point in order to handle pipes, command concatenation, and redirection.
<ul>
<li>In the case of a pipe (<code>|</code>), each side is a separate command (or command block) that gets special handling in phase 5.3</li>
<li>In the case of <code>&amp;</code>, <code>&amp;&amp;</code>, or <code>||</code> command concatenation, each side of the concatenation is treated as a separate command.</li>
<li>In the case of <code>&lt;</code>, <code>&lt;&lt;</code>, <code>&gt;</code>, or <code>&gt;&gt;</code> redirection, the redirection clause is parsed, temporarily removed, and then appended to the end of the current command. A redirection clause consists of an optional file handle digit, the redirection operator, and the redirection destination token.
<ul>
<li>If the token that precedes the redirection operator is a single unescaped digit, then the digit specifies the file handle to be redirected. If the handle token is not found, then output redirection defaults to 1 (stdout), and input redirection defaults to 0 (stdin).</li>
</ul>
</li>
</ul>
</li>
<li>If the very first token for this command (prior to moving redirection to the end) begins with <code>@</code>, then the <code>@</code> has special meaning. (<code>@</code> is not special in any other context)
<ul>
<li>The special <code>@</code> is removed.</li>
<li>If ECHO is ON, then this command, along with any following concatenated commands on this line, are excluded from the phase 3 echo. If the <code>@</code> is before an opening <code>(</code>, then the entire parenthesized block is excluded from the phase 3 echo.</li>
</ul>
</li>
<li>Process parenthesis (provides for compound statements across multiple lines):
<ul>
<li>If the parser is not looking for a command token, then <code>(</code> is not special.</li>
<li>If the parser is looking for a command token and finds <code>(</code>, then start a new compound statement and increment the parenthesis counter</li>
<li>If the parenthesis counter is &gt; 0 then <code>)</code> terminates the compound statement and decrements the parenthesis counter.</li>
<li>If the line end is reached and the parenthesis counter is &gt; 0 then the next line will be appended to the compound statement (starts again with phase 0)</li>
<li>If the parenthesis counter is 0 and the parser is looking for a command, then <code>)</code> functions similar to a <code>REM</code> statement as long as it is immediately followed by a token delimiter, special character, newline, or end-of-file
<ul>
<li>All special characters lose their meaning except <code>^</code> (line concatenation is possible)</li>
<li>Once the end of the logical line is reached, the entire "command" is discarded.</li>
</ul>
</li>
</ul>
</li>
<li>Each command is parsed into a series of tokens. The first token is always treated as a command token (after special <code>@</code> have been stripped and redirection moved to the end).
<ul>
<li>Leading token delimiters prior to the command token are stripped</li>
<li>When parsing the command token, <code>(</code> functions as a command token delimiter, in addition to the standard token delimiters</li>
<li>The handling of subsequent tokens depends on the command.</li>
</ul>
</li>
<li>Most commands simply concatenate all arguments after the command token into a single argument token. All argument token delimiters are preserved. Argument options are typically not parsed until phase 7.</li>
<li>Three commands get special handling - IF, FOR, and REM
<ul>
<li>IF is split into two or three distinct parts that are processed independently. A syntax error in the IF construction will result in a fatal syntax error.
<ul>
<li>The comparison operation is the actual command that flows all the way through to phase 7
<ul>
<li>All IF options are fully parsed in phase 2.</li>
<li>Consecutive token delimiters collapse into a single space.</li>
<li>Depending on the comparison operator, there will be one or two value tokens that are identified.</li>
</ul>
</li>
<li>The True command block is the set of commands after the condition, and is parsed like any other command block. If ELSE is to be used, then the True block must be parenthesized.</li>
<li>The optional False command block is the set of commands after ELSE. Again, this command block is parsed normally.</li>
<li>The True and False command blocks do not automatically flow into the subsequent phases. Their subsequent processing is controled by phase 7.</li>
</ul>
</li>
<li>FOR is split in two after the DO. A syntax error in the FOR construction will result in a fatal syntax error.
<ul>
<li>The portion through DO is the actual FOR iteration command that flows all the way through phase 7
<ul>
<li>All FOR options are fully parsed in phase 2.</li>
<li>The IN parenthesized clause treats <code>&lt;LF&gt;</code> as <code>&lt;space&gt;</code>. After the IN clause is parsed, all tokens are concatenated together to form a single token.</li>
<li>Consecutive unescaped/unquoted token delimiters collapse into a single space throughout the FOR command through DO.</li>
</ul>
</li>
<li>The portion after DO is a command block that is parsed normally. Subsequent processing of the DO command block is controled by the iteration in phase 7.</li>
</ul>
</li>
<li>REM detected in phase 2 is treated dramatically different than all other commands.
<ul>
<li>Only one argument token is parsed - the parser ignores characters after the first argument token.</li>
<li>The REM command may appear in phase 3 output, but the command is never executed, and the original argument text is echoed - escaping carets are not removed, except...
<ul>
<li>If there is only one argument token that ends with an unescaped <code>^</code> that ends the line, then the argument token is thrown away, and the subsequent line is parsed and appended to the REM. This repeats until there is more than one token, or the last character is not <code>^</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If the command token begins with <code>:</code>, and this is the first round of phase 2 (not a restart due to CALL in phase 6) then
<ul>
<li>The token is normally treated as an <em>Unexecuted Label</em>.
<ul>
<li>The remainder of the line is parsed, however <code>)</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code> and <code>|</code> no longer have special meaning. The entire remainder of the line is considered to be part of the label "command".</li>
<li>The <code>^</code> continues to be special, meaning that line continuation can be used to append the subsequent line to the label.</li>
<li>An <em>Unexecuted Label</em> within a parenthesized block will result in a fatal syntax error unless it is immediately followed by a command or <em>Executed Label</em> on the next line.
<ul>
<li><code>(</code> no longer has special meaning for the first command that follows the <em>Unexecuted Label</em>.</li>
</ul>
</li>
<li>The command is aborted after label parsing is complete. Subsequent phases do not take place for the label</li>
</ul>
</li>
<li>There are three exceptions that can cause a label found in phase 2 to be treated as an <em>Executed Label</em> that continues parsing through phase 7.
<ul>
<li>There is redirection that precedes the label token, and there is a <code>|</code> pipe or <code>&amp;</code>, <code>&amp;&amp;</code>, or <code>||</code> command concatenation on the line.</li>
<li>There is redirection that precedes the label token, and the command is within a parenthesized block.</li>
<li>The label token is the very first command on a line within a parenthesized block, and the line above ended with an <em>Unexecuted Label</em>.</li>
</ul>
</li>
<li>The following occurs when an <em>Executed Label</em> is discovered in phase 2
<ul>
<li>The label, its arguments, and its redirection are all excluded from any echo output in phase 3</li>
<li>Any subsequent concatenated commands on the line are fully parsed and executed.</li>
</ul>
</li>
<li>For more information about <em>Executed Labels</em> vs. <em>Unexecuted Labels</em>, see <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=3803&amp;p=55405#p55405" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=3803&amp;p=55405#p55405</a></li>
</ul>
</li>
</ul>
<p><strong>Phase 3) Echo the parsed command(s)</strong> Only if the command block did not begin with <code>@</code>, and ECHO was ON at the start of the preceding step.</p>
<p><strong>Phase 4) FOR <code>%X</code> variable expansion:</strong> Only if a FOR command is active and the commands after DO are being processed.</p>
<ul>
<li>At this point, phase 1 of batch processing will have already converted a FOR variable like <code>%%X</code> into <code>%X</code>. The command line has different percent expansion rules for phase 1. This is the reason that command lines use <code>%X</code> but batch files use <code>%%X</code> for FOR variables.</li>
<li>FOR variable names are case sensitive, but <code>~modifiers</code> are not case sensitive.</li>
<li><code>~modifiers</code> take precedence over variable names. If a character following <code>~</code> is both a modifier and a valid FOR variable name, and there exists a subsequent character that is an active FOR variable name, then the character is interpreted as a modifier.</li>
<li>FOR variable names are global, but only within the context of a DO clause. If a routine is CALLed from within a FOR DO clause, then the FOR variables are not expanded within the CALLed routine. But if the routine has its own FOR command, then <em><strong>all</strong></em> currently defined FOR variables are accessible to the inner DO commands.</li>
<li>FOR variable names can be reused within nested FORs. The inner FOR value takes precedence, but once the INNER FOR closes, then the outer FOR value is restored.</li>
<li>If ECHO was ON at the start of this phase, then phase 3) is repeated to show the parsed DO commands after the FOR variables have been expanded.</li>
</ul>
<p><em><strong>---- From this point onward, each command identified in phase 2 is processed separately.<br>
---- Phases 5 through 7 are completed for one command before moving on to the next.</strong></em></p>
<p><strong>Phase 5) Delayed Expansion:</strong> Only if delayed expansion is on, the command is not in a <a href="https://stackoverflow.com/q/8192318/1012053">parenthesized block on either side of a pipe</a>, and the command is not a <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7761" rel="noreferrer">"naked" batch script</a> (script name without parentheses, CALL, command concatenation, or pipe).</p>
<ul>
<li>Each token for a command is parsed for delayed expansion independently.
<ul>
<li>Most commands parse two or more tokens - the command token, the arguments token, and each redirection destination token.</li>
<li>The FOR command parses the IN clause token only.</li>
<li>The IF command parses the comparison values only - either one or two, depending on the comparison operator.</li>
</ul>
</li>
<li>For each parsed token, first check if it contains any <code>!</code>. If not, then the token is not parsed - important for <code>^</code> characters.
If the token does contain <code>!</code>, then scan each character from left to right:
<ul>
<li>If it is a caret (<code>^</code>) the next character has no special meaning, the caret itself is removed</li>
<li>If it is an exclamation mark, search for the next exclamation mark (carets are not observed anymore), expand to the value of the variable.
<ul>
<li>Consecutive opening <code>!</code> are collapsed into a single <code>!</code></li>
<li>Any remaining unpaired <code>!</code> is removed</li>
</ul>
</li>
<li>Expanding vars at this stage is "safe", because special characters are not detected anymore (even <code>&lt;CR&gt;</code> or <code>&lt;LF&gt;</code>)</li>
<li><em>For a more complete explanation, read the 2nd half of this from dbenham
<a href="https://stackoverflow.com/a/7970912/1012053">same thread - Exclamation Point Phase</a></em></li>
</ul>
</li>
</ul>
<p><strong>Phase 5.3) Pipe processing:</strong> Only if commands are on either side of a pipe<br>
Each side of the pipe is processed independently and asynchronously.</p>
<ul>
<li>If command is internal to cmd.exe, or it is a batch file, or if it is a parenthesized command block, then it is executed in a new cmd.exe thread via <code>%comspec% /S /D /c" commandBlock"</code>, so the command block gets a phase restart, but this time in command line mode.
<ul>
<li>If a parenthesized command block, then all <code>&lt;LF&gt;</code> with a command before and after are converted to <code>&lt;space&gt;&amp;</code>. Other <code>&lt;LF&gt;</code> are stripped.</li>
</ul>
</li>
<li>This is the end of processing for the pipe commands.</li>
<li>See <a href="https://stackoverflow.com/q/8192318/1012053">Why does delayed expansion fail when inside a piped block of code?</a> for more about pipe parsing and processing</li>
</ul>
<p><strong>Phase 5.5) Execute Redirection:</strong> Any redirection that was discovered in phase 2 is now executed.</p>
<ul>
<li>The results of phases 4 and 5 can impact the redirection that was discovered in phase 2.</li>
<li>If the redirection fails, then the remainder of the command is aborted. <a href="https://stackoverflow.com/q/10354016/1012053">Note that failed redirection does not set ERRORLEVEL to 1 unless <code>||</code> is used</a>.</li>
</ul>
<p><strong>Phase 6) CALL processing/Caret doubling:</strong> Only if the command token is CALL, or if the text before the first occurring standard token delimiter is CALL. If CALL is parsed from a larger command token, then the unused portion is prepended to the arguments token before proceeding.</p>
<ul>
<li>Scan the arguments token for an unquoted <code>/?</code>. If found anywhere within the tokens, then abort phase 6 and proceed to Phase 7, where the HELP for CALL will be printed.</li>
<li>Remove the first <code>CALL</code>, so multiple CALL's can be stacked</li>
<li>Double all carets</li>
<li>Restart phases 1, 1.5, and 2, but do not continue to phase 3
<ul>
<li>Any doubled carets are reduced back to one caret as long as they are not quoted. But unfortunately, quoted carets remain doubled.</li>
<li>Phase 1 changes a bit
- Expansion errors in step 1.2 or 1.3 abort the CALL, but the error is not fatal - batch processing continues.</li>
<li>Phase 2 tasks are altered a bit
<ul>
<li>Any newly appearing unquoted, unescaped redirection that was not detected in the first round of phase 2 is detected, but it is removed (including the file name) without actually performing the redirection</li>
<li>Any newly appearing unquoted, unescaped caret at the end of the line is removed without performing line continuation</li>
<li>The CALL is aborted without error if any of the following are detected
<ul>
<li>Newly appearing unquoted, unescaped <code>&amp;</code> or <code>|</code></li>
<li>The resultant command token begins with unquoted, unescaped <code>(</code></li>
<li>The very first token after the removed CALL began with <code>@</code></li>
</ul>
</li>
<li>If the resultant command is a seemingly valid IF or FOR, then execution will subsequently fail with an error stating that <code>IF</code> or <code>FOR</code> is not recognized as an internal or external command.</li>
<li>Of course the CALL is not aborted in this 2nd round of phase 2 if the resultant command token is a label beginning with <code>:</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the resultant command token is CALL, then restart Phase 6 (repeats until no more CALL)</li>
<li>If the resultant command token is a batch script or a :label, then execution of the CALL is fully handled by the remainder of Phase 6.
<ul>
<li>Push the current batch script file position on the call stack so that execution can resume from the correct position when the CALL is completed.</li>
<li>Setup the %0, %1, %2, ...%N and %* argument tokens for the CALL, using all resultant tokens</li>
<li>If the command token is a label that begins with <code>:</code>, then
<ul>
<li>Restart Phase 5. This can impact what :label is CALLed. But since the %0 etc. tokens have already been setup, it will not alter the arguments that are passed to the CALLed routine.</li>
<li>Execute GOTO label to position the file pointer at the beginning of the subroutine (ignore any other tokens that may follow the :label) See Phase 7 for rules on how GOTO works.
<ul>
<li>If the :label token is missing, or the :label is not found, then the call stack is immediately popped to restore the saved file position, and the CALL is aborted.</li>
<li>If the :label happens to contain /?, then GOTO help is printed instead of searching for the :label. The file pointer does not move, such that code after the CALL is executed twice, once in the CALL context, and then again after the CALL return. See <a href="https://stackoverflow.com/q/31987023/1012053">Why CALL prints the GOTO help message in this script?And why command after that are executed twice?</a> for more info.</li>
</ul>
</li>
</ul>
</li>
<li>Else transfer control to the specified batch script.</li>
<li>Execution of the CALLed :label or script continues until either EXIT /B or end-of-file is reached, at which point the CALL stack is popped and execution resumes from the saved file position.<br>
Phase 7 is not executed for CALLed scripts or :labels.</li>
</ul>
</li>
<li>Else the result of phase 6 falls through into phase 7 for execution.</li>
</ul>
<p><strong>Phase 7) Execute:</strong> The command is executed</p>
<ul>
<li><strong>7.1 - Execute internal command</strong> - If the command token is quoted, then skip this step. Otherwise, attempt to parse out an internal command and execute.
<ul>
<li>The following tests are made to determine if an unquoted command token represents an internal command:
<ul>
<li>If the command token exactly matches an internal command, then execute it.</li>
<li>Else break the command token before the first occurrence of <code>+</code> <code>/</code> <code>[</code> <code>]</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>,</code> <code>;</code> or <code>=</code><br>
If the preceding text is an internal command, then remember that command
<ul>
<li>If in command line mode, or if the command is from a parenthesized block, IF true or false command block, FOR DO command block, or involved with command concatenation, then execute the internal command</li>
<li>Else (must be a stand-alone command in batch mode) scan the current folder and the PATH for a .COM, .EXE, .BAT, or .CMD file whose base name matches the original command token
<ul>
<li>If the first matching file is a .BAT or .CMD, then goto 7.3.exec and execute that script</li>
<li>Else (match not found or first match is .EXE or .COM) execute the remembered internal command</li>
</ul>
</li>
</ul>
</li>
<li>Else break the command token before the first occurrence of <code>.</code> <code>\</code> or <code>:</code><br>
If the preceding text is not an internal command, then goto 7.2<br>
Else the preceding text may be an internal command. Remember this command.</li>
<li>Break the command token before the first occurrence of <code>+</code> <code>/</code> <code>[</code> <code>]</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>,</code> <code>;</code> or <code>=</code><br>
If the preceding text is a path to an existing file, then goto 7.2<br>
Else execute the remembered internal command.</li>
</ul>
</li>
<li>If an internal command is parsed from a larger command token, then the unused portion of the command token is included in the argument list</li>
<li>Just because a command token is parsed as an internal command does not mean that it will execute successfully. Each internal command has its own rules as to how the arguments and options are parsed, and what syntax is allowed.</li>
<li>All internal commands will print help instead of performing their function if <code>/?</code> is detected. Most recognize <code>/?</code> if it appears anywhere in the arguments. But a few commands like ECHO and SET only print help if the first argument token begins with <code>/?</code>.</li>
<li>SET has some interesting semantics:
<ul>
<li>If a SET command has a quote before the variable name and extensions are enabled<br>
<code>set "name=content" ignored</code> <strong>--&gt;</strong> value=<code>content</code><br>
then the text between the first equal sign and the last quote is used as the content (first equal and last quote excluded). Text after the last quote is ignored. If there is no quote after the equal sign, then the rest of the line is used as content.</li>
<li>If a SET command does not have a quote before the name<br>
<code>set name="content" not ignored</code> <strong>--&gt;</strong> value=<code>"content" not ignored</code><br>
then the entire remainder of the line after the equal is used as content, including any and all quotes that may be present.</li>
</ul>
</li>
<li>An IF comparison is evaluated, and depending on whether the condition is true or false, the appropriate already parsed dependent command block is processed, starting with phase 5.</li>
<li>The IN clause of a FOR command is iterated appropriately.
<ul>
<li>If this is a FOR /F that iterates the output of a command block, then:
<ul>
<li>The IN clause is executed in a new cmd.exe process via CMD /C.</li>
<li>The command block must go through the entire parsing process a second time, but this time in a command line context</li>
<li>ECHO will start out ON, and delayed expansion will usually start out disabled (dependent on the registry setting)</li>
<li>All environment changes made by the IN clause command block will be lost once the child cmd.exe process terminates</li>
</ul>
</li>
<li>For each iteration:
<ul>
<li>The FOR variable values are defined</li>
<li>The already parsed DO command block is then processed, starting with phase 4.</li>
</ul>
</li>
</ul>
</li>
<li>GOTO uses the following logic to locate the :label
<ul>
<li>Parse the label from the first argument token</li>
<li>Scan for the next occurrence of the label
<ul>
<li>Start from the current file position</li>
<li>If end of file is reached, then loop back to the beginning of file and continue to the original starting point.</li>
</ul>
</li>
<li>The scan stops at the first occurrence of the label that it finds, and the file pointer is set to the line immediately following the label. Execution of the script resumes from that point. Note that a successful true GOTO will immediately abort any parsed block of code, including FOR loops.</li>
<li>If the label is not found, or the label token is missing, then the GOTO fails, an error message is printed, and the call stack is popped. This effectively functions as an EXIT /B, except any already parsed commands in the current command block that follow the GOTO are still executed, but in the context of the CALLer (the context that exists after EXIT /B)</li>
<li>See <a href="https://www.dostips.com/forum/viewtopic.php?t=3803" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?t=3803</a> for a more precise description of label parsing rules, and <a href="https://www.dostips.com/forum/viewtopic.php?t=8988" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?t=8988</a> for label scanning rules.</li>
</ul>
</li>
<li>RENAME and COPY both accept wildcards for the source and target paths. But Microsoft does a terrible job documenting how the wildcards work, especially for the target path. A useful set of wildcard rules may be found at <a href="https://superuser.com/q/475874/109090">How does the Windows RENAME command interpret wildcards?</a></li>
</ul>
</li>
<li><strong>7.2 - Execute volume change</strong> - Else if the command token does not begin with a quote, is exactly two characters long, and the 2nd character is a colon, then change the volume
<ul>
<li>All argument tokens are ignored</li>
<li>If the volume specified by the first character cannot be found, then abort with an error</li>
<li>A command token of <code>::</code> will always result in an error unless SUBST is used to define a volume for <code>::</code><br>
If SUBST is used to define a volume for <code>::</code>, then the volume will be changed, it will not be treated as a label.</li>
</ul>
</li>
<li><strong>7.3 - Execute external command</strong> - Else try to treat the command as an external command.
<ul>
<li>If in command line mode and the command is not quoted and does not begin with a volume specification, white-space, <code>,</code>, <code>;</code>, <code>=</code> or <code>+</code> then break the command token at the first occurrence of <code>&lt;space&gt;</code> <code>,</code> <code>;</code> or <code>=</code> and prepend the remainder to the argument token(s).</li>
<li>If the 2nd character of the command token is a colon, then verify the volume specified by the 1st character can be found.<br>
If the volume cannot be found, then abort with an error.</li>
<li>If in batch mode and the command token begins with <code>:</code>, then goto 7.4<br>
Note that if the label token begins with <code>::</code>, then this will not be reached because the preceding step will have aborted with an error unless SUBST is used to define a volume for <code>::</code>.</li>
<li>Identify the external command to execute.
<ul>
<li>This is a complex process that may involve the current volume, current directory, PATH variable, PATHEXT variable, and or file associations.</li>
<li>If a valid external command cannot be identified, then abort with an error.</li>
</ul>
</li>
<li>If in command line mode and the command token begins with <code>:</code>, then goto 7.4<br>
Note that this is rarely reached because the preceding step will have aborted with an error unless the command token begins with <code>::</code>, and SUBST is used to define a volume for <code>::</code>, and the entire command token is a valid path to an external command.</li>
<li><strong>7.3.exec</strong> - Execute the external command.</li>
</ul>
</li>
<li><strong>7.4 - Ignore a label</strong> - Ignore the command and all its arguments if the command token begins with <code>:</code>.<br>
Rules in 7.2 and 7.3 may prevent a label from reaching this point.</li>
</ul>
<hr>
<h2>Command Line Parser:</h2>
<p>Works like the BatchLine-Parser, except:</p>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<ul>
<li>No <code>%*</code>, <code>%1</code> etc. argument expansion</li>
<li>If var is undefined, then <code>%var%</code> is left unchanged.</li>
<li>No special handling of <code>%%</code>. If var=content, then <code>%%var%%</code> expands to <code>%content%</code>.</li>
</ul>
<p><strong>Phase 3) Echo the parsed command(s)</strong></p>
<ul>
<li>This is not performed after phase 2. It is only performed after phase 4 for the FOR DO command block.</li>
</ul>
<p><strong>Phase 5) Delayed Expansion:</strong> only if DelayedExpansion is enabled</p>
<ul>
<li>If var is undefined, then <code>!var!</code> is left unchanged.</li>
</ul>
<p><strong>Phase 7) Execute Command</strong></p>
<ul>
<li>Attempts to CALL or GOTO a :label result in an error.</li>
<li>As already documented in phase 7, an executed label may result in an error under different scenarios.
<ul>
<li>Batch executed labels can only cause an error if they begin with <code>::</code></li>
<li>Command line executed labels almost always result in an error</li>
</ul>
</li>
</ul>
<hr>
<h2>Parsing of integer values</h2>
<p>There are many different contexts where cmd.exe parses integer values from strings, and the rules are inconsistent:</p>
<ul>
<li><code>SET /A</code></li>
<li><code>IF</code></li>
<li><code>%var:~n,m%</code> (variable substring expansion)</li>
<li><code>FOR /F "TOKENS=n"</code></li>
<li><code>FOR /F "SKIP=n"</code></li>
<li><code>FOR /L %%A in (n1 n2 n3)</code></li>
<li><code>EXIT [/B] n</code></li>
</ul>
<p>Details for these rules may be found at <a href="https://www.dostips.com/forum/viewtopic.php?t=3758" rel="noreferrer">Rules for how CMD.EXE parses numbers</a></p>
<hr>
<p>For anyone wishing to improve the cmd.exe parsing rules, there is a <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=8355" rel="noreferrer">discussion topic on the DosTips forum</a> where issues can be reported and suggestions made.</p>
<p>Hope it helps<br>
Jan Erik (jeb) - Original author and discoverer of phases<br>
Dave Benham (dbenham) - Much additional content and editing</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When invoking a command from a command window, tokenization of the command line arguments is not done by <code>cmd.exe</code> (a.k.a. "the shell").  Most often the tokenization is done by the newly formed processes' C/C++ runtime, but this is not necessarily so -- for example, if the new process was not written in C/C++, or if the new process chooses to ignore <code>argv</code> and process the raw commandline for itself (e.g. with <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx" rel="noreferrer">GetCommandLine()</a>).  At the OS level, Windows passes command lines untokenized as a single string to new processes.  This is in contrast to most *nix shells, where the shell tokenizes arguments in a consistent, predictable way before passing them to the newly formed process.  All this means that you may experience wildly divergent argument tokenization behavior across different programs on Windows, as individual programs often take argument tokenization into their own hands.</p>

<p>If it sounds like anarchy, it kind of is.  However, since a large number of Windows programs <em>do</em> utilize the Microsoft C/C++ runtime's <code>argv</code>, it may be generally useful to understand <a href="http://msdn.microsoft.com/en-us/library/a1y7w461.aspx" rel="noreferrer">how the MSVCRT tokenizes</a> arguments.  Here is an excerpt:</p>

<ul>
<li>Arguments are delimited by white space, which is either a space or a tab.</li>
<li>A string surrounded by double quotation marks is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument. Note that the caret (^) is not recognized as an escape character or delimiter.</li>
<li>A double quotation mark preceded by a backslash, \", is interpreted as a literal double quotation mark (").</li>
<li>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</li>
<li>If an even number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\), and the double quotation mark (") is interpreted as a string delimiter.</li>
<li>If an odd number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\) and the double quotation mark is interpreted as an escape sequence by the remaining backslash, causing a literal double quotation mark (") to be placed in argv.</li>
</ul>

<hr>

<p>The Microsoft "batch language" (<code>.bat</code>) is no exception to this anarchic environment, and it has developed its own unique rules for tokenization and escaping. It also looks like cmd.exe's command prompt does do some preprocessing of the command line argument (mostly for variable substitution and escaping) before passing the argument off to the newly executing process.  You can read more about the low-level details of the batch language and cmd escaping in the excellent answers by jeb and dbenham on this page.  </p>

<hr>

<p>Let's build a simple command line utility in C and see what it says about your test cases:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> {
    <span class="hljs-type">int</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d][%s]\n"</span>, i, argv[i]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>(Notes: argv[0] is always the name of the executable, and is omitted below for brevity.  Tested on Windows XP SP3. Compiled with Visual Studio 2005.)</p>

<pre><code>&gt; test.exe "a ""b"" c"
argv[1][a "b" c]

&gt; test.exe """a b c"""
argv[1]["a b c"]

&gt; test.exe "a"" b c
argv[1][a" b c]
</code></pre>

<p>And a few of my own tests:</p>

<pre><code>&gt; test.exe a "b" c
argv[1][a]
argv[2][b]
argv[3][c]

&gt; test.exe a "b c" "d e
argv[1][a]
argv[2][b c]
argv[3][d e]

&gt; test.exe a \"b\" c
argv[1][a]
argv[2]["b"]
argv[3][c]
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Percent Expansion Rules</h1>
<p>Here is an expanded explanation of Phase 1 in <a href="https://stackoverflow.com/a/4095133/1012053">jeb's answer</a> (valid for both batch mode and command line mode).</p>
<p><strong>Phase 1) Percent Expansion</strong>
Starting from left, scan each character for <code>%</code> or <code>&lt;LF&gt;</code>. If found then</p>
<ul>
<li><strong>1.05 (truncate line at <code>&lt;LF&gt;</code>)</strong></li>
<li>If the character is <code>&lt;LF&gt;</code> then
<ul>
<li>Drop (ignore) the remainder of the line from the <code>&lt;LF&gt;</code> onward</li>
<li>Goto Phase 2.0</li>
</ul>
</li>
<li>Else the character must be <code>%</code>, so proceed to 1.1</li>
<li><strong>1.1 (escape <code>%</code>)</strong> <em>skipped if command line mode</em></li>
<li>If batch mode and followed by another <code>%</code> then<br>
Replace <code>%%</code> with single <code>%</code> and continue scan</li>
<li><strong>1.2 (expand argument)</strong> <em>skipped if command line mode</em></li>
<li>Else if batch mode then
<ul>
<li>If followed by <code>*</code> and command extensions are enabled then<br>
Replace <code>%*</code> with the text of all command line arguments (Replace with nothing if there are no arguments) and continue scan.</li>
<li>Else if followed by <code>&lt;digit&gt;</code> then<br>
Replace <code>%&lt;digit&gt;</code> with argument value (replace with nothing if undefined) and continue scan.</li>
<li>Else if followed by <code>~</code> and command extensions are enabled then
<ul>
<li>If followed by optional valid list of argument modifiers followed by required <code>&lt;digit&gt;</code> then<br>
Replace <code>%~[modifiers]&lt;digit&gt;</code> with modified argument value (replace with nothing if not defined or if specified $PATH: modifier is not defined) and continue scan.<br>
<em>Note: modifiers are case insensitive and can appear multiple times in any order, except $PATH: modifier can only appear once and must be the last modifier before the <code>&lt;digit&gt;</code></em></li>
<li>Else invalid modified argument syntax raises <em><strong>fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!</strong></em></li>
</ul>
</li>
</ul>
</li>
<li><strong>1.3 (expand variable)</strong></li>
<li>Else if command extensions are disabled then<br>
Look at next string of characters, breaking before <code>%</code> or end of buffer, and call them VAR (may be an empty list)
<ul>
<li>If next character is <code>%</code> then
<ul>
<li>If VAR is defined then<br>
Replace <code>%VAR%</code> with value of VAR and continue scan</li>
<li>Else if batch mode then<br>
Remove <code>%VAR%</code> and continue scan</li>
<li>Else goto 1.4</li>
</ul>
</li>
<li>Else goto 1.4</li>
</ul>
</li>
<li>Else if command extensions are enabled then<br>
Look at next string of characters, breaking before <code>%</code> <code>:</code> or end of buffer, and call them VAR (may be an empty list). If VAR breaks before <code>:</code> and the subsequent character is <code>%</code> then include <code>:</code> as the last character in VAR and break before <code>%</code>.
<ul>
<li>If next character is <code>%</code> then
<ul>
<li>If VAR is defined then<br>
Replace <code>%VAR%</code> with value of VAR and continue scan</li>
<li>Else if batch mode then<br>
Remove <code>%VAR%</code> and continue scan</li>
<li>Else goto 1.4</li>
</ul>
</li>
<li>Else if next character is <code>:</code> then
<ul>
<li>If VAR is undefined then
<ul>
<li>If batch mode then<br>
Remove <code>%VAR:</code> and continue scan.</li>
<li>Else goto 1.4</li>
</ul>
</li>
<li>Else if next character is <code>~</code> then
<ul>
<li>If next string of characters matches pattern of <code>[integer][,[integer]]%</code> then<br>
Replace <code>%VAR:~[integer][,[integer]]%</code> with substring of value of VAR (possibly resulting in empty string) and continue scan.</li>
<li>Else goto 1.4</li>
</ul>
</li>
<li>Else if followed by <code>=</code> or <code>*=</code> then<br>
Invalid variable search and replace syntax raises <em><strong>fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!</strong></em></li>
<li>Else if next string of characters matches pattern of <code>[*]search=[replace]%</code>, where search may include any set of characters except <code>=</code>, and replace may include any set of characters except <code>%</code>, then<br>
Replace <code>%VAR:[*]search=[replace]%</code> with value of VAR after performing search and replace (possibly resulting in empty string) and continue scan</li>
<li>Else goto 1.4</li>
</ul>
</li>
</ul>
</li>
<li><strong>1.4 (strip %)</strong>
<ul>
<li>Else If batch mode then<br>
Remove <code>%</code> and continue scan starting with the next character after the <code>%</code></li>
<li>Else preserve the leading <code>%</code> and continue scan starting with the next character after the preserved leading <code>%</code></li>
</ul>
</li>
</ul>
<p>The above helps explain why this batch</p>
<pre><code>@echo off
setlocal enableDelayedExpansion
set "1var=varA"
set "~f1var=varB"
call :test "arg1"
exit /b  
::
:test "arg1"
echo %%1var%% = %1var%
echo ^^^!1var^^^! = !1var!
echo --------
echo %%~f1var%% = %~f1var%
echo ^^^!~f1var^^^! = !~f1var!
exit /b
</code></pre>
<p>Gives these results:</p>
<pre><code>%1var% = "arg1"var
!1var! = varA
--------
%~f1var% = P:\arg1var
!~f1var! = varB
</code></pre>
<p><em><strong>Note 1</strong></em> - Phase 1 occurs prior to the recognition of REM statements. This is very important because it means even a remark can generate a fatal error if it has invalid argument expansion syntax or invalid variable search and replace syntax!</p>
<pre><code>@echo off
rem %~x This generates a fatal argument expansion error
echo this line is never reached
</code></pre>
<p><em><strong>Note 2</strong></em> - Another interesting consequence of the % parsing rules: Variables containing : in the name can be defined, but they cannot be expanded unless command extensions are disabled. There is one exception - a variable name containing a single colon at the end can be expanded while command extensions are enabled. However, you cannot perform substring or search and replace operations on variable names ending with a colon. The batch file below (courtesy of jeb) demonstrates this behavior</p>
<pre><code>@echo off
setlocal
set var=content
set var:=Special
set var::=double colon
set var:~0,2=tricky
set var::~0,2=unfortunate
echo %var%
echo %var:%
echo %var::%
echo %var:~0,2%
echo %var::~0,2%
echo Now with DisableExtensions
setlocal DisableExtensions
echo %var%
echo %var:%
echo %var::%
echo %var:~0,2%
echo %var::~0,2%
</code></pre>
<p><em><strong>Note 3</strong></em> - An interesting outcome of the order of the parsing rules that jeb lays out in his post: When performing find and replace with delayed expansion, special characters in both the find and replace terms must be escaped or quoted. But the situation is different for percent expansion - the find term must not be escaped (though it can be quoted). The percent replace string may or may not require escape or quote, depending on your intent.</p>
<pre><code>@echo off
setlocal enableDelayedExpansion
set "var=this &amp; that"
echo %var:&amp;=and%
echo "%var:&amp;=and%"
echo !var:^&amp;=and!
echo "!var:&amp;=and!"
</code></pre>
<hr>
<p>#Delayed Expansion Rules
Here is an expanded, and more accurate explanation of Phase 5 in <a href="https://stackoverflow.com/a/4095133/1012053">jeb's answer</a> (Valid for both batch mode and command line mode)</p>
<p><strong>Phase 5) Delayed Expansion</strong></p>
<p>This phase is skipped if any of the following conditions apply:</p>
<ul>
<li>Delayed expansion is disabled.</li>
<li>The command is within a parenthesized block on either side of a pipe.</li>
<li>The incoming command token is a "naked" batch script, meaning it is not associated with <code>CALL</code>, parenthesized block, any form of command concatenation (<code>&amp;</code>, <code>&amp;&amp;</code> or <code>||</code>), or a pipe <code>|</code>.</li>
</ul>
<p>The delayed expansion process is applied to tokens independently. A command may have multiple tokens:</p>
<ul>
<li>The command token. For most commands the command name itself is a token. But a few commands have specialized regions that are considered a TOKEN for Phase 5.
<ul>
<li><code>for ... in(TOKEN) do</code></li>
<li><code>if defined TOKEN</code></li>
<li><code>if exists TOKEN</code></li>
<li><code>if errorlevel TOKEN</code></li>
<li><code>if cmdextversion TOKEN</code></li>
<li><code>if TOKEN comparison TOKEN</code>, where comparison is one of <code>==</code>, <code>equ</code>, <code>neq</code>, <code>lss</code>, <code>leq</code>, <code>gtr</code>, or <code>geq</code></li>
</ul>
</li>
<li>The arguments token</li>
<li>The destination token of redirection (one per redirection)</li>
</ul>
<p>No change is made to tokens that do not contain <code>!</code>.</p>
<p>For each token that does contain at least one <code>!</code>, scan each character from left to right for <code>^</code> or <code>!</code>, and if found, then</p>
<ul>
<li><strong>5.1 (caret escape)</strong> Needed for <code>!</code> or <code>^</code> literals</li>
<li>If character is a caret <code>^</code> then
<ul>
<li>Remove the <code>^</code></li>
<li>Scan the next character and preserve it as a literal</li>
<li>Continue the scan</li>
</ul>
</li>
<li><strong>5.2 (expand variable)</strong></li>
<li>If character is <code>!</code>, then
<ul>
<li>If command extensions are disabled then<br>
Look at next string of characters, breaking before <code>!</code> or <code>&lt;LF&gt;</code>, and call them VAR (may be an empty list)
<ul>
<li>If next character is <code>!</code> then
<ul>
<li>If VAR is defined, then<br>
Replace <code>!VAR!</code> with value of VAR and continue scan</li>
<li>Else if batch mode then<br>
Remove <code>!VAR!</code> and continue scan</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else if command extensions are enabled then<br>
Look at next string of characters, breaking before <code>!</code>, <code>:</code>, or <code>&lt;LF&gt;</code>, and call them VAR (may be an empty list). If VAR breaks before <code>:</code> and the subsequent character is <code>!</code> then include <code>:</code> as the last character in VAR and break before <code>!</code>
<ul>
<li>If next character is <code>!</code> then
<ul>
<li>If VAR exists, then<br>
Replace <code>!VAR!</code> with value of VAR and continue scan</li>
<li>Else if batch mode then<br>
Remove <code>!VAR!</code> and continue scan</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else if next character is <code>:</code> then
<ul>
<li>If VAR is undefined then
<ul>
<li>If batch mode then<br>
Remove <code>!VAR:</code> and continue scan</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else if next character is <code>~</code> then
<ul>
<li>If next string of characters matches pattern of <code>[integer][,[integer]]!</code> then Replace <code>!VAR:~[integer][,[integer]]!</code> with substring of value of VAR (possibly resulting in empty string) and continue scan.</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else if next string of characters matches pattern of <code>[*]search=[replace]!</code>, where search may include any set of characters except <code>=</code>, and replace may include any set of characters except <code>!</code>, then<br>
Replace <code>!VAR:[*]search=[replace]!</code> with value of VAR after performing search and replace (possibly resulting in an empty string) and continue scan</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>Else goto 5.2.1</li>
</ul>
</li>
<li>5.2.1
<ul>
<li>If batch mode then remove the leading <code>!</code><br>
Else preserve the leading <code>!</code></li>
<li>Continue the scan starting with the next character after the preserved leading <code>!</code></li>
</ul>
</li>
</ul>
</li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As pointed out, commands are passed the entire argument string in μSoft land, and it is up to them to parse this into separate arguments for their own use. There is no consistencty in this between different programs, and therefore there is no one set of rules to describe this process. You really need to check each corner case for whatever C library your program uses.</p>

<p>As far as the system <code>.bat</code> files go, here is that test:</p>

<pre class="lang-sh s-code-block"><code class="hljs language-bash">c&gt; <span class="hljs-built_in">type</span> args.cmd
@<span class="hljs-built_in">echo</span> off
<span class="hljs-built_in">echo</span> cmdcmdline:[%cmdcmdline%]
<span class="hljs-built_in">echo</span> 0:[%0]
<span class="hljs-built_in">echo</span> *:[%*]
<span class="hljs-built_in">set</span> allargs=%*
<span class="hljs-keyword">if</span> not defined allargs goto :eof
setlocal
@rem Wot about a <span class="hljs-built_in">nice</span> <span class="hljs-keyword">for</span> loop?
@rem Then we are <span class="hljs-keyword">in</span> the land of delayedexpansion, !n!, call, etc.
@rem Plays havoc with args like %t%, a<span class="hljs-string">"b etc. ugh!
set n=1
:loop
    echo %n%:[%1]
    set /a n+=1
    shift
    set param=%1
    if defined param goto :loop
endlocal
</span></code></pre>

<p>Now we can run some tests. See if you can figure out just what μSoft are trying to do:</p>

<pre><code>C&gt;args a b c
cmdcmdline:[cmd.exe ]
0:[args]
*:[a b c]
1:[a]
2:[b]
3:[c]
</code></pre>

<p>Fine so far. (I'll leave out the uninteresting <code>%cmdcmdline%</code> and <code>%0</code> from now on.)</p>

<pre><code>C&gt;args *.*
*:[*.*]
1:[*.*]
</code></pre>

<p>No filename expansion.</p>

<pre><code>C&gt;args "a b" c
*:["a b" c]
1:["a b"]
2:[c]
</code></pre>

<p>No quote stripping, though quotes do prevent argument splitting.</p>

<pre><code>c&gt;args ""a b" c
*:[""a b" c]
1:[""a]
2:[b" c]
</code></pre>

<p>Consecutive double quotes causes them to lose any special parsing abilities they may have had. @Beniot's example:</p>

<pre><code>C&gt;args "a """ b "" c"""
*:["a """ b "" c"""]
1:["a """]
2:[b]
3:[""]
4:[c"""]
</code></pre>

<p>Quiz: How do you pass the value of any environment var as a <em>single</em> argument (i.e., as <code>%1</code>) to a bat file?</p>

<pre><code>c&gt;set t=a "b c
c&gt;set t
t=a "b c
c&gt;args %t%
1:[a]
2:["b c]
c&gt;args "%t%"
1:["a "b]
2:[c"]
c&gt;Aaaaaargh!
</code></pre>

<p>Sane parsing seems forever broken.</p>

<p>For your entertainment, try adding miscellaneous <code>^</code>, <code>\</code>, <code>'</code>, <code>&amp;</code> (&amp;c.) characters to these examples.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You have some great answers above already, but to answer one part of your question:</p>

<pre><code>set a =b, echo %a %b% c%  bb c%
</code></pre>

<p>What is happening there is that because you have a space before the =, a variable is created called <code>%a&lt;space&gt;%</code>
so when you <code>echo %a %</code> that is evaluated correctly as <code>b</code>.</p>

<p>The remaining part <code>b% c%</code> is then evaluated as plain text + an undefined variable <code>% c%</code>, which should be echoed as typed, for me <code>echo %a %b% c%</code> returns <code>bb% c%</code></p>

<p>I suspect that the ability to include spaces in variable names is more of an oversight than a planned 'feature'</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1><code>FOR</code>-Loop Meta-Variable Expansion</h1>
<p>This is an extended explanation of <em><strong>Phase 4)</strong></em> in the <a href="https://stackoverflow.com/a/4095133">accepted answer</a> (applicable for both batch file mode and command line mode). Of course a <code>for</code> command must be active. The following describes the processing of the command line portion after the <code>do</code> clause. Note that in batch file mode, <code>%%</code> has already been converted to <code>%</code> due to the foregoing immediate <code>%</code>-expansion phase (<em>Phase 1)</em>).</p>
<ul>
<li>scan for <code>%</code>-sign, beginning from the left up to the end of the line; if one is found, then:
<ul>
<li>if <a href="https://ss64.com/nt/cmd.html" rel="nofollow noreferrer" title="CMD.exe">Command Extensions</a> are enabled (default), check if next character is <code>~</code>; if yes, then:
<ul>
<li>take as many as possible of the following characters in the case-insensitive set <code>fdpnxsatz</code> (even multiple times each) that are preceding a character that defines a <code>for</code> variable reference or a <code>$</code>-sign; if such a <code>$</code>-sign is encountered, then:
<ul>
<li>scan for a <code>:</code><sup>1</sup>; if found, then:
<ul>
<li>if there is a character following the <code>:</code>, use it as a <code>for</code> variable reference and expand as expected, unless it is not defined, then do not expand and continue scan at that character position;</li>
<li>if the <code>:</code> is the last character, <strong><code>cmd.exe</code> will crash!</strong></li>
</ul>
</li>
<li>else (no <code>:</code> is found) do not expand anything;</li>
</ul>
</li>
<li>else (if no <code>$</code>-sign is encountered) expand the <code>for</code> variable using all the modifiers, unless it is not defined, then do not expand and continue scan at that character position;</li>
</ul>
</li>
<li>else (if no <code>~</code> is found or Command Extensions are disabled) check the next character:
<ul>
<li>if there is no more character available, do not expand anything;</li>
<li>if the next character is <code>%</code>, do not expand anything and go back to the beginning of the scan at this character position<sup>2</sup>;</li>
<li>else use the next character as a <code>for</code> variable reference and expand, unless such is not defined, then do not expand;</li>
</ul>
</li>
</ul>
</li>
<li>go back to the beginning of the scan at the next character position (as long as there still characters available);</li>
</ul>
<hr>
<p><sub>1)  The string between <code>$</code> and <code>:</code> is considered as the name of an environment variable, which may even be empty; since an environment variable cannot have an empty name, the behaviour is just the same as for an undefined environment variable.</sub>
<br>
<sub>2)  This implies that a <code>for</code> meta-variable named <code>%</code> cannot be expanded without a <code>~</code>-modifier.</sub></p>
<hr>
<p><sub>Original source: <a href="https://stackoverflow.com/a/56240800" title="How to safely echo FOR variable %%~p followed by a string literal">How to safely echo FOR variable %%~p followed by a string literal</a></sub></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>edit: see accepted answer, what follows is wrong and explains only how to pass a command line to TinyPerl.</p>

<hr>

<p>Regarding quotes, I have the feeling that the behaviour is the following:</p>

<ul>
<li>when a <code>"</code> is found, string globbing begins</li>
<li>when string globbing occurs:
<ul>
<li>every character that is not a <code>"</code> is globbed</li>
<li>when a <code>"</code> is found:
<ul>
<li>if it is followed by <code>""</code> (thus a triple <code>"</code>) then a double quote is added to the string</li>
<li>if it is followed by <code>"</code> (thus a double <code>"</code>) then a double quote is added to the string and string globbing ends</li>
<li>if the next character is not <code>"</code>, string globbing ends</li>
</ul></li>
<li>when line ends, string globbing ends.</li>
</ul></li>
</ul>

<p>In short:</p>

<p><code>"a """ b "" c"""</code> consists of two strings: <code>a " b "</code> and <code>c"</code></p>

<p><code>"a""</code>, <code>"a"""</code> and<code>"a""""</code> are all the same string if at the end of a line</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Note that Microsoft has published its Terminal's source code. It may work similar to the command line with respect to syntax parsing. Maybe someone is interested in testing the reverse-engineered parsing rules on accordance with the terminal's parsing rules.</p>

<p><a href="https://github.com/Microsoft/Terminal" rel="nofollow noreferrer">Link</a> to the source code.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;We performed experiments to investigate the grammar of batch scripts. We also investigated differences between batch and command line mode.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Batch Line Parser:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Here is a brief overview of phases in the batch file line parser:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 0) Read Line:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 2) Process special characters, tokenize, and build a cached command block:\u0026lt;/strong\u0026gt; This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt; Only if the command block did not begin with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, and ECHO was ON at the start of the preceding step.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 4) FOR \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; variable expansion:\u0026lt;/strong\u0026gt; Only if a FOR command is active and the commands after DO are being processed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; Only if delayed expansion is enabled\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.3) Pipe processing:\u0026lt;/strong\u0026gt; Only if commands are on either side of a pipe\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.5) Execute Redirection:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 6) CALL processing/Caret doubling:\u0026lt;/strong\u0026gt; Only if the command token is CALL\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute:\u0026lt;/strong\u0026gt; The command is executed\n\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Here are details for each phase:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the phases described below are only a model of how the batch parser works. The actual cmd.exe internals may not reflect these phases. But this model is effective at predicting behavior of batch scripts.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 0) Read Line:\u0026lt;/strong\u0026gt; Read line of input through first \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When reading a line to be parsed as a command, \u0026lt;code\u0026gt;\u0026amp;lt;Ctrl-Z\u0026amp;gt;\u0026lt;/code\u0026gt; (0x1A) is read as \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; (LineFeed 0x0A)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When GOTO or CALL reads lines while scanning for a :label, \u0026lt;code\u0026gt;\u0026amp;lt;Ctrl-Z\u0026amp;gt;\u0026lt;/code\u0026gt;, is treated as itself - it is \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; converted to \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A double \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; is replaced by a single \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expansion of arguments (\u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%2\u0026lt;/code\u0026gt;, etc.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expansion of \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt;, if var does not exist replace it with nothing\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Line is truncated at first \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; not within \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt; expansion\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;For a complete explanation read the first half of this from dbenham \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7970912/1012053\u0026quot;\u0026gt;Same thread: Percent Phase\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 2) Process special characters, tokenize, and build a cached command block:\u0026lt;/strong\u0026gt; This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes. What follows is an approximation of this process.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are concepts that are important throughout this phase.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A token is simply a string of characters that is treated as a unit.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Tokens are separated by token delimiters. The standard token delimiters are \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0B\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0C\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;0xFF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nConsecutive token delimiters are treated as one - there are no empty tokens between token delimiters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There are no token delimiters within a quoted string. The entire quoted string is always treated as part of a single token. A single token may consist of a combination of quoted strings and unquoted characters.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The following characters may have special meaning in this phase, depending on context: \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0B\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0C\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0xFF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Look at each character from left to right:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; then remove it, as if it were never there (except for weird \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=9429\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;redirection behavior\u0026lt;/a\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a caret (\u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;), the next character is escaped, and the escaping caret is removed. Escaped characters lose all special meaning (except for \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a quote (\u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;), toggle the quote flag. If the quote flag is active, then only \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; are special. All other characters lose their special meaning until the next quote toggles the quote flag off. It is not possible to escape the closing quote. All quoted characters are always within the same token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; always turns off the quote flag. Other behaviors vary depending on context, but quotes never alter the behavior of \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Escaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is stripped\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The next character is escaped. If at the end of line buffer, then the next line is read and processed by phases 1 and 1.5 and appended to the current one before escaping the next character. If the next character is \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, then it is treated as a literal, meaning this process is not recursive.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; not within parentheses\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is stripped and parsing of the current line is terminated.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any remaining characters in the line buffer are simply ignored.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; within a FOR IN parenthesized block\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is converted into a \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If at the end of the line buffer, then the next line is read and appended to the current one.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; within a parenthesized command block\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is converted into \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;, and the \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; is treated as part of the next line of the command block.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If at the end of line buffer, then the next line is read and appended to the space.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If one of the special characters \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, split the line at this point in order to handle pipes, command concatenation, and redirection.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;In the case of a pipe (\u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;), each side is a separate command (or command block) that gets special handling in phase 5.3\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the case of \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; command concatenation, each side of the concatenation is treated as a separate command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the case of \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; redirection, the redirection clause is parsed, temporarily removed, and then appended to the end of the current command. A redirection clause consists of an optional file handle digit, the redirection operator, and the redirection destination token.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the token that precedes the redirection operator is a single unescaped digit, then the digit specifies the file handle to be redirected. If the handle token is not found, then output redirection defaults to 1 (stdout), and input redirection defaults to 0 (stdin).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the very first token for this command (prior to moving redirection to the end) begins with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, then the \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; has special meaning. (\u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is not special in any other context)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The special \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is removed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If ECHO is ON, then this command, along with any following concatenated commands on this line, are excluded from the phase 3 echo. If the \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is before an opening \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;, then the entire parenthesized block is excluded from the phase 3 echo.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Process parenthesis (provides for compound statements across multiple lines):\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the parser is not looking for a command token, then \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; is not special.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parser is looking for a command token and finds \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;, then start a new compound statement and increment the parenthesis counter\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parenthesis counter is \u0026amp;gt; 0 then \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt; terminates the compound statement and decrements the parenthesis counter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the line end is reached and the parenthesis counter is \u0026amp;gt; 0 then the next line will be appended to the compound statement (starts again with phase 0)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parenthesis counter is 0 and the parser is looking for a command, then \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt; functions similar to a \u0026lt;code\u0026gt;REM\u0026lt;/code\u0026gt; statement as long as it is immediately followed by a token delimiter, special character, newline, or end-of-file\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All special characters lose their meaning except \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; (line concatenation is possible)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Once the end of the logical line is reached, the entire \u0026quot;command\u0026quot; is discarded.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Each command is parsed into a series of tokens. The first token is always treated as a command token (after special \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; have been stripped and redirection moved to the end).\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Leading token delimiters prior to the command token are stripped\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When parsing the command token, \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; functions as a command token delimiter, in addition to the standard token delimiters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The handling of subsequent tokens depends on the command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Most commands simply concatenate all arguments after the command token into a single argument token. All argument token delimiters are preserved. Argument options are typically not parsed until phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Three commands get special handling - IF, FOR, and REM\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;IF is split into two or three distinct parts that are processed independently. A syntax error in the IF construction will result in a fatal syntax error.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The comparison operation is the actual command that flows all the way through to phase 7\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All IF options are fully parsed in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consecutive token delimiters collapse into a single space.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Depending on the comparison operator, there will be one or two value tokens that are identified.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The True command block is the set of commands after the condition, and is parsed like any other command block. If ELSE is to be used, then the True block must be parenthesized.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The optional False command block is the set of commands after ELSE. Again, this command block is parsed normally.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The True and False command blocks do not automatically flow into the subsequent phases. Their subsequent processing is controled by phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR is split in two after the DO. A syntax error in the FOR construction will result in a fatal syntax error.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The portion through DO is the actual FOR iteration command that flows all the way through phase 7\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All FOR options are fully parsed in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IN parenthesized clause treats \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;. After the IN clause is parsed, all tokens are concatenated together to form a single token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consecutive unescaped/unquoted token delimiters collapse into a single space throughout the FOR command through DO.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The portion after DO is a command block that is parsed normally. Subsequent processing of the DO command block is controled by the iteration in phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;REM detected in phase 2 is treated dramatically different than all other commands.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Only one argument token is parsed - the parser ignores characters after the first argument token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The REM command may appear in phase 3 output, but the command is never executed, and the original argument text is echoed - escaping carets are not removed, except...\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If there is only one argument token that ends with an unescaped \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; that ends the line, then the argument token is thrown away, and the subsequent line is parsed and appended to the REM. This repeats until there is more than one token, or the last character is not \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, and this is the first round of phase 2 (not a restart due to CALL in phase 6) then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The token is normally treated as an \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The remainder of the line is parsed, however \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; no longer have special meaning. The entire remainder of the line is considered to be part of the label \u0026quot;command\u0026quot;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; continues to be special, meaning that line continuation can be used to append the subsequent line to the label.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt; within a parenthesized block will result in a fatal syntax error unless it is immediately followed by a command or \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; on the next line.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; no longer has special meaning for the first command that follows the \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command is aborted after label parsing is complete. Subsequent phases do not take place for the label\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There are three exceptions that can cause a label found in phase 2 to be treated as an \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; that continues parsing through phase 7.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;There is redirection that precedes the label token, and there is a \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; pipe or \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; command concatenation on the line.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There is redirection that precedes the label token, and the command is within a parenthesized block.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The label token is the very first command on a line within a parenthesized block, and the line above ended with an \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The following occurs when an \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; is discovered in phase 2\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The label, its arguments, and its redirection are all excluded from any echo output in phase 3\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any subsequent concatenated commands on the line are fully parsed and executed.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For more information about \u0026lt;em\u0026gt;Executed Labels\u0026lt;/em\u0026gt; vs. \u0026lt;em\u0026gt;Unexecuted Labels\u0026lt;/em\u0026gt;, see \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=3803\u0026amp;amp;p=55405#p55405\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=3803\u0026amp;amp;p=55405#p55405\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt; Only if the command block did not begin with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, and ECHO was ON at the start of the preceding step.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 4) FOR \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; variable expansion:\u0026lt;/strong\u0026gt; Only if a FOR command is active and the commands after DO are being processed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;At this point, phase 1 of batch processing will have already converted a FOR variable like \u0026lt;code\u0026gt;%%X\u0026lt;/code\u0026gt; into \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt;. The command line has different percent expansion rules for phase 1. This is the reason that command lines use \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; but batch files use \u0026lt;code\u0026gt;%%X\u0026lt;/code\u0026gt; for FOR variables.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names are case sensitive, but \u0026lt;code\u0026gt;~modifiers\u0026lt;/code\u0026gt; are not case sensitive.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;~modifiers\u0026lt;/code\u0026gt; take precedence over variable names. If a character following \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; is both a modifier and a valid FOR variable name, and there exists a subsequent character that is an active FOR variable name, then the character is interpreted as a modifier.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names are global, but only within the context of a DO clause. If a routine is CALLed from within a FOR DO clause, then the FOR variables are not expanded within the CALLed routine. But if the routine has its own FOR command, then \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;all\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; currently defined FOR variables are accessible to the inner DO commands.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names can be reused within nested FORs. The inner FOR value takes precedence, but once the INNER FOR closes, then the outer FOR value is restored.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If ECHO was ON at the start of this phase, then phase 3) is repeated to show the parsed DO commands after the FOR variables have been expanded.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;---- From this point onward, each command identified in phase 2 is processed separately.\u0026lt;br\u0026gt;\n---- Phases 5 through 7 are completed for one command before moving on to the next.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; Only if delayed expansion is on, the command is not in a \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8192318/1012053\u0026quot;\u0026gt;parenthesized block on either side of a pipe\u0026lt;/a\u0026gt;, and the command is not a \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=7761\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;naked\u0026quot; batch script\u0026lt;/a\u0026gt; (script name without parentheses, CALL, command concatenation, or pipe).\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Each token for a command is parsed for delayed expansion independently.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Most commands parse two or more tokens - the command token, the arguments token, and each redirection destination token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The FOR command parses the IN clause token only.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IF command parses the comparison values only - either one or two, depending on the comparison operator.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For each parsed token, first check if it contains any \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;. If not, then the token is not parsed - important for \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; characters.\nIf the token does contain \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then scan each character from left to right:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If it is a caret (\u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;) the next character has no special meaning, the caret itself is removed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it is an exclamation mark, search for the next exclamation mark (carets are not observed anymore), expand to the value of the variable.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Consecutive opening \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; are collapsed into a single \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any remaining unpaired \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; is removed\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expanding vars at this stage is \u0026quot;safe\u0026quot;, because special characters are not detected anymore (even \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;For a more complete explanation, read the 2nd half of this from dbenham\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7970912/1012053\u0026quot;\u0026gt;same thread - Exclamation Point Phase\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.3) Pipe processing:\u0026lt;/strong\u0026gt; Only if commands are on either side of a pipe\u0026lt;br\u0026gt;\nEach side of the pipe is processed independently and asynchronously.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If command is internal to cmd.exe, or it is a batch file, or if it is a parenthesized command block, then it is executed in a new cmd.exe thread via \u0026lt;code\u0026gt;%comspec% /S /D /c\u0026quot; commandBlock\u0026quot;\u0026lt;/code\u0026gt;, so the command block gets a phase restart, but this time in command line mode.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If a parenthesized command block, then all \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; with a command before and after are converted to \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026amp;amp;\u0026lt;/code\u0026gt;. Other \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; are stripped.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This is the end of processing for the pipe commands.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8192318/1012053\u0026quot;\u0026gt;Why does delayed expansion fail when inside a piped block of code?\u0026lt;/a\u0026gt; for more about pipe parsing and processing\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.5) Execute Redirection:\u0026lt;/strong\u0026gt; Any redirection that was discovered in phase 2 is now executed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The results of phases 4 and 5 can impact the redirection that was discovered in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the redirection fails, then the remainder of the command is aborted. \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/10354016/1012053\u0026quot;\u0026gt;Note that failed redirection does not set ERRORLEVEL to 1 unless \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; is used\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 6) CALL processing/Caret doubling:\u0026lt;/strong\u0026gt; Only if the command token is CALL, or if the text before the first occurring standard token delimiter is CALL. If CALL is parsed from a larger command token, then the unused portion is prepended to the arguments token before proceeding.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Scan the arguments token for an unquoted \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt;. If found anywhere within the tokens, then abort phase 6 and proceed to Phase 7, where the HELP for CALL will be printed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Remove the first \u0026lt;code\u0026gt;CALL\u0026lt;/code\u0026gt;, so multiple CALL\u0026apos;s can be stacked\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Double all carets\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Restart phases 1, 1.5, and 2, but do not continue to phase 3\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Any doubled carets are reduced back to one caret as long as they are not quoted. But unfortunately, quoted carets remain doubled.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Phase 1 changes a bit\n- Expansion errors in step 1.2 or 1.3 abort the CALL, but the error is not fatal - batch processing continues.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Phase 2 tasks are altered a bit\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Any newly appearing unquoted, unescaped redirection that was not detected in the first round of phase 2 is detected, but it is removed (including the file name) without actually performing the redirection\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any newly appearing unquoted, unescaped caret at the end of the line is removed without performing line continuation\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The CALL is aborted without error if any of the following are detected\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Newly appearing unquoted, unescaped \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The resultant command token begins with unquoted, unescaped \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The very first token after the removed CALL began with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command is a seemingly valid IF or FOR, then execution will subsequently fail with an error stating that \u0026lt;code\u0026gt;IF\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;FOR\u0026lt;/code\u0026gt; is not recognized as an internal or external command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Of course the CALL is not aborted in this 2nd round of phase 2 if the resultant command token is a label beginning with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command token is CALL, then restart Phase 6 (repeats until no more CALL)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command token is a batch script or a :label, then execution of the CALL is fully handled by the remainder of Phase 6.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Push the current batch script file position on the call stack so that execution can resume from the correct position when the CALL is completed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Setup the %0, %1, %2, ...%N and %* argument tokens for the CALL, using all resultant tokens\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the command token is a label that begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Restart Phase 5. This can impact what :label is CALLed. But since the %0 etc. tokens have already been setup, it will not alter the arguments that are passed to the CALLed routine.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Execute GOTO label to position the file pointer at the beginning of the subroutine (ignore any other tokens that may follow the :label) See Phase 7 for rules on how GOTO works.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the :label token is missing, or the :label is not found, then the call stack is immediately popped to restore the saved file position, and the CALL is aborted.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the :label happens to contain /?, then GOTO help is printed instead of searching for the :label. The file pointer does not move, such that code after the CALL is executed twice, once in the CALL context, and then again after the CALL return. See \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/31987023/1012053\u0026quot;\u0026gt;Why CALL prints the GOTO help message in this script?And why command after that are executed twice?\u0026lt;/a\u0026gt; for more info.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else transfer control to the specified batch script.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Execution of the CALLed :label or script continues until either EXIT /B or end-of-file is reached, at which point the CALL stack is popped and execution resumes from the saved file position.\u0026lt;br\u0026gt;\nPhase 7 is not executed for CALLed scripts or :labels.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else the result of phase 6 falls through into phase 7 for execution.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute:\u0026lt;/strong\u0026gt; The command is executed\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.1 - Execute internal command\u0026lt;/strong\u0026gt; - If the command token is quoted, then skip this step. Otherwise, attempt to parse out an internal command and execute.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The following tests are made to determine if an unquoted command token represents an internal command:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the command token exactly matches an internal command, then execute it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else break the command token before the first occurrence of \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is an internal command, then remember that command\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode, or if the command is from a parenthesized block, IF true or false command block, FOR DO command block, or involved with command concatenation, then execute the internal command\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else (must be a stand-alone command in batch mode) scan the current folder and the PATH for a .COM, .EXE, .BAT, or .CMD file whose base name matches the original command token\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the first matching file is a .BAT or .CMD, then goto 7.3.exec and execute that script\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else (match not found or first match is .EXE or .COM) execute the remembered internal command\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else break the command token before the first occurrence of \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is not an internal command, then goto 7.2\u0026lt;br\u0026gt;\nElse the preceding text may be an internal command. Remember this command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Break the command token before the first occurrence of \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is a path to an existing file, then goto 7.2\u0026lt;br\u0026gt;\nElse execute the remembered internal command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an internal command is parsed from a larger command token, then the unused portion of the command token is included in the argument list\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Just because a command token is parsed as an internal command does not mean that it will execute successfully. Each internal command has its own rules as to how the arguments and options are parsed, and what syntax is allowed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All internal commands will print help instead of performing their function if \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt; is detected. Most recognize \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt; if it appears anywhere in the arguments. But a few commands like ECHO and SET only print help if the first argument token begins with \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;SET has some interesting semantics:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If a SET command has a quote before the variable name and extensions are enabled\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;set \u0026quot;name=content\u0026quot; ignored\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;--\u0026amp;gt;\u0026lt;/strong\u0026gt; value=\u0026lt;code\u0026gt;content\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nthen the text between the first equal sign and the last quote is used as the content (first equal and last quote excluded). Text after the last quote is ignored. If there is no quote after the equal sign, then the rest of the line is used as content.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a SET command does not have a quote before the name\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;set name=\u0026quot;content\u0026quot; not ignored\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;--\u0026amp;gt;\u0026lt;/strong\u0026gt; value=\u0026lt;code\u0026gt;\u0026quot;content\u0026quot; not ignored\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nthen the entire remainder of the line after the equal is used as content, including any and all quotes that may be present.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An IF comparison is evaluated, and depending on whether the condition is true or false, the appropriate already parsed dependent command block is processed, starting with phase 5.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IN clause of a FOR command is iterated appropriately.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If this is a FOR /F that iterates the output of a command block, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The IN clause is executed in a new cmd.exe process via CMD /C.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command block must go through the entire parsing process a second time, but this time in a command line context\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ECHO will start out ON, and delayed expansion will usually start out disabled (dependent on the registry setting)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All environment changes made by the IN clause command block will be lost once the child cmd.exe process terminates\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For each iteration:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The FOR variable values are defined\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The already parsed DO command block is then processed, starting with phase 4.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;GOTO uses the following logic to locate the :label\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Parse the label from the first argument token\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Scan for the next occurrence of the label\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Start from the current file position\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If end of file is reached, then loop back to the beginning of file and continue to the original starting point.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The scan stops at the first occurrence of the label that it finds, and the file pointer is set to the line immediately following the label. Execution of the script resumes from that point. Note that a successful true GOTO will immediately abort any parsed block of code, including FOR loops.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the label is not found, or the label token is missing, then the GOTO fails, an error message is printed, and the call stack is popped. This effectively functions as an EXIT /B, except any already parsed commands in the current command block that follow the GOTO are still executed, but in the context of the CALLer (the context that exists after EXIT /B)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=3803\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?t=3803\u0026lt;/a\u0026gt; for a more precise description of label parsing rules, and \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=8988\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?t=8988\u0026lt;/a\u0026gt; for label scanning rules.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;RENAME and COPY both accept wildcards for the source and target paths. But Microsoft does a terrible job documenting how the wildcards work, especially for the target path. A useful set of wildcard rules may be found at \u0026lt;a href=\u0026quot;https://superuser.com/q/475874/109090\u0026quot;\u0026gt;How does the Windows RENAME command interpret wildcards?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.2 - Execute volume change\u0026lt;/strong\u0026gt; - Else if the command token does not begin with a quote, is exactly two characters long, and the 2nd character is a colon, then change the volume\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All argument tokens are ignored\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the volume specified by the first character cannot be found, then abort with an error\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A command token of \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt; will always result in an error unless SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, then the volume will be changed, it will not be treated as a label.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.3 - Execute external command\u0026lt;/strong\u0026gt; - Else try to treat the command as an external command.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode and the command is not quoted and does not begin with a volume specification, white-space, \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; then break the command token at the first occurrence of \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; and prepend the remainder to the argument token(s).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the 2nd character of the command token is a colon, then verify the volume specified by the 1st character can be found.\u0026lt;br\u0026gt;\nIf the volume cannot be found, then abort with an error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If in batch mode and the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then goto 7.4\u0026lt;br\u0026gt;\nNote that if the label token begins with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, then this will not be reached because the preceding step will have aborted with an error unless SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Identify the external command to execute.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;This is a complex process that may involve the current volume, current directory, PATH variable, PATHEXT variable, and or file associations.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a valid external command cannot be identified, then abort with an error.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode and the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then goto 7.4\u0026lt;br\u0026gt;\nNote that this is rarely reached because the preceding step will have aborted with an error unless the command token begins with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and the entire command token is a valid path to an external command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.3.exec\u0026lt;/strong\u0026gt; - Execute the external command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.4 - Ignore a label\u0026lt;/strong\u0026gt; - Ignore the command and all its arguments if the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nRules in 7.2 and 7.3 may prevent a label from reaching this point.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Command Line Parser:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Works like the BatchLine-Parser, except:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;No \u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt; etc. argument expansion\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If var is undefined, then \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt; is left unchanged.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;No special handling of \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt;. If var=content, then \u0026lt;code\u0026gt;%%var%%\u0026lt;/code\u0026gt; expands to \u0026lt;code\u0026gt;%content%\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;This is not performed after phase 2. It is only performed after phase 4 for the FOR DO command block.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; only if DelayedExpansion is enabled\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If var is undefined, then \u0026lt;code\u0026gt;!var!\u0026lt;/code\u0026gt; is left unchanged.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute Command\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Attempts to CALL or GOTO a :label result in an error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;As already documented in phase 7, an executed label may result in an error under different scenarios.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Batch executed labels can only cause an error if they begin with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Command line executed labels almost always result in an error\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Parsing of integer values\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;There are many different contexts where cmd.exe parses integer values from strings, and the rules are inconsistent:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;SET /A\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;IF\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;%var:~n,m%\u0026lt;/code\u0026gt; (variable substring expansion)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /F \u0026quot;TOKENS=n\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /F \u0026quot;SKIP=n\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /L %%A in (n1 n2 n3)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;EXIT [/B] n\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Details for these rules may be found at \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=3758\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Rules for how CMD.EXE parses numbers\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;For anyone wishing to improve the cmd.exe parsing rules, there is a \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=8355\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;discussion topic on the DosTips forum\u0026lt;/a\u0026gt; where issues can be reported and suggestions made.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Hope it helps\u0026lt;br\u0026gt;\nJan Erik (jeb) - Original author and discoverer of phases\u0026lt;br\u0026gt;\nDave Benham (dbenham) - Much additional content and editing\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When invoking a command from a command window, tokenization of the command line arguments is not done by \u0026lt;code\u0026gt;cmd.exe\u0026lt;/code\u0026gt; (a.k.a. \u0026quot;the shell\u0026quot;).  Most often the tokenization is done by the newly formed processes\u0026apos; C/C++ runtime, but this is not necessarily so -- for example, if the new process was not written in C/C++, or if the new process chooses to ignore \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt; and process the raw commandline for itself (e.g. with \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GetCommandLine()\u0026lt;/a\u0026gt;).  At the OS level, Windows passes command lines untokenized as a single string to new processes.  This is in contrast to most *nix shells, where the shell tokenizes arguments in a consistent, predictable way before passing them to the newly formed process.  All this means that you may experience wildly divergent argument tokenization behavior across different programs on Windows, as individual programs often take argument tokenization into their own hands.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If it sounds like anarchy, it kind of is.  However, since a large number of Windows programs \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; utilize the Microsoft C/C++ runtime\u0026apos;s \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt;, it may be generally useful to understand \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/a1y7w461.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;how the MSVCRT tokenizes\u0026lt;/a\u0026gt; arguments.  Here is an excerpt:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Arguments are delimited by white space, which is either a space or a tab.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A string surrounded by double quotation marks is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument. Note that the caret (^) is not recognized as an escape character or delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A double quotation mark preceded by a backslash, \\\u0026quot;, is interpreted as a literal double quotation mark (\u0026quot;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Backslashes are interpreted literally, unless they immediately precede a double quotation mark.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an even number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\), and the double quotation mark (\u0026quot;) is interpreted as a string delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an odd number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\) and the double quotation mark is interpreted as an escape sequence by the remaining backslash, causing a literal double quotation mark (\u0026quot;) to be placed in argv.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The Microsoft \u0026quot;batch language\u0026quot; (\u0026lt;code\u0026gt;.bat\u0026lt;/code\u0026gt;) is no exception to this anarchic environment, and it has developed its own unique rules for tokenization and escaping. It also looks like cmd.exe\u0026apos;s command prompt does do some preprocessing of the command line argument (mostly for variable substitution and escaping) before passing the argument off to the newly executing process.  You can read more about the low-level details of the batch language and cmd escaping in the excellent answers by jeb and dbenham on this page.  \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s build a simple command line utility in C and see what it says about your test cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[])\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; argc; i++) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;argv[%d][%s]\\n\u0026quot;\u0026lt;/span\u0026gt;, i, argv[i]);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Notes: argv[0] is always the name of the executable, and is omitted below for brevity.  Tested on Windows XP SP3. Compiled with Visual Studio 2005.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt; test.exe \u0026quot;a \u0026quot;\u0026quot;b\u0026quot;\u0026quot; c\u0026quot;\nargv[1][a \u0026quot;b\u0026quot; c]\n\n\u0026amp;gt; test.exe \u0026quot;\u0026quot;\u0026quot;a b c\u0026quot;\u0026quot;\u0026quot;\nargv[1][\u0026quot;a b c\u0026quot;]\n\n\u0026amp;gt; test.exe \u0026quot;a\u0026quot;\u0026quot; b c\nargv[1][a\u0026quot; b c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And a few of my own tests:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt; test.exe a \u0026quot;b\u0026quot; c\nargv[1][a]\nargv[2][b]\nargv[3][c]\n\n\u0026amp;gt; test.exe a \u0026quot;b c\u0026quot; \u0026quot;d e\nargv[1][a]\nargv[2][b c]\nargv[3][d e]\n\n\u0026amp;gt; test.exe a \\\u0026quot;b\\\u0026quot; c\nargv[1][a]\nargv[2][\u0026quot;b\u0026quot;]\nargv[3][c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Percent Expansion Rules\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Here is an expanded explanation of Phase 1 in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133/1012053\u0026quot;\u0026gt;jeb\u0026apos;s answer\u0026lt;/a\u0026gt; (valid for both batch mode and command line mode).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion\u0026lt;/strong\u0026gt;\nStarting from left, scan each character for \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;. If found then\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.05 (truncate line at \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the character is \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Drop (ignore) the remainder of the line from the \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; onward\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Goto Phase 2.0\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else the character must be \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, so proceed to 1.1\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.1 (escape \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;)\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;skipped if command line mode\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If batch mode and followed by another \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; with single \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.2 (expand argument)\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;skipped if command line mode\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If followed by \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; and command extensions are enabled then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt; with the text of all command line arguments (Replace with nothing if there are no arguments) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; with argument value (replace with nothing if undefined) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; and command extensions are enabled then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If followed by optional valid list of argument modifiers followed by required \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%~[modifiers]\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; with modified argument value (replace with nothing if not defined or if specified $PATH: modifier is not defined) and continue scan.\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Note: modifiers are case insensitive and can appear multiple times in any order, except $PATH: modifier can only appear once and must be the last modifier before the \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else invalid modified argument syntax raises \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.3 (expand variable)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are disabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; or end of buffer, and call them VAR (may be an empty list)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are enabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; or end of buffer, and call them VAR (may be an empty list). If VAR breaks before \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; and the subsequent character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then include \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; as the last character in VAR and break before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is undefined then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR:\u0026lt;/code\u0026gt; and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next string of characters matches pattern of \u0026lt;code\u0026gt;[integer][,[integer]]%\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR:~[integer][,[integer]]%\u0026lt;/code\u0026gt; with substring of value of VAR (possibly resulting in empty string) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*=\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nInvalid variable search and replace syntax raises \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next string of characters matches pattern of \u0026lt;code\u0026gt;[*]search=[replace]%\u0026lt;/code\u0026gt;, where search may include any set of characters except \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;, and replace may include any set of characters except \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR:[*]search=[replace]%\u0026lt;/code\u0026gt; with value of VAR after performing search and replace (possibly resulting in empty string) and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.4 (strip %)\u0026lt;/strong\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Else If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan starting with the next character after the \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else preserve the leading \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan starting with the next character after the preserved leading \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The above helps explain why this batch\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal enableDelayedExpansion\nset \u0026quot;1var=varA\u0026quot;\nset \u0026quot;~f1var=varB\u0026quot;\ncall :test \u0026quot;arg1\u0026quot;\nexit /b  \n::\n:test \u0026quot;arg1\u0026quot;\necho %%1var%% = %1var%\necho ^^^!1var^^^! = !1var!\necho --------\necho %%~f1var%% = %~f1var%\necho ^^^!~f1var^^^! = !~f1var!\nexit /b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Gives these results:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;%1var% = \u0026quot;arg1\u0026quot;var\n!1var! = varA\n--------\n%~f1var% = P:\\arg1var\n!~f1var! = varB\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 1\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - Phase 1 occurs prior to the recognition of REM statements. This is very important because it means even a remark can generate a fatal error if it has invalid argument expansion syntax or invalid variable search and replace syntax!\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nrem %~x This generates a fatal argument expansion error\necho this line is never reached\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 2\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - Another interesting consequence of the % parsing rules: Variables containing : in the name can be defined, but they cannot be expanded unless command extensions are disabled. There is one exception - a variable name containing a single colon at the end can be expanded while command extensions are enabled. However, you cannot perform substring or search and replace operations on variable names ending with a colon. The batch file below (courtesy of jeb) demonstrates this behavior\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal\nset var=content\nset var:=Special\nset var::=double colon\nset var:~0,2=tricky\nset var::~0,2=unfortunate\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\necho Now with DisableExtensions\nsetlocal DisableExtensions\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 3\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - An interesting outcome of the order of the parsing rules that jeb lays out in his post: When performing find and replace with delayed expansion, special characters in both the find and replace terms must be escaped or quoted. But the situation is different for percent expansion - the find term must not be escaped (though it can be quoted). The percent replace string may or may not require escape or quote, depending on your intent.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal enableDelayedExpansion\nset \u0026quot;var=this \u0026amp;amp; that\u0026quot;\necho %var:\u0026amp;amp;=and%\necho \u0026quot;%var:\u0026amp;amp;=and%\u0026quot;\necho !var:^\u0026amp;amp;=and!\necho \u0026quot;!var:\u0026amp;amp;=and!\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;#Delayed Expansion Rules\nHere is an expanded, and more accurate explanation of Phase 5 in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133/1012053\u0026quot;\u0026gt;jeb\u0026apos;s answer\u0026lt;/a\u0026gt; (Valid for both batch mode and command line mode)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This phase is skipped if any of the following conditions apply:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Delayed expansion is disabled.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command is within a parenthesized block on either side of a pipe.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The incoming command token is a \u0026quot;naked\u0026quot; batch script, meaning it is not associated with \u0026lt;code\u0026gt;CALL\u0026lt;/code\u0026gt;, parenthesized block, any form of command concatenation (\u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt;), or a pipe \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The delayed expansion process is applied to tokens independently. A command may have multiple tokens:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The command token. For most commands the command name itself is a token. But a few commands have specialized regions that are considered a TOKEN for Phase 5.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;for ... in(TOKEN) do\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if defined TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if exists TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if errorlevel TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if cmdextversion TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if TOKEN comparison TOKEN\u0026lt;/code\u0026gt;, where comparison is one of \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;equ\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;neq\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;lss\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;leq\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gtr\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;geq\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The arguments token\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The destination token of redirection (one per redirection)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;No change is made to tokens that do not contain \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For each token that does contain at least one \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, scan each character from left to right for \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, and if found, then\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;5.1 (caret escape)\u0026lt;/strong\u0026gt; Needed for \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; literals\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If character is a caret \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Remove the \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Scan the next character and preserve it as a literal\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Continue the scan\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;5.2 (expand variable)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If command extensions are disabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, and call them VAR (may be an empty list)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are enabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, and call them VAR (may be an empty list). If VAR breaks before \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; and the subsequent character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then include \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; as the last character in VAR and break before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR exists, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is undefined then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR:\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next string of characters matches pattern of \u0026lt;code\u0026gt;[integer][,[integer]]!\u0026lt;/code\u0026gt; then Replace \u0026lt;code\u0026gt;!VAR:~[integer][,[integer]]!\u0026lt;/code\u0026gt; with substring of value of VAR (possibly resulting in empty string) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next string of characters matches pattern of \u0026lt;code\u0026gt;[*]search=[replace]!\u0026lt;/code\u0026gt;, where search may include any set of characters except \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;, and replace may include any set of characters except \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR:[*]search=[replace]!\u0026lt;/code\u0026gt; with value of VAR after performing search and replace (possibly resulting in an empty string) and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;5.2.1\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then remove the leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nElse preserve the leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Continue the scan starting with the next character after the preserved leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As pointed out, commands are passed the entire argument string in μSoft land, and it is up to them to parse this into separate arguments for their own use. There is no consistencty in this between different programs, and therefore there is no one set of rules to describe this process. You really need to check each corner case for whatever C library your program uses.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as the system \u0026lt;code\u0026gt;.bat\u0026lt;/code\u0026gt; files go, here is that test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;c\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt; args.cmd\n@\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; off\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; cmdcmdline:[%cmdcmdline%]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; 0:[%0]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; *:[%*]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt; allargs=%*\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; not defined allargs goto :eof\nsetlocal\n@rem Wot about a \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nice\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; loop?\n@rem Then we are \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; the land of delayedexpansion, !n!, call, etc.\n@rem Plays havoc with args like %t%, a\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b etc. ugh!\nset n=1\n:loop\n    echo %n%:[%1]\n    set /a n+=1\n    shift\n    set param=%1\n    if defined param goto :loop\nendlocal\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now we can run some tests. See if you can figure out just what μSoft are trying to do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args a b c\ncmdcmdline:[cmd.exe ]\n0:[args]\n*:[a b c]\n1:[a]\n2:[b]\n3:[c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Fine so far. (I\u0026apos;ll leave out the uninteresting \u0026lt;code\u0026gt;%cmdcmdline%\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;%0\u0026lt;/code\u0026gt; from now on.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args *.*\n*:[*.*]\n1:[*.*]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No filename expansion.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args \u0026quot;a b\u0026quot; c\n*:[\u0026quot;a b\u0026quot; c]\n1:[\u0026quot;a b\u0026quot;]\n2:[c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No quote stripping, though quotes do prevent argument splitting.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c\u0026amp;gt;args \u0026quot;\u0026quot;a b\u0026quot; c\n*:[\u0026quot;\u0026quot;a b\u0026quot; c]\n1:[\u0026quot;\u0026quot;a]\n2:[b\u0026quot; c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Consecutive double quotes causes them to lose any special parsing abilities they may have had. @Beniot\u0026apos;s example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args \u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;\n*:[\u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;]\n1:[\u0026quot;a \u0026quot;\u0026quot;\u0026quot;]\n2:[b]\n3:[\u0026quot;\u0026quot;]\n4:[c\u0026quot;\u0026quot;\u0026quot;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Quiz: How do you pass the value of any environment var as a \u0026lt;em\u0026gt;single\u0026lt;/em\u0026gt; argument (i.e., as \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt;) to a bat file?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c\u0026amp;gt;set t=a \u0026quot;b c\nc\u0026amp;gt;set t\nt=a \u0026quot;b c\nc\u0026amp;gt;args %t%\n1:[a]\n2:[\u0026quot;b c]\nc\u0026amp;gt;args \u0026quot;%t%\u0026quot;\n1:[\u0026quot;a \u0026quot;b]\n2:[c\u0026quot;]\nc\u0026amp;gt;Aaaaaargh!\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sane parsing seems forever broken.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For your entertainment, try adding miscellaneous \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; (\u0026amp;amp;c.) characters to these examples.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You have some great answers above already, but to answer one part of your question:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;set a =b, echo %a %b% c%  bb c%\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What is happening there is that because you have a space before the =, a variable is created called \u0026lt;code\u0026gt;%a\u0026amp;lt;space\u0026amp;gt;%\u0026lt;/code\u0026gt;\nso when you \u0026lt;code\u0026gt;echo %a %\u0026lt;/code\u0026gt; that is evaluated correctly as \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The remaining part \u0026lt;code\u0026gt;b% c%\u0026lt;/code\u0026gt; is then evaluated as plain text + an undefined variable \u0026lt;code\u0026gt;% c%\u0026lt;/code\u0026gt;, which should be echoed as typed, for me \u0026lt;code\u0026gt;echo %a %b% c%\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;bb% c%\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I suspect that the ability to include spaces in variable names is more of an oversight than a planned \u0026apos;feature\u0026apos;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;\u0026lt;code\u0026gt;FOR\u0026lt;/code\u0026gt;-Loop Meta-Variable Expansion\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;This is an extended explanation of \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Phase 4)\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; in the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133\u0026quot;\u0026gt;accepted answer\u0026lt;/a\u0026gt; (applicable for both batch file mode and command line mode). Of course a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; command must be active. The following describes the processing of the command line portion after the \u0026lt;code\u0026gt;do\u0026lt;/code\u0026gt; clause. Note that in batch file mode, \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; has already been converted to \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; due to the foregoing immediate \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;-expansion phase (\u0026lt;em\u0026gt;Phase 1)\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;scan for \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;-sign, beginning from the left up to the end of the line; if one is found, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if \u0026lt;a href=\u0026quot;https://ss64.com/nt/cmd.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;CMD.exe\u0026quot;\u0026gt;Command Extensions\u0026lt;/a\u0026gt; are enabled (default), check if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt;; if yes, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;take as many as possible of the following characters in the case-insensitive set \u0026lt;code\u0026gt;fdpnxsatz\u0026lt;/code\u0026gt; (even multiple times each) that are preceding a character that defines a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference or a \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign; if such a \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign is encountered, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;scan for a \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;; if found, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if there is a character following the \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, use it as a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference and expand as expected, unless it is not defined, then do not expand and continue scan at that character position;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is the last character, \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;cmd.exe\u0026lt;/code\u0026gt; will crash!\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (no \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is found) do not expand anything;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (if no \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign is encountered) expand the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable using all the modifiers, unless it is not defined, then do not expand and continue scan at that character position;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (if no \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; is found or Command Extensions are disabled) check the next character:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if there is no more character available, do not expand anything;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, do not expand anything and go back to the beginning of the scan at this character position\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else use the next character as a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference and expand, unless such is not defined, then do not expand;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;go back to the beginning of the scan at the next character position (as long as there still characters available);\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;1)  The string between \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is considered as the name of an environment variable, which may even be empty; since an environment variable cannot have an empty name, the behaviour is just the same as for an undefined environment variable.\u0026lt;/sub\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;sub\u0026gt;2)  This implies that a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; meta-variable named \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; cannot be expanded without a \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt;-modifier.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;Original source: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/56240800\u0026quot; title=\u0026quot;How to safely echo FOR variable %%~p followed by a string literal\u0026quot;\u0026gt;How to safely echo FOR variable %%~p followed by a string literal\u0026lt;/a\u0026gt;\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;edit: see accepted answer, what follows is wrong and explains only how to pass a command line to TinyPerl.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Regarding quotes, I have the feeling that the behaviour is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;when a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is found, string globbing begins\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when string globbing occurs:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;every character that is not a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is globbed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is found:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if it is followed by \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; (thus a triple \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;) then a double quote is added to the string\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if it is followed by \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; (thus a double \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;) then a double quote is added to the string and string globbing ends\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the next character is not \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;, string globbing ends\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when line ends, string globbing ends.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;In short:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; consists of two strings: \u0026lt;code\u0026gt;a \u0026quot; b \u0026quot;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;c\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; and\u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; are all the same string if at the end of a line\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Note that Microsoft has published its Terminal\u0026apos;s source code. It may work similar to the command line with respect to syntax parsing. Maybe someone is interested in testing the reverse-engineered parsing rules on accordance with the terminal\u0026apos;s parsing rules.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/Microsoft/Terminal\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Link\u0026lt;/a\u0026gt; to the source code.\u0026lt;/p\u0026gt;\n    "],"id":356,"title":"How does the Windows Command Interpreter (CMD.EXE) parse scripts?","content":"\n                \n\u0026lt;p\u0026gt;I ran into \u0026lt;a href=\u0026quot;https://ss64.com\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;ss64.com\u0026lt;/a\u0026gt; which provides good help regarding how to write batch scripts that the Windows Command Interpreter will run.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, I have been unable to find a good explanation of the \u0026lt;strong\u0026gt;grammar\u0026lt;/strong\u0026gt; of batch scripts, how things expand or do not expand, and how to escape things.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here are sample questions that I have not been able to solve:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;How is the quote system managed? I made a \u0026lt;a href=\u0026quot;http://tinyperl.sourceforge.net/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;TinyPerl\u0026lt;/a\u0026gt; script\u0026lt;br\u0026gt;\n( \u0026lt;code\u0026gt;foreach $i (@ARGV) { print \u0026apos;*\u0026apos; . $i ; }\u0026lt;/code\u0026gt; ), compiled it and called it this way :\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;my_script.exe \u0026quot;a \u0026quot;\u0026quot;b\u0026quot;\u0026quot; c\u0026quot;\u0026lt;/code\u0026gt; → output is  \u0026lt;code\u0026gt;*a \u0026quot;b*c\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;my_script.exe \u0026quot;\u0026quot;\u0026quot;a b c\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; → output it \u0026lt;code\u0026gt;*\u0026quot;a*b*c\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;How does the internal \u0026lt;code\u0026gt;echo\u0026lt;/code\u0026gt; command work? What is expanded inside that command?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Why do I have to use \u0026lt;code\u0026gt;for [...] %%I\u0026lt;/code\u0026gt; in file scripts, but \u0026lt;code\u0026gt;for [...] %I\u0026lt;/code\u0026gt; in interactive sessions?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What are the escape characters, and in what context? How to escape a percent sign? For example, how can I echo \u0026lt;code\u0026gt;%PROCESSOR_ARCHITECTURE%\u0026lt;/code\u0026gt; literally? I found that \u0026lt;code\u0026gt;echo.exe %\u0026quot;\u0026quot;PROCESSOR_ARCHITECTURE%\u0026lt;/code\u0026gt; works, is there a better solution?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;How do pairs of \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; match? Example:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;set b=a\u0026lt;/code\u0026gt; , \u0026lt;code\u0026gt;echo %a %b% c%\u0026lt;/code\u0026gt; → \u0026lt;code\u0026gt;%a a c%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;set a =b\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;echo %a %b% c%\u0026lt;/code\u0026gt; → \u0026lt;code\u0026gt;bb% c%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;How do I ensure a variable passes to a command as a single argument if ever this variable contains double quotes?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;How are variables stored when using the \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt; command? For example, if I do \u0026lt;code\u0026gt;set a=a\u0026quot; b\u0026lt;/code\u0026gt; and then \u0026lt;code\u0026gt;echo.%a%\u0026lt;/code\u0026gt; I obtain \u0026lt;code\u0026gt;a\u0026quot; b\u0026lt;/code\u0026gt;. If I however use \u0026lt;code\u0026gt;echo.exe\u0026lt;/code\u0026gt; from the UnxUtils, I get \u0026lt;code\u0026gt;a b\u0026lt;/code\u0026gt;. How comes \u0026lt;code\u0026gt;%a%\u0026lt;/code\u0026gt; expands in a different way?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Thank you for your lights.\u0026lt;/p\u0026gt;\n    ","slug":"how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560","postType":"QUESTION","createdAt":"2022-07-09T17:28:51.000Z","updatedAt":"2022-07-09T17:28:51.000Z","tags":[{"id":1993,"name":"variable-expansion","slug":"variable-expansion","createdAt":"2022-07-09T17:28:51.000Z","updatedAt":"2022-07-09T17:28:51.000Z","Questions_Tags":{"questionId":356,"tagId":1993}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>