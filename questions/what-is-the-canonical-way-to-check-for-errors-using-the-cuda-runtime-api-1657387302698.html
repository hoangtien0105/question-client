<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_buildManifest.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698">What is the canonical way to check for errors using the CUDA runtime API?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/cuda">cuda</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/error-checking">error-checking</a></div></div><div class="question-content mt-5">
                
<p>Looking through the answers and comments on CUDA questions, and in the <a href="https://stackoverflow.com/tags/cuda/info">CUDA tag wiki</a>, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like <code>cudaGetLastError</code>, <code>cudaPeekAtLastError</code>, and <code>cudaGetErrorString</code>, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">gpuErrchk</span>(ans) { <span class="hljs-built_in">gpuAssert</span>((ans), __FILE__, __LINE__); }
inline void <span class="hljs-built_in">gpuAssert</span>(cudaError_t code, const char *file, int line, bool abort=true)
{
   if (code != cudaSuccess) 
   {
      <span class="hljs-built_in">fprintf</span>(stderr,"GPUassert: %s %s %d\n", cudaGetErrorString(code), file, line);
      if (abort) <span class="hljs-built_in">exit</span>(code);
   }
}
</code></pre>

<p>You can then wrap each API call with the <code>gpuErrchk</code> macro, which will process the return status of the API call it wraps, for example:</p>

<pre class="default s-code-block"><code class="hljs language-lisp">gpuErrchk( <span class="hljs-name">cudaMalloc</span>(<span class="hljs-name">&amp;a_d</span>, size*sizeof(<span class="hljs-name">int</span>)) )<span class="hljs-comment">;</span>
</code></pre>

<p>If there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to <code>stderr</code> and the application will exit. You could conceivably modify <code>gpuAssert</code> to raise an exception rather than call <code>exit()</code> in a more sophisticated application if it were required.</p>

<p>A second related question is how to check for errors in kernel launches, which can't be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss">kernel&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(a);
<span class="hljs-built_in">gpuErrchk</span>( cudaPeekAtLastError() );
<span class="hljs-built_in">gpuErrchk</span>( cudaDeviceSynchronize() );
</code></pre>

<p>will firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:</p>

<pre class="default s-code-block"><code class="hljs language-scss">kernel&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(a_d);
<span class="hljs-built_in">gpuErrchk</span>( cudaPeekAtLastError() );
<span class="hljs-built_in">gpuErrchk</span>( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );
</code></pre>

<p>in which case the <code>cudaMemcpy</code> call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. </p>

<p>Note that when using <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism" rel="noreferrer">CUDA Dynamic Parallelism</a>, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }</span>
<span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">cdpAssert</span><span class="hljs-params">(cudaError_t code, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line, <span class="hljs-type">bool</span> abort=<span class="hljs-literal">true</span>)</span>
</span>{
   <span class="hljs-keyword">if</span> (code != cudaSuccess)
   {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"GPU kernel assert: %s %s %d\n"</span>, <span class="hljs-built_in">cudaGetErrorString</span>(code), file, line);
      <span class="hljs-keyword">if</span> (abort) <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);
   }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>talonmies' answer above is a fine way to abort an application in an <code>assert</code>-style manner.</p>

<p>Occasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.</p>

<p>Here's a reasonably terse way to do that by throwing a C++ exception derived from <code>std::runtime_error</code> using <code>thrust::system_error</code>:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrust/system_error.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrust/system/cuda/error.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">throw_on_cuda_error</span><span class="hljs-params">(cudaError_t code, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line)</span>
</span>{
  <span class="hljs-keyword">if</span>(code != cudaSuccess)
  {
    std::stringstream ss;
    ss &lt;&lt; file &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">")"</span>;
    std::string file_and_line;
    ss &gt;&gt; file_and_line;
    <span class="hljs-keyword">throw</span> thrust::<span class="hljs-built_in">system_error</span>(code, thrust::<span class="hljs-built_in">cuda_category</span>(), file_and_line);
  }
}
</code></pre>

<p>This will incorporate the filename, line number, and an English language description of the <code>cudaError_t</code> into the thrown exception's <code>.what()</code> member:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-comment">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>()
{
  <span class="hljs-keyword">try</span>
  {
    <span class="hljs-comment">// do something crazy</span>
    <span class="hljs-title function_ invoke__">throw_on_cuda_error</span>(<span class="hljs-title function_ invoke__">cudaSetDevice</span>(-<span class="hljs-number">1</span>), <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);
  }
  <span class="hljs-keyword">catch</span>(thrust::<span class="hljs-variable constant_">system_error</span> &amp;e)
  {
    std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"CUDA error after cudaSetDevice: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;

    <span class="hljs-comment">// oops, recover</span>
    <span class="hljs-title function_ invoke__">cudaSetDevice</span>(<span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The output:</p>

<pre class="default s-code-block"><code class="hljs language-ocaml">$ nvcc <span class="hljs-keyword">exception</span>.cu -run
<span class="hljs-type">CUDA</span> error after cudaSetDevice: <span class="hljs-keyword">exception</span>.cu(<span class="hljs-number">23</span>): invalid device ordinal
</code></pre>

<p>A client of <code>some_function</code> can distinguish CUDA errors from other kinds of errors if desired:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">try</span>
{
  <span class="hljs-comment">// call some_function which may throw something</span>
  <span class="hljs-title function_ invoke__">some_function</span>();
}
<span class="hljs-keyword">catch</span>(thrust::<span class="hljs-variable constant_">system_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"CUDA error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">bad_alloc</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Bad memory allocation during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">runtime_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Runtime error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
<span class="hljs-keyword">catch</span>(...)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Some other kind of error during some_function"</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;

  <span class="hljs-comment">// no idea what to do, so just rethrow the exception</span>
  <span class="hljs-keyword">throw</span>;
}
</code></pre>

<p>Because <code>thrust::system_error</code> is a <code>std::runtime_error</code>, we can alternatively handle it in the same manner of a broad class of errors if we don't require the precision of the previous example:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">try</span>
{
  <span class="hljs-comment">// call some_function which may throw something</span>
  <span class="hljs-title function_ invoke__">some_function</span>();
}
<span class="hljs-keyword">catch</span>(std::<span class="hljs-variable constant_">runtime_error</span> &amp;e)
{
  std::<span class="hljs-variable constant_">cerr</span> &lt;&lt; <span class="hljs-string">"Runtime error during some_function: "</span> &lt;&lt; e.<span class="hljs-title function_ invoke__">what</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>The C++-canonical way: Don't check for errors...use the C++ bindings which throw exceptions.</h3>
<p>I used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared's answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.</p>
<p>So I've approached this in a different and more fundamental way. For a sample of the result, here's part of the CUDA <code>vectorAdd</code> sample - with <em>complete</em> error checking of every runtime API call:</p>
<pre class="default s-code-block"><code class="hljs language-rust"><span class="hljs-comment">// (... prepare host-side buffers here ...)</span>

auto current_device = cuda::device::current::<span class="hljs-title function_ invoke__">get</span>();
auto d_A = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);
auto d_B = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);
auto d_C = cuda::memory::device::make_unique&lt;float[]&gt;(current_device, numElements);

cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(d_A.<span class="hljs-title function_ invoke__">get</span>(), h_A.<span class="hljs-title function_ invoke__">get</span>(), size);
cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(d_B.<span class="hljs-title function_ invoke__">get</span>(), h_B.<span class="hljs-title function_ invoke__">get</span>(), size);

auto launch_config = cuda::<span class="hljs-title function_ invoke__">launch_config_builder</span>()
    .<span class="hljs-title function_ invoke__">overall_size</span>(numElements)
    .<span class="hljs-title function_ invoke__">block_size</span>(<span class="hljs-number">256</span>)
    .<span class="hljs-title function_ invoke__">build</span>();

cuda::<span class="hljs-title function_ invoke__">launch</span>(vectorAdd, launch_config,
    d_A.<span class="hljs-title function_ invoke__">get</span>(), d_B.<span class="hljs-title function_ invoke__">get</span>(), d_C.<span class="hljs-title function_ invoke__">get</span>(), numElements
);    
cuda::memory::<span class="hljs-title function_ invoke__">copy</span>(h_C.<span class="hljs-title function_ invoke__">get</span>(), d_C.<span class="hljs-title function_ invoke__">get</span>(), size);

<span class="hljs-comment">// (... verify results here...)</span>
</code></pre>
<p>Again - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error <em>after</em> launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a <code>cuda::outstanding_error::ensure_none()</code> command).</p>
<p>The code above uses my</p>
<p><a href="https://github.com/eyalroz/cuda-api-wrappers" rel="nofollow noreferrer"><strong>Thin Modern-C++ wrappers for the CUDA Runtime API library</strong></a> (Github)</p>
<p>Note that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.</p>
<p>A few links to how CUDA errors are automagically checked with these wrappers:</p>
<ul>
<li><a href="https://github.com/eyalroz/cuda-api-wrappers/blob/master/examples/by_runtime_api_module/error_handling.cu" rel="nofollow noreferrer">A test program throwing and catching a bunch of exceptions</a></li>
<li><a href="https://codedocs.xyz/eyalroz/cuda-api-wrappers/error_8hpp.html" rel="nofollow noreferrer">Documentation for the error-related functionality</a></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The solution discussed <a href="https://code.google.com/p/stanford-cs193g-sp2010/wiki/TutorialWhenSomethingGoesWrong" rel="noreferrer">here</a> worked well for me. This solution uses built-in cuda functions and is very simple to implement.</p>

<p>The relevant code is copied below:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span>
</span>{
  *ptr = <span class="hljs-number">7</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
  foo&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// make the host block until the device is finished with foo</span>
  <span class="hljs-built_in">cudaDeviceSynchronize</span>();

  <span class="hljs-comment">// check for error</span>
  cudaError_t error = <span class="hljs-built_in">cudaGetLastError</span>();
  <span class="hljs-keyword">if</span>(error != cudaSuccess)
  {
    <span class="hljs-comment">// print the CUDA error message and exit</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"CUDA error: %s\n"</span>, <span class="hljs-built_in">cudaGetErrorString</span>(error));
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-id\u0026quot;\u0026gt;#define\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;(ans) { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuAssert\u0026lt;/span\u0026gt;((ans), __FILE__, __LINE__); }\ninline void \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuAssert\u0026lt;/span\u0026gt;(cudaError_t code, const char *file, int line, bool abort=true)\n{\n   if (code != cudaSuccess) \n   {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(stderr,\u0026quot;GPUassert: %s %s %d\\n\u0026quot;, cudaGetErrorString(code), file, line);\n      if (abort) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(code);\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can then wrap each API call with the \u0026lt;code\u0026gt;gpuErrchk\u0026lt;/code\u0026gt; macro, which will process the return status of the API call it wraps, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt;gpuErrchk( \u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cudaMalloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;\u0026amp;amp;a_d\u0026lt;/span\u0026gt;, size*sizeof(\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)) )\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to \u0026lt;code\u0026gt;stderr\u0026lt;/code\u0026gt; and the application will exit. You could conceivably modify \u0026lt;code\u0026gt;gpuAssert\u0026lt;/code\u0026gt; to raise an exception rather than call \u0026lt;code\u0026gt;exit()\u0026lt;/code\u0026gt; in a more sophisticated application if it were required.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A second related question is how to check for errors in kernel launches, which can\u0026apos;t be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;kernel\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(a);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaPeekAtLastError() );\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaDeviceSynchronize() );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;kernel\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(a_d);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaPeekAtLastError() );\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;gpuErrchk\u0026lt;/span\u0026gt;( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in which case the \u0026lt;code\u0026gt;cudaMemcpy\u0026lt;/code\u0026gt; call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that when using \u0026lt;a href=\u0026quot;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CUDA Dynamic Parallelism\u0026lt;/a\u0026gt;, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;__device__ \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cdpAssert\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cudaError_t code, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *file, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; line, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; abort=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (code != cudaSuccess)\n   {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;GPU kernel assert: %s %s %d\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetErrorString\u0026lt;/span\u0026gt;(code), file, line);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (abort) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;talonmies\u0026apos; answer above is a fine way to abort an application in an \u0026lt;code\u0026gt;assert\u0026lt;/code\u0026gt;-style manner.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Occasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a reasonably terse way to do that by throwing a C++ exception derived from \u0026lt;code\u0026gt;std::runtime_error\u0026lt;/code\u0026gt; using \u0026lt;code\u0026gt;thrust::system_error\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;thrust/system_error.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;thrust/system/cuda/error.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw_on_cuda_error\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cudaError_t code, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *file, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(code != cudaSuccess)\n  {\n    std::stringstream ss;\n    ss \u0026amp;lt;\u0026amp;lt; file \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; line \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\u0026quot;\u0026lt;/span\u0026gt;;\n    std::string file_and_line;\n    ss \u0026amp;gt;\u0026amp;gt; file_and_line;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; thrust::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt;(code, thrust::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cuda_category\u0026lt;/span\u0026gt;(), file_and_line);\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will incorporate the filename, line number, and an English language description of the \u0026lt;code\u0026gt;cudaError_t\u0026lt;/code\u0026gt; into the thrown exception\u0026apos;s \u0026lt;code\u0026gt;.what()\u0026lt;/code\u0026gt; member:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#include \u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do something crazy\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;throw_on_cuda_error\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cudaSetDevice\u0026lt;/span\u0026gt;(-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;__FILE__\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;__LINE__\u0026lt;/span\u0026gt;);\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(thrust::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n  {\n    std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error after cudaSetDevice: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oops, recover\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cudaSetDevice\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-ocaml\u0026quot;\u0026gt;$ nvcc \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exception\u0026lt;/span\u0026gt;.cu -run\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CUDA\u0026lt;/span\u0026gt; error after cudaSetDevice: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exception\u0026lt;/span\u0026gt;.cu(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;): invalid device ordinal\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A client of \u0026lt;code\u0026gt;some_function\u0026lt;/code\u0026gt; can distinguish CUDA errors from other kinds of errors if desired:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call some_function which may throw something\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(thrust::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;system_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;bad_alloc\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Bad memory allocation during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Runtime error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(...)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Some other kind of error during some_function\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no idea what to do, so just rethrow the exception\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;thrust::system_error\u0026lt;/code\u0026gt; is a \u0026lt;code\u0026gt;std::runtime_error\u0026lt;/code\u0026gt;, we can alternatively handle it in the same manner of a broad class of errors if we don\u0026apos;t require the precision of the previous example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call some_function which may throw something\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;some_function\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;runtime_error\u0026lt;/span\u0026gt; \u0026amp;amp;e)\n{\n  std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;cerr\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Runtime error during some_function: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; e.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;endl\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;The C++-canonical way: Don\u0026apos;t check for errors...use the C++ bindings which throw exceptions.\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;I used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared\u0026apos;s answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So I\u0026apos;ve approached this in a different and more fundamental way. For a sample of the result, here\u0026apos;s part of the CUDA \u0026lt;code\u0026gt;vectorAdd\u0026lt;/code\u0026gt; sample - with \u0026lt;em\u0026gt;complete\u0026lt;/em\u0026gt; error checking of every runtime API call:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (... prepare host-side buffers here ...)\u0026lt;/span\u0026gt;\n\nauto current_device = cuda::device::current::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\nauto d_A = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\nauto d_B = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\nauto d_C = cuda::memory::device::make_unique\u0026amp;lt;float[]\u0026amp;gt;(current_device, numElements);\n\ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(d_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), h_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(d_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), h_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\n\nauto launch_config = cuda::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;launch_config_builder\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;overall_size\u0026lt;/span\u0026gt;(numElements)\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;block_size\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;)\n    .\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;build\u0026lt;/span\u0026gt;();\n\ncuda::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;launch\u0026lt;/span\u0026gt;(vectorAdd, launch_config,\n    d_A.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_B.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), numElements\n);    \ncuda::memory::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(h_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), d_C.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(), size);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (... verify results here...)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a \u0026lt;code\u0026gt;cuda::outstanding_error::ensure_none()\u0026lt;/code\u0026gt; command).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code above uses my\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/eyalroz/cuda-api-wrappers\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Thin Modern-C++ wrappers for the CUDA Runtime API library\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; (Github)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A few links to how CUDA errors are automagically checked with these wrappers:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/eyalroz/cuda-api-wrappers/blob/master/examples/by_runtime_api_module/error_handling.cu\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;A test program throwing and catching a bunch of exceptions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://codedocs.xyz/eyalroz/cuda-api-wrappers/error_8hpp.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Documentation for the error-related functionality\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The solution discussed \u0026lt;a href=\u0026quot;https://code.google.com/p/stanford-cs193g-sp2010/wiki/TutorialWhenSomethingGoesWrong\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; worked well for me. This solution uses built-in cuda functions and is very simple to implement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The relevant code is copied below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;__global__ \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ptr)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  *ptr = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  foo\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make the host block until the device is finished with foo\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaDeviceSynchronize\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// check for error\u0026lt;/span\u0026gt;\n  cudaError_t error = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetLastError\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(error != cudaSuccess)\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// print the CUDA error message and exit\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CUDA error: %s\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cudaGetErrorString\u0026lt;/span\u0026gt;(error));\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":217,"title":"What is the canonical way to check for errors using the CUDA runtime API?","content":"\n                \n\u0026lt;p\u0026gt;Looking through the answers and comments on CUDA questions, and in the \u0026lt;a href=\u0026quot;https://stackoverflow.com/tags/cuda/info\u0026quot;\u0026gt;CUDA tag wiki\u0026lt;/a\u0026gt;, I see it is often suggested that the return status of every API call should checked for errors. The API documentation contains functions like \u0026lt;code\u0026gt;cudaGetLastError\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;cudaPeekAtLastError\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;cudaGetErrorString\u0026lt;/code\u0026gt;, but what is the best way to put these together to reliably catch and report errors without requiring lots of extra code?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698","postType":"QUESTION","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","tags":[{"id":1496,"name":"cuda","slug":"cuda","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","Questions_Tags":{"questionId":217,"tagId":1496}},{"id":1497,"name":"error-checking","slug":"error-checking","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","Questions_Tags":{"questionId":217,"tagId":1497}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},"buildId":"8pZkyd0U8-Y2Qf3QK9j7l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>