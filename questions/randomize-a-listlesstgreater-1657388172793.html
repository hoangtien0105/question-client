<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-bf26e92d2540e305.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_buildManifest.js" defer=""></script><script src="/_next/static/9SrIo1zGFc3tF1E8on9-4/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/randomize-a-listlesstgreater-1657388172793#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/randomize-a-listlesstgreater-1657388172793">Randomize a List&lt;T&gt;</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/generic-list">generic-list</a></div></div><div class="question-content mt-5">
                
<p>What is the best way to randomize the order of a generic list in C#? I've got a finite set of 75 numbers in a list I would like to assign a random order to, in order to draw them for a lottery type application.</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Shuffle any <code>(I)List</code> with an extension method based on the <a href="http://en.wikipedia.org/wiki/Fisher-Yates_shuffle" rel="noreferrer">Fisher-Yates shuffle</a>:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random rng = <span class="hljs-keyword">new</span> Random();  

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>  
{  
    <span class="hljs-built_in">int</span> n = list.Count;  
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) {  
        n--;  
        <span class="hljs-built_in">int</span> k = rng.Next(n + <span class="hljs-number">1</span>);  
        T <span class="hljs-keyword">value</span> = list[k];  
        list[k] = list[n];  
        list[n] = <span class="hljs-keyword">value</span>;  
    }  
}
</code></pre>

<p>Usage:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">List&lt;Product&gt; products = GetProducts();
products.Shuffle();
</code></pre>

<p>The code above uses the much criticised System.Random method to select swap candidates. It's fast but not as random as it should be. If you need a better quality of randomness in your shuffles use the random number generator in System.Security.Cryptography like so:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">using</span> System.Security.Cryptography;
...
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>
{
    RNGCryptoServiceProvider provider = <span class="hljs-keyword">new</span> RNGCryptoServiceProvider();
    <span class="hljs-built_in">int</span> n = list.Count;
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">byte</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">do</span> provider.GetBytes(box);
        <span class="hljs-keyword">while</span> (!(box[<span class="hljs-number">0</span>] &lt; n * (Byte.MaxValue / n)));
        <span class="hljs-built_in">int</span> k = (box[<span class="hljs-number">0</span>] % n);
        n--;
        T <span class="hljs-keyword">value</span> = list[k];
        list[k] = list[n];
        list[n] = <span class="hljs-keyword">value</span>;
    }
}
</code></pre>

<p>A simple comparison is available <a href="https://web.archive.org/web/20150801085341/http://blog.thijssen.ch/2010/02/when-random-is-too-consistent.html" rel="noreferrer">at this blog</a> (WayBack Machine).</p>

<p>Edit: Since writing this answer a couple years back, many people have commented or written to me, to point out the big silly flaw in my comparison. They are of course right. There's nothing wrong with System.Random if it's used in the way it was intended. In my first example above, I instantiate the rng variable inside of the Shuffle method, which is asking for trouble if the method is going to be called repeatedly. Below is a fixed, full example based on a really useful comment received today from @weston here on SO.</p>

<p>Program.cs:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> System.Threading;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">SimpleLottery</span>
{
  <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
  {
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>
    {
      <span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">75</span>));
      numbers.Shuffle();
      Console.WriteLine(<span class="hljs-string">"The winning numbers are: {0}"</span>, <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">",  "</span>, numbers.GetRange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)));
    }
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeRandom</span>
  {
      [<span class="hljs-meta">ThreadStatic</span>] <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random Local;

      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Random ThisThreadsRandom
      {
          <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> Local ?? (Local = <span class="hljs-keyword">new</span> Random(<span class="hljs-keyword">unchecked</span>(Environment.TickCount * <span class="hljs-number">31</span> + Thread.CurrentThread.ManagedThreadId))); }
      }
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyExtensions</span>
  {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>
    {
      <span class="hljs-built_in">int</span> n = list.Count;
      <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)
      {
        n--;
        <span class="hljs-built_in">int</span> k = ThreadSafeRandom.ThisThreadsRandom.Next(n + <span class="hljs-number">1</span>);
        T <span class="hljs-keyword">value</span> = list[k];
        list[k] = list[n];
        list[n] = <span class="hljs-keyword">value</span>;
      }
    }
  }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If we only need to shuffle items in a completely random order (just to mix the items in a list), I prefer this simple yet effective code that orders items by guid...</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> shuffledcards = cards.OrderBy(a =&gt; Guid.NewGuid()).ToList();
</code></pre>
<hr>
<p>As people have pointed out in the comments, GUIDs are not guaranteed to be random, so we should be using a real random number generator instead:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random rng = <span class="hljs-keyword">new</span> Random();
...
<span class="hljs-keyword">var</span> shuffledcards = cards.OrderBy(a =&gt; rng.Next()).ToList();
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm bit surprised by all the clunky versions of this simple algorithm here. Fisher-Yates (or Knuth shuffle) is bit tricky but very compact. Why is it tricky? Because your need to pay attention to whether your random number generator <code>r(a,b)</code> returns value where <code>b</code> is inclusive or exclusive. I've also edited <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm" rel="noreferrer">Wikipedia description</a> so people don't blindly follow pseudocode there and create hard to detect bugs. For .Net, <code>Random.Next(a,b)</code> returns number exclusive of <code>b</code> so without further ado, here's how it can be implemented in C#/.Net:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list, Random rnd</span>)</span>
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=list.Count; i &gt; <span class="hljs-number">0</span>; i--)
        list.Swap(<span class="hljs-number">0</span>, rnd.Next(<span class="hljs-number">0</span>, i));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>
{
    <span class="hljs-keyword">var</span> temp = list[i];
    list[i] = list[j];
    list[j] = temp;
}
</code></pre>

<p><a href="https://dotnetfiddle.net/f7aG0o#" rel="noreferrer">Try this code</a>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Extension method for IEnumerable:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Randomize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; source</span>)</span>
{
    Random rnd = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-keyword">return</span> source.OrderBy&lt;T, <span class="hljs-built_in">int</span>&gt;((item) =&gt; rnd.Next());
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Idea is get anonymous object with item and random order and then reorder items by this order and return value:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> result = items.Select(x =&gt; <span class="hljs-keyword">new</span> { <span class="hljs-keyword">value</span> = x, order = rnd.Next() })
            .OrderBy(x =&gt; x.order).Select(x =&gt; x.<span class="hljs-keyword">value</span>).ToList()
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Randomize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">List&lt;T&gt; list</span>)</span>
    {
        List&lt;T&gt; randomizedList = <span class="hljs-keyword">new</span> List&lt;T&gt;();
        Random rnd = <span class="hljs-keyword">new</span> Random();
        <span class="hljs-keyword">while</span> (list.Count &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">int</span> index = rnd.Next(<span class="hljs-number">0</span>, list.Count); <span class="hljs-comment">//pick a random item from the master list</span>
            randomizedList.Add(list[index]); <span class="hljs-comment">//place it at the end of the randomized list</span>
            list.RemoveAt(index);
        }
        <span class="hljs-keyword">return</span> randomizedList;
    }
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>EDIT</strong>
The <code>RemoveAt</code> is a weakness in my previous version. This solution overcomes that.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">
        <span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; source,
        Random generator = <span class="hljs-literal">null</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (generator == <span class="hljs-literal">null</span>)
    {
        generator = <span class="hljs-keyword">new</span> Random();
    }

    <span class="hljs-keyword">var</span> elements = source.ToArray();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = elements.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        <span class="hljs-keyword">var</span> swapIndex = generator.Next(i + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> elements[swapIndex];
        elements[swapIndex] = elements[i];
    }
}
</code></pre>

<p>Note the optional <code>Random generator</code>, if the base framework implementation of <code>Random</code> is not thread-safe or cryptographically strong enough for your needs, you can inject your implementation into the operation.</p>

<p><a href="https://stackoverflow.com/a/24648788/659190">A suitable implementation for a thread-safe cryptographically strong <code>Random</code> implementation can be found in this answer.</a></p>

<hr>

<p><s>Here's an idea, extend IList in a (hopefully) efficient way.</s></p><s>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>
{
    <span class="hljs-keyword">var</span> choices = Enumerable.Range(<span class="hljs-number">0</span>, list.Count).ToList();
    <span class="hljs-keyword">var</span> rng = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> n = choices.Count; n &gt; <span class="hljs-number">1</span>; n--)
    {
        <span class="hljs-built_in">int</span> k = rng.Next(n);
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> list[choices[k]];
        choices.RemoveAt(k);
    }

    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> list[choices[<span class="hljs-number">0</span>]];
}
</code></pre>

</s><p><s></s></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is my preferred method of a shuffle when it's desirable to not modify the original. It's a variant of the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_.22inside-out.22_algorithm" rel="noreferrer">FisherYates "inside-out" algorithm</a> that works on any enumerable sequence (the length of <code>source</code> does not need to be known from start).</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">NextList</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> Random r, IEnumerable&lt;T&gt; source</span>)</span>
{
  <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;T&gt;();
  <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> source)
  {
    <span class="hljs-keyword">var</span> i = r.Next(list.Count + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (i == list.Count)
    {
      list.Add(item);
    }
    <span class="hljs-keyword">else</span>
    {
      <span class="hljs-keyword">var</span> temp = list[i];
      list[i] = item;
      list.Add(temp);
    }
  }
  <span class="hljs-keyword">return</span> list;
}
</code></pre>

<p>This algorithm can also be implemented by allocating a range from <code>0</code> to <code>length - 1</code> and randomly exhausting the indices by swapping the randomly chosen index with the last index until all indices have been chosen exactly once. This above code accomplishes the exact same thing but without the additional allocation. Which is pretty neat.</p>

<p>With regards to the <code>Random</code> class it's a general purpose number generator (and If I was running a lottery I'd consider using something different). It also relies on a time based seed value by default. A small alleviation of the problem is to seed the <code>Random</code> class with the <code>RNGCryptoServiceProvider</code> or you could use the <code>RNGCryptoServiceProvider</code> in a method similar to this (see below) to generate uniformly chosen random double floating point values but running a lottery pretty much requires understanding randomness and the nature of the randomness source.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> bytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">8</span>];
_secureRng.GetBytes(bytes);
<span class="hljs-keyword">var</span> v = BitConverter.ToUInt64(bytes, <span class="hljs-number">0</span>);
<span class="hljs-keyword">return</span> (<span class="hljs-built_in">double</span>)v / ((<span class="hljs-built_in">double</span>)<span class="hljs-built_in">ulong</span>.MaxValue + <span class="hljs-number">1</span>);
</code></pre>

<p>The point of generating a random double (between 0 and 1 exclusively) is to use to scale to an integer solution. If you need to pick something from a list based on a random double <code>x</code> that's always going to be <code>0 &lt;= x &amp;&amp; x &lt; 1</code> is straight forward.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">return</span> list[(<span class="hljs-built_in">int</span>)(x * list.Count)];
</code></pre>

<p>Enjoy!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't mind using two <code>Lists</code>, then this is probably the easiest way to do it, but probably not the most efficient or unpredictable one: </p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">List&lt;<span class="hljs-built_in">int</span>&gt; xList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;() { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
List&lt;<span class="hljs-built_in">int</span>&gt; deck = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> xInt <span class="hljs-keyword">in</span> xList)
    deck.Insert(random.Next(<span class="hljs-number">0</span>, deck.Count + <span class="hljs-number">1</span>), xInt);
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I usually use:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;T&gt; ();
fillList (list);
<span class="hljs-keyword">var</span> randomizedList = <span class="hljs-keyword">new</span> List&lt;T&gt; ();
<span class="hljs-keyword">var</span> rnd = <span class="hljs-keyword">new</span> Random ();
<span class="hljs-keyword">while</span> (list.Count != <span class="hljs-number">0</span>)
{
    <span class="hljs-keyword">var</span> index = rnd.Next (<span class="hljs-number">0</span>, list.Count);
    randomizedList.Add (list [index]);
    list.RemoveAt (index);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you have a fixed number (75), you could create an array with 75 elements, then enumerate your list, moving the elements to randomized positions in the array.  You can generate the mapping of list number to array index using the <a href="http://en.wikipedia.org/wiki/Knuth_shuffle" rel="nofollow noreferrer" title="Fisher-Yates shuffle">Fisher-Yates shuffle</a>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can achieve that be using this simple extension method</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IEnumerableExtensions</span>
{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">t</span>&gt; <span class="hljs-title">Randomize</span>&lt;<span class="hljs-title">t</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;t&gt; target</span>)</span>
    {
        Random r = <span class="hljs-keyword">new</span> Random();

        <span class="hljs-keyword">return</span> target.OrderBy(x=&gt;(r.Next()));
    }        
}
</code></pre>

<p>and you can use it by doing the following</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-comment">// use this on any collection that implements IEnumerable!</span>
<span class="hljs-comment">// List, Array, HashSet, Collection, etc</span>

List&lt;<span class="hljs-built_in">string</span>&gt; myList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; { <span class="hljs-string">"hello"</span>, <span class="hljs-string">"random"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"bat"</span>, <span class="hljs-string">"baz"</span> };

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> myList.Randomize())
{
    Console.WriteLine(s);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just wanted to suggest a variant using an <code>IComparer&lt;T&gt;</code> and <code>List.Sort()</code>:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RandomIntComparer</span> : <span class="hljs-title">IComparer</span>&lt;<span class="hljs-title">int</span>&gt;
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Random _random = <span class="hljs-keyword">new</span> Random();
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>
    {
        <span class="hljs-keyword">return</span> _random.Next(<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>);
    }
}
</code></pre>
<p>Usage:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">list.Sort(<span class="hljs-keyword">new</span> RandomIntComparer());
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have found an interesting solution online.</p>

<p>Courtesy: <a href="https://improveandrepeat.com/2018/08/a-simple-way-to-shuffle-your-lists-in-c/" rel="nofollow noreferrer">https://improveandrepeat.com/2018/08/a-simple-way-to-shuffle-your-lists-in-c/</a></p>

<p>var shuffled = myList.OrderBy(x =&gt; Guid.NewGuid()).ToList();</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One can use the Shuffle extension methond from morelinq package, it works on IEnumerables</p>
<blockquote>
<p>install-package morelinq</p>
</blockquote>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">using</span> MoreLinq;
...    
<span class="hljs-keyword">var</span> randomized = list.Shuffle();
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple modification of the <a href="https://stackoverflow.com/a/1262619/">accepted answer</a> that returns a new list instead of working in-place, and accepts the more general <code>IEnumerable&lt;T&gt;</code> as many other Linq methods do.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random rng = <span class="hljs-keyword">new</span> Random();

<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Returns a new list where the elements are randomly shuffled.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Based on the Fisher-Yates shuffle, which has O(n) complexity.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; list</span>)</span> {
    <span class="hljs-keyword">var</span> source = list.ToList();
    <span class="hljs-built_in">int</span> n = source.Count;
    <span class="hljs-keyword">var</span> shuffled = <span class="hljs-keyword">new</span> List&lt;T&gt;(n);
    shuffled.AddRange(source);
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) {
        n--;
        <span class="hljs-built_in">int</span> k = rng.Next(n + <span class="hljs-number">1</span>);
        T <span class="hljs-keyword">value</span> = shuffled[k];
        shuffled[k] = shuffled[n];
        shuffled[n] = <span class="hljs-keyword">value</span>;
    }
    <span class="hljs-keyword">return</span> shuffled;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">    List&lt;T&gt; OriginalList = <span class="hljs-keyword">new</span> List&lt;T&gt;();
    List&lt;T&gt; TempList = <span class="hljs-keyword">new</span> List&lt;T&gt;();
    Random random = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-built_in">int</span> length = OriginalList.Count;
    <span class="hljs-built_in">int</span> TempIndex = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) {
        TempIndex = random.Next(<span class="hljs-number">0</span>, length);  <span class="hljs-comment">// get random value between 0 and original length</span>
        TempList.Add(OriginalList[TempIndex]); <span class="hljs-comment">// add to temp list</span>
        OriginalList.RemoveAt(TempIndex); <span class="hljs-comment">// remove from original list</span>
        length = OriginalList.Count;  <span class="hljs-comment">// get new list &lt;T&gt; length.</span>
    }

    OriginalList = <span class="hljs-keyword">new</span> List&lt;T&gt;();
    OriginalList = TempList; <span class="hljs-comment">// copy all items from temp list to original list.</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is an implementation of the Fisher-Yates shuffle that allows specification of the number of elements to return; hence, it is not necessary to first sort the whole collection before taking your desired number of elements.</p>
<p>The sequence of swapping elements is reversed from default; and proceeds from the first element to the last element, so that retrieving a subset of the collection yields the same (partial) sequence as shuffling the whole collection:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">collection.TakeRandom(<span class="hljs-number">5</span>).SequenceEqual(collection.Shuffle().Take(<span class="hljs-number">5</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<p>This algorithm is based on Durstenfeld's (modern) version of the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm" rel="nofollow noreferrer">Fisher-Yates shuffle</a> on Wikipedia.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">TakeRandom</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; collection, <span class="hljs-built_in">int</span> count, Random random</span>)</span> =&gt; shuffle(collection, count, random);
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; collection, Random random</span>)</span> =&gt; shuffle(collection, <span class="hljs-literal">null</span>, random);
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; collection, <span class="hljs-built_in">int</span>? take, Random random</span>)</span>
{
    <span class="hljs-keyword">var</span> a = collection.ToArray();
    <span class="hljs-keyword">var</span> n = a.Length;
    <span class="hljs-keyword">if</span> (take &lt;= <span class="hljs-number">0</span> || take &gt; n) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"Invalid number of elements to return."</span>);
    <span class="hljs-keyword">var</span> end = take ?? n;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; end; i++)
    {
        <span class="hljs-keyword">var</span> j = random.Next(i, n);
        (a[i], a[j]) = (a[j], a[i]);
    }

    <span class="hljs-keyword">if</span> (take.HasValue) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArraySegment&lt;T&gt;(a, <span class="hljs-number">0</span>, take.Value);
    <span class="hljs-keyword">return</span> a;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can make the Fisher-Yates shuffle more terse and expressive by using tuples for the swap.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Random random = <span class="hljs-keyword">new</span> Random();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>
{
    <span class="hljs-built_in">int</span> n = list.Count;
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)
    {
        n--;
        <span class="hljs-built_in">int</span> k = random.Next(n + <span class="hljs-number">1</span>);
        (list[k], list[n]) = (list[n], list[k]);
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's an efficient Shuffler that returns a byte array of shuffled values. It never shuffles more than is needed. It can be restarted from where it previously left off. My actual implementation (not shown) is a MEF component that allows a user specified replacement shuffler.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">Shuffle</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] array, <span class="hljs-built_in">int</span> start, <span class="hljs-built_in">int</span> count</span>)</span>
    {
        <span class="hljs-built_in">int</span> n = array.Length - start;
        <span class="hljs-built_in">byte</span>[] shuffled = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[count];
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++, start++)
        {
            <span class="hljs-built_in">int</span> k = UniformRandomGenerator.Next(n--) + start;
            shuffled[i] = array[k];
            array[k] = array[start];
            array[start] = shuffled[i];
        }
        <span class="hljs-keyword">return</span> shuffled;
    }
</code></pre>

<p>`</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your question is how to <strong>randomize</strong> a list. This means:</p>
<ol>
<li>All unique combinations should be possible of happening</li>
<li>All unique combinations should occur with the same distribution (AKA being non-biased).</li>
</ol>
<p>A large number of the answers posted for this question do NOT satisfy the two requirements above for being "random".</p>
<p>Here's a compact, non-biased pseudo-random function following the Fisher-Yates shuffle method.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list, Random rnd</span>)</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = list.Count<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)
    {
        <span class="hljs-keyword">var</span> randomIndex = rnd.Next(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//maxValue (i + 1) is EXCLUSIVE</span>
        list.Swap(i, randomIndex); 
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list, <span class="hljs-built_in">int</span> indexA, <span class="hljs-built_in">int</span> indexB</span>)</span>
{
   <span class="hljs-keyword">var</span> temp = list[indexA];
   list[indexA] = list[indexB];
   list[indexB] = temp;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We can use an extension method for List and use a thread-safe random generator combination.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListExtensions</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IList&lt;T&gt; list</span>)</span>
    {
        <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(list));
        <span class="hljs-built_in">int</span> n = list.Count;
        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)
        {
            n--;
            <span class="hljs-built_in">int</span> k = ThreadSafeRandom.Next(n + <span class="hljs-number">1</span>);
            (list[n], list[k]) = (list[k], list[n]);
        }
    }
}

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeRandom</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Random _global = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ThreadLocal&lt;Random&gt; _local = <span class="hljs-keyword">new</span> ThreadLocal&lt;Random&gt;(() =&gt;
    {
        <span class="hljs-built_in">int</span> seed;
        <span class="hljs-keyword">lock</span> (_global)
        {
            seed = _global.Next();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random(seed);
    });

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Next</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> maxValue</span>)</span>
    {
        <span class="hljs-keyword">return</span> _local.Value.Next(maxValue);
    }
}
</code></pre>
<p>I've packaged this on <a href="https://www.nuget.org/packages/ListShuffle" rel="nofollow noreferrer">NuGet</a> with the source code available on <a href="https://github.com/MarkCiliaVincenti/ListShuffle" rel="nofollow noreferrer">GitHub</a>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a thread-safe way to do this:</p>



<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnumerableExtension</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random globalRng = <span class="hljs-keyword">new</span> Random();

    [<span class="hljs-meta">ThreadStatic</span>]
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random _rng;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random rng 
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">if</span> (_rng == <span class="hljs-literal">null</span>)
            {
                <span class="hljs-built_in">int</span> seed;
                <span class="hljs-keyword">lock</span> (globalRng)
                {
                    seed = globalRng.Next();
                }
                _rng = <span class="hljs-keyword">new</span> Random(seed);
             }
             <span class="hljs-keyword">return</span> _rng;
         }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Shuffle</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; items</span>)</span>
    {
        <span class="hljs-keyword">return</span> items.OrderBy (i =&gt; rng.Next());
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Deck</span>(<span class="hljs-params">IEnumerable&lt;Card&gt; initialCards</span>)</span> 
    {
    cards = <span class="hljs-keyword">new</span> List&lt;Card&gt;(initialCards);
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Shuffle</span>() 
     }</span>
    {
        List&lt;Card&gt; NewCards = <span class="hljs-keyword">new</span> List&lt;Card&gt;();
        <span class="hljs-keyword">while</span> (cards.Count &gt; <span class="hljs-number">0</span>) 
        {
            <span class="hljs-built_in">int</span> CardToMove = random.Next(cards.Count);
            NewCards.Add(cards[CardToMove]);
            cards.RemoveAt(CardToMove);
        }
        cards = NewCards;
    }

<span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetCardNames</span>()</span> 

{
    <span class="hljs-built_in">string</span>[] CardNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[cards.Count];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cards.Count; i++)
    CardNames[i] = cards[i].Name;
    <span class="hljs-keyword">return</span> CardNames;
}

Deck deck1;
Deck deck2;
Random random = <span class="hljs-keyword">new</span> Random();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span> 
{

InitializeComponent();
ResetDeck(<span class="hljs-number">1</span>);
ResetDeck(<span class="hljs-number">2</span>);
RedrawDeck(<span class="hljs-number">1</span>);
 RedrawDeck(<span class="hljs-number">2</span>);

}



 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetDeck</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> deckNumber</span>)</span> 
    {
    <span class="hljs-keyword">if</span> (deckNumber == <span class="hljs-number">1</span>) 
{
      <span class="hljs-built_in">int</span> numberOfCards = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>);
      deck1 = <span class="hljs-keyword">new</span> Deck(<span class="hljs-keyword">new</span> Card[] { });
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfCards; i++)
           deck1.Add(<span class="hljs-keyword">new</span> Card((Suits)random.Next(<span class="hljs-number">4</span>),(Values)random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>)));
       deck1.Sort();
}


   <span class="hljs-keyword">else</span>
    deck2 = <span class="hljs-keyword">new</span> Deck();
 }

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> {
ResetDeck(<span class="hljs-number">1</span>);
RedrawDeck(<span class="hljs-number">1</span>);

}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> 
{
    deck1.Shuffle();
    RedrawDeck(<span class="hljs-number">1</span>);

}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToDeck1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> 
{

    <span class="hljs-keyword">if</span> (listBox2.SelectedIndex &gt;= <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> (deck2.Count &gt; <span class="hljs-number">0</span>) {
    deck1.Add(deck2.Deal(listBox2.SelectedIndex));

}

    RedrawDeck(<span class="hljs-number">1</span>);
    RedrawDeck(<span class="hljs-number">2</span>);

}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;GameObject&gt; <span class="hljs-title">ShuffleList</span>(<span class="hljs-params">List&lt;GameObject&gt; ActualList</span>)</span> {


    List&lt;GameObject&gt; newList = ActualList;
    List&lt;GameObject&gt; outList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();

    <span class="hljs-built_in">int</span> count = newList.Count;

    <span class="hljs-keyword">while</span> (newList.Count &gt; <span class="hljs-number">0</span>) {

        <span class="hljs-built_in">int</span> rando = Random.Range(<span class="hljs-number">0</span>, newList.Count);

        outList.Add(newList[rando]);

        newList.RemoveAt(rando);

     

    }

    <span class="hljs-keyword">return</span> (outList);

}
</code></pre>
<p>usage :</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">List&lt;GameObject&gt; GetShuffle = ShuffleList(ActualList);
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Old post for sure, but I just use a GUID.  </p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">Items = Items.OrderBy(o =&gt; Guid.NewGuid().ToString()).ToList();
</code></pre>

<p>A GUID is always unique, and since it is regenerated every time the result changes each time.  </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A very simple approach to this kind of problem is to use a number of random element swap in the list.</p>

<p>In pseudo-code this would look like this:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">do</span> 
    r1 = randomPositionInList()
    r2 = randomPositionInList()
    swap elements at index r1 <span class="hljs-keyword">and</span> index r2 
<span class="hljs-keyword">for</span> a certain number of times
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Shuffle any \u0026lt;code\u0026gt;(I)List\u0026lt;/code\u0026gt; with an extension method based on the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Fisher-Yates shuffle\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random rng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();  \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;  \n{  \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = list.Count;  \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {  \n        n--;  \n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = rng.Next(n + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);  \n        T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = list[k];  \n        list[k] = list[n];  \n        list[n] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;;  \n    }  \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;List\u0026amp;lt;Product\u0026amp;gt; products = GetProducts();\nproducts.Shuffle();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The code above uses the much criticised System.Random method to select swap candidates. It\u0026apos;s fast but not as random as it should be. If you need a better quality of randomness in your shuffles use the random number generator in System.Security.Cryptography like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Security.Cryptography;\n...\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    RNGCryptoServiceProvider provider = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; RNGCryptoServiceProvider();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = list.Count;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] box = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; provider.GetBytes(box);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!(box[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] \u0026amp;lt; n * (Byte.MaxValue / n)));\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = (box[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] % n);\n        n--;\n        T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = list[k];\n        list[k] = list[n];\n        list[n] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A simple comparison is available \u0026lt;a href=\u0026quot;https://web.archive.org/web/20150801085341/http://blog.thijssen.ch/2010/02/when-random-is-too-consistent.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;at this blog\u0026lt;/a\u0026gt; (WayBack Machine).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: Since writing this answer a couple years back, many people have commented or written to me, to point out the big silly flaw in my comparison. They are of course right. There\u0026apos;s nothing wrong with System.Random if it\u0026apos;s used in the way it was intended. In my first example above, I instantiate the rng variable inside of the Shuffle method, which is asking for trouble if the method is going to be called repeatedly. Below is a fixed, full example based on a really useful comment received today from @weston here on SO.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program.cs:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Collections.Generic;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Threading;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SimpleLottery\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Program\u0026lt;/span\u0026gt;\n  {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] args\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; numbers = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(Enumerable.Range(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;75\u0026lt;/span\u0026gt;));\n      numbers.Shuffle();\n      Console.WriteLine(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The winning numbers are: {0}\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;.Join(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,  \u0026quot;\u0026lt;/span\u0026gt;, numbers.GetRange(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)));\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ThreadSafeRandom\u0026lt;/span\u0026gt;\n  {\n      [\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;ThreadStatic\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random Local;\n\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random ThisThreadsRandom\n      {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Local ?? (Local = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unchecked\u0026lt;/span\u0026gt;(Environment.TickCount * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt; + Thread.CurrentThread.ManagedThreadId))); }\n      }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MyExtensions\u0026lt;/span\u0026gt;\n  {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = list.Count;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n      {\n        n--;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = ThreadSafeRandom.ThisThreadsRandom.Next(n + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = list[k];\n        list[k] = list[n];\n        list[n] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;;\n      }\n    }\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If we only need to shuffle items in a completely random order (just to mix the items in a list), I prefer this simple yet effective code that orders items by guid...\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; shuffledcards = cards.OrderBy(a =\u0026amp;gt; Guid.NewGuid()).ToList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;As people have pointed out in the comments, GUIDs are not guaranteed to be random, so we should be using a real random number generator instead:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random rng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n...\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; shuffledcards = cards.OrderBy(a =\u0026amp;gt; rng.Next()).ToList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m bit surprised by all the clunky versions of this simple algorithm here. Fisher-Yates (or Knuth shuffle) is bit tricky but very compact. Why is it tricky? Because your need to pay attention to whether your random number generator \u0026lt;code\u0026gt;r(a,b)\u0026lt;/code\u0026gt; returns value where \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is inclusive or exclusive. I\u0026apos;ve also edited \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wikipedia description\u0026lt;/a\u0026gt; so people don\u0026apos;t blindly follow pseudocode there and create hard to detect bugs. For .Net, \u0026lt;code\u0026gt;Random.Next(a,b)\u0026lt;/code\u0026gt; returns number exclusive of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; so without further ado, here\u0026apos;s how it can be implemented in C#/.Net:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list, Random rnd\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i=list.Count; i \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i--)\n        list.Swap(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, rnd.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, i));\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Swap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; temp = list[i];\n    list[i] = list[j];\n    list[j] = temp;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://dotnetfiddle.net/f7aG0o#\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Try this code\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Extension method for IEnumerable:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Randomize\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    Random rnd = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; source.OrderBy\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;((item) =\u0026amp;gt; rnd.Next());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Idea is get anonymous object with item and random order and then reorder items by this order and return value:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = items.Select(x =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = x, order = rnd.Next() })\n            .OrderBy(x =\u0026amp;gt; x.order).Select(x =\u0026amp;gt; x.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;).ToList()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Randomize\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;List\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        List\u0026amp;lt;T\u0026amp;gt; randomizedList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;();\n        Random rnd = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (list.Count \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; index = rnd.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, list.Count); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//pick a random item from the master list\u0026lt;/span\u0026gt;\n            randomizedList.Add(list[index]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//place it at the end of the randomized list\u0026lt;/span\u0026gt;\n            list.RemoveAt(index);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; randomizedList;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt;\nThe \u0026lt;code\u0026gt;RemoveAt\u0026lt;/code\u0026gt; is a weakness in my previous version. This solution overcomes that.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; source,\n        Random generator = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (generator == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n    {\n        generator = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; elements = source.ToArray();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = elements.Length - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; i \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i--)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; swapIndex = generator.Next(i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; elements[swapIndex];\n        elements[swapIndex] = elements[i];\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the optional \u0026lt;code\u0026gt;Random generator\u0026lt;/code\u0026gt;, if the base framework implementation of \u0026lt;code\u0026gt;Random\u0026lt;/code\u0026gt; is not thread-safe or cryptographically strong enough for your needs, you can inject your implementation into the operation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/24648788/659190\u0026quot;\u0026gt;A suitable implementation for a thread-safe cryptographically strong \u0026lt;code\u0026gt;Random\u0026lt;/code\u0026gt; implementation can be found in this answer.\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;s\u0026gt;Here\u0026apos;s an idea, extend IList in a (hopefully) efficient way.\u0026lt;/s\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;s\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; choices = Enumerable.Range(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, list.Count).ToList();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; rng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = choices.Count; n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; n--)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = rng.Next(n);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list[choices[k]];\n        choices.RemoveAt(k);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list[choices[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;/s\u0026gt;\u0026lt;p\u0026gt;\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is my preferred method of a shuffle when it\u0026apos;s desirable to not modify the original. It\u0026apos;s a variant of the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_.22inside-out.22_algorithm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;FisherYates \u0026quot;inside-out\u0026quot; algorithm\u0026lt;/a\u0026gt; that works on any enumerable sequence (the length of \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt; does not need to be known from start).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;NextList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; Random r, IEnumerable\u0026amp;lt;T\u0026amp;gt; source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; source)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = r.Next(list.Count + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (i == list.Count)\n    {\n      list.Add(item);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; temp = list[i];\n      list[i] = item;\n      list.Add(temp);\n    }\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This algorithm can also be implemented by allocating a range from \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;length - 1\u0026lt;/code\u0026gt; and randomly exhausting the indices by swapping the randomly chosen index with the last index until all indices have been chosen exactly once. This above code accomplishes the exact same thing but without the additional allocation. Which is pretty neat.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With regards to the \u0026lt;code\u0026gt;Random\u0026lt;/code\u0026gt; class it\u0026apos;s a general purpose number generator (and If I was running a lottery I\u0026apos;d consider using something different). It also relies on a time based seed value by default. A small alleviation of the problem is to seed the \u0026lt;code\u0026gt;Random\u0026lt;/code\u0026gt; class with the \u0026lt;code\u0026gt;RNGCryptoServiceProvider\u0026lt;/code\u0026gt; or you could use the \u0026lt;code\u0026gt;RNGCryptoServiceProvider\u0026lt;/code\u0026gt; in a method similar to this (see below) to generate uniformly chosen random double floating point values but running a lottery pretty much requires understanding randomness and the nature of the randomness source.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; bytes = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n_secureRng.GetBytes(bytes);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; v = BitConverter.ToUInt64(bytes, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)v / ((\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ulong\u0026lt;/span\u0026gt;.MaxValue + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The point of generating a random double (between 0 and 1 exclusively) is to use to scale to an integer solution. If you need to pick something from a list based on a random double \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; that\u0026apos;s always going to be \u0026lt;code\u0026gt;0 \u0026amp;lt;= x \u0026amp;amp;\u0026amp;amp; x \u0026amp;lt; 1\u0026lt;/code\u0026gt; is straight forward.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list[(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)(x * list.Count)];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Enjoy!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t mind using two \u0026lt;code\u0026gt;Lists\u0026lt;/code\u0026gt;, then this is probably the easiest way to do it, but probably not the most efficient or unpredictable one: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; xList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;() { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; };\nList\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; deck = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; xInt \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; xList)\n    deck.Insert(random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, deck.Count + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), xInt);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I usually use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt; ();\nfillList (list);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; randomizedList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt; ();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; rnd = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random ();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (list.Count != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; index = rnd.Next (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, list.Count);\n    randomizedList.Add (list [index]);\n    list.RemoveAt (index);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you have a fixed number (75), you could create an array with 75 elements, then enumerate your list, moving the elements to randomized positions in the array.  You can generate the mapping of list number to array index using the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Knuth_shuffle\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;Fisher-Yates shuffle\u0026quot;\u0026gt;Fisher-Yates shuffle\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can achieve that be using this simple extension method\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerableExtensions\u0026lt;/span\u0026gt;\n{\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Randomize\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;t\u0026amp;gt; target\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        Random r = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; target.OrderBy(x=\u0026amp;gt;(r.Next()));\n    }        \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and you can use it by doing the following\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use this on any collection that implements IEnumerable!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// List, Array, HashSet, Collection, etc\u0026lt;/span\u0026gt;\n\nList\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; myList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;random\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;world\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bat\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;baz\u0026quot;\u0026lt;/span\u0026gt; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; s \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; myList.Randomize())\n{\n    Console.WriteLine(s);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just wanted to suggest a variant using an \u0026lt;code\u0026gt;IComparer\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;List.Sort()\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;RandomIntComparer\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IComparer\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; Random _random = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    \n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Compare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;list.Sort(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; RandomIntComparer());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have found an interesting solution online.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Courtesy: \u0026lt;a href=\u0026quot;https://improveandrepeat.com/2018/08/a-simple-way-to-shuffle-your-lists-in-c/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://improveandrepeat.com/2018/08/a-simple-way-to-shuffle-your-lists-in-c/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;var shuffled = myList.OrderBy(x =\u0026amp;gt; Guid.NewGuid()).ToList();\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One can use the Shuffle extension methond from morelinq package, it works on IEnumerables\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;install-package morelinq\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; MoreLinq;\n...    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; randomized = list.Shuffle();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple modification of the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1262619/\u0026quot;\u0026gt;accepted answer\u0026lt;/a\u0026gt; that returns a new list instead of working in-place, and accepts the more general \u0026lt;code\u0026gt;IEnumerable\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; as many other Linq methods do.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random rng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Returns a new list where the elements are randomly shuffled.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Based on the Fisher-Yates shuffle, which has O(n) complexity.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; source = list.ToList();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = source.Count;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; shuffled = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;(n);\n    shuffled.AddRange(source);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {\n        n--;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = rng.Next(n + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = shuffled[k];\n        shuffled[k] = shuffled[n];\n        shuffled[n] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; shuffled;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;    List\u0026amp;lt;T\u0026amp;gt; OriginalList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;();\n    List\u0026amp;lt;T\u0026amp;gt; TempList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;();\n    Random random = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; length = OriginalList.Count;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; TempIndex = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (length \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n        TempIndex = random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, length);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get random value between 0 and original length\u0026lt;/span\u0026gt;\n        TempList.Add(OriginalList[TempIndex]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// add to temp list\u0026lt;/span\u0026gt;\n        OriginalList.RemoveAt(TempIndex); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove from original list\u0026lt;/span\u0026gt;\n        length = OriginalList.Count;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get new list \u0026amp;lt;T\u0026amp;gt; length.\u0026lt;/span\u0026gt;\n    }\n\n    OriginalList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;T\u0026amp;gt;();\n    OriginalList = TempList; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy all items from temp list to original list.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is an implementation of the Fisher-Yates shuffle that allows specification of the number of elements to return; hence, it is not necessary to first sort the whole collection before taking your desired number of elements.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The sequence of swapping elements is reversed from default; and proceeds from the first element to the last element, so that retrieving a subset of the collection yields the same (partial) sequence as shuffling the whole collection:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;collection.TakeRandom(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;).SequenceEqual(collection.Shuffle().Take(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This algorithm is based on Durstenfeld\u0026apos;s (modern) version of the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Fisher-Yates shuffle\u0026lt;/a\u0026gt; on Wikipedia.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;TakeRandom\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; collection, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count, Random random\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; =\u0026amp;gt; shuffle(collection, count, random);\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; collection, Random random\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; =\u0026amp;gt; shuffle(collection, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;, random);\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;IEnumerable\u0026amp;lt;T\u0026amp;gt; collection, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;? take, Random random\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = collection.ToArray();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = a.Length;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (take \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; || take \u0026amp;gt; n) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentException(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Invalid number of elements to return.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; end = take ?? n;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; end; i++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; j = random.Next(i, n);\n        (a[i], a[j]) = (a[j], a[i]);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (take.HasValue) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArraySegment\u0026amp;lt;T\u0026amp;gt;(a, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, take.Value);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can make the Fisher-Yates shuffle more terse and expressive by using tuples for the swap.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; Random random = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = list.Count;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    {\n        n--;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = random.Next(n + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        (list[k], list[n]) = (list[n], list[k]);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s an efficient Shuffler that returns a byte array of shuffled values. It never shuffles more than is needed. It can be restarted from where it previously left off. My actual implementation (not shown) is a MEF component that allows a user specified replacement shuffler.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] array, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; start, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = array.Length - start;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] shuffled = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[count];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; count; i++, start++)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = UniformRandomGenerator.Next(n--) + start;\n            shuffled[i] = array[k];\n            array[k] = array[start];\n            array[start] = shuffled[i];\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; shuffled;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;`\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your question is how to \u0026lt;strong\u0026gt;randomize\u0026lt;/strong\u0026gt; a list. This means:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;All unique combinations should be possible of happening\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All unique combinations should occur with the same distribution (AKA being non-biased).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;A large number of the answers posted for this question do NOT satisfy the two requirements above for being \u0026quot;random\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s a compact, non-biased pseudo-random function following the Fisher-Yates shuffle method.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list, Random rnd\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = list.Count\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;; i \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i--)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; randomIndex = rnd.Next(i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//maxValue (i + 1) is EXCLUSIVE\u0026lt;/span\u0026gt;\n        list.Swap(i, randomIndex); \n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Swap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; indexA, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; indexB\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; temp = list[indexA];\n   list[indexA] = list[indexB];\n   list[indexB] = temp;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We can use an extension method for List and use a thread-safe random generator combination.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ListExtensions\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IList\u0026amp;lt;T\u0026amp;gt; list\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (list == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentNullException(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nameof\u0026lt;/span\u0026gt;(list));\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = list.Count;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        {\n            n--;\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = ThreadSafeRandom.Next(n + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n            (list[n], list[k]) = (list[k], list[n]);\n        }\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;internal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ThreadSafeRandom\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; Random _global = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; ThreadLocal\u0026amp;lt;Random\u0026amp;gt; _local = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ThreadLocal\u0026amp;lt;Random\u0026amp;gt;(() =\u0026amp;gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; seed;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt; (_global)\n        {\n            seed = _global.Next();\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random(seed);\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Next\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; maxValue\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _local.Value.Next(maxValue);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;ve packaged this on \u0026lt;a href=\u0026quot;https://www.nuget.org/packages/ListShuffle\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;NuGet\u0026lt;/a\u0026gt; with the source code available on \u0026lt;a href=\u0026quot;https://github.com/MarkCiliaVincenti/ListShuffle\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a thread-safe way to do this:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;EnumerableExtension\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random globalRng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n\n    [\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;ThreadStatic\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random _rng;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Random rng \n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_rng == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; seed;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt; (globalRng)\n                {\n                    seed = globalRng.Next();\n                }\n                _rng = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random(seed);\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _rng;\n         }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; items\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; items.OrderBy (i =\u0026amp;gt; rng.Next());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Deck\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;IEnumerable\u0026amp;lt;Card\u0026amp;gt; initialCards\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \n    {\n    cards = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;Card\u0026amp;gt;(initialCards);\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Shuffle\u0026lt;/span\u0026gt;() \n     }\u0026lt;/span\u0026gt;\n    {\n        List\u0026amp;lt;Card\u0026amp;gt; NewCards = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;Card\u0026amp;gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (cards.Count \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; CardToMove = random.Next(cards.Count);\n            NewCards.Add(cards[CardToMove]);\n            cards.RemoveAt(CardToMove);\n        }\n        cards = NewCards;\n    }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GetCardNames\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt; \n\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] CardNames = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[cards.Count];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; cards.Count; i++)\n    CardNames[i] = cards[i].Name;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CardNames;\n}\n\nDeck deck1;\nDeck deck2;\nRandom random = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Random();\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Form1\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt; \n{\n\nInitializeComponent();\nResetDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\nResetDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\nRedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n RedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\n}\n\n\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ResetDeck\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; deckNumber\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \n    {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (deckNumber == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \n{\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; numberOfCards = random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;);\n      deck1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Deck(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Card[] { });\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; numberOfCards; i++)\n           deck1.Add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Card((Suits)random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;),(Values)random.Next(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;)));\n       deck1.Sort();\n}\n\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    deck2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Deck();\n }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;reset1_Click\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; sender, EventArgs e\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\nResetDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\nRedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;shuffle1_Click\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; sender, EventArgs e\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \n{\n    deck1.Shuffle();\n    RedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;moveToDeck1_Click\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; sender, EventArgs e\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \n{\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (listBox2.SelectedIndex \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (deck2.Count \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n    deck1.Add(deck2.Deal(listBox2.SelectedIndex));\n\n}\n\n    RedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    RedrawDeck(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; List\u0026amp;lt;GameObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ShuffleList\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;List\u0026amp;lt;GameObject\u0026amp;gt; ActualList\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n\n\n    List\u0026amp;lt;GameObject\u0026amp;gt; newList = ActualList;\n    List\u0026amp;lt;GameObject\u0026amp;gt; outList = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;GameObject\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count = newList.Count;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (newList.Count \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; rando = Random.Range(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, newList.Count);\n\n        outList.Add(newList[rando]);\n\n        newList.RemoveAt(rando);\n\n     \n\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (outList);\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;usage :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;List\u0026amp;lt;GameObject\u0026amp;gt; GetShuffle = ShuffleList(ActualList);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Old post for sure, but I just use a GUID.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;Items = Items.OrderBy(o =\u0026amp;gt; Guid.NewGuid().ToString()).ToList();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A GUID is always unique, and since it is regenerated every time the result changes each time.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A very simple approach to this kind of problem is to use a number of random element swap in the list.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In pseudo-code this would look like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; \n    r1 = randomPositionInList()\n    r2 = randomPositionInList()\n    swap elements at index r1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; index r2 \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; a certain number of times\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":492,"title":"Randomize a List\u003cT\u003e","content":"\n                \n\u0026lt;p\u0026gt;What is the best way to randomize the order of a generic list in C#? I\u0026apos;ve got a finite set of 75 numbers in a list I would like to assign a random order to, in order to draw them for a lottery type application.\u0026lt;/p\u0026gt;\n    ","slug":"randomize-a-listlesstgreater-1657388172793","postType":"QUESTION","createdAt":"2022-07-09T17:36:12.000Z","updatedAt":"2022-07-09T17:36:12.000Z","tags":[{"id":2468,"name":"generic-list","slug":"generic-list","createdAt":"2022-07-09T17:36:12.000Z","updatedAt":"2022-07-09T17:36:12.000Z","Questions_Tags":{"questionId":492,"tagId":2468}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"randomize-a-listlesstgreater-1657388172793"},"buildId":"9SrIo1zGFc3tF1E8on9-4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>