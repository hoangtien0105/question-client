<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why are these constructs using pre and post-increment undefined behavior? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="#include &lt;stdio.h&gt;

int main(void)
{
   int i = 0;
   i = i++ + ++i;
   printf(&quot;%d\n&quot;, i); // 3

   i = 1;
   i = (i++);
   printf(&quot;%d\n&quot;, i); // 2 Should be 1, no ?

   volatile int u = 0;
   u = u++ + ++u;
   printf(&quot;%d\n&quot;, u); // 1

   u = 1;
   u = (u++);
   printf(&quot;%d\n&quot;, u); // 2 Should also be one, no ?

   register int v = 0;
   v = v++ + ++v;
   printf(&quot;%d\n&quot;, v); // 3 (Should be the same as u ?)

   int w = 0;
   printf(&quot;%d %d\n&quot;, ++w, w); // shouldn&#x27;t this print 1 1

   int x[2] = { 5, 8 }, y = 0;
   x[y] = y ++;
   printf(&quot;%d %d\n&quot;, x[0], x[1]); // shouldn&#x27;t this print 0 8? or 5 0?
}

    "/><meta property="og:title" content="Why are these constructs using pre and post-increment undefined behavior? | Solutions Checker"/><meta property="og:description" content="#include &lt;stdio.h&gt;

int main(void)
{
   int i = 0;
   i = i++ + ++i;
   printf(&quot;%d\n&quot;, i); // 3

   i = 1;
   i = (i++);
   printf(&quot;%d\n&quot;, i); // 2 Should be 1, no ?

   volatile int u = 0;
   u = u++ + ++u;
   printf(&quot;%d\n&quot;, u); // 1

   u = 1;
   u = (u++);
   printf(&quot;%d\n&quot;, u); // 2 Should also be one, no ?

   register int v = 0;
   v = v++ + ++v;
   printf(&quot;%d\n&quot;, v); // 3 (Should be the same as u ?)

   int w = 0;
   printf(&quot;%d %d\n&quot;, ++w, w); // shouldn&#x27;t this print 1 1

   int x[2] = { 5, 8 }, y = 0;
   x[y] = y ++;
   printf(&quot;%d %d\n&quot;, x[0], x[1]); // shouldn&#x27;t this print 0 8? or 5 0?
}

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why are these constructs using pre and post-increment undefined behavior?","text":"#include &lt;stdio.h&gt;\n\nint main(void)\n{\n   int i = 0;\n   i = i++ + ++i;\n   printf(&quot;%d\\n&quot;, i); // 3\n\n   i = 1;\n   i = (i++);\n   printf(&quot;%d\\n&quot;, i); // 2 Should be 1, no ?\n\n   volatile int u = 0;\n   u = u++ + ++u;\n   printf(&quot;%d\\n&quot;, u); // 1\n\n   u = 1;\n   u = (u++);\n   printf(&quot;%d\\n&quot;, u); // 2 Should also be one, no ?\n\n   register int v = 0;\n   v = v++ + ++v;\n   printf(&quot;%d\\n&quot;, v); // 3 (Should be the same as u ?)\n\n   int w = 0;\n   printf(&quot;%d %d\\n&quot;, ++w, w); // shouldn&apos;t this print 1 1\n\n   int x[2] = { 5, 8 }, y = 0;\n   x[y] = y ++;\n   printf(&quot;%d %d\\n&quot;, x[0], x[1]); // shouldn&apos;t this print 0 8? or 5 0?\n}\n\n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can&apos;t predict the behavior when the code is run.\n\nAs far as I know, the standard doesn&apos;t explicitly say why the concept of undefined behavior exists. In my mind, it&apos;s simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.\n\nSo, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to undefined behavior. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared volatile, that doesn&apos;t prove or change anything. It is undefined; you cannot reason about the behavior.\n\nYour most interesting-looking example, the one with\n\nu = (u++);\n\n\nis a text-book example of undefined behavior (see Wikipedia&apos;s entry on sequence points).\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand why the behavior of these constructs are undefined, let&apos;s understand these terms first in the light of C11 standard:\nSequenced: (5.1.2.3)\n\nGiven any two evaluations A and B, if A is sequenced before B, then the execution of A shall precede the execution of B.\n\nUnsequenced:\n\nIf A is not sequenced before or after B, then A and B are unsequenced.\n\nEvaluations can be one of two things:\n\nvalue computations, which work out the result of an expression; and\nside effects, which are modifications of objects.\n\nSequence Point:\n\nThe presence of a sequence point between the evaluation of expressions A and B implies that every value computation and side effect associated with A is sequenced before every value computation and side effect associated with B.\n\nNow coming to the question, for the expressions like\nint i = 1;\ni = i++;\n\nstandard says that:\n6.5 Expressions:\n\nIf a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. [...]\n\nTherefore, the above expression invokes UB because two side effects on the same object i is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to i will be done before or after the side effect by ++.\nDepending on whether assignment occurs before or after the increment, different results will be produced and that&apos;s the one of the case of undefined behavior.\nLets rename the i at left of assignment be il and at the right of assignment (in the expression i++) be ir, then the expression be like\nil = ir++     // Note that suffix l and r are used for the sake of clarity.\n              // Both il and ir represents the same object.  \n\nAn important point regarding Postfix ++ operator is that:\n\njust because the ++ comes after the variable does not mean that the increment happens late. The increment can happen as early as the compiler likes as long as the compiler ensures that the original value is used.\n\nIt means the expression il = ir++ could be evaluated either as\ntemp = ir;      // i = 1\nir = ir + 1;    // i = 2   side effect by ++ before assignment\nil = temp;      // i = 1   result is 1  \n\nor\ntemp = ir;      // i = 1\nil = temp;      // i = 1   side effect by assignment before ++\nir = ir + 1;    // i = 2   result is 2  \n\nresulting in two different results 1 and 2 which depends on the sequence of side effects by assignment and ++ and hence invokes UB.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I think the relevant parts of the C99 standard are 6.5 Expressions, ยง2\n\n\n  Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.\n\n\nand 6.5.16 Assignment operators, ยง4:\n\n\n  The order of evaluation of the operands is unspecified. If an attempt is made to modify\n  the result of an assignment operator or to access it after the next sequence point, the\n  behavior is undefined. \n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.\n\nThis is what I get on my machine, together with what I think is going on:\n\n$ cat evil.c\nvoid evil(){\n  int i = 0;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code for function evil:\n   0x00000000 &lt;+0&gt;:   push   %ebp\n   0x00000001 &lt;+1&gt;:   mov    %esp,%ebp\n   0x00000003 &lt;+3&gt;:   sub    $0x10,%esp\n   0x00000006 &lt;+6&gt;:   movl   $0x0,-0x4(%ebp)  // i = 0   i = 0\n   0x0000000d &lt;+13&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 1\n   0x00000011 &lt;+17&gt;:  mov    -0x4(%ebp),%eax  // j = i   i = 1  j = 1\n   0x00000014 &lt;+20&gt;:  add    %eax,%eax        // j += j  i = 1  j = 2\n   0x00000016 &lt;+22&gt;:  add    %eax,-0x4(%ebp)  // i += j  i = 3\n   0x00000019 &lt;+25&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 4\n   0x0000001d &lt;+29&gt;:  leave  \n   0x0000001e &lt;+30&gt;:  ret\nEnd of assembler dump.\n\n\n(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The behavior can&apos;t really be explained because it invokes both unspecified behavior and undefined behavior, so we can not make any general predictions about this code, although if you read Olve Maudal&apos;s work such as Deep C and Unspecified and Undefined sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don&apos;t do that anywhere near production.\n\nSo moving on to unspecified behavior, in draft c99 standard section6.5 paragraph 3 says(emphasis mine):\n\n\n  The grouping of operators and operands is indicated by the syntax.74) Except as specified\n  later (for the function-call (), &amp;&amp;, ||, ?:, and comma operators), the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.\n\n\nSo when we have a line like this:\n\ni = i++ + ++i;\n\n\nwe do not know whether i++ or ++i will be evaluated first. This is mainly to give the compiler better options for optimization.\n\nWe also have undefined behavior here as well since the program is modifying variables(i, u, etc..) more than once between sequence points. From draft standard section 6.5 paragraph 2(emphasis mine):\n\n\n  Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.\n\n\nit cites the following code examples as being undefined:\n\ni = ++i + 1;\na[i++] = i; \n\n\nIn all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the ; in each one of these cases:\n\ni = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n\n\nUnspecified behavior is defined in the draft c99 standard in section 3.4.4 as:\n\n\n  use of an unspecified value, or other behavior where this International Standard provides\n  two or more possibilities and imposes no further requirements on which is chosen in any\n  instance\n\n\nand undefined behavior is defined in section 3.4.3 as:\n\n\n  behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirements\n\n\nand notes that:\n\n\n  Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, what are they supposed to mean? What was the programmer trying to do?\n\nThe first fragment asked about, i = i++ + ++i, is pretty clearly insane in my book.  No one would ever write it in a real program, it&apos;s not obvious what it does, there&apos;s no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it&apos;s not obvious to you and me what it&apos;s supposed to do, it&apos;s fine in my book if the compiler can&apos;t figure out what it&apos;s supposed to do, either.\n\nThe second fragment, i = i++, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:\n\ni = i + 1\n\n\nC, of course, has a handy shortcut:\n\ni++\n\n\nThis means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing\n\ni = i++\n\n\nwhat we&apos;re really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We&apos;re confused, so it doesn&apos;t bother me too much if the compiler gets confused, too.\n\nRealistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it&apos;s not obvious what an expression using ++ means, don&apos;t write it.&quot;\n\nWe used to spend countless hours on comp.lang.c discussing expressions like these and why they&apos;re undefined.  Two of my longer answers, that try to really explain why, are archived on the web:\n\n\nWhy doesn&apos;t the Standard define what these do?\nDoesn&apos;t operator precedence determine the order of evaluation?\n\n\nSee also question 3.8 and the rest of the questions in section 3 of the C FAQ list.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Often this question is linked as a duplicate of questions related to code like\n\nprintf(&quot;%d %d\\n&quot;, i, i++);\n\n\nor \n\nprintf(&quot;%d %d\\n&quot;, ++i, i++);\n\n\nor similar variants.\n\nWhile this is also undefined behaviour as stated already, there are subtle differences when printf() is involved when comparing to a statement such as:\n\nx = i++ + i++;\n\n\n\n\nIn the following statement:\n\nprintf(&quot;%d %d\\n&quot;, ++i, i++);\n\n\nthe order of evaluation of arguments in printf() is unspecified. That means, expressions i++ and ++i could be evaluated in any order. C11 standard has some relevant descriptions on this:\n\nAnnex J, unspecified behaviours\n\n\n  The order in which the function designator, arguments, and\n  subexpressions within the arguments are evaluated in a function call\n  (6.5.2.2).\n\n\n3.4.4, unspecified behavior\n\n\n  Use of an unspecified value, or other behavior where this\n  International Standard provides two or more possibilities and imposes\n  no further requirements on which is chosen in any instance.\n  \n  EXAMPLE An example of unspecified behavior is the order in which the\n  arguments to a function are evaluated.\n\n\nThe unspecified behaviour itself is NOT an issue. Consider this example:\n\nprintf(&quot;%d %d\\n&quot;, ++x, y++);\n\n\nThis too has unspecified behaviour because the order of evaluation of ++x and y++ is unspecified. But it&apos;s perfectly legal and valid statement. There&apos;s no undefined behaviour in this statement. Because the modifications (++x and y++) are done to distinct objects.\n\nWhat renders the following statement \n\nprintf(&quot;%d %d\\n&quot;, ++i, i++);\n\n\nas undefined behaviour is the fact that these two expressions modify the same object i without an intervening sequence point.\n\n\n\nAnother detail is that the comma involved in the printf() call is a separator, not the comma operator.\n\nThis is an important distinction because the comma operator does introduce a sequence point between the evaluation of their operands, which makes the following legal:\n\nint i = 5;\nint j;\n\nj = (++i, i++);  // No undefined behaviour here because the comma operator \n                 // introduces a sequence point between &apos;++i&apos; and &apos;i++&apos;\n\nprintf(&quot;i=%d j=%d\\n&quot;,i, j); // prints: i=7 j=6\n\n\nThe comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in j = (++i, i++);, ++i increments i to 6 and i++ yields old value of i (6) which is assigned to j. Then i becomes 7 due to post-increment.\n\nSo if the comma in the function call were to be a comma operator then \n\nprintf(&quot;%d %d\\n&quot;, ++i, i++);\n\n\nwill not be a problem. But it invokes undefined behaviour because the comma here is a separator.\n\n\n\nFor those who are new to undefined behaviour would benefit from reading What Every C Programmer Should Know About Undefined Behavior  to understand the concept and many other variants of undefined behaviour in C.\n\nThis post: Undefined, unspecified and implementation-defined behavior is also relevant.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:\n\nIn a single operation, read `i` and lock it to prevent access until further notice\nCompute (1+read_value)\nIn a single operation, unlock `i` and store the computed value\n\n\nWhile I don&apos;t think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, i would get incremented by two) and it&apos;s not totally inconceivable that some future processor might provide a feature something like that.\n\nIf the compiler were to write i++ as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn&apos;t happen to notice that one of the other instructions happened to access i, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable i is used in both places, but if a routine accepts references to two pointers p and q, and uses (*p) and (*q) in the above expression (rather than using i twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object&apos;s address were passed for both p and q.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"While the syntax of the expressions like a = a++ or a++ + a++ is legal, the behaviour of these constructs is undefined because a shall in C standard is not obeyed. C99 6.5p2:\n\n\n  \n  Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]\n  \n\n\nWith footnote 73 further clarifying that\n\n\n  \n  This paragraph renders undefined statement expressions such as\n\ni = ++i + 1;\na[i++] = i;\n\n  \n  while allowing\n\ni = i + 1;\na[i] = i;\n\n  \n\n\nThe various sequence points are listed in Annex C of C11 (and C99):\n\n\n  \n  The following are the sequence points described in 5.1.2.3:\n  \n  \n  Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).\n  Between the evaluations of the first and second operands of the following operators: logical AND &amp;&amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).\n  Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).\n  The end of a full declarator: declarators (6.7.6);\n  Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).\n  Immediately before a library function returns (7.1.4).\n  After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).\n  Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). \n  \n  \n\n\nThe wording of the same paragraph in C11 is:\n\n\n  \n  If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) \n  \n\n\n\n\nYou can detect such errors in a program by for example using a recent version of GCC with -Wall and -Werror, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:\n\n% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function main:\nplusplus.c:6:6: error: operation on i may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:6:6: error: operation on i may be undefined [-Werror=sequence-point]\nplusplus.c:10:6: error: operation on i may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:14:6: error: operation on u may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:14:6: error: operation on u may be undefined [-Werror=sequence-point]\nplusplus.c:18:6: error: operation on u may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:22:6: error: operation on v may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:22:6: error: operation on v may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n\n\nThe important part is to know what a sequence point is -- and what is a sequence point and what isn&apos;t. For example the comma operator is a sequence point, so\n\nj = (i ++, ++ i);\n\n\nis well-defined, and will increment i by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment i by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write j = (i += 2) which is yet again a &quot;clever&quot; way to write\n\ni += 2;\nj = i;\n\n\nHowever, the , in function argument lists is not a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call \n\nint i = 0;\nprintf(&quot;%d %d\\n&quot;, i++, ++i, i);\n\n\nhas undefined behaviour because there is no sequence point between the evaluations of i++ and ++i in function arguments, and the value of i is therefore modified twice, by both i++ and ++i, between the previous and the next sequence point.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. \nSo every statement of the form:\n\ni = i++;\ni = i++ + ++i;\n\n\nand so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.\n\nHowever, two different variables can be incremented between two sequence points.\n\nwhile(*src++ = *dst++);\n\n\nThe above is a common coding practice while copying/analysing strings.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"In https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c someone asked about a statement like:\n\nint k[] = {0,1,2,3,4,5,6,7,8,9,10};\nint i = 0;\nint num;\nnum = k[++i+k[++i]] + k[++i];\nprintf(&quot;%d&quot;, num);\n\n\nwhich prints 7... the OP expected it to print 6.\n\nThe ++i increments aren&apos;t guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 ++i executed, then the values of k[] were read, then the last ++i then k[].\n\nnum = k[i+1]+k[i+2] + k[i+3];\ni += 3\n\n\nModern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using ++) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.\nThis answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.\nI assume you&apos;ve heard the basic definition of C&apos;s ++ and -- operators by now, and how the prefix form ++x differs from the postfix form x++.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like\nint x = 5;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nBut, to your surprise, this program did not help you understand  it printed some strange, inexplicable output, suggesting that maybe ++ does something completely different, not at all what you thought it did.\nOr, perhaps you&apos;re looking at a hard-to-understand expression like\nint x = 5;\nx = x++ + ++x;\nprintf(&quot;%d\\n&quot;, x);\n\nPerhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you&apos;re likely to get two different answers!  What&apos;s up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)\nAs you&apos;ve heard by now, these expressions are undefined, which means that the C language makes no guarantee about what they&apos;ll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that&apos;s not so.\nWhat makes an expression undefined?  Are expressions involving ++ and -- always undefined?  Of course not: these are useful operators, and if you use them properly, they&apos;re perfectly well-defined.\nFor the expressions we&apos;re talking about, what makes them undefined is when there&apos;s too much going on at once, when we can&apos;t tell what order things will happen in, but when the order matters to the result we&apos;ll get.\nLet&apos;s go back to the two examples I&apos;ve used in this answer.  When I wrote\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nthe question is, before actually calling printf, does the compiler compute the value of x first, or x++, or maybe ++x?  But it turns out we don&apos;t know.  There&apos;s no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can&apos;t say whether the compiler will do x first, then ++x, then x++, or x++ then ++x then x, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we&apos;ll clearly get a different series of numbers printed out.\nWhat about this crazy expression?\nx = x++ + ++x;\n\nThe problem with this expression is that it contains three different attempts to modify the value of x: (1) the x++ part tries to take x&apos;s value, add 1, store the new value in x, and return the old value; (2) the ++x part tries to take x&apos;s value, add 1, store the new value in x, and return the new value; and (3) the x = part tries to assign the sum of the other two back to x.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually determine the final value of x?  Again, and perhaps surprisingly, there&apos;s no rule in C to tell us.\nYou might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I&apos;ll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like x, precedence and associativity do not tell us which of those attempts happens first, or last, or anything.\n\nSo with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?\nThese expressions are all fine:\ny = x++;\nz = x++ + y++;\nx = x + 1;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n\nThese expressions are all undefined:\nx = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nAnd the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?\nAs I said earlier, the undefined expressions are the ones where there&apos;s too much going at once, where you can&apos;t be sure what order things happen in, and where the order matters:\n\nIf there&apos;s one variable that&apos;s getting modified (assigned to) in two or more different places, how do you know which modification happens first?\nIf there&apos;s a variable that&apos;s getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?\n\nAs an example of #1, in the expression\nx = x++ + ++x;\n\nthere are three attempts to modify x.\nAs an example of #2, in the expression\ny = x + x++;\n\nwe both use the value of x, and modify it.\nSo that&apos;s the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don&apos;t also attempt to use the value of that variable somewhere else.\n\nOne more thing.  You might be wondering how to &quot;fix&quot; the undefined expressions I started this answer by presenting.\nIn the case of printf(&quot;%d %d %d\\n&quot;, x, ++x, x++);, it&apos;s easy  just write it as three separate printf calls:\nprintf(&quot;%d &quot;, x);\nprintf(&quot;%d &quot;, ++x);\nprintf(&quot;%d\\n&quot;, x++);\n\nNow the behavior is perfectly well defined, and you&apos;ll get sensible results.\nIn the case of x = x++ + ++x, on the other hand, there&apos;s no way to fix it.  There&apos;s no way to write it so that it has guaranteed behavior matching your expectations  but that&apos;s okay, because you would never write an expression like x = x++ + ++x in a real program anyway.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"A good explanation about what happens in this kind of computation is provided in the document n1188 from the ISO W14 site.\n\nI explain the ideas.\n\nThe main rule from the standard ISO 9899 that applies in this situation is  6.5p2.\n\n\n  Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.\n\n\nThe sequence points in an expression like i=i++ are before i= and after i++.  \n\nIn the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of i=i++ there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of expression-statement in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).\n\nSo the order of instructions inside a box has no clear order.\n\ni=i++\n\n\ncan be interpreted as\n\ntmp = i\ni=i+1\ni = tmp\n\n\nor as\n\ntmp = i\ni = tmp\ni=i+1\n\n\nbecause both all these forms to interpret the code i=i++ are valid and because both generate different answers, the behavior is undefined.\n\nSo a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.\n\nEDIT:\n\nOther good source for explaining such ambiguities are the entries from c-faq site (also published as a book) , namely here and here and here .\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).\nHowever if you stick to one compiler, you will find the behavior persistent, as long as you don&apos;t add function calls or pointers, which would make the behavior more messy.\nUsing Nuwen MinGW 15 GCC 7.1 you will get:\n #include&lt;stdio.h&gt;\n int main(int argc, char ** argv)\n {\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); //1\n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); //1\n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); //2\n }\n\nHow does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).\naccording to GCC C++: Operators\n\nIn GCC C++,  the precedence of the operators controls the order in\nwhich the individual operators are evaluated\n\nthe equivalent code in defined behavior C++ as   GCC understands:\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    //i = i++ + ++i;\n    int r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    //i = (i++);\n    r=i;\n    i++;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 1\n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    //u = (u++);\n    r=u;\n    u++;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 1\n\n    register int v = 0;\n    //v = v++ + ++v;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    printf(&quot;%d\\n&quot;, v); //2\n}\n\nThen we go to Visual Studio. Visual Studio 2015, you get:\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n\nHow does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.\nSo the equivalent in defined behavior C++ as Visual C++ understands:\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int r;\n    int i = 0;\n    //i = i++ + ++i;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    //i = (i++);\n    r = i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    //u = (u++);\n    r = u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    //v = v++ + ++v;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n\nas Visual Studio documentation states at Precedence and Order of Evaluation:\n\nWhere several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/increment">increment</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/operator-precedence">operator-precedence</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/sequence-points">sequence-points</a></div></div><div class="question-content mt-5">
                
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
   <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
   i = i++ + ++i;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

   i = <span class="hljs-number">1</span>;
   i = (i++);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 Should be 1, no ?</span>

   <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
   u = u++ + ++u;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 1</span>

   u = <span class="hljs-number">1</span>;
   u = (u++);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 Should also be one, no ?</span>

   <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
   v = v++ + ++v;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 (Should be the same as u ?)</span>

   <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++w, w); <span class="hljs-comment">// shouldn't this print 1 1</span>

   <span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = { <span class="hljs-number">5</span>, <span class="hljs-number">8</span> }, y = <span class="hljs-number">0</span>;
   x[y] = y ++;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]); <span class="hljs-comment">// shouldn't this print 0 8? or 5 0?</span>
}
</code></pre>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</p>

<p>As far as I know, the standard doesn't explicitly say <em>why</em> the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</p>

<p>So, with that in mind, why are these "issues"? The language clearly says that certain things lead to <a href="http://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer">undefined behavior</a>. There is no problem, there is no "should" involved. If the undefined behavior changes when one of the involved variables is declared <code>volatile</code>, that doesn't prove or change anything. It is <em>undefined</em>; you cannot reason about the behavior.</p>

<p>Your most interesting-looking example, the one with</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">u = (u++);
</code></pre>

<p>is a text-book example of undefined behavior (see Wikipedia's entry on <a href="http://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer">sequence points</a>).</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand <strong>why the behavior of these constructs are undefined</strong>, let's understand these terms first in the light of C11 standard:</p>
<p><strong>Sequenced:</strong> (5.1.2.3)</p>
<blockquote>
<p>Given any two evaluations <code>A</code> and <code>B</code>, if <code>A</code> is sequenced before <code>B</code>, then the execution of <code>A</code> shall precede the execution of <code>B</code>.</p>
</blockquote>
<p><strong>Unsequenced:</strong></p>
<blockquote>
<p>If <code>A</code> is not sequenced before or after <code>B</code>, then <code>A</code> and <code>B</code> are unsequenced.</p>
</blockquote>
<p>Evaluations can be one of two things:</p>
<ul>
<li><strong>value computations</strong>, which work out the result of an expression; and</li>
<li><strong>side effects</strong>, which are modifications of objects.</li>
</ul>
<p><strong>Sequence Point:</strong></p>
<blockquote>
<p>The presence of a sequence point between the evaluation of expressions <code>A</code> and <code>B</code> implies that every <em>value computation</em> and <em>side effect</em> associated with <code>A</code> is sequenced before every <em>value computation</em> and <em>side effect</em> associated with <code>B</code>.</p>
</blockquote>
<p>Now coming to the question, for the expressions like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;
i = i++;
</code></pre>
<p>standard says that:</p>
<h3>6.5 Expressions:</h3>
<blockquote>
<p><strong>If a side effect on a scalar object is unsequenced relative to</strong> either <strong>a different side effect on the same scalar object</strong> or a value computation using the value of the same scalar object, <strong>the behavior is undefined</strong>. [...]</p>
</blockquote>
<p>Therefore, the above expression invokes UB because two side effects on the same object <code>i</code> is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to <code>i</code> will be done before or after the side effect by <code>++</code>.<br>
Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of <strong>undefined behavior</strong>.</p>
<p>Lets rename the <code>i</code> at left of assignment be <code>il</code> and at the right of assignment (in the expression <code>i++</code>) be <code>ir</code>, then the expression be like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">il = ir++     <span class="hljs-comment">// Note that suffix l and r are used for the sake of clarity.</span>
              <span class="hljs-comment">// Both il and ir represents the same object.  </span>
</code></pre>
<p><a href="https://stackoverflow.com/a/17935062/2455888">An important point</a> regarding Postfix <code>++</code> operator is that:</p>
<blockquote>
<p><strong>just because the <code>++</code> comes after the variable does not mean that the increment happens late</strong>. The increment can happen as early as the compiler likes <em>as long as the compiler ensures that the original value is used</em>.</p>
</blockquote>
<p>It means the expression <code>il = ir++</code> could be evaluated either as</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">temp = ir;      <span class="hljs-comment">// i = 1</span>
ir = ir + <span class="hljs-number">1</span>;    <span class="hljs-comment">// i = 2   side effect by ++ before assignment</span>
il = temp;      <span class="hljs-comment">// i = 1   result is 1  </span>
</code></pre>
<p>or</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">temp = ir;      <span class="hljs-comment">// i = 1</span>
il = temp;      <span class="hljs-comment">// i = 1   side effect by assignment before ++</span>
ir = ir + <span class="hljs-number">1</span>;    <span class="hljs-comment">// i = 2   result is 2  </span>
</code></pre>
<p>resulting in two different results <code>1</code> and <code>2</code> which depends on the sequence of side effects by assignment and <code>++</code> and hence invokes UB.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think the relevant parts of the C99 standard are 6.5 Expressions, ยง2</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value
  modified at most once by the evaluation of an expression. Furthermore, the prior value
  shall be read only to determine the value to be stored.</p>
</blockquote>

<p>and 6.5.16 Assignment operators, ยง4:</p>

<blockquote>
  <p>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined. </p>
</blockquote>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</p>

<p>This is what I get on my machine, together with what I think is going on:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">$ cat evil.c
<span class="hljs-type">void</span> <span class="hljs-title function_">evil</span><span class="hljs-params">()</span>{
  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
  i+= i++ + ++i;
}
$ gcc evil.c -c -o evil.bin
$ gdb evil.bin
(gdb) disassemble evil
Dump of assembler code <span class="hljs-keyword">for</span> function evil:
   <span class="hljs-number">0x00000000</span> &lt;+<span class="hljs-number">0</span>&gt;:   push   %ebp
   <span class="hljs-number">0x00000001</span> &lt;+<span class="hljs-number">1</span>&gt;:   mov    %esp,%ebp
   <span class="hljs-number">0x00000003</span> &lt;+<span class="hljs-number">3</span>&gt;:   sub    $<span class="hljs-number">0x10</span>,%esp
   <span class="hljs-number">0x00000006</span> &lt;+<span class="hljs-number">6</span>&gt;:   movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i = 0   i = 0</span>
   <span class="hljs-number">0x0000000d</span> &lt;+<span class="hljs-number">13</span>&gt;:  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i++     i = 1</span>
   <span class="hljs-number">0x00000011</span> &lt;+<span class="hljs-number">17</span>&gt;:  mov    <span class="hljs-number">-0x4</span>(%ebp),%eax  <span class="hljs-comment">// j = i   i = 1  j = 1</span>
   <span class="hljs-number">0x00000014</span> &lt;+<span class="hljs-number">20</span>&gt;:  add    %eax,%eax        <span class="hljs-comment">// j += j  i = 1  j = 2</span>
   <span class="hljs-number">0x00000016</span> &lt;+<span class="hljs-number">22</span>&gt;:  add    %eax,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i += j  i = 3</span>
   <span class="hljs-number">0x00000019</span> &lt;+<span class="hljs-number">25</span>&gt;:  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i++     i = 4</span>
   <span class="hljs-number">0x0000001d</span> &lt;+<span class="hljs-number">29</span>&gt;:  leave  
   <span class="hljs-number">0x0000001e</span> &lt;+<span class="hljs-number">30</span>&gt;:  ret
End of assembler dump.
</code></pre>

<p>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The behavior can't really be explained because it invokes both <a href="http://en.wikipedia.org/wiki/Unspecified_behavior" rel="noreferrer">unspecified behavior</a> and <a href="http://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer">undefined behavior</a>, so we can not make any general predictions about this code, although if you read <em>Olve Maudal's</em> work such as <a href="http://www.slideshare.net/olvemaudal/deep-c" rel="noreferrer">Deep C</a> and <a href="http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf" rel="noreferrer">Unspecified and Undefined</a> sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</p>

<p>So moving on to <em>unspecified behavior</em>, in <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" rel="noreferrer">draft c99 standard</a> section<code>6.5</code> paragraph <em>3</em> says(<em>emphasis mine</em>):</p>

<blockquote>
  <p>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;&amp;, ||, ?:, and comma operators), <strong>the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.</strong></p>
</blockquote>

<p>So when we have a line like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++ + ++i;
</code></pre>

<p>we do not know whether <code>i++</code> or <code>++i</code> will be evaluated first. This is mainly to give the compiler <a href="https://stackoverflow.com/a/12540468/1708801">better options for optimization</a>.</p>

<p>We also have <em>undefined behavior</em> here as well since the program is modifying variables(<code>i</code>, <code>u</code>, etc..) more than once between <a href="http://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer">sequence points</a>. From draft standard section <code>6.5</code> paragraph <em>2</em>(<em>emphasis mine</em>):</p>

<blockquote>
  <p><strong>Between the previous and next sequence point an object shall have its stored value
  modified at most once</strong> by the evaluation of an expression. Furthermore, <strong>the prior value
  shall be read only to determine the value to be stored</strong>.</p>
</blockquote>

<p>it cites the following code examples as being undefined:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = ++i + <span class="hljs-number">1</span>;
a[i++] = i; 
</code></pre>

<p>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the <code>;</code> in each one of these cases:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++ + ++i;
^   ^       ^

i = (i++);
^    ^

u = u++ + ++u;
^   ^       ^

u = (u++);
^    ^

v = v++ + ++v;
^   ^       ^
</code></pre>

<p><em>Unspecified behavior</em> is defined in the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" rel="noreferrer">draft c99 standard</a> in section <code>3.4.4</code> as:</p>

<blockquote>
  <p>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</p>
</blockquote>

<p>and <em>undefined behavior</em> is defined in section <code>3.4.3</code> as:</p>

<blockquote>
  <p>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</p>
</blockquote>

<p>and notes that:</p>

<blockquote>
  <p>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>
</blockquote>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, <em>what are they supposed to mean?</em> <em>What was the programmer trying to do?</em></p>

<p>The first fragment asked about, <code>i = i++ + ++i</code>, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</p>

<p>The second fragment, <code>i = i++</code>, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i + <span class="hljs-number">1</span>
</code></pre>

<p>C, of course, has a handy shortcut:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i++
</code></pre>

<p>This means, "add 1 to i, and assign the result back to i".  So if we construct a hodgepodge of the two, by writing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++
</code></pre>

<p>what we're really saying is "add 1 to i, and assign the result back to i, and assign the result back to i".  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</p>

<p>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, "If it's not obvious what an expression using ++ means, don't write it."</p>

<p>We used to spend countless hours on comp.lang.c discussing expressions like these and <em>why</em> they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</p>

<ul>
<li><a href="http://www.eskimo.com/~scs/readings/undef.950321.html" rel="noreferrer">Why doesn't the Standard define what these do?</a></li>
<li><a href="http://www.eskimo.com/~scs/readings/precvsooe.960725.html" rel="noreferrer">Doesn't operator precedence determine the order of evaluation?</a></li>
</ul>

<p>See also <a href="http://c-faq.com/expr/seqpoints.html" rel="noreferrer">question 3.8</a> and the rest of the questions in <a href="http://c-faq.com/expr/index.html" rel="noreferrer">section 3</a> of the <a href="http://c-faq.com/" rel="noreferrer">C FAQ list</a>.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Often this question is linked as a duplicate of questions related to code like</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i, i++);
</code></pre>

<p>or </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>or similar variants.</p>

<p>While this is also <a href="https://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer"><em>undefined behaviour</em></a> as stated already, there are subtle differences when <code>printf()</code> is involved when comparing to a statement such as:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">x = i++ + i++;
</code></pre>

<hr>

<p>In the following statement:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>the <a href="http://en.cppreference.com/w/c/language/eval_order" rel="noreferrer"><em>order of evaluation</em></a> of arguments in <code>printf()</code> is <a href="https://en.wikipedia.org/wiki/Unspecified_behavior" rel="noreferrer"><em>unspecified</em></a>. That means, expressions <code>i++</code> and <code>++i</code> could be evaluated in any order. <a href="http://port70.net/~nsz/c/c11/n1570.html" rel="noreferrer">C11 standard</a> has some relevant descriptions on this:</p>

<p><strong>Annex J, unspecified behaviours</strong></p>

<blockquote>
  <p>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</p>
</blockquote>

<p><strong>3.4.4, unspecified behavior</strong></p>

<blockquote>
  <p>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</p>
  
  <p>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</p>
</blockquote>

<p>The <em>unspecified behaviour</em> itself is NOT an issue. Consider this example:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++x, y++);
</code></pre>

<p>This too has <em>unspecified behaviour</em> because the order of evaluation of <code>++x</code> and <code>y++</code> is unspecified. But it's perfectly legal and valid statement. There's <em>no</em> undefined behaviour in this statement. Because the modifications (<code>++x</code> and <code>y++</code>) are done to <em>distinct</em> objects.</p>

<p>What renders the following statement </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>as <em>undefined behaviour</em> is the fact that these two expressions modify the <em>same</em> object <code>i</code> without an intervening <a href="https://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer"><em>sequence point</em></a>.</p>

<hr>

<p>Another detail is that the <em>comma</em> involved in the printf() call is a <em>separator</em>, not the <a href="https://en.wikipedia.org/wiki/Comma_operator" rel="noreferrer"><em>comma operator</em></a>.</p>

<p>This is an important distinction because the <em>comma operator</em> does introduce a <em>sequence point</em> between the evaluation of their operands, which makes the following legal:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> j;

j = (++i, i++);  <span class="hljs-comment">// No undefined behaviour here because the comma operator </span>
                 <span class="hljs-comment">// introduces a sequence point between '++i' and 'i++'</span>

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"i=%d j=%d\n"</span>,i, j); <span class="hljs-comment">// prints: i=7 j=6</span>
</code></pre>

<p>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in <code>j = (++i, i++);</code>, <code>++i</code> increments <code>i</code> to <code>6</code> and <code>i++</code> yields old value of <code>i</code> (<code>6</code>) which is assigned to <code>j</code>. Then <code>i</code> becomes <code>7</code> due to post-increment.</p>

<p>So if the <em>comma</em> in the function call were to be a comma operator then </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>will not be a problem. But it invokes <em>undefined behaviour</em> because the <em>comma</em> here is a <em>separator</em>.</p>

<hr>

<p>For those who are new to <em>undefined behaviour</em> would benefit from reading <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html" rel="noreferrer">What Every C Programmer Should Know About Undefined Behavior</a>  to understand the concept and many other variants of undefined behaviour in C.</p>

<p>This post: <a href="https://stackoverflow.com/a/4105123/1275169">Undefined, unspecified and implementation-defined behavior</a> is also relevant.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement "i++" with the sequence:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">In a single operation, read `i` and lock it to prevent access until further notice
<span class="hljs-title function_">Compute</span> <span class="hljs-params">(<span class="hljs-number">1</span>+read_value)</span>
In a single operation, unlock `i` and store the computed value
</code></pre>

<p>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, <code>i</code> would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</p>

<p>If the compiler were to write <code>i++</code> as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access <code>i</code>, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable <code>i</code> is used in both places, but if a routine accepts references to two pointers <code>p</code> and <code>q</code>, and uses <code>(*p)</code> and <code>(*q)</code> in the above expression (rather than using <code>i</code> twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both <code>p</code> and <code>q</code>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While the <strong>syntax</strong> of the expressions like <code>a = a++</code> or <code>a++ + a++</code> is legal, the <strong>behaviour</strong> of these constructs is <strong>undefined</strong> because a <strong><em>shall</em></strong> in C standard is not obeyed. <a href="http://port70.net/~nsz/c/c99/n1256.html#6.5p2" rel="noreferrer">C99 6.5p2</a>:</p>

<blockquote>
  <ol start="2">
  <li>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</li>
  </ol>
</blockquote>

<p>With <a href="http://port70.net/~nsz/c/c99/n1256.html#note73" rel="noreferrer">footnote 73</a> further clarifying that</p>

<blockquote>
  <ol start="73">
  <li><p>This paragraph renders undefined statement expressions such as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = ++i + <span class="hljs-number">1</span>;
a[i++] = i;
</code></pre>
  
  <p>while allowing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i + <span class="hljs-number">1</span>;
a[i] = i;
</code></pre></li>
  </ol>
</blockquote>

<p>The various sequence points are listed in Annex C of <a href="http://port70.net/~nsz/c/c11/n1570.html#C" rel="noreferrer">C11</a> (and <a href="http://port70.net/~nsz/c/c99/n1256.html#C" rel="noreferrer">C99</a>):</p>

<blockquote>
  <ol>
  <li><p>The following are the sequence points described in 5.1.2.3:</p>
  
  <ul>
  <li>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</li>
  <li>Between the evaluations of the first and second operands of the following operators: logical AND &amp;&amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</li>
  <li>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</li>
  <li>The end of a full declarator: declarators (6.7.6);</li>
  <li>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</li>
  <li>Immediately before a library function returns (7.1.4).</li>
  <li>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</li>
  <li>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). </li>
  </ul></li>
  </ol>
</blockquote>

<p>The wording of the same <a href="http://port70.net/~nsz/c/c11/n1570.html#6.5p2" rel="noreferrer">paragraph in C11</a> is:</p>

<blockquote>
  <ol start="2">
  <li>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) </li>
  </ol>
</blockquote>

<hr>

<p>You can detect such errors in a program by for example using a recent version of GCC with <code>-Wall</code> and <code>-Werror</code>, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">% gcc plusplus.c -Wall -Werror -pedantic
plusplus.c: In function main:
plusplus.c:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
    i = i++ + ++i;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
plusplus.c:<span class="hljs-number">10</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
    i = (i++);
    ~~^~~~~~~
plusplus.c:<span class="hljs-number">14</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
    u = u++ + ++u;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">14</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
plusplus.c:<span class="hljs-number">18</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
    u = (u++);
    ~~^~~~~~~
plusplus.c:<span class="hljs-number">22</span>:<span class="hljs-number">6</span>: error: operation on v may be undefined [-Werror=sequence-point]
    v = v++ + ++v;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">22</span>:<span class="hljs-number">6</span>: error: operation on v may be undefined [-Werror=sequence-point]
cc1: all warnings being treated as errors
</code></pre>

<p>The important part is to know <a href="https://stackoverflow.com/questions/3575350/sequence-points-in-c">what a sequence point is -- and <em>what is</em> a sequence point and what <em>isn't</em></a>. For example the <em>comma operator</em> is a sequence point, so</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">j = (i ++, ++ i);
</code></pre>

<p>is well-defined, and will increment <code>i</code> by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment <code>i</code> by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write <code>j = (i += 2)</code> which is yet again a "clever" way to write</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i += <span class="hljs-number">2</span>;
j = i;
</code></pre>

<p>However, the <code>,</code> in function argument lists is <em>not</em> a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i++, ++i, i);
</code></pre>

<p>has <em>undefined behaviour</em> because <strong>there is no sequence point between the evaluations of <code>i++</code> and <code>++i</code> in function arguments</strong>, and the value of <code>i</code> is therefore modified twice, by both <code>i++</code> and <code>++i</code>, between the previous and the next sequence point.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. <br>
So every statement of the form:<br></p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++;
i = i++ + ++i;
</code></pre>

<p>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.<br></p>

<p>However, two different variables can be incremented between two sequence points.<br></p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">while</span>(*src++ = *dst++);
</code></pre>

<p>The above is a common coding practice while copying/analysing strings.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In <a href="https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c">https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c</a> someone asked about a statement like:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> k[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>};
<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-type">int</span> num;
num = k[++i+k[++i]] + k[++i];
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, num);
</code></pre>

<p>which prints 7... the OP expected it to print 6.</p>

<p>The <code>++i</code> increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 <code>++i</code> executed, then the values of <code>k[]</code> were read, then the last <code>++i</code> then <code>k[]</code>.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">num = k[i+<span class="hljs-number">1</span>]+k[i+<span class="hljs-number">2</span>] + k[i+<span class="hljs-number">3</span>];
i += <span class="hljs-number">3</span>
</code></pre>

<p>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your question was probably not, "Why are these constructs undefined behavior in C?".  Your question was probably, "Why did this code (using <code>++</code>) not give me the value I expected?", and someone marked your question as a duplicate, and sent you here.</p>
<p><em>This</em> answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</p>
<p>I assume you've heard the basic definition of C's <code>++</code> and <code>--</code> operators by now, and how the prefix form <code>++x</code> differs from the postfix form <code>x++</code>.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>But, to your surprise, this program did <em>not</em> help you understand  it printed some strange, inexplicable output, suggesting that maybe <code>++</code> does something completely different, not at all what you thought it did.</p>
<p>Or, perhaps you're looking at a hard-to-understand expression like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
x = x++ + ++x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x);
</code></pre>
<p>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</p>
<p>As you've heard by now, these expressions are <em>undefined</em>, which means that the C language makes no guarantee about what they'll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</p>
<p>What makes an expression undefined?  Are expressions involving <code>++</code> and <code>--</code> always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</p>
<p>For the expressions we're talking about, what makes them undefined is when there's too much going on at once, when we can't tell what order things will happen in, but when the order matters to the result we'll get.</p>
<p>Let's go back to the two examples I've used in this answer.  When I wrote</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>the question is, before actually calling <code>printf</code>, does the compiler compute the value of <code>x</code> first, or <code>x++</code>, or maybe <code>++x</code>?  But it turns out <em>we don't know</em>.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do <code>x</code> first, then <code>++x</code>, then <code>x++</code>, or <code>x++</code> then <code>++x</code> then <code>x</code>, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get a different series of numbers printed out.</p>
<p>What about this crazy expression?</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++ + ++x;
</code></pre>
<p>The problem with this expression is that it contains three different attempts to modify the value of <code>x</code>: (1) the <code>x++</code> part tries to take <code>x</code>'s value, add 1, store the new value in <code>x</code>, and return the old value; (2) the <code>++x</code> part tries to take <code>x</code>'s value, add 1, store the new value in <code>x</code>, and return the new value; and (3) the <code>x =</code> part tries to assign the sum of the other two back to <code>x</code>.  Which of those three attempted assignments will "win"?  Which of the three values will actually determine the final value of <code>x</code>?  Again, and perhaps surprisingly, there's no rule in C to tell us.</p>
<p>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like <code>x</code>, precedence and associativity do <em>not</em> tell us which of those attempts happens first, or last, or anything.</p>
<hr>
<p>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</p>
<p>These expressions are all fine:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">y = x++;
z = x++ + y++;
x = x + <span class="hljs-number">1</span>;
x = a[i++];
x = a[i++] + b[j++];
x[i++] = a[j++] + b[k++];
x = *p++;
x = *p++ + *q++;
</code></pre>
<p>These expressions are all undefined:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++;
x = x++ + ++x;
y = x + x++;
a[i] = i++;
a[i++] = i;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</p>
<p>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</p>
<ol>
<li>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</li>
<li>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</li>
</ol>
<p>As an example of #1, in the expression</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++ + ++x;
</code></pre>
<p>there are three attempts to modify <code>x</code>.</p>
<p>As an example of #2, in the expression</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">y = x + x++;
</code></pre>
<p>we both use the value of <code>x</code>, and modify it.</p>
<p>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</p>
<hr>
<p>One more thing.  You might be wondering how to "fix" the undefined expressions I started this answer by presenting.</p>
<p>In the case of <code>printf("%d %d %d\n", x, ++x, x++);</code>, it's easy  just write it as three separate <code>printf</code> calls:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, x);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ++x);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x++);
</code></pre>
<p>Now the behavior is perfectly well defined, and you'll get sensible results.</p>
<p>In the case of <code>x = x++ + ++x</code>, on the other hand, there's no way to fix it.  There's no way to write it so that it has guaranteed behavior matching your expectations  but that's okay, because you would never write an expression like <code>x = x++ + ++x</code> in a real program anyway.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A good explanation about what happens in this kind of computation is provided in the document <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf" rel="noreferrer">n1188</a> from <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/" rel="noreferrer">the ISO W14 site</a>.</p>

<p>I explain the ideas.</p>

<p>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</p>
</blockquote>

<p>The sequence points in an expression like <code>i=i++</code> are before <code>i=</code> and after <code>i++</code>.  </p>

<p>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of <code>i=i++</code> there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of <code>expression-statement</code> in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</p>

<p>So the order of instructions inside a box has no clear order.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i=i++
</code></pre>

<p>can be interpreted as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">tmp = i
i=i+<span class="hljs-number">1</span>
i = tmp
</code></pre>

<p>or as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">tmp = i
i = tmp
i=i+<span class="hljs-number">1</span>
</code></pre>

<p>because both all these forms to interpret the code <code>i=i++</code> are valid and because both generate different answers, the behavior is undefined.</p>

<p>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</p>

<p>EDIT:</p>

<p>Other good source for explaining such ambiguities are the entries from <a href="http://c-faq.com/" rel="noreferrer">c-faq</a> site (also published <a href="https://rads.stackoverflow.com/amzn/click/com/0201845199" rel="noreferrer">as a book</a>) , namely <a href="http://c-faq.com/expr/seqpoints.html" rel="noreferrer">here</a> and <a href="http://c-faq.com/expr/evalorder4.html" rel="noreferrer">here</a> and <a href="http://c-faq.com/expr/confused.html" rel="noreferrer">here</a> .</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</p>
<p>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</p>
<p>Using <a href="https://nuwen.net/mingw.html" rel="nofollow noreferrer">Nuwen MinGW</a> 15 GCC 7.1 you will get:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
 {
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    i = i++ + ++i;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2</span>

    i = <span class="hljs-number">1</span>;
    i = (i++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">//1</span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    u = u++ + ++u;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2</span>

    u = <span class="hljs-number">1</span>;
    u = (u++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">//1</span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    v = v++ + ++v;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">//2</span>
 }
</code></pre>
<p>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</p>
<p>according to <a href="http://helpcentreonline.com/article/operator_console_gcc.pdf" rel="nofollow noreferrer">GCC C++: Operators</a></p>
<blockquote>
<p>In GCC C++,  the precedence of the operators controls the order in
which the individual operators are evaluated</p>
</blockquote>
<p>the equivalent code in defined behavior C++ as   GCC understands:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//i = i++ + ++i;</span>
    <span class="hljs-type">int</span> r;
    r=i;
    i++;
    ++i;
    r+=i;
    i=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2</span>

    i = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//i = (i++);</span>
    r=i;
    i++;
    i=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 1</span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//u = u++ + ++u;</span>
    r=u;
    u++;
    ++u;
    r+=u;
    u=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2</span>

    u = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//u = (u++);</span>
    r=u;
    u++;
    u=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 1</span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//v = v++ + ++v;</span>
    r=v;
    v++;
    ++v;
    r+=v;
    v=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">//2</span>
}
</code></pre>
<p>Then we go to <a href="https://www.visualstudio.com/" rel="nofollow noreferrer">Visual Studio</a>. Visual Studio 2015, you get:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    i = i++ + ++i;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

    i = <span class="hljs-number">1</span>;
    i = (i++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    u = u++ + ++u;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 3</span>

    u = <span class="hljs-number">1</span>;
    u = (u++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    v = v++ + ++v;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 </span>
}
</code></pre>
<p>How does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</p>
<p>So the equivalent in defined behavior C++ as Visual C++ understands:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> r;
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//i = i++ + ++i;</span>
    ++i;
    r = i + i;
    i = r;
    i++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

    i = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//i = (i++);</span>
    r = i;
    i = r;
    i++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//u = u++ + ++u;</span>
    ++u;
    r = u + u;
    u = r;
    u++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 3</span>

    u = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//u = (u++);</span>
    r = u;
    u = r;
    u++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//v = v++ + ++v;</span>
    ++v;
    r = v + v;
    v = r;
    v++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 </span>
}
</code></pre>
<p>as Visual Studio documentation states at <a href="https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx" rel="nofollow noreferrer">Precedence and Order of Evaluation</a>:</p>
<blockquote>
<p>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</p>
</blockquote>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can\u0026apos;t predict the behavior when the code is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as I know, the standard doesn\u0026apos;t explicitly say \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; the concept of undefined behavior exists. In my mind, it\u0026apos;s simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, with that in mind, why are these \u0026quot;issues\u0026quot;? The language clearly says that certain things lead to \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;. There is no problem, there is no \u0026quot;should\u0026quot; involved. If the undefined behavior changes when one of the involved variables is declared \u0026lt;code\u0026gt;volatile\u0026lt;/code\u0026gt;, that doesn\u0026apos;t prove or change anything. It is \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt;; you cannot reason about the behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your most interesting-looking example, the one with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;u = (u++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is a text-book example of undefined behavior (see Wikipedia\u0026apos;s entry on \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sequence points\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand \u0026lt;strong\u0026gt;why the behavior of these constructs are undefined\u0026lt;/strong\u0026gt;, let\u0026apos;s understand these terms first in the light of C11 standard:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequenced:\u0026lt;/strong\u0026gt; (5.1.2.3)\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Given any two evaluations \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is sequenced before \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then the execution of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; shall precede the execution of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unsequenced:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is not sequenced before or after \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; are unsequenced.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Evaluations can be one of two things:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;value computations\u0026lt;/strong\u0026gt;, which work out the result of an expression; and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;side effects\u0026lt;/strong\u0026gt;, which are modifications of objects.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequence Point:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The presence of a sequence point between the evaluation of expressions \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; implies that every \u0026lt;em\u0026gt;value computation\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;side effect\u0026lt;/em\u0026gt; associated with \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is sequenced before every \u0026lt;em\u0026gt;value computation\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;side effect\u0026lt;/em\u0026gt; associated with \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Now coming to the question, for the expressions like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\ni = i++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;standard says that:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;6.5 Expressions:\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;If a side effect on a scalar object is unsequenced relative to\u0026lt;/strong\u0026gt; either \u0026lt;strong\u0026gt;a different side effect on the same scalar object\u0026lt;/strong\u0026gt; or a value computation using the value of the same scalar object, \u0026lt;strong\u0026gt;the behavior is undefined\u0026lt;/strong\u0026gt;. [...]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Therefore, the above expression invokes UB because two side effects on the same object \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; will be done before or after the side effect by \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nDepending on whether assignment occurs before or after the increment, different results will be produced and that\u0026apos;s the one of the case of \u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Lets rename the \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; at left of assignment be \u0026lt;code\u0026gt;il\u0026lt;/code\u0026gt; and at the right of assignment (in the expression \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;) be \u0026lt;code\u0026gt;ir\u0026lt;/code\u0026gt;, then the expression be like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;il = ir++     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note that suffix l and r are used for the sake of clarity.\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Both il and ir represents the same object.  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/17935062/2455888\u0026quot;\u0026gt;An important point\u0026lt;/a\u0026gt; regarding Postfix \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; operator is that:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;just because the \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; comes after the variable does not mean that the increment happens late\u0026lt;/strong\u0026gt;. The increment can happen as early as the compiler likes \u0026lt;em\u0026gt;as long as the compiler ensures that the original value is used\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;It means the expression \u0026lt;code\u0026gt;il = ir++\u0026lt;/code\u0026gt; could be evaluated either as\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;temp = ir;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1\u0026lt;/span\u0026gt;\nir = ir + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 2   side effect by ++ before assignment\u0026lt;/span\u0026gt;\nil = temp;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1   result is 1  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;temp = ir;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1\u0026lt;/span\u0026gt;\nil = temp;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1   side effect by assignment before ++\u0026lt;/span\u0026gt;\nir = ir + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 2   result is 2  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;resulting in two different results \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; which depends on the sequence of side effects by assignment and \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and hence invokes UB.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the relevant parts of the C99 standard are 6.5 Expressions, ยง2\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and 6.5.16 Assignment operators, ยง4:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The order of evaluation of the operands is unspecified. If an attempt is made to modify\n  the result of an assignment operator or to access it after the next sequence point, the\n  behavior is undefined. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is what I get on my machine, together with what I think is going on:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ cat evil.c\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;evil\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; function evil:\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026amp;gt;:   push   %ebp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000001\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;:   mov    %esp,%ebp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000003\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\u0026amp;gt;:   sub    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x10\u0026lt;/span\u0026gt;,%esp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000006\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\u0026amp;gt;:   movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 0   i = 0\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000d\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;\u0026amp;gt;:  addl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i++     i = 1\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000011\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;\u0026amp;gt;:  mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp),%eax  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j = i   i = 1  j = 1\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000014\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\u0026amp;gt;:  add    %eax,%eax        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j += j  i = 1  j = 2\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000016\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;\u0026amp;gt;:  add    %eax,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i += j  i = 3\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000019\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;25\u0026lt;/span\u0026gt;\u0026amp;gt;:  addl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i++     i = 4\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000001d\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;29\u0026lt;/span\u0026gt;\u0026amp;gt;:  leave  \n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000001e\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;\u0026amp;gt;:  ret\nEnd of assembler dump.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The behavior can\u0026apos;t really be explained because it invokes both \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Unspecified_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;unspecified behavior\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;, so we can not make any general predictions about this code, although if you read \u0026lt;em\u0026gt;Olve Maudal\u0026apos;s\u0026lt;/em\u0026gt; work such as \u0026lt;a href=\u0026quot;http://www.slideshare.net/olvemaudal/deep-c\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Deep C\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Unspecified and Undefined\u0026lt;/a\u0026gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don\u0026apos;t do that anywhere near production.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So moving on to \u0026lt;em\u0026gt;unspecified behavior\u0026lt;/em\u0026gt;, in \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;draft c99 standard\u0026lt;/a\u0026gt; section\u0026lt;code\u0026gt;6.5\u0026lt;/code\u0026gt; paragraph \u0026lt;em\u0026gt;3\u0026lt;/em\u0026gt; says(\u0026lt;em\u0026gt;emphasis mine\u0026lt;/em\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The grouping of operators and operands is indicated by the syntax.74) Except as specified\n  later (for the function-call (), \u0026amp;amp;\u0026amp;amp;, ||, ?:, and comma operators), \u0026lt;strong\u0026gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So when we have a line like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++ + ++i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we do not know whether \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; will be evaluated first. This is mainly to give the compiler \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/12540468/1708801\u0026quot;\u0026gt;better options for optimization\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We also have \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; here as well since the program is modifying variables(\u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;u\u0026lt;/code\u0026gt;, etc..) more than once between \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sequence points\u0026lt;/a\u0026gt;. From draft standard section \u0026lt;code\u0026gt;6.5\u0026lt;/code\u0026gt; paragraph \u0026lt;em\u0026gt;2\u0026lt;/em\u0026gt;(\u0026lt;em\u0026gt;emphasis mine\u0026lt;/em\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once\u0026lt;/strong\u0026gt; by the evaluation of an expression. Furthermore, \u0026lt;strong\u0026gt;the prior value\n  shall be read only to determine the value to be stored\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;it cites the following code examples as being undefined:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = ++i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i++] = i; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; in each one of these cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unspecified behavior\u0026lt;/em\u0026gt; is defined in the \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;draft c99 standard\u0026lt;/a\u0026gt; in section \u0026lt;code\u0026gt;3.4.4\u0026lt;/code\u0026gt; as:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;use of an unspecified value, or other behavior where this International Standard provides\n  two or more possibilities and imposes no further requirements on which is chosen in any\n  instance\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; is defined in section \u0026lt;code\u0026gt;3.4.3\u0026lt;/code\u0026gt; as:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirements\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and notes that:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, \u0026lt;em\u0026gt;what are they supposed to mean?\u0026lt;/em\u0026gt; \u0026lt;em\u0026gt;What was the programmer trying to do?\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The first fragment asked about, \u0026lt;code\u0026gt;i = i++ + ++i\u0026lt;/code\u0026gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it\u0026apos;s not obvious what it does, there\u0026apos;s no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it\u0026apos;s not obvious to you and me what it\u0026apos;s supposed to do, it\u0026apos;s fine in my book if the compiler can\u0026apos;t figure out what it\u0026apos;s supposed to do, either.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The second fragment, \u0026lt;code\u0026gt;i = i++\u0026lt;/code\u0026gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;C, of course, has a handy shortcut:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This means, \u0026quot;add 1 to i, and assign the result back to i\u0026quot;.  So if we construct a hodgepodge of the two, by writing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what we\u0026apos;re really saying is \u0026quot;add 1 to i, and assign the result back to i, and assign the result back to i\u0026quot;.  We\u0026apos;re confused, so it doesn\u0026apos;t bother me too much if the compiler gets confused, too.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, \u0026quot;If it\u0026apos;s not obvious what an expression using ++ means, don\u0026apos;t write it.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We used to spend countless hours on comp.lang.c discussing expressions like these and \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; they\u0026apos;re undefined.  Two of my longer answers, that try to really explain why, are archived on the web:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.eskimo.com/~scs/readings/undef.950321.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Why doesn\u0026apos;t the Standard define what these do?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.eskimo.com/~scs/readings/precvsooe.960725.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Doesn\u0026apos;t operator precedence determine the order of evaluation?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;http://c-faq.com/expr/seqpoints.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;question 3.8\u0026lt;/a\u0026gt; and the rest of the questions in \u0026lt;a href=\u0026quot;http://c-faq.com/expr/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;section 3\u0026lt;/a\u0026gt; of the \u0026lt;a href=\u0026quot;http://c-faq.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C FAQ list\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Often this question is linked as a duplicate of questions related to code like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or similar variants.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While this is also \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; as stated already, there are subtle differences when \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is involved when comparing to a statement such as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = i++ + i++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;In the following statement:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/language/eval_order\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;order of evaluation\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; of arguments in \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Unspecified_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;unspecified\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. That means, expressions \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; could be evaluated in any order. \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C11 standard\u0026lt;/a\u0026gt; has some relevant descriptions on this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Annex J, unspecified behaviours\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The order in which the function designator, arguments, and\n  subexpressions within the arguments are evaluated in a function call\n  (6.5.2.2).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.4, unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Use of an unspecified value, or other behavior where this\n  International Standard provides two or more possibilities and imposes\n  no further requirements on which is chosen in any instance.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;EXAMPLE An example of unspecified behavior is the order in which the\n  arguments to a function are evaluated.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;unspecified behaviour\u0026lt;/em\u0026gt; itself is NOT an issue. Consider this example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++x, y++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This too has \u0026lt;em\u0026gt;unspecified behaviour\u0026lt;/em\u0026gt; because the order of evaluation of \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y++\u0026lt;/code\u0026gt; is unspecified. But it\u0026apos;s perfectly legal and valid statement. There\u0026apos;s \u0026lt;em\u0026gt;no\u0026lt;/em\u0026gt; undefined behaviour in this statement. Because the modifications (\u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y++\u0026lt;/code\u0026gt;) are done to \u0026lt;em\u0026gt;distinct\u0026lt;/em\u0026gt; objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What renders the following statement \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;as \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; is the fact that these two expressions modify the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; object \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; without an intervening \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;sequence point\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Another detail is that the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; involved in the printf() call is a \u0026lt;em\u0026gt;separator\u0026lt;/em\u0026gt;, not the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Comma_operator\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is an important distinction because the \u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt; does introduce a \u0026lt;em\u0026gt;sequence point\u0026lt;/em\u0026gt; between the evaluation of their operands, which makes the following legal:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j;\n\nj = (++i, i++);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No undefined behaviour here because the comma operator \u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// introduces a sequence point between \u0026apos;++i\u0026apos; and \u0026apos;i++\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;i=%d j=%d\\n\u0026quot;\u0026lt;/span\u0026gt;,i, j); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// prints: i=7 j=6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in \u0026lt;code\u0026gt;j = (++i, i++);\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; increments \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; yields old value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt;) which is assigned to \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt;. Then \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; becomes \u0026lt;code\u0026gt;7\u0026lt;/code\u0026gt; due to post-increment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; in the function call were to be a comma operator then \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will not be a problem. But it invokes \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; because the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; here is a \u0026lt;em\u0026gt;separator\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For those who are new to \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; would benefit from reading \u0026lt;a href=\u0026quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What Every C Programmer Should Know About Undefined Behavior\u0026lt;/a\u0026gt;  to understand the concept and many other variants of undefined behaviour in C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This post: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4105123/1275169\u0026quot;\u0026gt;Undefined, unspecified and implementation-defined behavior\u0026lt;/a\u0026gt; is also relevant.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement \u0026quot;i++\u0026quot; with the sequence:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;In a single operation, read `i` and lock it to prevent access until further notice\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Compute\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;+read_value)\u0026lt;/span\u0026gt;\nIn a single operation, unlock `i` and store the computed value\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While I don\u0026apos;t think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; would get incremented by two) and it\u0026apos;s not totally inconceivable that some future processor might provide a feature something like that.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the compiler were to write \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn\u0026apos;t happen to notice that one of the other instructions happened to access \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is used in both places, but if a routine accepts references to two pointers \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt;, and uses \u0026lt;code\u0026gt;(*p)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;(*q)\u0026lt;/code\u0026gt; in the above expression (rather than using \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object\u0026apos;s address were passed for both \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While the \u0026lt;strong\u0026gt;syntax\u0026lt;/strong\u0026gt; of the expressions like \u0026lt;code\u0026gt;a = a++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;a++ + a++\u0026lt;/code\u0026gt; is legal, the \u0026lt;strong\u0026gt;behaviour\u0026lt;/strong\u0026gt; of these constructs is \u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt; because a \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;shall\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; in C standard is not obeyed. \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99 6.5p2\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;With \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#note73\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;footnote 73\u0026lt;/a\u0026gt; further clarifying that\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;73\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This paragraph renders undefined statement expressions such as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = ++i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i++] = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;while allowing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i] = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The various sequence points are listed in Annex C of \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html#C\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C11\u0026lt;/a\u0026gt; (and \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#C\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The following are the sequence points described in 5.1.2.3:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the first and second operands of the following operators: logical AND \u0026amp;amp;\u0026amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;The end of a full declarator: declarators (6.7.6);\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Immediately before a library function returns (7.1.4).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The wording of the same \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;paragraph in C11\u0026lt;/a\u0026gt; is:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) \u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You can detect such errors in a program by for example using a recent version of GCC with \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-Werror\u0026lt;/code\u0026gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function main:\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on v may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on v may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The important part is to know \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c\u0026quot;\u0026gt;what a sequence point is -- and \u0026lt;em\u0026gt;what is\u0026lt;/em\u0026gt; a sequence point and what \u0026lt;em\u0026gt;isn\u0026apos;t\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. For example the \u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt; is a sequence point, so\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;j = (i ++, ++ i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is well-defined, and will increment \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write \u0026lt;code\u0026gt;j = (i += 2)\u0026lt;/code\u0026gt; which is yet again a \u0026quot;clever\u0026quot; way to write\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\nj = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, the \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; in function argument lists is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, i++, ++i, i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;has \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; because \u0026lt;strong\u0026gt;there is no sequence point between the evaluations of \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; in function arguments\u0026lt;/strong\u0026gt;, and the value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is therefore modified twice, by both \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt;, between the previous and the next sequence point.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. \u0026lt;br\u0026gt;\nSo every statement of the form:\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++;\ni = i++ + ++i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, two different variables can be incremented between two sequence points.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(*src++ = *dst++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above is a common coding practice while copying/analysing strings.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c\u0026quot;\u0026gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c\u0026lt;/a\u0026gt; someone asked about a statement like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; num;\nnum = k[++i+k[++i]] + k[++i];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\u0026quot;\u0026lt;/span\u0026gt;, num);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which prints 7... the OP expected it to print 6.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; increments aren\u0026apos;t guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; executed, then the values of \u0026lt;code\u0026gt;k[]\u0026lt;/code\u0026gt; were read, then the last \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;k[]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;num = k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]+k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] + k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\ni += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your question was probably not, \u0026quot;Why are these constructs undefined behavior in C?\u0026quot;.  Your question was probably, \u0026quot;Why did this code (using \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt;) not give me the value I expected?\u0026quot;, and someone marked your question as a duplicate, and sent you here.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;This\u0026lt;/em\u0026gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I assume you\u0026apos;ve heard the basic definition of C\u0026apos;s \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;--\u0026lt;/code\u0026gt; operators by now, and how the prefix form \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; differs from the postfix form \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But, to your surprise, this program did \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; help you understand  it printed some strange, inexplicable output, suggesting that maybe \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; does something completely different, not at all what you thought it did.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Or, perhaps you\u0026apos;re looking at a hard-to-understand expression like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\nx = x++ + ++x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you\u0026apos;re likely to get two different answers!  What\u0026apos;s up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As you\u0026apos;ve heard by now, these expressions are \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt;, which means that the C language makes no guarantee about what they\u0026apos;ll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that\u0026apos;s not so.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What makes an expression undefined?  Are expressions involving \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;--\u0026lt;/code\u0026gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they\u0026apos;re perfectly well-defined.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For the expressions we\u0026apos;re talking about, what makes them undefined is when there\u0026apos;s too much going on at once, when we can\u0026apos;t tell what order things will happen in, but when the order matters to the result we\u0026apos;ll get.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s go back to the two examples I\u0026apos;ve used in this answer.  When I wrote\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;the question is, before actually calling \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt;, does the compiler compute the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; first, or \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;, or maybe \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt;?  But it turns out \u0026lt;em\u0026gt;we don\u0026apos;t know\u0026lt;/em\u0026gt;.  There\u0026apos;s no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can\u0026apos;t say whether the compiler will do \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; first, then \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we\u0026apos;ll clearly get a different series of numbers printed out.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What about this crazy expression?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++ + ++x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The problem with this expression is that it contains three different attempts to modify the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;: (1) the \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt; part tries to take \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;\u0026apos;s value, add 1, store the new value in \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and return the old value; (2) the \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; part tries to take \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;\u0026apos;s value, add 1, store the new value in \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and return the new value; and (3) the \u0026lt;code\u0026gt;x =\u0026lt;/code\u0026gt; part tries to assign the sum of the other two back to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.  Which of those three attempted assignments will \u0026quot;win\u0026quot;?  Which of the three values will actually determine the final value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;?  Again, and perhaps surprisingly, there\u0026apos;s no rule in C to tell us.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I\u0026apos;ll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, precedence and associativity do \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; tell us which of those attempts happens first, or last, or anything.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;These expressions are all fine:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;y = x++;\nz = x++ + y++;\nx = x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;These expressions are all undefined:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As I said earlier, the undefined expressions are the ones where there\u0026apos;s too much going at once, where you can\u0026apos;t be sure what order things happen in, and where the order matters:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If there\u0026apos;s one variable that\u0026apos;s getting modified (assigned to) in two or more different places, how do you know which modification happens first?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If there\u0026apos;s a variable that\u0026apos;s getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;As an example of #1, in the expression\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++ + ++x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;there are three attempts to modify \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an example of #2, in the expression\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;y = x + x++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;we both use the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and modify it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So that\u0026apos;s the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don\u0026apos;t also attempt to use the value of that variable somewhere else.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;One more thing.  You might be wondering how to \u0026quot;fix\u0026quot; the undefined expressions I started this answer by presenting.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;code\u0026gt;printf(\u0026quot;%d %d %d\\n\u0026quot;, x, ++x, x++);\u0026lt;/code\u0026gt;, it\u0026apos;s easy  just write it as three separate \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; calls:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, ++x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now the behavior is perfectly well defined, and you\u0026apos;ll get sensible results.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;code\u0026gt;x = x++ + ++x\u0026lt;/code\u0026gt;, on the other hand, there\u0026apos;s no way to fix it.  There\u0026apos;s no way to write it so that it has guaranteed behavior matching your expectations  but that\u0026apos;s okay, because you would never write an expression like \u0026lt;code\u0026gt;x = x++ + ++x\u0026lt;/code\u0026gt; in a real program anyway.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A good explanation about what happens in this kind of computation is provided in the document \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;n1188\u0026lt;/a\u0026gt; from \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the ISO W14 site\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I explain the ideas.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The sequence points in an expression like \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; are before \u0026lt;code\u0026gt;i=\u0026lt;/code\u0026gt; and after \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of \u0026lt;code\u0026gt;expression-statement\u0026lt;/code\u0026gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the order of instructions inside a box has no clear order.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i=i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;can be interpreted as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;tmp = i\ni=i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\ni = tmp\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;tmp = i\ni = tmp\ni=i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;because both all these forms to interpret the code \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; are valid and because both generate different answers, the behavior is undefined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Other good source for explaining such ambiguities are the entries from \u0026lt;a href=\u0026quot;http://c-faq.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;c-faq\u0026lt;/a\u0026gt; site (also published \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201845199\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;as a book\u0026lt;/a\u0026gt;) , namely \u0026lt;a href=\u0026quot;http://c-faq.com/expr/seqpoints.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://c-faq.com/expr/evalorder4.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://c-faq.com/expr/confused.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; .\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However if you stick to one compiler, you will find the behavior persistent, as long as you don\u0026apos;t add function calls or pointers, which would make the behavior more messy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;a href=\u0026quot;https://nuwen.net/mingw.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Nuwen MinGW\u0026lt;/a\u0026gt; 15 GCC 7.1 you will get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    i = i++ + ++i;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    i = (i++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    u = u++ + ++u;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    u = (u++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    v = v++ + ++v;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//2\u0026lt;/span\u0026gt;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;according to \u0026lt;a href=\u0026quot;http://helpcentreonline.com/article/operator_console_gcc.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GCC C++: Operators\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In GCC C++,  the precedence of the operators controls the order in\nwhich the individual operators are evaluated\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;the equivalent code in defined behavior C++ as   GCC understands:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = i++ + ++i;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = (i++);\u0026lt;/span\u0026gt;\n    r=i;\n    i++;\n    i=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = u++ + ++u;\u0026lt;/span\u0026gt;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = (u++);\u0026lt;/span\u0026gt;\n    r=u;\n    u++;\n    u=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//v = v++ + ++v;\u0026lt;/span\u0026gt;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//2\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then we go to \u0026lt;a href=\u0026quot;https://www.visualstudio.com/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Visual Studio\u0026lt;/a\u0026gt;. Visual Studio 2015, you get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    i = i++ + ++i;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    i = (i++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    u = u++ + ++u;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    u = (u++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    v = v++ + ++v;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;How does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So the equivalent in defined behavior C++ as Visual C++ understands:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; r;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = i++ + ++i;\u0026lt;/span\u0026gt;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = (i++);\u0026lt;/span\u0026gt;\n    r = i;\n    i = r;\n    i++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = u++ + ++u;\u0026lt;/span\u0026gt;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = (u++);\u0026lt;/span\u0026gt;\n    r = u;\n    u = r;\n    u++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//v = v++ + ++v;\u0026lt;/span\u0026gt;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;as Visual Studio documentation states at \u0026lt;a href=\u0026quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Precedence and Order of Evaluation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"id":81,"title":"Why are these constructs using pre and post-increment undefined behavior?","content":"\n                \n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   i = i++ + ++i;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n   i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   i = (i++);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 Should be 1, no ?\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   u = u++ + ++u;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n   u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   u = (u++);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 Should also be one, no ?\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   v = v++ + ++v;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 (Should be the same as u ?)\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; w = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++w, w); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// shouldn\u0026apos;t this print 1 1\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; }, y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   x[y] = y ++;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// shouldn\u0026apos;t this print 0 8? or 5 0?\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109","postType":"QUESTION","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","tags":[{"id":298,"name":"increment","slug":"increment","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":298}},{"id":299,"name":"operator-precedence","slug":"operator-precedence","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":299}},{"id":301,"name":"sequence-points","slug":"sequence-points","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":301}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>