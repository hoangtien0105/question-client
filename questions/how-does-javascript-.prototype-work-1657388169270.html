<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How does JavaScript .prototype work? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I&#x27;m not that into dynamic programming languages but I&#x27;ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?
var obj = new Object();
obj.prototype.test = function() { alert(&#x27;Hello?&#x27;); };
var obj2 = new obj();
obj2.test();

I remember a lot discussion I had with people a while back (I&#x27;m not exactly sure what I&#x27;m doing) but as I understand it, there&#x27;s no concept of a class. It&#x27;s just an object, and instances of those objects are clones of the original, right?
But what is the exact purpose of this &quot;.prototype&quot; property in JavaScript? How does it relate to instantiating objects?
Update: correct way
var obj = new Object(); // not a functional object
obj.prototype.test = function() { alert(&#x27;Hello?&#x27;); }; // this is wrong!

function MyObject() {} // a first class functional object
MyObject.prototype.test = function() { alert(&#x27;OK&#x27;); } // OK

Also these slides really helped a lot.
    "/><meta property="og:title" content="How does JavaScript .prototype work? | Solutions Checker"/><meta property="og:description" content="I&#x27;m not that into dynamic programming languages but I&#x27;ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?
var obj = new Object();
obj.prototype.test = function() { alert(&#x27;Hello?&#x27;); };
var obj2 = new obj();
obj2.test();

I remember a lot discussion I had with people a while back (I&#x27;m not exactly sure what I&#x27;m doing) but as I understand it, there&#x27;s no concept of a class. It&#x27;s just an object, and instances of those objects are clones of the original, right?
But what is the exact purpose of this &quot;.prototype&quot; property in JavaScript? How does it relate to instantiating objects?
Update: correct way
var obj = new Object(); // not a functional object
obj.prototype.test = function() { alert(&#x27;Hello?&#x27;); }; // this is wrong!

function MyObject() {} // a first class functional object
MyObject.prototype.test = function() { alert(&#x27;OK&#x27;); } // OK

Also these slides really helped a lot.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How does JavaScript .prototype work?","text":"I&apos;m not that into dynamic programming languages but I&apos;ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?\nvar obj = new Object();\nobj.prototype.test = function() { alert(&apos;Hello?&apos;); };\nvar obj2 = new obj();\nobj2.test();\n\nI remember a lot discussion I had with people a while back (I&apos;m not exactly sure what I&apos;m doing) but as I understand it, there&apos;s no concept of a class. It&apos;s just an object, and instances of those objects are clones of the original, right?\nBut what is the exact purpose of this &quot;.prototype&quot; property in JavaScript? How does it relate to instantiating objects?\nUpdate: correct way\nvar obj = new Object(); // not a functional object\nobj.prototype.test = function() { alert(&apos;Hello?&apos;); }; // this is wrong!\n\nfunction MyObject() {} // a first class functional object\nMyObject.prototype.test = function() { alert(&apos;OK&apos;); } // OK\n\nAlso these slides really helped a lot.\n    ","answerCount":26,"upVoteCount":500,"suggestedAnswer":[{"text":"In a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.\n\nIn JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It&apos;s not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.\n\nExample:\n\n\n\n//Define a functional object to hold persons in JavaScript\nvar Person = function(name) {\n  this.name = name;\n};\n\n//Add dynamically to the already defined object a new getter\nPerson.prototype.getName = function() {\n  return this.name;\n};\n\n//Create a new object of type Person\nvar john = new Person(&quot;John&quot;);\n\n//Try the getter\nalert(john.getName());\n\n//If now I modify person, also John gets the updates\nPerson.prototype.sayMyName = function() {\n  alert(&apos;Hello, my name is &apos; + this.getName());\n};\n\n//Call the new method on john\njohn.sayMyName();\n Run code snippetHide resultsExpand snippet\n\n\n\nUntil now I&apos;ve been extending the base object, now I create another object and then inheriting from Person.\n\n//Create a new object of type Customer by defining its constructor. It&apos;s not \n//related to Person for now.\nvar Customer = function(name) {\n    this.name = name;\n};\n\n//Now I link the objects and to do so, we link the prototype of Customer to \n//a new instance of Person. The prototype is the base that will be used to \n//construct all new instances and also, will modify dynamically all already \n//constructed objects because in JavaScript objects retain a pointer to the \n//prototype\nCustomer.prototype = new Person();     \n\n//Now I can call the methods of Person on the Customer, let&apos;s try, first \n//I need to create a Customer.\nvar myCustomer = new Customer(&apos;Dream Inc.&apos;);\nmyCustomer.sayMyName();\n\n//If I add new methods to Person, they will be added to Customer, but if I\n//add new methods to Customer they won&apos;t be added to Person. Example:\nCustomer.prototype.setAmountDue = function(amountDue) {\n    this.amountDue = amountDue;\n};\nCustomer.prototype.getAmountDue = function() {\n    return this.amountDue;\n};\n\n//Let&apos;s try:       \nmyCustomer.setAmountDue(2000);\nalert(myCustomer.getAmountDue());\n\n\nShow code snippet\n\nvar Person = function (name) {\n    this.name = name;\n};\nPerson.prototype.getName = function () {\n    return this.name;\n};\nvar john = new Person(&quot;John&quot;);\nalert(john.getName());\nPerson.prototype.sayMyName = function () {\n    alert(&apos;Hello, my name is &apos; + this.getName());\n};\njohn.sayMyName();\nvar Customer = function (name) {\n    this.name = name;\n};\nCustomer.prototype = new Person();\n\nvar myCustomer = new Customer(&apos;Dream Inc.&apos;);\nmyCustomer.sayMyName();\nCustomer.prototype.setAmountDue = function (amountDue) {\n    this.amountDue = amountDue;\n};\nCustomer.prototype.getAmountDue = function () {\n    return this.amountDue;\n};\nmyCustomer.setAmountDue(2000);\nalert(myCustomer.getAmountDue());\n Run code snippetHide resultsExpand snippet\n\n\n\nWhile as said I can&apos;t call setAmountDue(), getAmountDue() on a Person.\n\n//The following statement generates an error.\njohn.setAmountDue(1000);\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Every JavaScript object has an internal &quot;slot&quot; called [[Prototype]] whose value is either null or an object. You can think of a slot as a property on an object, internal to the JavaScript engine, hidden from the code you write. The square brackets around [[Prototype]] are deliberate, and are an ECMAScript specification convention to denote internal slots. \n\nThe value pointed at by the [[Prototype]] of an object, is colloquially known as &quot;the prototype of that object.&quot; \n\nIf you access a property via the dot (obj.propName) or bracket (obj[&apos;propName&apos;]) notation, and the object does not directly have such a property (ie. an own property, checkable via obj.hasOwnProperty(&apos;propName&apos;)), the runtime looks for a property with that name on the object referenced by the [[Prototype]] instead. If the [[Prototype]] also does not have such a property, its [[Prototype]] is checked in turn, and so on. In this way, the original object&apos;s prototype chain is walked until a match is found, or its end is reached. At the top of the prototype chain is the null value.\n\nModern JavaScript implementations allow read and/or write access to the [[Prototype]] in the following ways:\n\n\nThe new operator (configures the prototype chain on the default object returned from a constructor function),\nThe extends keyword (configures the prototype chain when using the class syntax),\nObject.create will set the supplied argument as the [[Prototype]] of the resulting object,\nObject.getPrototypeOf and Object.setPrototypeOf (get/set the [[Prototype]] after object creation), and\nThe standardized accessor (ie. getter/setter) property named __proto__ (similar to 4.)\n\n\nObject.getPrototypeOf and Object.setPrototypeOf are preferred over __proto__, in part because the behavior of o.__proto__ is unusual when an object has a prototype of null.\n\nAn object&apos;s [[Prototype]] is initially set during object creation.\n\nIf you create a new object via new Func(), the object&apos;s [[Prototype]] will, by default, be set to the object referenced by Func.prototype.\n\nNote that, therefore, all classes, and all functions that can be used with the new operator, have a property named .prototype in addition to their own [[Prototype]] internal slot. This dual use of the word &quot;prototype&quot; is the source of endless confusion amongst newcomers to the language.\n\nUsing new with constructor functions allows us to simulate classical inheritance in JavaScript; although JavaScript&apos;s inheritance system is - as we have seen - prototypical, and not class-based.\n\nPrior to the introduction of class syntax to JavaScript, constructor functions were the only way to simulate classes. We can think of properties of the object referenced by the constructor function&apos;s .prototype property as shared members; ie. members which are the same for each instance. In class-based systems, methods are implemented the same way for each instance, so methods are conceptually added to the .prototype property; an object&apos;s fields, however, are instance-specific and are therefore added to the object itself during construction.\n\nWithout the class syntax, developers had to manually configure the prototype chain to achieve similar functionality to classical inheritance. This led to a preponderance of different ways to achieve this. \n\nHere&apos;s one way:\n\nfunction Child() {}\nfunction Parent() {}\nParent.prototype.inheritedMethod = function () { return &apos;this is inherited&apos; }\n\nfunction inherit(child, parent) {\n  child.prototype = Object.create(parent.prototype)\n  child.prototype.constructor = child\n  return child;\n}\n\nChild = inherit(Child, Parent)\nconst o = new Child\nconsole.log(o.inheritedMethod()) // &apos;this is inherited&apos;\n\n\n...and here&apos;s another way:\n\nfunction Child() {}\nfunction Parent() {}\nParent.prototype.inheritedMethod = function () { return &apos;this is inherited&apos; }\n\nfunction inherit(child, parent) {\n    function tmp() {}\n    tmp.prototype = parent.prototype\n    const proto = new tmp()\n    proto.constructor = child\n    child.prototype = proto\n    return child\n}\n\nChild = inherit(Child, Parent)\nconst o = new Child\nconsole.log(o.inheritedMethod()) // &apos;this is inherited&apos;\n\n\nThe class syntax introduced in ES2015 simplifies things, by providing extends as the &quot;one true way&quot; to configure the prototype chain in order to simulate classical inheritance in JavaScript.\n\nSo, similar to the code above, if you use the class syntax to create a new object like so:\n\nclass Parent { inheritedMethod() { return &apos;this is inherited&apos; } }\nclass Child extends Parent {}\n\nconst o = new Child\nconsole.log(o.inheritedMethod()) // &apos;this is inherited&apos;\n\n\n...the resulting object&apos;s [[Prototype]] will be set to an instance of Parent, whose [[Prototype]], in turn, is Parent.prototype.\n\nFinally, if you create a new object via Object.create(foo), the resulting object&apos;s [[Prototype]] will be set to foo.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This is a very simple prototype based object model that would be considered as a sample during the explanation, with no comment yet:\n\nfunction Person(name){\n    this.name = name;\n}\nPerson.prototype.getName = function(){\n    console.log(this.name);\n}\nvar person = new Person(&quot;George&quot;);\n\n\n\n\nThere are some crucial points that we have to consider before going through the prototype concept.\n\n1- How JavaScript functions actually work:\n\nTo take the first step we have to figure out, how JavaScript functions actually work , as a class like function using this keyword in it or just as a regular function with its arguments, what it does and what it returns.\n\nLet&apos;s say we want to create a Person object model. but in this step I&apos;m gonna be trying to do the same exact thing without using prototype and new keyword.\n\nSo in this step functions, objects and this keyword, are all we have.\n\nThe first question would be how this keyword could be useful without using new keyword.\n\nSo to answer that let&apos;s say we have an empty object, and two functions like:\n\nvar person = {};\nfunction Person(name){  this.name = name;  }\n\nfunction getName(){\n    console.log(this.name);\n}\n\n\nand now without using new keyword how we could use these functions. So JavaScript has 3 different ways to do that:\n\na. first way is just to call the function as a regular function:\n\nPerson(&quot;George&quot;);\ngetName();//would print the &quot;George&quot; in the console\n\n\nin this case, this would be the current context object, which is usually is the global  window object in the browser or GLOBAL in Node.js. It means we would have, window.name in browser or GLOBAL.name in Node.js, with &quot;George&quot; as its value.\n\nb. We can attach them to an object, as its properties\n\n-The easiest way to do this is modifying the empty person object, like:\n\nperson.Person = Person;\nperson.getName = getName;\n\n\nthis way we can call them like:\n\nperson.Person(&quot;George&quot;);\nperson.getName();// --&gt;&quot;George&quot;\n\n\nand now the person object is like:\n\nObject {Person: function, getName: function, name: &quot;George&quot;}\n\n\n\n\n-The other way to attach a property to an object is using the prototype of that object that can be find in any JavaScript object with the name of __proto__, and I have tried to explain it a bit on the summary part. So we could get the similar result by doing:\n\nperson.__proto__.Person = Person;\nperson.__proto__.getName = getName;\n\n\nBut this way what we actually are doing is modifying the Object.prototype, because whenever we create a JavaScript object using literals ({ ... }), it gets created based on Object.prototype, which means it gets attached to the newly created object as an attribute named __proto__ , so if we change it, as we have done on our previous code snippet, all the JavaScript objects would get changed, not a good practice. So what could be the better practice now:\n\nperson.__proto__ = {\n    Person: Person,\n    getName: getName\n};\n\n\nand now other objects are in peace, but it still doesn&apos;t seem to be a good practice. So we have still one more solutions, but to use this solution we should get back to that line of code where person object got created (var person = {};) then change it like:\n\nvar propertiesObject = {\n    Person: Person,\n    getName: getName\n};\nvar person = Object.create(propertiesObject);\n\n\nwhat it does is creating a new JavaScript Object and attach the propertiesObject to the __proto__ attribute. So to make sure you can do:\n\nconsole.log(person.__proto__===propertiesObject); //true\n\n\nBut the tricky point here is you have access to all the properties defined in __proto__ on the first level of the person object(read the summary part for more detail).\n\n\n\nas you see using any of these two way this would exactly point to the person object.\n\nc. JavaScript has another way to provide the function with this, which is using call or apply to invoke the function.\n\n\n  The apply() method calls a function with a given this value and\n  arguments provided as an array (or an array-like object).\n\n\nand\n\n\n  The call() method calls a function with a given this value and\n  arguments provided individually.\n\n\nthis way which is my favorite, we can easily call our functions like:\n\nPerson.call(person, &quot;George&quot;);\n\n\nor\n\n//apply is more useful when params count is not fixed\nPerson.apply(person, [&quot;George&quot;]);\n\ngetName.call(person);   \ngetName.apply(person);\n\n\nthese 3 methods are the important initial steps to figure out the .prototype functionality.\n\n\n\n2- How does the new keyword work?\n\nthis is the second step to understand the .prototype functionality.this is what I use to simulate the process:\n\nfunction Person(name){  this.name = name;  }\nmy_person_prototype = { getName: function(){ console.log(this.name); } };\n\n\nin this part I&apos;m gonna be trying to take all the steps which JavaScript takes, without using the new keyword and prototype, when you use new keyword. so when we do new Person(&quot;George&quot;), Person function serves as a constructor, These are what JavaScript does, one by one:\n\na. first of all it makes an empty object, basically an empty hash like:\n\nvar newObject = {};\n\n\nb. the next step that JavaScript takes is to attach the all prototype objects to the newly created object\n\nwe have my_person_prototype here similar to the prototype object.\n\nfor(var key in my_person_prototype){\n    newObject[key] = my_person_prototype[key];\n}\n\n\nIt is not the way that JavaScript actually attaches the properties that are defined in the prototype. The actual way is related to the prototype chain concept.\n\n\n\na. &amp; b. Instead of these two steps you can have the exact same result by doing:\n\nvar newObject = Object.create(my_person_prototype);\n//here you can check out the __proto__ attribute\nconsole.log(newObject.__proto__ === my_person_prototype); //true\n//and also check if you have access to your desired properties\nconsole.log(typeof newObject.getName);//&quot;function&quot;\n\n\nnow we can call the getName function in our my_person_prototype:\n\nnewObject.getName();\n\n\nc. then it gives that object to the constructor,\n\nwe can do this with our sample like:\n\nPerson.call(newObject, &quot;George&quot;);\n\n\nor\n\nPerson.apply(newObject, [&quot;George&quot;]);\n\n\nthen the constructor can do whatever it wants, because this inside of that constructor is the object that was just created.\n\nnow the end result before simulating the other steps:\n    Object {name: &quot;George&quot;}\n\n\n\nSummary:\n\nBasically, when you use the new keyword on a function, you are calling on that and that function serves as a constructor, so when you say:\n\nnew FunctionName()\n\n\nJavaScript internally makes an object, an empty hash and then it gives that object to the constructor, then the constructor can do whatever it wants, because this inside of that constructor is the object that was just created and then it gives you that object of course if you haven&apos;t used the return statement in your function or if you&apos;ve put a return undefined; at the end of your function body.\n\nSo when JavaScript goes to look up a property on an object, the first thing it does, is it looks it up on that object. And then there is a secret property [[prototype]] which we usually have it like __proto__ and that property is what JavaScript looks at next. And when it looks through the __proto__, as far as it is again another JavaScript object, it has its own __proto__ attribute, it goes up and up until it gets to the point where the next __proto__ is null. The point is the only object in JavaScript that its __proto__ attribute is null is Object.prototype object:\n\nconsole.log(Object.prototype.__proto__===null);//true\n\n\nand that&apos;s how inheritance works in JavaScript.\n\n\n\nIn other words, when you have a prototype property on a function and you call a new on that, after JavaScript finishes looking at that newly created object for properties, it will go look at the function&apos;s .prototype and also it is possible that this object has its own internal prototype. and so on.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"prototype allows you to make classes. if you do not use prototype then it becomes a static.\n\nHere is a short example.\n\nvar obj = new Object();\nobj.test = function() { alert(&apos;Hello?&apos;); };\n\n\nIn the above case, you have static funcation call test. This function can be accessed only by obj.test where you can imagine obj to be a class.\n\nwhere as in the below code\n\nfunction obj()\n{\n}\n\nobj.prototype.test = function() { alert(&apos;Hello?&apos;); };\nvar obj2 = new obj();\nobj2.test();\n\n\nThe obj has become a class which can now be instantiated. Multiple instances of obj can exist and they all have the test function.\n\nThe above is my understanding. I am making it a community wiki, so people can correct me if I am wrong.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The seven Koans of prototype\n\nAs Ciro San descended Mount Fire Fox after deep meditation, his mind was clear and peaceful.\n\nHis hand however, was restless, and by itself grabbed a brush and jotted down the following notes.\n\n\n\n0) Two different things can be called &quot;prototype&quot;:\n\n\nthe prototype property, as in obj.prototype\nthe prototype internal property, denoted as [[Prototype]] in ES5.\n\nIt can be retrieved via the ES5 Object.getPrototypeOf().\n\nFirefox makes it accessible through the __proto__ property as an extension. ES6 now mentions some optional requirements for __proto__.\n\n\n\n\n1) Those concepts exist to answer the question:\n\n\n  When I do obj.property, where does JS look for .property?\n\n\nIntuitively, classical inheritance should affect property lookup.\n\n\n\n2)\n\n\n__proto__ is used for the dot . property lookup as in obj.property. \n.prototype is not used for lookup directly, only indirectly as it determines __proto__ at object creation with new.\n\n\nLookup order is:\n\n\nobj properties added with obj.p = ... or Object.defineProperty(obj, ...)\nproperties of obj.__proto__\nproperties of obj.__proto__.__proto__, and so on\nif some __proto__ is null, return undefined.\n\n\nThis is the so-called prototype chain.\n\nYou can avoid . lookup with obj.hasOwnProperty(&apos;key&apos;) and Object.getOwnPropertyNames(f)\n\n\n\n3) There are two main ways to set obj.__proto__:\n\n\nnew:\n\nvar F = function() {}\nvar f = new F()\n\n\nthen new has set:\n\nf.__proto__ === F.prototype\n\n\nThis is where .prototype gets used.\nObject.create:\n\n f = Object.create(proto)\n\n\nsets:\n\nf.__proto__ === proto\n\n\n\n\n\n4) The code:\n\nvar F = function(i) { this.i = i }\nvar f = new F(1)\n\n\nCorresponds to the following diagram (some Number stuff is omitted):\n\n(Function)       (  F  )                                      (f)-----&gt;(1)\n |  ^             | | ^                                        |   i    |\n |  |             | | |                                        |        |\n |  |             | | +-------------------------+              |        |\n |  |constructor  | |                           |              |        |\n |  |             | +--------------+            |              |        |\n |  |             |                |            |              |        |\n |  |             |                |            |              |        |\n |[[Prototype]]   |[[Prototype]]   |prototype   |constructor   |[[Prototype]]\n |  |             |                |            |              |        |\n |  |             |                |            |              |        |\n |  |             |                | +----------+              |        |\n |  |             |                | |                         |        |\n |  |             |                | | +-----------------------+        |\n |  |             |                | | |                                |\n v  |             v                v | v                                |\n(Function.prototype)              (F.prototype)                         |\n |                                 |                                    |\n |                                 |                                    |\n |[[Prototype]]                    |[[Prototype]]          [[Prototype]]|\n |                                 |                                    |\n |                                 |                                    |\n | +-------------------------------+                                    |\n | |                                                                    |\n v v                                                                    v\n(Object.prototype)                                       (Number.prototype)\n | | ^\n | | |\n | | +---------------------------+\n | |                             |\n | +--------------+              |\n |                |              |\n |                |              |\n |[[Prototype]]   |constructor   |prototype\n |                |              |\n |                |              |\n |                | -------------+\n |                | |\n v                v |\n(null)           (Object)\n\n\nThis diagram shows many language predefined object nodes:\n\n\nnull\nObject\nObject.prototype\nFunction\nFunction.prototype\n1\nNumber.prototype (can be found with (1).__proto__, parenthesis mandatory to satisfy syntax)\n\n\nOur 2 lines of code only created the following new objects:\n\n\nf\nF\nF.prototype\n\n\ni is now a property of f because when you do:\n\nvar f = new F(1)\n\n\nit evaluates F with this being the value that new will return, which then gets assigned to f.\n\n\n\n5) .constructor normally comes from F.prototype through the . lookup:\n\nf.constructor === F\n!f.hasOwnProperty(&apos;constructor&apos;)\nObject.getPrototypeOf(f) === F.prototype\nF.prototype.hasOwnProperty(&apos;constructor&apos;)\nF.prototype.constructor === f.constructor\n\n\nWhen we write f.constructor, JavaScript does the . lookup as:\n\n\nf does not have .constructor\nf.__proto__ === F.prototype has .constructor === F, so take it\n\n\nThe result f.constructor == F is intuitively correct, since F is used to construct f, e.g. set fields, much like in classic OOP languages. \n\n\n\n6) Classical inheritance syntax can be achieved by manipulating prototypes chains.\n\nES6 adds the class and extends keywords, which are mostly syntax sugar for previously possible prototype manipulation madness.\n\nclass C {\n    constructor(i) {\n        this.i = i\n    }\n    inc() {\n        return this.i + 1\n    }\n}\n\nclass D extends C {\n    constructor(i) {\n        super(i)\n    }\n    inc2() {\n        return this.i + 2\n    }\n}\n\n\n\n\n// Inheritance syntax works as expected.\nc = new C(1)\nc.inc() === 2\n(new D(1)).inc() === 2\n(new D(1)).inc2() === 3\n\n\n\n\n// &quot;Classes&quot; are just function objects.\nC.constructor === Function\nC.__proto__ === Function.prototype\nD.constructor === Function\n// D is a function &quot;indirectly&quot; through the chain.\nD.__proto__ === C\nD.__proto__.__proto__ === Function.prototype\n\n\n\n\n// &quot;extends&quot; sets up the prototype chain so that base class\n// lookups will work as expected\nvar d = new D(1)\nd.__proto__ === D.prototype\nD.prototype.__proto__ === C.prototype\n// This is what `d.inc` actually does.\nd.__proto__.__proto__.inc === C.prototype.inc\n\n\n\n\n// Class variables\n// No ES6 syntax sugar apparently:\n// http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives\nC.c = 1\nC.c === 1\n// Because `D.__proto__ === C`.\nD.c === 1\n// Nothing makes this work.\nd.c === undefined\n\n\nSimplified diagram without all predefined objects:\n\n(c)-----&gt;(1)\n |   i\n |\n |\n |[[Prototype]]\n |\n |\n v    __proto__\n(C)&lt;--------------(D)         (d)\n| |                |           |\n| |                |           |\n| |prototype       |prototype  |[[Prototype]] \n| |                |           |\n| |                |           |\n| |                | +---------+\n| |                | |\n| |                | |\n| |                v v\n|[[Prototype]]    (D.prototype)--------&gt; (inc2 function object)\n| |                |             inc2\n| |                |\n| |                |[[Prototype]]\n| |                |\n| |                |\n| | +--------------+\n| | |\n| | |\n| v v\n| (C.prototype)-------&gt;(inc function object)\n|                inc\nv\nFunction.prototype\n\n\nLet&apos;s take a moment to study how the following works:\n\nc = new C(1)\nc.inc() === 2\n\n\nThe first line sets c.i to 1 as explained in &quot;4)&quot;.\n\nOn the second line, when we do:\n\nc.inc()\n\n\n\n.inc is found through the [[Prototype]] chain: c -&gt; C -&gt; C.prototype -&gt; inc\nwhen we call a function in Javascript as X.Y(), JavaScript automatically sets this to equal X inside the Y() function call! \n\n\nThe exact same logic also explains d.inc and d.inc2.\n\nThis article https://javascript.info/class#not-just-a-syntax-sugar mentions further effects of class worth knowing. Some of them may not be achievable without the class keyword (TODO check which):\n\n\n[[FunctionKind]]:&quot;classConstructor&quot;, which forces the constructor to be called with new: What is the reason ES6 class constructors can&apos;t be called as normal functions?\nClass methods are non-enumerable. Can be done with Object.defineProperty.\nClasses always use strict. Can be done with an explicit use strict for every function, which is admittedly tedious.\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"After reading this thread, I feel confused with JavaScript Prototype Chain, then I found these charts \n\nhttp://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance\n\n\nit&apos;s a clear chart to show JavaScript Inheritance by Prototype Chain\n\nand \n\nhttp://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/\n\nthis one contains a example with code and several nice diagrams.\n\n\n  prototype chain ultimately falls back to Object.prototype. \n  \n  prototype chain can be technically extended as long as you want, each time by setting the prototype of the subclass equal to an object of the parent class.\n\n\nHope it&apos;s also helpful for you to understand JavaScript Prototype Chain.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Every object has an internal property, [[Prototype]], linking it to another object:\n\nobject [[Prototype]]  anotherObject\n\n\nIn traditional javascript, the linked object is the prototype property of a function:\n\nobject [[Prototype]]  aFunction.prototype\n\n\nSome environments expose [[Prototype]] as __proto__:\n\nanObject.__proto__ === anotherObject\n\n\nYou create the [[Prototype]] link when creating an object.\n\n// (1) Object.create:\nvar object = Object.create(anotherObject)\n// object.__proto__ = anotherObject\n\n// (2) ES6 object initializer:\nvar object = { __proto__: anotherObject };\n// object.__proto__ = anotherObject\n\n// (3) Traditional JavaScript:\nvar object = new aFunction;\n// object.__proto__ = aFunction.prototype\n\n\nSo these statements are equivalent:\n\nvar object = Object.create(Object.prototype);\nvar object = { __proto__: Object.prototype }; // ES6 only\nvar object = new Object;\n\n\nYou can&apos;t actually see the link target (Object.prototype) in a new statement; instead the target is implied by the constructor (Object).\n\nRemember:\n\n\nEvery object has a link, [[Prototype]], sometimes exposed as __proto__.\nEvery function has a prototype property, initially holding an empty object.\nObjects created with new are linked to the prototype property of their constructor.\nIf a function is never used as a constructor, its prototype property will go unused.\nIf you don&apos;t need a constructor, use Object.create instead of new.\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Javascript doesn&apos;t have inheritance in the usual sense, but it has the prototype chain.\n\nprototype chain\n\nIf a member of an object can&apos;t be found in the object it looks for it in the prototype chain. The chain consists of other objects. The prototype of a given instance can be accessed with the __proto__ variable. Every object has one, as there is no difference between classes and instances in javascript.\n\nThe advantage of adding a function / variable to the prototype is that it has to be in the memory only once, not for every instance.\n\nIt&apos;s also useful for inheritance, because the prototype chain can consist of many other objects.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"This article is long. But I am sure it will clear most of your queries \nregarding the &quot;prototypical&quot; nature of JavaScript Inheritance. And even more. Please read the complete article.\n\nJavaScript basically has two kinds of data types\n\n\nNon objects \nObjects\n\n\nNon objects\n\nFollowing are the Non object data types\n\n\nstring\nnumber (including NaN and Infinity)\nboolean values(true,false) \nundefined\n\n\nThese data types return following when you use the typeof operator \n\ntypeof &quot;string literal&quot; (or a variable containing string literal)  === &apos;string&apos;\n\ntypeof 5 (or any numeric literal or a variable containing numeric literal or NaN or Infynity)  === &apos;number&apos;\n\ntypeof true (or false or a variable containing true or false)  === &apos;boolean&apos;\n\ntypeof undefined (or an undefined variable or a variable containing undefined) === &apos;undefined&apos;\n\nThe string,number and boolean data types can be represented both as Objects and Non objects.When they are represented as objects their typeof is always === &apos;object&apos;. We shall come back to this once we understand the object data types.\n\nObjects\n\nThe object datatypes can be further divided into two types\n\n\nFunction type objects\nNon Function type objects\n\n\nThe Function type objects are the ones that return the string &apos;function&apos; with typeof operator. \nAll the user defined functions and all the JavaScript built in objects that can create new objects by using new operator fall into this category. For eg.\n\n\nObject\nString \nNumber  \nBoolean\nArray \nTyped Arrays\nRegExp\nFunction \nAll the other built in objects that can create new objects by using new operator\nfunction UserDefinedFunction(){ /*user defined code */ }\n\n\nSo,\ntypeof(Object) === typeof(String) === typeof(Number) === typeof(Boolean) === typeof(Array)  === typeof(RegExp) === typeof(Function)  === typeof(UserDefinedFunction) === &apos;function&apos;\n\nAll the Function type objects are actually instances of the built in JavaScript object Function (including the Function object i.e it is recursively defined). It is as if the these objects have been defined in the following way\n\nvar Object= new Function ([native code for object Object])\nvar String= new Function ([native code for object String])\nvar Number= new Function ([native code for object Number])\nvar Boolean= new Function ([native code for object Boolean])\nvar Array= new Function ([native code for object Array])\nvar RegExp= new Function ([native code for object RegExp])\nvar Function= new Function ([native code  for object Function])\nvar UserDefinedFunction= new Function (&quot;user defined code&quot;)\n\n\nAs mentioned, the Function type objects can further create new objects using the new operator. For e.g an object of type Object, String, Number, Boolean, Array, RegExp  Or UserDefinedFunction can be created by using\n\nvar a=new Object() or var a=Object() or var a={} //Create object of type Object\nvar a=new String() //Create object of type String\nvar a=new Number() //Create object of type Number\nvar a=new Boolean() //Create object of type Boolean\nvar a=new Array() or var a=Array() or var a=[]  //Create object of type Array\nvar a=new RegExp() or var a=RegExp() //Create object of type RegExp\nvar a=new UserDefinedFunction() \n\n\nThe objects thus created are all Non Function type objects and return their typeof===&apos;object&apos;. In all these cases the object &quot;a&quot; cannot further create \nobjects using operator new. So the following is wrong\n\nvar b=new a() //error. a is not typeof===&apos;function&apos;\n\n\nThe built in object Math is typeof===&apos;object&apos;. Hence a new object of type Math cannot be created by new operator.\n\nvar b=new Math() //error. Math is not typeof===&apos;function&apos;\n\n\nAlso notice that Object,Array and RegExp functions can create a new object without even using operator new. However the follwing ones don&apos;t.\n\nvar a=String() // Create a new Non Object string. returns a typeof===&apos;string&apos; \nvar a=Number() // Create a new Non Object Number. returns a typeof===&apos;number&apos;\nvar a=Boolean() //Create a new Non Object Boolean. returns a typeof===&apos;boolean&apos;\n\n\nThe user defined functions are special case. \n\nvar a=UserDefinedFunction() //may or may not create an object of type UserDefinedFunction() based on how it is defined.\n\n\nSince the Function type objects can create new objects they are also called Constructors.\n\nEvery Constructor/Function (whether built in or user defined) when defined automatically has a property called &quot;prototype&quot; whose value by default is set as an object. This object itself has a property called &quot;constructor&quot; which by default references back the Constructor/Function .\n\nFor example when we define a function\n\nfunction UserDefinedFunction()\n{\n}\n\n\nfollowing automatically happens\n\nUserDefinedFunction.prototype={constructor:UserDefinedFunction}\n\n\nThis &quot;prototype&quot; property is only present in the Function type objects \n(and never in Non Function type objects). \n\nThis is because when a new object is created (using new operator)it inherits all properties and methods from Constructor function&apos;s current prototype object i.e. an internal reference is created in the newly created object that references the object referenced by Constructor function&apos;s current prototype object.\n\nThis &quot;internal reference&quot; that is created in the object for referencing inherited properties is known as the object&apos;s prototype (which references the object referenced by Constructor&apos;s &quot;prototype&quot; property but is different from it). For any object (Function or Non Function) this can be retrieved using Object.getPrototypeOf() method. Using this method one can trace the prototype chain of an object. \n\nAlso, every object that is created (Function type or Non Function type) has a &quot;constructor&quot; property which is inherited from the object referenced by prototype  property of the Constructor function. By default this &quot;constructor&quot; property references the Constructor function that created it (if the Constructor Function&apos;s default &quot;prototype&quot; is not changed). \n\nFor all Function type objects the constructor function is always\nfunction Function(){}\n\nFor Non Function type objects (e.g Javascript Built in  Math object) the constructor function is the function that created it.\nFor Math object it is function Object(){}. \n\nAll the concept explained above can be a little daunting to understand without any supporting code. Please go through the following code line by line to understand the concept. Try to execute it to have a better understanding.\n\nfunction UserDefinedFunction()\n{ \n\n} \n\n/* creating the above function automatically does the following as mentioned earlier\n\nUserDefinedFunction.prototype={constructor:UserDefinedFunction}\n\n*/\n\n\nvar newObj_1=new UserDefinedFunction()\n\nalert(Object.getPrototypeOf(newObj_1)===UserDefinedFunction.prototype)  //Displays true\n\nalert(newObj_1.constructor) //Displays function UserDefinedFunction\n\n//Create a new property in UserDefinedFunction.prototype object\n\nUserDefinedFunction.prototype.TestProperty=&quot;test&quot;\n\nalert(newObj_1.TestProperty) //Displays &quot;test&quot;\n\nalert(Object.getPrototypeOf(newObj_1).TestProperty)// Displays &quot;test&quot;\n\n//Create a new Object\n\nvar objA = {\n        property1 : &quot;Property1&quot;,\n        constructor:Array\n\n}\n\n\n//assign a new object to UserDefinedFunction.prototype\nUserDefinedFunction.prototype=objA\n\nalert(Object.getPrototypeOf(newObj_1)===UserDefinedFunction.prototype)  //Displays false. The object referenced by UserDefinedFunction.prototype has changed\n\n//The internal reference does not change\nalert(newObj_1.constructor) // This shall still Display function UserDefinedFunction\n\nalert(newObj_1.TestProperty) //This shall still Display &quot;test&quot; \n\nalert(Object.getPrototypeOf(newObj_1).TestProperty) //This shall still Display &quot;test&quot;\n\n\n//Create another object of type UserDefinedFunction\nvar newObj_2= new UserDefinedFunction();\n\nalert(Object.getPrototypeOf(newObj_2)===objA) //Displays true.\n\nalert(newObj_2.constructor) //Displays function Array()\n\nalert(newObj_2.property1) //Displays &quot;Property1&quot;\n\nalert(Object.getPrototypeOf(newObj_2).property1) //Displays &quot;Property1&quot;\n\n//Create a new property in objA\nobjA.property2=&quot;property2&quot;\n\nalert(objA.property2) //Displays &quot;Property2&quot;\n\nalert(UserDefinedFunction.prototype.property2) //Displays &quot;Property2&quot;\n\nalert(newObj_2.property2) // Displays Property2\n\nalert(Object.getPrototypeOf(newObj_2).property2) //Displays  &quot;Property2&quot;\n\n\nThe prototype chain of every object ultimately traces back to Object.prototype (which itself does not have any prototype object) .\nFollowing code can be used for tracing the prototype chain of an object\n\nvar o=Starting object;\n\ndo {\n    alert(o + &quot;\\n&quot; + Object.getOwnPropertyNames(o))\n\n}while(o=Object.getPrototypeOf(o))\n\n\nThe prototype chain for various objects work out as follows.\n\n\nEvery Function object (including built in Function object)-&gt;\nFunction.prototype -&gt; Object.prototype -&gt; null   \nSimple Objects (created By new Object() or {} including built in Math  object)-&gt;   Object.prototype -&gt; null\nObject created with new or Object.create -&gt; One or More prototype chains -&gt; Object.prototype -&gt; null\n\n\nFor creating an object without any prototype use the following:\n\nvar o=Object.create(null)\nalert(Object.getPrototypeOf(o)) //Displays null\n\n\nOne might think that setting the prototype property of the Constructor to null shall create an object with a null prototype. However in such cases the newly created object&apos;s prototype is set to Object.prototype and its constructor is set to function Object. This is demonstrated by the following code\n\nfunction UserDefinedFunction(){}\nUserDefinedFunction.prototype=null// Can be set to any non object value (number,string,undefined etc.)\n\nvar o=new UserDefinedFunction()\nalert(Object.getPrototypeOf(o)==Object.prototype)   //Displays true\nalert(o.constructor)    //Displays Function Object\n\n\nFollowing in the summary of this article\n\n\nThere are two types of objects Function types and Non Function types\nOnly Function type objects can create a new object using the operator new. The objects thus created are Non Function type objects. The Non Function type objects cannot further create an object using operator new.\nAll Function type objects by default have a &quot;prototype&quot; property. This &quot;prototype&quot; property references an object that has a &quot;constructor&quot; property that by default references the Function type object itself.  \nAll objects (Function type and Non Function type) have a &quot;constructor&quot; property that by default references the Function type object/Constructor that created it.\nEvery object that gets created internally references the object referenced by\n&quot;prototype&quot; property of the Constructor that created it. This object is known as the created object&apos;s prototype (which is different from Function type objects &quot;prototype&quot; property which it references) . This way the created object can directly access the methods and properties defined in object referenced by the Constructor&apos;s &quot;prototype&quot; property (at the time of object creation).\nAn object&apos;s prototype (and hence its inherited property names) can be retrieved using the Object.getPrototypeOf()   method. In fact this method \ncan be used for navigating the entire prototype chain of the object.\nThe prototype chain of every object ultimately traces back to Object.prototype (Unless the object is created using Object.create(null) in which case the object has no prototype).\ntypeof(new Array())===&apos;object&apos; is by design of language and not a mistake as pointed by Douglas Crockford  \nSetting the prototype property of the Constructor to null(or undefined,number,true,false,string) shall not create an object with a null prototype. In such cases the newly created object&apos;s prototype is set to Object.prototype and its constructor is set to function Object. \n\n\nHope this helps.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"It may help to categorise prototype chains into two categories.\n\nConsider the constructor:\n\n function Person() {}\n\n\nThe value of Object.getPrototypeOf(Person) is a function. In fact, it is Function.prototype. Since Person was created as a function, it shares the same prototype function object that all functions have. It is the same as Person.__proto__, but that property should not be used. Anyway, with Object.getPrototypeOf(Person) you effectively walk up the ladder of what is called the prototype chain.\n\nThe chain in upward direction looks like this:\n\n    Person  Function.prototype  Object.prototype (end point)\n\nImportant is that this prototype chain has little to do with the objects that Person can construct. Those constructed objects have their own prototype chain, and this chain can potentially have no close ancestor in common with the one mentioned above.\n\nTake for example this object:\n\nvar p = new Person();\n\n\np has no direct prototype-chain relationship with Person. Their relationship is a different one. The object p has its own prototype chain. Using Object.getPrototypeOf, you&apos;ll find the chain is as follows:\n\n    p  Person.prototype  Object.prototype (end point)\n\nThere is no function object in this chain (although that could be).\n\nSo Person seems related to two kinds of chains, which live their own lives. To &quot;jump&quot; from one chain to the other, you use:\n\n\n.prototype: jump from the constructor&apos;s chain to the created-object&apos;s chain. This property is thus only defined for function objects (as new can only be used on functions).\n.constructor: jump from the created-object&apos;s chain to the constructor&apos;s chain.\n\n\nHere is a visual presentation of the two prototype chains involved, represented as columns:\n\n\n\nTo summarise:\n\n\n  The prototype property gives no information of the subject&apos;s prototype chain, but of objects created by the subject. \n\n\nIt is no surprise that the name of the property prototype can lead to confusion. It would maybe have been clearer if this property had been named prototypeOfConstructedInstances or something along that line.\n\nYou can jump back and forth between the two prototype chains:\n\nPerson.prototype.constructor === Person\n\n\nThis symmetry can be broken by explicitly assigning a different object to the prototype property (more about that later).\n\nCreate one Function, Get Two Objects\n\nPerson.prototype is an object that was created at the same time the function Person was created. It has Person as constructor, even though that constructor did not actually execute yet. So two objects are created at the same time:\n\n\nThe function Person itself\nThe object that will act as prototype when the function is called as a constructor\n\n\nBoth are objects, but they have different roles: the function object constructs, while the other object represents the prototype of any object that function will construct. The prototype object will become the parent of the constructed object in its prototype chain.\n\nSince a function is also an object, it also has its own parent in its own prototype chain, but recall that these two chains are about different things. \n\nHere are some equalities that could help grasp the issue -- all of these print true:\n\n\n\nfunction Person() {};\n\n// This is prototype chain info for the constructor (the function object):\nconsole.log(Object.getPrototypeOf(Person) === Function.prototype);\n// Step further up in the same hierarchy:\nconsole.log(Object.getPrototypeOf(Function.prototype) === Object.prototype);\nconsole.log(Object.getPrototypeOf(Object.prototype) === null);\nconsole.log(Person.__proto__ === Function.prototype);\n// Here we swap lanes, and look at the constructor of the constructor\nconsole.log(Person.constructor === Function);\nconsole.log(Person instanceof Function);\n\n// Person.prototype was created by Person (at the time of its creation)\n// Here we swap lanes back and forth:\nconsole.log(Person.prototype.constructor === Person);\n// Although it is not an instance of it:\nconsole.log(!(Person.prototype instanceof Person));\n// Instances are objects created by the constructor:\nvar p = new Person();\n// Similarly to what was shown for the constructor, here we have\n// the same for the object created by the constructor:\nconsole.log(Object.getPrototypeOf(p) === Person.prototype);\nconsole.log(p.__proto__ === Person.prototype);\n// Here we swap lanes, and look at the constructor\nconsole.log(p.constructor === Person);\nconsole.log(p instanceof Person);\n Run code snippetHide resultsExpand snippet\n\n\n\nAdding levels to the prototype chain\n\nAlthough a prototype object is created when you create a constructor function, you can ignore that object, and assign another object that should be used as prototype for any subsequent instances created by that constructor.\n\nFor instance:\n\nfunction Thief() { }\nvar p = new Person();\nThief.prototype = p; // this determines the prototype for any new Thief objects:\nvar t = new Thief();\n\n\nNow the prototype chain of t is one step longer than that of p:\n\n    t  p  Person.prototype  Object.prototype (end point)\n\nThe other prototype chain is not longer: Thief and Person are siblings sharing the same parent in their prototype chain:\n\n    Person}\n    Thief  }  Function.prototype  Object.prototype (end point)\n\nThe earlier presented graphic can then be extended to this (the original Thief.prototype is left out):\n\n\n\nThe blue lines represent prototype chains, the other coloured lines represent other relationships:\n\n\nbetween an object and its constructor\nbetween a constructor and the prototype object that will be used for constructing objects\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The concept of prototypal inheritance is one of the most complicated for many developers. Let&apos;s try to understand the root of problem to understand prototypal inheritance better. Let&apos;s start with a plain function. \n\n\n\nIf we use a new operator on the Tree function, we call it as a constructor function. \n\n\n\nEvery JavaScript function has a prototype. When you log the Tree.prototype, you get...\n\n\n\nIf you look at the above console.log() output, you could a see a constructor property on Tree.prototype and a __proto__ property too. The __proto__ represents the prototype that this function is based off, and since this is just a plain JavaScript function with no inheritance set up yet, it refers to the Object prototype which is something just built in to JavaScript...\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\nThis has things like .toString, .toValue, .hasOwnProperty etc...\n\n__proto__ which was brought my mozilla is deprecated and is replaced by Object.getPrototypeOf method to get the object&apos;s prototype. \n\n\n\nObject.getPrototypeOf(Tree.prototype); // Object {} \n\n\nLet&apos;s add a method to our Tree prototype. \n\n\n\nWe have modified the Root and added a function branch to it. \n\n\n\nThat means when you create an instance of Tree, you can call it&apos;s branch method.\n\n\n\nWe can also add primitives or objects to our Prototype. \n\n\n\nLet&apos;s add a child-tree to our Tree. \n\n\n\nHere the Child inherits its prototype from Tree, what we are doing here is using Object.create() method to create a new object based off what you pass, here it is Tree.prototype. In this case what we&apos;re doing is setting the prototype of Child to a new object that looks identical to the Tree prototype. Next we are setting the Child&apos;s constructor to Child, if we don&apos;t it would point to Tree(). \n\n\n\nChild now has its own prototype, its __proto__ points to Tree and Tree&apos;s prototype points to base Object. \n\nChild  \n|\n \\\n  \\\n   Tree.prototype\n   - branch\n   |\n   |\n    \\\n     \\\n      Object.prototype\n      -toString\n      -valueOf\n      -etc., etc.\n\n\nNow you create an instance of Child and call branch which is originally available in Tree. We haven&apos;t actually defined our branch on the Child prototype. BUT, in the Root prototype which Child inherits from. \n\n\n\nIn JS everything is not an object, everything can act like an object.\n\nJavascript has primitives like strings, number, booleans, undefined, null. They are not object(i.e reference types), but certainly can act like an object. Let&apos;s look at an example here.\n\n\n\nIn the first line of this listing, a primitive string value is assigned to name. The second line treats name like an object and calls charAt(0) using dot notation.\n\nThis is what happens behind the scenes:\n// what the JavaScript engine does\n\n\n\nThe String object exists only for one statement before its destroyed (a process called autoboxing). Let&apos;s again get back to our prototypal inheritance. \n\n\nJavascript supports inheritance via delegation based on\nprototypes.\nEach Function has a prototype property, which refers to another\nobject.\nproperties/functions are looked from the object itself or via\nprototype chain if it does not exist\n\n\nA prototype in JS is an object which yields you to the parent of another object. [ie.. delegation] Delegation means that if you are unable to do something, youll tell someone else to do it for you.\n\n\n\nhttps://jsfiddle.net/say0tzpL/1/\n\nIf you look up the above fiddle, dog has access to toString method, but its not available in it, but available via the prototype chain which delegates to Object.prototype\n\n\n\nIf you look at the below one, we are trying to access the call method which is available in every function.\n\n\n\nhttps://jsfiddle.net/rknffckc/\n\nIf you look up the above fiddle, Profile Function has access to call method, but its not available in it, but available via the prototype chain which delegates to Function.prototype\n\n\n\nNote: prototype is a property of the function constructor, whereas __proto__ is a property of the objects constructed from the function constructor. Every function comes with a prototype property whose value is an empty object. When we create an instance of the function, we get an internal property [[Prototype]] or __proto__ whose reference is the prototype of the Function constructor.\n\n\n\nThe above diagram looks bit complicated, but brings out the whole picture on how prototype chaining works. Let&apos;s walk through this slowly:\n\nThere are two instance b1 and b2, whose constructor is Bar and parent is Foo and has two methods from prototype chain identify and speak via Bar and Foo\n\n\n\nhttps://jsfiddle.net/kbp7jr7n/\n\nIf you look up the code above, we have Foo constructor who has the method identify() and Bar constructor which has speak method. We create two Bar instance b1 and b2 whose parent type is Foo. Now while calling speak method of Bar, we are able to identify the who is calling the speak via prototype chain. \n\n\n\nBar now has all the methods of Foo which are defined in its prototype. Let&apos;s dig further in understanding the Object.prototype and Function.prototype and how they are related. If you look up the constructor of Foo, Bar and Object are Function constructor.\n\n\n\nThe prototype of Bar is Foo, prototype of Foo is Object and if you look closely the prototype of Foo is related to Object.prototype.\n\n\n\nBefore we close this down, let&apos;s just wrap with a small piece of code here to summarize everything above. We are using instanceof operator here to check whether an object has in its prototype chain the prototype property of a constructor which below summarizes the entire big diagram. \n\n\n\nI hope this add&apos;s some information, I know this kinda could be big to grasp... in simple words its it&apos;s just objects linked to objects!!!! \n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"\n  what is the exact purpose of this &quot;.prototype&quot; property?\n\n\nThe interface to standard classes become extensible. For example, you are using the Array class and you also need to add a custom serializer for all your array objects. Would you spend time coding up a subclass, or use composition or ... The prototype property solves this by letting the users control the exact set of members/methods available to a class.\n\nThink of prototypes as an extra vtable-pointer. When some members are missing from the original class, the prototype is looked up at runtime.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"The Definitive Guide to Object-Oriented JavaScript - a very concise and clear ~30min video explanation of the asked question (Prototypal Inheritance topic begins from 5:45, although I&apos;d rather listen to the whole video). The author of this video also made JavaScript object visualizer website http://www.objectplayground.com/.\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I found it helpful to explain the &quot;prototype chain&quot; as recursive convention when obj_n.prop_X is being referenced:\n\nif obj_n.prop_X doesn&apos;t exist, check obj_n+1.prop_X where obj_n+1 = obj_n.[[prototype]]\n\nIf the prop_X is finally found in the k-th prototype object then\n\nobj_1.prop_X = obj_1.[[prototype]].[[prototype]]..(k-times)..[[prototype]].prop_X\n\nYou can find a graph of the relation of Javascript objects by their properties here:\n\n  \n\nhttp://jsobjects.org\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"When a constructor creates an object, that object implicitly references the constructors prototype property for the purpose of resolving property references. The constructors prototype property can be referenced by the program expression constructor.prototype, and properties added to an objects prototype are shared, through inheritance, by all objects sharing the prototype.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"There&apos;s two distinct but related entities here that need explaining:\n\n\nThe .prototype property of functions.\nThe [[Prototype]][1] property of all objects[2]. \n\n\nThese are two different things. \n\nThe [[Prototype]] property:\n\nThis is a property that exists on all[2] objects.\n\nWhat&apos;s stored here is another object, which, as an object itself, has a [[Prototype]] of its own that points to another object. That other object has a [[Prototype]] of its own. This story continues until you reach the prototypical object that provides methods that are accessible on all objects (like .toString).\n\nThe [[Prototype]] property is part of what forms the [[Prototype]] chain. This chain of [[Prototype]] objects is what is examined when, for example, [[Get]] or [[Set]] operations are performed on an object:\n\nvar obj = {}\nobj.a         // [[Get]] consults prototype chain\nobj.b = 20    // [[Set]] consults prototype chain\n\n\nThe .prototype property:\n\nThis is a property that is only found on functions. Using a very simple function:\n\nfunction Bar(){};\n\n\nThe .prototype property holds an object that will be assigned to b.[[Prototype]] when you do var b = new Bar. You can easily examine this:\n\n// Both assign Bar.prototype to b1/b2[[Prototype]]\nvar b = new Bar;\n// Object.getPrototypeOf grabs the objects [[Prototype]]\nconsole.log(Object.getPrototypeOf(b) === Bar.prototype) // true\n\n\nOne of the most important .prototypes is that of the Object function. This prototype holds the prototypical object that all [[Prototype]] chains contain. On it, all the available methods for new objects are defined:\n\n// Get properties that are defined on this object\nconsole.log(Object.getOwnPropertyDescriptors(Object.prototype))\n\n\nNow, since .prototype is an object, it has a [[Prototype]] property. When you don&apos;t make any assignments to Function.prototype, the .prototype&apos;s [[Prototype]] points to the prototypical object (Object.prototype). This is automatically performed anytime you create a new function. \n\nThis way, any time you do new Bar; the prototype chain is set up for you, you get everything defined on Bar.prototype and everything defined on Object.prototype:\n\nvar b = new Bar;\n// Get all Bar.prototype properties\nconsole.log(b.__proto__ === Bar.prototype)\n// Get all Object.prototype properties\nconsole.log(b.__proto__.__proto__ === Object.prototype)\n\n\nWhen you do make assignments to Function.prototype all you are doing is extending the prototype chain to include another object. It&apos;s like an insertion in a singly linked list. \n\nThis basically alters the [[Prototype]] chain allowing properties that are defined on the object assigned to Function.prototype to be seen by any object created by the function.\n\n\n\n[1: That won&apos;t confuse anyone; made available via the __proto__ property in many implementations.\n[2]: All except null.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Let me tell you my understanding of prototypes. I am not going to compare the inheritance here with other languages. I wish people would stop comparing languages, and just understand the language as itself. Understanding prototypes and prototypal inheritance is so simple, as I will show you below.\n\nPrototype is like a model, based on which you create a product. The crucial point to understand is that when you create an object using another object as it&apos;s prototype, the link between the prototype and the product is ever-lasting. For instance:\n\nvar model = {x:2};\nvar product = Object.create(model);\nmodel.y = 5;\nproduct.y\n=&gt;5\n\n\nEvery object contains an internal property called the [[prototype]], which can be accessed by the Object.getPrototypeOf() function. Object.create(model) creates a new object and sets it&apos;s [[prototype]] property to the object model. Hence when you do Object.getPrototypeOf(product), you will get the object model.\n\nProperties in the product are handled in the following way:\n\n\nWhen a property is accessed to just read it&apos;s value, its looked up in the scope chain. The search for the variable starts from the product upwards to it&apos;s prototype. If such a variable is found in the search, the search is stopped right there, and the value is returned. If such a variable cannot be found in the scope chain, undefined is returned.\nWhen a property is written(altered), then the property is always written on the product object. If the product does not have such a property already, it is implicitly created and written.\n\n\nSuch a linking of objects using the prototype property is called prototypal inheritance. There, it is so simple, agree?\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Another attempt to explain JavaScript prototype-based inheritance with better pictures\n\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Consider the following keyValueStore object :\n\nvar keyValueStore = (function() {\n    var count = 0;\n    var kvs = function() {\n        count++;\n        this.data = {};\n        this.get = function(key) { return this.data[key]; };\n        this.set = function(key, value) { this.data[key] = value; };\n        this.delete = function(key) { delete this.data[key]; };\n        this.getLength = function() {\n            var l = 0;\n            for (p in this.data) l++;\n            return l;\n        }\n    };\n\n    return  { // Singleton public properties\n        &apos;create&apos; : function() { return new kvs(); },\n        &apos;count&apos; : function() { return count; }\n    };\n})();\n\n\nI can create a new instance of this object by doing this :\n\nkvs = keyValueStore.create();\n\n\nEach instance of this object would have the following public properties :\n\n\ndata\nget \nset\ndelete\ngetLength\n\n\nNow, suppose we create 100 instances of this keyValueStore object. Even though get, set, delete, getLength will do the exact same thing for each of these 100 instances, every instance has its own copy of this function.\n\nNow, imagine if you could have just a single get, set, delete and getLength copy, and each instance would reference that same function. This would be better for performance and require less memory.\n\nThat&apos;s where prototypes come in. A prototype is a &quot;blueprint&quot; of properties that is inherited but not copied by instances. So this means that it exists only once in memory for all instances of an object and is shared by all of those instances.\n\nNow, consider the keyValueStore object again. I could rewrite it like this :\n\nvar keyValueStore = (function() {\n    var count = 0;\n    var kvs = function() {\n        count++;\n        this.data = {};\n    };\n\n    kvs.prototype = {\n        &apos;get&apos; : function(key) { return this.data[key]; },\n        &apos;set&apos; : function(key, value) { this.data[key] = value; },\n        &apos;delete&apos; : function(key) { delete this.data[key]; },\n        &apos;getLength&apos; : function() {\n            var l = 0;\n            for (p in this.data) l++;\n            return l;\n        }\n    };\n\n    return  {\n        &apos;create&apos; : function() { return new kvs(); },\n        &apos;count&apos; : function() { return count; }\n    };\n})();\n\n\nThis does EXACTLY the same as the previous version of the keyValueStore object, except that all of its methods are now put in a prototype. What this means, is that all of the 100 instances now share these four methods instead of each having their own copy.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Summary:\n\n\nFunctions are objects in javascript and thus can have properties\n(Constructor) functions always have a prototype property\nWhen a function is used as a constructor with the new keyword the object gets  prototype. A reference to this prototype can be found on the __proto__ property of the newly created object.\nThis __proto__ property refers to the prototype property of the constructor function.\n\n\nExample:\n\n\n\nfunction Person (name) {\n  this.name = name;\n}\n\nlet me = new Person(&apos;willem&apos;);\n\nconsole.log(Person.prototype) // Person has a prototype property\n\nconsole.log(Person.prototype === me.__proto__) // the __proto__ property of the instance refers to prototype property of the function.\n Run code snippetHide resultsExpand snippet\n\n\n\nWhy is this usefull:\n\nJavascript has a mechanism when looking up properties on Objects which is called &apos;prototypal inheritance&apos;, here is what is basically does:\n\n\nFirst is checked if the property is located on the Object itself. If so this property is returned.\nIf the property is not located on the object itself it will &apos;climb up the protochain&apos;. It basically looks at the object referred to by the proto property. There it checks if the property is available on the object referred to by proto\nIf the property isn&apos;t located on the proto object it will climb up the proto chain all the way up to Object object.\nIf it cannot find the property nowhere on the object and its prototype chain it will return undefined.\n\n\nFor example:\n\n\n\nfunction Person(name) {\n  this.name = name;\n}\n\nlet mySelf = new Person(&apos;Willem&apos;);\n\nconsole.log(mySelf.__proto__ === Person.prototype);\n\nconsole.log(mySelf.__proto__.__proto__ === Object.prototype);\n Run code snippetHide resultsExpand snippet\n\n\n\nUpdate:\n\nThe  __proto__ property has been deprecated, although it is implemented in most modern browsers a better way to obtain the prototype object reference would be:\n\nObject.getPrototypeOf()\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"I always like analogies when it comes to understand this type of stuff. &apos;Prototypical inheritance&apos; is pretty confusing in comparison to class bass inheritance in my opinion, even though prototypes are much simpler paradigm. In fact with prototypes, there really is no inheritance, so the name in and of itself misleading, it&apos;s more a type of &apos;delegation&apos;.\n\nImagine this ....\n\nYou&apos;re in high-school, and you&apos;re in class and have a quiz that&apos;s due today, but you don&apos;t have a pen to fill out your answers. Doh!\n\nYou&apos;re sitting next to your friend Finnius, who might have a pen. You ask, and he looks around his desk unsuccessfully, but instead of saying &quot;I don&apos;t have a pen&quot;, he&apos;s a nice friend he checks with his other friend Derp if he has a pen. Derp does indeed have a spare pen and passes it back to Finnius, who passes it over to you to complete your quiz. Derp has entrusted the pen to Finnius, who has delegated the pen to you for use.\n\nWhat is important here is that Derp does not give the pen to you, as you don&apos;t have a direct relationship with him.\n\nThis, is a simplified example of how prototypes work, where a tree of data is searched for the thing you&apos;re looking for.\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"another scheme showing __proto__, prototype and constructor relations:\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"It&apos;s just that you already have an object with Object.new but you still don&apos;t have an object when using the constructor syntax.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"\n  It&apos;s important to understand that there is a distinction between an object&apos;s prototype (which is available via Object.getPrototypeOf(obj), or via the deprecated __proto__ property) and the prototype property on constructor functions. The former is the property on each instance, and the latter is the property on the constructor. That is, Object.getPrototypeOf(new Foobar()) refers to the same object as Foobar.prototype.\n\n\nReference: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"The Prototype creates new object by cloning existing object. So really when we think about prototype we can really think cloning or making a copy of something instead of making it up.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"If you want to understand the concept of prototype and prototype based inheritance from the basics, check the official MDN docs, they explain it pretty well.\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\n\nWhen it comes to inheritance, JavaScript only has one construct:\nobjects. Each object has a private property which holds a link to\nanother object called its prototype. That prototype object has a\nprototype of its own, and so on until an object is reached with null\nas its prototype. By definition, null has no prototype, and acts as\nthe final link in this prototype chain.\n\nAlso, here&apos;s another good resource that explains using simple examples - https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-does-javascript-.prototype-work-1657388169270#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-does-javascript-.prototype-work-1657388169270">How does JavaScript .prototype work?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/prototype-oriented">prototype-oriented</a></div></div><div class="question-content mt-5">
                
<p>I'm not that into dynamic programming languages but I've written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello?'</span>); };
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">obj</span>();
obj2.<span class="hljs-title function_">test</span>();
</code></pre>
<p>I remember a lot discussion I had with people a while back (I'm not exactly sure what I'm doing) but as I understand it, there's no concept of a class. It's just an object, and instances of those objects are clones of the original, right?</p>
<p>But what is the exact purpose of this ".prototype" property in JavaScript? How does it relate to instantiating objects?</p>
<h3>Update: correct way</h3>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// not a functional object</span>
obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello?'</span>); }; <span class="hljs-comment">// this is wrong!</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyObject</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// a first class functional object</span>
<span class="hljs-title class_">MyObject</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'OK'</span>); } <span class="hljs-comment">// OK</span>
</code></pre>
<p>Also these <a href="http://ejohn.org/apps/learn/#64" rel="noreferrer">slides</a> really helped a lot.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.</p>

<p>In JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It's not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.</p>

<p>Example:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//Define a functional object to hold persons in JavaScript</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
};

<span class="hljs-comment">//Add dynamically to the already defined object a new getter</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
};

<span class="hljs-comment">//Create a new object of type Person</span>
<span class="hljs-keyword">var</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John"</span>);

<span class="hljs-comment">//Try the getter</span>
<span class="hljs-title function_">alert</span>(john.<span class="hljs-title function_">getName</span>());

<span class="hljs-comment">//If now I modify person, also John gets the updates</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayMyName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello, my name is '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>());
};

<span class="hljs-comment">//Call the new method on john</span>
john.<span class="hljs-title function_">sayMyName</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>Until now I've been extending the base object, now I create another object and then inheriting from Person.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//Create a new object of type Customer by defining its constructor. It's not </span>
<span class="hljs-comment">//related to Person for now.</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Customer</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
};

<span class="hljs-comment">//Now I link the objects and to do so, we link the prototype of Customer to </span>
<span class="hljs-comment">//a new instance of Person. The prototype is the base that will be used to </span>
<span class="hljs-comment">//construct all new instances and also, will modify dynamically all already </span>
<span class="hljs-comment">//constructed objects because in JavaScript objects retain a pointer to the </span>
<span class="hljs-comment">//prototype</span>
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();     

<span class="hljs-comment">//Now I can call the methods of Person on the Customer, let's try, first </span>
<span class="hljs-comment">//I need to create a Customer.</span>
<span class="hljs-keyword">var</span> myCustomer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">'Dream Inc.'</span>);
myCustomer.<span class="hljs-title function_">sayMyName</span>();

<span class="hljs-comment">//If I add new methods to Person, they will be added to Customer, but if I</span>
<span class="hljs-comment">//add new methods to Customer they won't be added to Person. Example:</span>
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setAmountDue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">amountDue</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">amountDue</span> = amountDue;
};
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAmountDue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">amountDue</span>;
};

<span class="hljs-comment">//Let's try:       </span>
myCustomer.<span class="hljs-title function_">setAmountDue</span>(<span class="hljs-number">2000</span>);
<span class="hljs-title function_">alert</span>(myCustomer.<span class="hljs-title function_">getAmountDue</span>());
</code></pre>

<p></p><div class="snippet" data-lang="js" data-hide="true"><div class="snippet-display" style="vertical-align: center"><p><a class="snippet-show-link-chevron"><span class="expander-arrow-hide" style="vertical-align: middle;"></span></a><a class="snippet-show-link"><span class="show-hide" data-ishidden="true" style="vertical-align: middle">Show code snippet</span></a></p></div>
<div class="snippet-code snippet-currently-hidden" style="display: none;">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
};
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
};
<span class="hljs-keyword">var</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John"</span>);
<span class="hljs-title function_">alert</span>(john.<span class="hljs-title function_">getName</span>());
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayMyName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello, my name is '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>());
};
john.<span class="hljs-title function_">sayMyName</span>();
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Customer</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
};
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();

<span class="hljs-keyword">var</span> myCustomer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">'Dream Inc.'</span>);
myCustomer.<span class="hljs-title function_">sayMyName</span>();
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setAmountDue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">amountDue</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">amountDue</span> = amountDue;
};
<span class="hljs-title class_">Customer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAmountDue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">amountDue</span>;
};
myCustomer.<span class="hljs-title function_">setAmountDue</span>(<span class="hljs-number">2000</span>);
<span class="hljs-title function_">alert</span>(myCustomer.<span class="hljs-title function_">getAmountDue</span>());</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>While as said I can't call setAmountDue(), getAmountDue() on a Person.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//The following statement generates an error.</span>
john.<span class="hljs-title function_">setAmountDue</span>(<span class="hljs-number">1000</span>);
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every JavaScript object <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots" rel="noreferrer">has an internal "slot"</a> called <code>[[Prototype]]</code> whose value is either <code>null</code> or an <code>object</code>. You can think of a slot as a property on an object, internal to the JavaScript engine, hidden from the code you write. The square brackets around <code>[[Prototype]]</code> are deliberate, and are an ECMAScript specification convention to denote internal slots. </p>

<p>The value pointed at by the <code>[[Prototype]]</code> of an object, is colloquially known as "the prototype of that object." </p>

<p>If you access a property via the dot (<code>obj.propName</code>) or bracket (<code>obj['propName']</code>) notation, and the object does not directly have such a property (ie. an <em>own property</em>, checkable via <code>obj.hasOwnProperty('propName')</code>), the runtime looks for a property with that name on the object referenced by the <code>[[Prototype]]</code> instead. If the <code>[[Prototype]]</code> <em>also</em> does not have such a property, its <code>[[Prototype]]</code> is checked in turn, and so on. In this way, the original object's <em>prototype chain</em> is walked until a match is found, or its end is reached. At the top of the prototype chain is the <code>null</code> value.</p>

<p>Modern JavaScript implementations allow read and/or write access to the <code>[[Prototype]]</code> in the following ways:</p>

<ol>
<li>The <code>new</code> operator (configures the prototype chain on the default object returned from a constructor function),</li>
<li>The <code>extends</code> keyword (configures the prototype chain when using the class syntax),</li>
<li><code>Object.create</code> will set the supplied argument as the <code>[[Prototype]]</code> of the resulting object,</li>
<li><code>Object.getPrototypeOf</code> and <code>Object.setPrototypeOf</code> (get/set the <code>[[Prototype]]</code> <em>after</em> object creation), and</li>
<li>The standardized accessor (ie. getter/setter) property named <code>__proto__</code> (similar to 4.)</li>
</ol>

<p><code>Object.getPrototypeOf</code> and <code>Object.setPrototypeOf</code> are preferred over <code>__proto__</code>, in part because the behavior of <code>o.__proto__</code> <a href="https://stackoverflow.com/a/35458348/38522">is unusual</a> when an object has a prototype of <code>null</code>.</p>

<p>An object's <code>[[Prototype]]</code> is initially set during object creation.</p>

<p>If you create a new object via <code>new Func()</code>, the object's <code>[[Prototype]]</code> will, by default, be set to the object referenced by <code>Func.prototype</code>.</p>

<p>Note that, therefore, <strong>all classes, and all functions that can be used with the <code>new</code> operator, have a property named <code>.prototype</code> in addition to their own <code>[[Prototype]]</code> internal slot.</strong> This dual use of the word "prototype" is the source of endless confusion amongst newcomers to the language.</p>

<p>Using <code>new</code> with constructor functions allows us to simulate classical inheritance in JavaScript; although JavaScript's inheritance system is - as we have seen - prototypical, and not class-based.</p>

<p>Prior to the introduction of class syntax to JavaScript, constructor functions were the only way to simulate classes. We can think of properties of the object referenced by the constructor function's <code>.prototype</code> property as shared members; ie. members which are the same for each instance. In class-based systems, methods are implemented the same way for each instance, so methods are conceptually added to the <code>.prototype</code> property; an object's fields, however, are instance-specific and are therefore added to the object itself during construction.</p>

<p>Without the class syntax, developers had to manually configure the prototype chain to achieve similar functionality to classical inheritance. This led to a preponderance of different ways to achieve this. </p>

<p>Here's one way:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {}
<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">inheritedMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'this is inherited'</span> }

<span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">child, parent</span>) {
  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child
  <span class="hljs-keyword">return</span> child;
}

<span class="hljs-title class_">Child</span> = <span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Child</span>, <span class="hljs-title class_">Parent</span>)
<span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">inheritedMethod</span>()) <span class="hljs-comment">// 'this is inherited'</span>
</code></pre>

<p>...and here's another way:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {}
<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">inheritedMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'this is inherited'</span> }

<span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">child, parent</span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">tmp</span>(<span class="hljs-params"></span>) {}
    tmp.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
    <span class="hljs-keyword">const</span> proto = <span class="hljs-keyword">new</span> <span class="hljs-title function_">tmp</span>()
    proto.<span class="hljs-property">constructor</span> = child
    child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto
    <span class="hljs-keyword">return</span> child
}

<span class="hljs-title class_">Child</span> = <span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Child</span>, <span class="hljs-title class_">Parent</span>)
<span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">inheritedMethod</span>()) <span class="hljs-comment">// 'this is inherited'</span>
</code></pre>

<p>The class syntax introduced in ES2015 simplifies things, by providing <code>extends</code> as the "one true way" to configure the prototype chain in order to simulate classical inheritance in JavaScript.</p>

<p>So, similar to the code above, if you use the class syntax to create a new object like so:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> { <span class="hljs-title function_">inheritedMethod</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'this is inherited'</span> } }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {}

<span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">inheritedMethod</span>()) <span class="hljs-comment">// 'this is inherited'</span>
</code></pre>

<p>...the resulting object's <code>[[Prototype]]</code> will be set to an instance of <code>Parent</code>, whose <code>[[Prototype]]</code>, in turn, is <code>Parent.prototype</code>.</p>

<p>Finally, if you create a new object via <code>Object.create(foo)</code>, the resulting object's <code>[[Prototype]]</code> will be set to <code>foo</code>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a very simple prototype based object model that would be considered as a sample during the explanation, with no comment yet:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>){
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"George"</span>);
</code></pre>

<hr>

<p>There are some crucial points that we have to consider before going through the prototype concept.</p>

<h1>1- How JavaScript functions actually work:</h1>

<p>To take the first step we have to figure out, how JavaScript functions actually work , as a class like function using <strong><code>this</code></strong> keyword in it or just as a regular function with its arguments, what it does and what it returns.</p>

<p>Let's say we want to create a <code>Person</code> object model. but in this step I'm gonna be trying to <strong>do the same exact thing without using <code>prototype</code> and <code>new</code> keyword</strong>.</p>

<p>So in this step <strong><code>functions</code></strong>, <strong><code>objects</code></strong> and <strong><code>this</code></strong> keyword, are all we have.</p>

<p>The first question would be <strong>how <code>this</code> keyword could be useful without using <code>new</code> keyword</strong>.</p>

<p>So to answer that let's say we have an empty object, and two functions like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> person = {};
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>){  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  }

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}
</code></pre>

<p>and now <strong>without using <code>new</code> keyword</strong> how we could use these functions. So JavaScript has 3 different ways to do that:</p>

<h2>a. first way is just to call the function as a regular function:</h2>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Person</span>(<span class="hljs-string">"George"</span>);
<span class="hljs-title function_">getName</span>();<span class="hljs-comment">//would print the "George" in the console</span>
</code></pre>

<p>in this case, this would be the current context object, which is usually is the global  <code>window</code> object in the browser or <code>GLOBAL</code> in <code>Node.js</code>. It means we would have, window.name in browser or GLOBAL.name in Node.js, with "George" as its value.</p>

<h2>b. We can <strong>attach</strong> them to an object, as its properties</h2>

<p>-<strong>The easiest way</strong> to do this is modifying the empty <code>person</code> object, like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">person.<span class="hljs-property">Person</span> = <span class="hljs-title class_">Person</span>;
person.<span class="hljs-property">getName</span> = getName;
</code></pre>

<p>this way we can call them like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">person.<span class="hljs-title class_">Person</span>(<span class="hljs-string">"George"</span>);
person.<span class="hljs-title function_">getName</span>();<span class="hljs-comment">// --&gt;"George"</span>
</code></pre>

<p>and now the <code>person</code> object is like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Object</span> {<span class="hljs-title class_">Person</span>: <span class="hljs-keyword">function</span>, <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"George"</span>}
</code></pre>

<hr>

<p>-<strong>The other way to attach a property</strong> to an object is using the <code>prototype</code> of that object that can be find in any JavaScript object with the name of <code>__proto__</code>, and I have tried to explain it a bit on the summary part. So we could get the similar result by doing:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">person.<span class="hljs-property">__proto__</span>.<span class="hljs-property">Person</span> = <span class="hljs-title class_">Person</span>;
person.<span class="hljs-property">__proto__</span>.<span class="hljs-property">getName</span> = getName;
</code></pre>

<p><strong>But</strong> this way what we actually are doing is modifying the <code>Object.prototype</code>, because whenever we create a JavaScript object using literals (<code>{ ... }</code>), it gets created based on <code>Object.prototype</code>, which means it gets attached to the newly created object as an attribute named <strong><code>__proto__</code></strong> , so if we change it, as we have done on our previous code snippet, all the JavaScript objects would get changed, not a good practice. So what could be the better practice now:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">person.<span class="hljs-property">__proto__</span> = {
    <span class="hljs-title class_">Person</span>: <span class="hljs-title class_">Person</span>,
    <span class="hljs-attr">getName</span>: getName
};
</code></pre>

<p>and now other objects are in peace, but it still doesn't seem to be a good practice. So we have still one more solutions, but to use this solution we should get back to that line of code where <code>person</code> object got created (<code>var person = {};</code>) then change it like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> propertiesObject = {
    <span class="hljs-title class_">Person</span>: <span class="hljs-title class_">Person</span>,
    <span class="hljs-attr">getName</span>: getName
};
<span class="hljs-keyword">var</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(propertiesObject);
</code></pre>

<p>what it does is creating a new JavaScript <code>Object</code> and attach the <code>propertiesObject</code> to the <code>__proto__</code> attribute. So to make sure you can do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span>===propertiesObject); <span class="hljs-comment">//true</span>
</code></pre>

<p>But the tricky point here is you have access to all the properties defined in <code>__proto__</code> on the first level of the <code>person</code> object(read the summary part for more detail).</p>

<hr>

<p>as you see using any of these two way <code>this</code> would exactly point to the <code>person</code> object.</p>

<h2>c. JavaScript has another way to provide the function with <code>this</code>, which is using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noreferrer">call</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noreferrer">apply</a> to invoke the function.</h2>

<blockquote>
  <p>The apply() method calls a function with a given this value and
  arguments provided as an array (or an array-like object).</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>The call() method calls a function with a given this value and
  arguments provided individually.</p>
</blockquote>

<p>this way which is my favorite, we can easily call our functions like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">"George"</span>);
</code></pre>

<p>or</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//apply is more useful when params count is not fixed</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">"George"</span>]);

getName.<span class="hljs-title function_">call</span>(person);   
getName.<span class="hljs-title function_">apply</span>(person);
</code></pre>

<p>these 3 methods are the important initial steps to figure out the .prototype functionality.</p>

<hr>

<h1>2- How does the <code>new</code> keyword work?</h1>

<p>this is the second step to understand the <code>.prototype</code> functionality.this is what I use to simulate the process:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>){  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  }
my_person_prototype = { <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); } };
</code></pre>

<p>in this part I'm gonna be trying to take all the steps which JavaScript takes, without using the <code>new</code> keyword and <code>prototype</code>, when you use <code>new</code> keyword. so when we do <code>new Person("George")</code>, <code>Person</code> function serves as a constructor, These are what JavaScript does, one by one:</p>

<h2>a. first of all it makes an empty object, basically an empty hash like:</h2>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> newObject = {};
</code></pre>

<h2>b. the next step that JavaScript takes is to <strong>attach</strong> the all prototype objects to the newly created object</h2>

<p>we have <code>my_person_prototype</code> here similar to the prototype object.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> my_person_prototype){
    newObject[key] = my_person_prototype[key];
}
</code></pre>

<p>It is not the way that JavaScript actually attaches the properties that are defined in the prototype. The actual way is related to the prototype chain concept.</p>

<hr>

<h2>a. &amp; b. Instead of these two steps you can have the exact same result by doing:</h2>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(my_person_prototype);
<span class="hljs-comment">//here you can check out the __proto__ attribute</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObject.<span class="hljs-property">__proto__</span> === my_person_prototype); <span class="hljs-comment">//true</span>
<span class="hljs-comment">//and also check if you have access to your desired properties</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> newObject.<span class="hljs-property">getName</span>);<span class="hljs-comment">//"function"</span>
</code></pre>

<p>now we can call the <code>getName</code> function in our <code>my_person_prototype</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">newObject.<span class="hljs-title function_">getName</span>();
</code></pre>

<h2>c. then it gives that object to the constructor,</h2>

<p>we can do this with our sample like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(newObject, <span class="hljs-string">"George"</span>);
</code></pre>

<p>or</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">apply</span>(newObject, [<span class="hljs-string">"George"</span>]);
</code></pre>

<p>then the constructor can do whatever it wants, because <strong>this</strong> inside of that constructor is the object that was just created.</p>

<p>now the end result before simulating the other steps:
    Object {name: "George"}</p>

<hr>

<h2>Summary:</h2>

<p>Basically, when you use the <strong>new</strong> keyword on a function, you are calling on that and that function serves as a constructor, so when you say:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionName</span>()
</code></pre>

<p>JavaScript internally makes an object, an empty hash and then it gives that object to the constructor, then the constructor can do whatever it wants, because <strong>this</strong> inside of that constructor is the object that was just created and then it gives you that object of course if you haven't used the return statement in your function or if you've put a <code>return undefined;</code> at the end of your function body.</p>

<p>So when JavaScript goes to look up a property on an object, the first thing it does, is it looks it up on that object. And then there is a secret property <strong><code>[[prototype]]</code></strong> which we usually have it like <strong><code>__proto__</code></strong> and that property is what JavaScript looks at next. And when it looks through the <strong><code>__proto__</code></strong>, as far as it is again another JavaScript object, it has its own <strong><code>__proto__</code></strong> attribute, it goes up and up until it gets to the point where the next <strong><code>__proto__</code></strong> is null. The point is the only object in JavaScript that its <strong><code>__proto__</code></strong> attribute is null is <code>Object.prototype</code> object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>===<span class="hljs-literal">null</span>);<span class="hljs-comment">//true</span>
</code></pre>

<p>and that's how inheritance works in JavaScript.</p>

<p><img src="https://i.stack.imgur.com/JnpBV.png" alt="The prototype chain"></p>

<p>In other words, when you have a prototype property on a function and you call a new on that, after JavaScript finishes looking at that newly created object for properties, it will go look at the function's <code>.prototype</code> and also it is possible that this object has its own internal prototype. and so on.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>prototype</code> allows you to make classes. if you do not use <code>prototype</code> then it becomes a static.</p>

<p>Here is a short example.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
obj.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello?'</span>); };
</code></pre>

<p>In the above case, you have static funcation call test. This function can be accessed only by obj.test where you can imagine obj to be a class.</p>

<p>where as in the below code</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">obj</span>(<span class="hljs-params"></span>)
{
}

obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello?'</span>); };
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">obj</span>();
obj2.<span class="hljs-title function_">test</span>();
</code></pre>

<p>The obj has become a class which can now be instantiated. Multiple instances of obj can exist and they all have the <code>test</code> function.</p>

<p>The above is my understanding. I am making it a community wiki, so people can correct me if I am wrong.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>The seven Koans of prototype</h2>

<p>As Ciro San descended Mount Fire Fox after deep meditation, his mind was clear and peaceful.</p>

<p>His hand however, was restless, and by itself grabbed a brush and jotted down the following notes.</p>

<hr>

<p><strong>0)</strong> Two different things can be called "prototype":</p>

<ul>
<li><p>the prototype property, as in <code>obj.prototype</code></p></li>
<li><p>the prototype internal property, denoted as <code>[[Prototype]]</code> <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2" rel="noreferrer">in ES5</a>.</p>

<p>It can be retrieved via the ES5 <code>Object.getPrototypeOf()</code>.</p>

<p>Firefox makes it accessible through the <code>__proto__</code> property as an extension. <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-additional-ecmascript-features-for-web-browsers" rel="noreferrer">ES6 now mentions</a> some optional requirements for <code>__proto__</code>.</p></li>
</ul>

<hr>

<p><strong>1)</strong> Those concepts exist to answer the question:</p>

<blockquote>
  <p>When I do <code>obj.property</code>, where does JS look for <code>.property</code>?</p>
</blockquote>

<p>Intuitively, classical inheritance should affect property lookup.</p>

<hr>

<p><strong>2)</strong></p>

<ul>
<li><code>__proto__</code> is used for the dot <code>.</code> property lookup as in <code>obj.property</code>. </li>
<li><code>.prototype</code> is <em>not</em> used for lookup directly, only indirectly as it determines <code>__proto__</code> at object creation with <code>new</code>.</li>
</ul>

<p>Lookup order is:</p>

<ul>
<li><code>obj</code> properties added with <code>obj.p = ...</code> or <code>Object.defineProperty(obj, ...)</code></li>
<li>properties of <code>obj.__proto__</code></li>
<li>properties of <code>obj.__proto__.__proto__</code>, and so on</li>
<li>if some <code>__proto__</code> is <code>null</code>, return <code>undefined</code>.</li>
</ul>

<p>This is the so-called <em>prototype chain</em>.</p>

<p>You can avoid <code>.</code> lookup with <code>obj.hasOwnProperty('key')</code> and <code>Object.getOwnPropertyNames(f)</code></p>

<hr>

<p><strong>3)</strong> There are two main ways to set <code>obj.__proto__</code>:</p>

<ul>
<li><p><code>new</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()
</code></pre>

<p>then <code>new</code> has set:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">f.<span class="hljs-property">__proto__</span> === F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
</code></pre>

<p><em>This</em> is where <code>.prototype</code> gets used.</p></li>
<li><p><code>Object.create</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> f = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto)
</code></pre>

<p>sets:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">f.<span class="hljs-property">__proto__</span> === proto
</code></pre></li>
</ul>

<hr>

<p><strong>4)</strong> The code:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> = i }
<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(<span class="hljs-number">1</span>)
</code></pre>

<p>Corresponds to the following diagram (some <code>Number</code> stuff is omitted):</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">(<span class="hljs-title class_">Function</span>)       (  F  )                                      (f)-----&gt;(<span class="hljs-number">1</span>)
 |  ^             | | ^                                        |   i    |
 |  |             | | |                                        |        |
 |  |             | | +-------------------------+              |        |
 |  |constructor  | |                           |              |        |
 |  |             | +--------------+            |              |        |
 |  |             |                |            |              |        |
 |  |             |                |            |              |        |
 |[[<span class="hljs-title class_">Prototype</span>]]   |[[<span class="hljs-title class_">Prototype</span>]]   |prototype   |constructor   |[[<span class="hljs-title class_">Prototype</span>]]
 |  |             |                |            |              |        |
 |  |             |                |            |              |        |
 |  |             |                | +----------+              |        |
 |  |             |                | |                         |        |
 |  |             |                | | +-----------------------+        |
 |  |             |                | | |                                |
 v  |             v                v | v                                |
(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)              (F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)                         |
 |                                 |                                    |
 |                                 |                                    |
 |[[<span class="hljs-title class_">Prototype</span>]]                    |[[<span class="hljs-title class_">Prototype</span>]]          [[<span class="hljs-title class_">Prototype</span>]]|
 |                                 |                                    |
 |                                 |                                    |
 | +-------------------------------+                                    |
 | |                                                                    |
 v v                                                                    v
(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)                                       (<span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
 | | ^
 | | |
 | | +---------------------------+
 | |                             |
 | +--------------+              |
 |                |              |
 |                |              |
 |[[<span class="hljs-title class_">Prototype</span>]]   |constructor   |prototype
 |                |              |
 |                |              |
 |                | -------------+
 |                | |
 v                v |
(<span class="hljs-literal">null</span>)           (<span class="hljs-title class_">Object</span>)
</code></pre>

<p>This diagram shows many language predefined object nodes:</p>

<ul>
<li><code>null</code></li>
<li><code>Object</code></li>
<li><code>Object.prototype</code></li>
<li><code>Function</code></li>
<li><code>Function.prototype</code></li>
<li><code>1</code></li>
<li><code>Number.prototype</code> (can be found with <code>(1).__proto__</code>, parenthesis mandatory to satisfy syntax)</li>
</ul>

<p>Our 2 lines of code only created the following new objects:</p>

<ul>
<li><code>f</code></li>
<li><code>F</code></li>
<li><code>F.prototype</code></li>
</ul>

<p><code>i</code> is now a property of <code>f</code> because when you do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(<span class="hljs-number">1</span>)
</code></pre>

<p>it evaluates <code>F</code> with <code>this</code> being the value that <code>new</code> will return, which then gets assigned to <code>f</code>.</p>

<hr>

<p><strong>5)</strong> <code>.constructor</code> normally comes from <code>F.prototype</code> through the <code>.</code> lookup:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">f.<span class="hljs-property">constructor</span> === F
!f.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'constructor'</span>)
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(f) === F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'constructor'</span>)
F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === f.<span class="hljs-property">constructor</span>
</code></pre>

<p>When we write <code>f.constructor</code>, JavaScript does the <code>.</code> lookup as:</p>

<ul>
<li><code>f</code> does not have <code>.constructor</code></li>
<li><code>f.__proto__ === F.prototype</code> has <code>.constructor === F</code>, so take it</li>
</ul>

<p>The result <code>f.constructor == F</code> is intuitively correct, since <code>F</code> is used to construct <code>f</code>, e.g. set fields, much like in classic OOP languages. </p>

<hr>

<p><strong>6)</strong> Classical inheritance syntax can be achieved by manipulating prototypes chains.</p>

<p>ES6 adds the <code>class</code> and <code>extends</code> keywords, which are mostly syntax sugar for previously possible prototype manipulation madness.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">i</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> = i
    }
    <span class="hljs-title function_">inc</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> + <span class="hljs-number">1</span>
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">C</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">i</span>) {
        <span class="hljs-variable language_">super</span>(i)
    }
    <span class="hljs-title function_">inc2</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> + <span class="hljs-number">2</span>
    }
}
</code></pre>



<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Inheritance syntax works as expected.</span>
c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(<span class="hljs-number">1</span>)
c.<span class="hljs-title function_">inc</span>() === <span class="hljs-number">2</span>
(<span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_">inc</span>() === <span class="hljs-number">2</span>
(<span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_">inc2</span>() === <span class="hljs-number">3</span>
</code></pre>



<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// "Classes" are just function objects.</span>
C.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>
C.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
D.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>
<span class="hljs-comment">// D is a function "indirectly" through the chain.</span>
D.<span class="hljs-property">__proto__</span> === C
D.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
</code></pre>



<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// "extends" sets up the prototype chain so that base class</span>
<span class="hljs-comment">// lookups will work as expected</span>
<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>(<span class="hljs-number">1</span>)
d.<span class="hljs-property">__proto__</span> === D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
<span class="hljs-comment">// This is what `d.inc` actually does.</span>
d.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">inc</span> === C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">inc</span>
</code></pre>



<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Class variables</span>
<span class="hljs-comment">// No ES6 syntax sugar apparently:</span>
<span class="hljs-comment">// http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives</span>
C.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>
C.<span class="hljs-property">c</span> === <span class="hljs-number">1</span>
<span class="hljs-comment">// Because `D.__proto__ === C`.</span>
D.<span class="hljs-property">c</span> === <span class="hljs-number">1</span>
<span class="hljs-comment">// Nothing makes this work.</span>
d.<span class="hljs-property">c</span> === <span class="hljs-literal">undefined</span>
</code></pre>

<p>Simplified diagram without all predefined objects:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">(c)-----&gt;(<span class="hljs-number">1</span>)
 |   i
 |
 |
 |[[<span class="hljs-title class_">Prototype</span>]]
 |
 |
 v    __proto__
(C)&lt;--------------(D)         (d)
| |                |           |
| |                |           |
| |prototype       |prototype  |[[<span class="hljs-title class_">Prototype</span>]] 
| |                |           |
| |                |           |
| |                | +---------+
| |                | |
| |                | |
| |                v v
|[[<span class="hljs-title class_">Prototype</span>]]    (D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)--------&gt; (inc2 <span class="hljs-keyword">function</span> object)
| |                |             inc2
| |                |
| |                |[[<span class="hljs-title class_">Prototype</span>]]
| |                |
| |                |
| | +--------------+
| | |
| | |
| v v
| (C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)-------&gt;(inc <span class="hljs-keyword">function</span> object)
|                inc
v
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
</code></pre>

<p>Let's take a moment to study how the following works:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(<span class="hljs-number">1</span>)
c.<span class="hljs-title function_">inc</span>() === <span class="hljs-number">2</span>
</code></pre>

<p>The first line sets <code>c.i</code> to <code>1</code> as explained in "4)".</p>

<p>On the second line, when we do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">c.<span class="hljs-title function_">inc</span>()
</code></pre>

<ul>
<li><code>.inc</code> is found through the <code>[[Prototype]]</code> chain: <code>c</code> -&gt; <code>C</code> -&gt; <code>C.prototype</code> -&gt; <code>inc</code></li>
<li>when we call a function in Javascript as <code>X.Y()</code>, JavaScript automatically sets <code>this</code> to equal <code>X</code> inside the <code>Y()</code> function call! </li>
</ul>

<p>The exact same logic also explains <code>d.inc</code> and <code>d.inc2</code>.</p>

<p>This article <a href="https://javascript.info/class#not-just-a-syntax-sugar" rel="noreferrer">https://javascript.info/class#not-just-a-syntax-sugar</a> mentions further effects of <code>class</code> worth knowing. Some of them may not be achievable without the <code>class</code> keyword (TODO check which):</p>

<ul>
<li><code>[[FunctionKind]]:"classConstructor"</code>, which forces the constructor to be called with new: <a href="https://stackoverflow.com/questions/44446650/what-is-the-reason-es6-class-constructors-cant-be-called-as-normal-functions">What is the reason ES6 class constructors can't be called as normal functions?</a></li>
<li>Class methods are non-enumerable. Can be done with <code>Object.defineProperty</code>.</li>
<li>Classes always <code>use strict</code>. Can be done with an explicit <code>use strict</code> for every function, which is admittedly tedious.</li>
</ul>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>After reading this thread, I feel confused with JavaScript Prototype Chain, then I found these charts </p>

<p><a href="http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance" rel="noreferrer">http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance</a>
<img src="https://i.stack.imgur.com/rcGmc.png" alt="*[[protytype]]* and <code>prototype</code> property of function objects"></p>

<p><em>it's a clear chart to show JavaScript Inheritance by Prototype Chain</em></p>

<p>and </p>

<p><a href="http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/" rel="noreferrer">http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/</a></p>

<p><em>this one contains a example with code and several nice diagrams.</em></p>

<blockquote>
  <p>prototype chain ultimately falls back to Object.prototype. </p>
  
  <p>prototype chain can be technically extended as long as you want, each time by setting the prototype of the subclass equal to an object of the parent class.</p>
</blockquote>

<p>Hope it's also helpful for you to understand JavaScript Prototype Chain.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every object has an internal property, <em>[[Prototype]]</em>, linking it to another object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">object [[<span class="hljs-title class_">Prototype</span>]]  anotherObject
</code></pre>

<p>In traditional javascript, the linked object is the <code>prototype</code> property of a function:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">object [[<span class="hljs-title class_">Prototype</span>]]  aFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
</code></pre>

<p>Some environments expose <em>[[Prototype]]</em> as <code>__proto__</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">anObject.<span class="hljs-property">__proto__</span> === anotherObject
</code></pre>

<p>You create the <em>[[Prototype]]</em> link when creating an object.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// (1) Object.create:</span>
<span class="hljs-keyword">var</span> object = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(anotherObject)
<span class="hljs-comment">// object.__proto__ = anotherObject</span>

<span class="hljs-comment">// (2) ES6 object initializer:</span>
<span class="hljs-keyword">var</span> object = { <span class="hljs-attr">__proto__</span>: anotherObject };
<span class="hljs-comment">// object.__proto__ = anotherObject</span>

<span class="hljs-comment">// (3) Traditional JavaScript:</span>
<span class="hljs-keyword">var</span> object = <span class="hljs-keyword">new</span> aFunction;
<span class="hljs-comment">// object.__proto__ = aFunction.prototype</span>
</code></pre>

<p>So these statements are equivalent:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> object = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-keyword">var</span> object = { <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> }; <span class="hljs-comment">// ES6 only</span>
<span class="hljs-keyword">var</span> object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>;
</code></pre>

<p>You can't actually see the link target (<code>Object.prototype</code>) in a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="nofollow noreferrer">new</a> statement; instead the target is implied by the constructor (<code>Object</code>).</p>

<p>Remember:</p>

<ul>
<li>Every object has a link, <em>[[Prototype]]</em>, sometimes exposed as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" rel="nofollow noreferrer">__proto__</a>.</li>
<li>Every function has a <code>prototype</code> property, initially holding an empty object.</li>
<li>Objects created with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="nofollow noreferrer">new</a> are linked to the <code>prototype</code> property of their constructor.</li>
<li>If a function is never used as a constructor, its <code>prototype</code> property will go unused.</li>
<li>If you don't need a constructor, use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="nofollow noreferrer">Object.create</a> instead of <code>new</code>.</li>
</ul>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Javascript doesn't have inheritance in the usual sense, but it has the prototype chain.</p>

<h2>prototype chain</h2>

<p>If a member of an object can't be found in the object it looks for it in the prototype chain. The chain consists of other objects. The prototype of a given instance can be accessed with the <code>__proto__</code> variable. Every object has one, as there is no difference between classes and instances in javascript.</p>

<p>The advantage of adding a function / variable to the prototype is that it has to be in the memory only once, not for every instance.</p>

<p>It's also useful for inheritance, because the prototype chain can consist of many other objects.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This article is long. But I am sure it will clear most of your queries 
regarding the "prototypical" nature of JavaScript Inheritance. And even more. Please read the complete article.</p>

<p>JavaScript basically has two kinds of data types</p>

<ul>
<li><strong><em>Non objects</em></strong> </li>
<li><strong><em>Objects</em></strong></li>
</ul>

<p><strong><em>Non objects</em></strong></p>

<p>Following are the <strong><em>Non object</em></strong> data types</p>

<ul>
<li><strong>string</strong></li>
<li><strong>number (including NaN and Infinity)</strong></li>
<li><strong>boolean values(true,false)</strong> </li>
<li><strong>undefined</strong></li>
</ul>

<p>These data types return following when you use the <strong>typeof</strong> operator </p>

<p><strong>typeof</strong> <em>"string literal"</em> (or a variable containing string literal)  === <strong>'string'</strong></p>

<p><strong>typeof</strong> <em>5</em> (or any numeric literal or a variable containing numeric literal or <strong><em>NaN or Infynity</em></strong>)  === <strong>'number'</strong></p>

<p><strong>typeof</strong> <em>true</em> (or <em>false</em> or a variable containing <em>true</em> or <em>false</em>)  === <strong>'boolean'</strong></p>

<p><strong>typeof</strong> <em>undefined</em> (or an undefined variable or a variable containing <em>undefined</em>) === <strong>'undefined'</strong></p>

<p>The <strong>string</strong>,<strong>number</strong> and <strong>boolean</strong> data types can be represented both as <strong>Objects</strong> and <strong>Non objects</strong>.When they are represented as objects their typeof is always === 'object'. We shall come back to this once we understand the object data types.</p>

<p><strong><em>Objects</em></strong></p>

<p>The object datatypes can be further divided into two types</p>

<ol>
<li><strong>Function type objects</strong></li>
<li><strong>Non Function type objects</strong></li>
</ol>

<p>The <strong>Function type objects</strong> are the ones that return the string <strong>'function'</strong> with <strong>typeof</strong> operator. 
All the user defined functions and all the JavaScript built in objects that can create new objects by using new operator fall into this category. For eg.</p>

<ul>
<li><strong>Object</strong></li>
<li><strong>String</strong> </li>
<li><strong>Number</strong>  </li>
<li><strong>Boolean</strong></li>
<li><strong>Array</strong> </li>
<li><strong>Typed Arrays</strong></li>
<li><strong>RegExp</strong></li>
<li><strong>Function</strong> </li>
<li>All the other built in objects that can create new objects by using new operator</li>
<li><em>function</em> <strong>UserDefinedFunction</strong>(){ /*user defined code */ }</li>
</ul>

<p>So,
<strong>typeof(Object)</strong> === <strong>typeof(String)</strong> === <strong>typeof(Number)</strong> === <strong>typeof(Boolean)</strong> === <strong>typeof(Array)</strong>  === <strong>typeof(RegExp)</strong> === <strong>typeof(Function)</strong>  === <strong>typeof(UserDefinedFunction)</strong> === <strong>'function'</strong></p>

<p>All the <strong><em>Function type objects</em></strong> are actually instances of the built in JavaScript object <strong>Function</strong> (including the <strong>Function</strong> object i.e it is recursively defined). It is as if the these objects have been defined in the following way</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Object</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">Object</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">String</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">String</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Number</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">Number</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Boolean</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">Boolean</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Array</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">Array</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">RegExp</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code <span class="hljs-keyword">for</span> object <span class="hljs-title class_">RegExp</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Function</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([native code  <span class="hljs-keyword">for</span> object <span class="hljs-title class_">Function</span>])
<span class="hljs-keyword">var</span> <span class="hljs-title class_">UserDefinedFunction</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> (<span class="hljs-string">"user defined code"</span>)
</code></pre>

<p>As mentioned, the <strong><em>Function type objects</em></strong> can further create new objects using the <strong>new operator</strong>. For e.g an object of type <strong>Object</strong>, <strong>String</strong>, <strong>Number</strong>, <strong>Boolean</strong>, <strong>Array</strong>, <strong>RegExp</strong>  Or <strong>UserDefinedFunction</strong> can be created by using</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() or <span class="hljs-keyword">var</span> a=<span class="hljs-title class_">Object</span>() or <span class="hljs-keyword">var</span> a={} <span class="hljs-comment">//Create object of type Object</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>() <span class="hljs-comment">//Create object of type String</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>() <span class="hljs-comment">//Create object of type Number</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>() <span class="hljs-comment">//Create object of type Boolean</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>() or <span class="hljs-keyword">var</span> a=<span class="hljs-title class_">Array</span>() or <span class="hljs-keyword">var</span> a=[]  <span class="hljs-comment">//Create object of type Array</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>() or <span class="hljs-keyword">var</span> a=<span class="hljs-title class_">RegExp</span>() <span class="hljs-comment">//Create object of type RegExp</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDefinedFunction</span>() 
</code></pre>

<p>The objects thus created are all <strong><em>Non Function type objects</em></strong> and return their <strong>typeof</strong>===<strong>'object'</strong>. In all these cases the object "a" cannot further create 
objects using operator new. So the following is wrong</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> b=<span class="hljs-keyword">new</span> <span class="hljs-title function_">a</span>() <span class="hljs-comment">//error. a is not typeof==='function'</span>
</code></pre>

<p>The built in object <strong>Math</strong> is <strong>typeof</strong>===<strong>'object'</strong>. Hence a new object of type Math cannot be created by new operator.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>() <span class="hljs-comment">//error. Math is not typeof==='function'</span>
</code></pre>

<p>Also notice that <strong>Object</strong>,<strong>Array</strong> and <strong>RegExp</strong> functions can create a new object without even using <strong>operator new</strong>. However the follwing ones don't.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-title class_">String</span>() <span class="hljs-comment">// Create a new Non Object string. returns a typeof==='string' </span>
<span class="hljs-keyword">var</span> a=<span class="hljs-title class_">Number</span>() <span class="hljs-comment">// Create a new Non Object Number. returns a typeof==='number'</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-title class_">Boolean</span>() <span class="hljs-comment">//Create a new Non Object Boolean. returns a typeof==='boolean'</span>
</code></pre>

<p>The user defined functions are special case. </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-title class_">UserDefinedFunction</span>() <span class="hljs-comment">//may or may not create an object of type UserDefinedFunction() based on how it is defined.</span>
</code></pre>

<p>Since the <strong><em>Function type objects</em></strong> can create new objects they are also called <strong><em>Constructors</em></strong>.</p>

<p>Every <strong>Constructor/Function</strong> (whether built in or user defined) when defined automatically has a property called <strong>"prototype"</strong> whose value by default is set as an object. This object itself has a property called <strong>"constructor"</strong> which by default references back the <strong>Constructor/Function</strong> .</p>

<p>For example when we define a function</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDefinedFunction</span>(<span class="hljs-params"></span>)
{
}
</code></pre>

<p>following automatically happens</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>={<span class="hljs-attr">constructor</span>:<span class="hljs-title class_">UserDefinedFunction</span>}
</code></pre>

<p>This <strong>"prototype" property</strong> is only present in the <strong>Function type objects</strong> 
(and never in <strong>Non Function type objects</strong>). </p>

<p>This is because <strong>when a new object is created (using new operator)it inherits all properties and methods from Constructor function's current prototype object i.e. an</strong> <strong><em>internal reference</em></strong> <strong>is created in the newly created object that references the object referenced by Constructor function's current prototype object.</strong></p>

<p>This <strong>"internal reference"</strong> that is created in the object for referencing inherited properties is known as the <strong>object's prototype</strong> (which references the object referenced by Constructor's <strong>"prototype"</strong> property but is different from it). For any object (Function or Non Function) this can be retrieved using <strong>Object.getPrototypeOf()</strong> method. Using this method one can trace the prototype chain of an object. </p>

<p>Also, <strong>every object that is created</strong> (<strong>Function type</strong> or <strong>Non Function type</strong>) has a <strong>"constructor"</strong> property which is inherited from the object referenced by prototype  property of the Constructor function. By default this <strong>"constructor"</strong> property references the <strong>Constructor function</strong> that created it (if the <strong>Constructor Function's</strong> default "prototype" is not changed). </p>

<p>For all <strong><em>Function type objects</em></strong> the constructor function is always
<strong><em>function Function(){}</em></strong></p>

<p>For <strong><em>Non Function type objects</em></strong> (e.g Javascript Built in  Math object) the constructor function is the function that created it.
For <strong>Math</strong> object it is <strong><em>function Object(){}</em></strong>. </p>

<p>All the concept explained above can be a little daunting to understand without any supporting code. Please go through the following code line by line to understand the concept. Try to execute it to have a better understanding.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDefinedFunction</span>(<span class="hljs-params"></span>)
{ 

} 

<span class="hljs-comment">/* creating the above function automatically does the following as mentioned earlier

UserDefinedFunction.prototype={constructor:UserDefinedFunction}

*/</span>


<span class="hljs-keyword">var</span> newObj_1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDefinedFunction</span>()

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_1)===<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)  <span class="hljs-comment">//Displays true</span>

<span class="hljs-title function_">alert</span>(newObj_1.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//Displays function UserDefinedFunction</span>

<span class="hljs-comment">//Create a new property in UserDefinedFunction.prototype object</span>

<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">TestProperty</span>=<span class="hljs-string">"test"</span>

<span class="hljs-title function_">alert</span>(newObj_1.<span class="hljs-property">TestProperty</span>) <span class="hljs-comment">//Displays "test"</span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_1).<span class="hljs-property">TestProperty</span>)<span class="hljs-comment">// Displays "test"</span>

<span class="hljs-comment">//Create a new Object</span>

<span class="hljs-keyword">var</span> objA = {
        property1 : <span class="hljs-string">"Property1"</span>,
        <span class="hljs-attr">constructor</span>:<span class="hljs-title class_">Array</span>

}


<span class="hljs-comment">//assign a new object to UserDefinedFunction.prototype</span>
<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=objA

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_1)===<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)  <span class="hljs-comment">//Displays false. The object referenced by UserDefinedFunction.prototype has changed</span>

<span class="hljs-comment">//The internal reference does not change</span>
<span class="hljs-title function_">alert</span>(newObj_1.<span class="hljs-property">constructor</span>) <span class="hljs-comment">// This shall still Display function UserDefinedFunction</span>

<span class="hljs-title function_">alert</span>(newObj_1.<span class="hljs-property">TestProperty</span>) <span class="hljs-comment">//This shall still Display "test" </span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_1).<span class="hljs-property">TestProperty</span>) <span class="hljs-comment">//This shall still Display "test"</span>


<span class="hljs-comment">//Create another object of type UserDefinedFunction</span>
<span class="hljs-keyword">var</span> newObj_2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDefinedFunction</span>();

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_2)===objA) <span class="hljs-comment">//Displays true.</span>

<span class="hljs-title function_">alert</span>(newObj_2.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//Displays function Array()</span>

<span class="hljs-title function_">alert</span>(newObj_2.<span class="hljs-property">property1</span>) <span class="hljs-comment">//Displays "Property1"</span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_2).<span class="hljs-property">property1</span>) <span class="hljs-comment">//Displays "Property1"</span>

<span class="hljs-comment">//Create a new property in objA</span>
objA.<span class="hljs-property">property2</span>=<span class="hljs-string">"property2"</span>

<span class="hljs-title function_">alert</span>(objA.<span class="hljs-property">property2</span>) <span class="hljs-comment">//Displays "Property2"</span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">property2</span>) <span class="hljs-comment">//Displays "Property2"</span>

<span class="hljs-title function_">alert</span>(newObj_2.<span class="hljs-property">property2</span>) <span class="hljs-comment">// Displays Property2</span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(newObj_2).<span class="hljs-property">property2</span>) <span class="hljs-comment">//Displays  "Property2"</span>
</code></pre>

<p>The prototype chain of every object ultimately traces back to Object.prototype (which itself does not have any prototype object) .
Following code can be used for tracing the prototype chain of an object</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> o=<span class="hljs-title class_">Starting</span> object;

<span class="hljs-keyword">do</span> {
    <span class="hljs-title function_">alert</span>(o + <span class="hljs-string">"\n"</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(o))

}<span class="hljs-keyword">while</span>(o=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o))
</code></pre>

<p>The prototype chain for various objects work out as follows.</p>

<ul>
<li>Every Function object (including built in Function object)-&gt;
Function.prototype -&gt; Object.prototype -&gt; null   </li>
<li>Simple Objects (created By new Object() or {} including built in Math  object)-&gt;   Object.prototype -&gt; null</li>
<li>Object created with new or Object.create -&gt; One or More prototype chains -&gt; Object.prototype -&gt; null</li>
</ul>

<p>For creating an object without any prototype use the following:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> o=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o)) <span class="hljs-comment">//Displays null</span>
</code></pre>

<p>One might think that setting the prototype property of the Constructor to null shall create an object with a null prototype. However in such cases the newly created object's prototype is set to Object.prototype and its constructor is set to function Object. This is demonstrated by the following code</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDefinedFunction</span>(<span class="hljs-params"></span>){}
<span class="hljs-title class_">UserDefinedFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-literal">null</span><span class="hljs-comment">// Can be set to any non object value (number,string,undefined etc.)</span>

<span class="hljs-keyword">var</span> o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDefinedFunction</span>()
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o)==<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)   <span class="hljs-comment">//Displays true</span>
<span class="hljs-title function_">alert</span>(o.<span class="hljs-property">constructor</span>)    <span class="hljs-comment">//Displays Function Object</span>
</code></pre>

<p>Following in the summary of this article</p>

<ul>
<li>There are two types of objects <strong>Function types</strong> and <strong>Non Function types</strong></li>
<li><p>Only <strong>Function type objects</strong> can create a new object using the <strong>operator new</strong>. The objects thus created are <strong>Non Function type</strong> objects. The <strong>Non Function type objects</strong> cannot further create an object using <strong>operator new</strong>.</p></li>
<li><p>All <strong>Function type objects</strong> by default have a <strong>"prototype"</strong> property. This <strong>"prototype"</strong> property references an object that has a <strong>"constructor"</strong> property that by default references the <strong>Function type object</strong> itself.  </p></li>
<li><p>All objects (<strong>Function type</strong> and <strong>Non Function type</strong>) have a "constructor" property that by default references the <strong>Function type object</strong>/<strong>Constructor</strong> that created it.</p></li>
<li><p>Every object that gets created internally references the object referenced by
<strong>"prototype"</strong> property of the Constructor that created it. This object is known as the created <strong><em>object's prototype</em></strong> (which is different from Function type objects "prototype" property which it references) . This way the created object can directly access the methods and properties defined in object referenced by the Constructor's "prototype" property (at the time of object creation).</p></li>
<li><p>An <strong>object's prototype</strong> (and hence its inherited property names) can be retrieved using the <strong>Object.getPrototypeOf()</strong>   method. In fact this method 
can be used for navigating the entire prototype chain of the object.</p></li>
<li><p>The prototype chain of every object ultimately traces back to Object.prototype (Unless the object is created using Object.create(null) in which case the object has no prototype).</p></li>
<li><p><strong>typeof(new Array())==='object'</strong> is by design of language and not a mistake as pointed by <a href="http://javascript.crockford.com/survey.html">Douglas Crockford</a>  </p></li>
<li><p>Setting the prototype property of the Constructor to null(or undefined,number,true,false,string) shall not create an object with a null prototype. In such cases the newly created object's prototype is set to Object.prototype and its constructor is set to function Object. </p></li>
</ul>

<p>Hope this helps.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It may help to categorise prototype chains into two categories.</p>

<p>Consider the constructor:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) {}
</code></pre>

<p>The value of <code>Object.getPrototypeOf(Person)</code> is a function. In fact, it is <code>Function.prototype</code>. Since <code>Person</code> was created as a function, it shares the same prototype function object that all functions have. It is the same as <code>Person.__proto__</code>, but that property should not be used. Anyway, with <code>Object.getPrototypeOf(Person)</code> you effectively walk up the ladder of what is called the prototype chain.</p>

<p>The chain in upward direction looks like this:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Person</code>  <code>Function.prototype</code>  <code>Object.prototype</code> (end point)</p>

<p>Important is that this prototype chain has little to do with the objects that <code>Person</code> can <em>construct</em>. Those constructed objects have their own prototype chain, and this chain can potentially have no close ancestor in common with the one mentioned above.</p>

<p>Take for example this object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
</code></pre>

<p><em>p</em> has no direct prototype-chain relationship with <em>Person</em>. Their relationship is a different one. The object <em>p</em> has its own prototype chain. Using <code>Object.getPrototypeOf</code>, you'll find the chain is as follows:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>p</code>  <code>Person.prototype</code>  <code>Object.prototype</code> (end point)</p>

<p>There is no function object in this chain (although that could be).</p>

<p>So <code>Person</code> seems related to two kinds of chains, which live their own lives. To "jump" from one chain to the other, you use:</p>

<ol>
<li><p><code>.prototype</code>: jump from the constructor's chain to the created-object's chain. This property is thus only defined for function objects (as <code>new</code> can only be used on functions).</p></li>
<li><p><code>.constructor</code>: jump from the created-object's chain to the constructor's chain.</p></li>
</ol>

<p>Here is a visual presentation of the two prototype chains involved, represented as columns:</p>

<p><a href="https://i.stack.imgur.com/FPPdI.png" rel="noreferrer"><img src="https://i.stack.imgur.com/FPPdI.png" alt="enter image description here"></a></p>

<p>To summarise:</p>

<blockquote>
  <p>The <code>prototype</code> property gives no information of the <em>subject's</em> prototype chain, but of objects <em>created by</em> the subject. </p>
</blockquote>

<p>It is no surprise that the name of the property <code>prototype</code> can lead to confusion. It would maybe have been clearer if this property had been named <code>prototypeOfConstructedInstances</code> or something along that line.</p>

<p>You can jump back and forth between the two prototype chains:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>
</code></pre>

<p>This symmetry can be broken by explicitly assigning a different object to the <code>prototype</code> property (more about that later).</p>

<h3>Create one Function, Get Two Objects</h3>

<p><code>Person.prototype</code> is an object that was created at the same time the function <code>Person</code> was created. It has <code>Person</code> as constructor, even though that constructor did not actually execute yet. So two objects are created at the same time:</p>

<ol>
<li>The function <code>Person</code> itself</li>
<li>The object that will act as prototype when the function is called as a constructor</li>
</ol>

<p>Both are objects, but they have different roles: the function object <em>constructs</em>, while the other object represents the prototype of any object that function will construct. The prototype object will become the parent of the constructed object in its prototype chain.</p>

<p>Since a function is also an object, it also has its own parent in its own prototype chain, but recall that these two chains are about different things. </p>

<p>Here are some equalities that could help grasp the issue -- all of these print <code>true</code>:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) {};

<span class="hljs-comment">// This is prototype chain info for the constructor (the function object):</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Person</span>) === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-comment">// Step further up in the same hierarchy:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) === <span class="hljs-literal">null</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-comment">// Here we swap lanes, and look at the constructor of the constructor</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);

<span class="hljs-comment">// Person.prototype was created by Person (at the time of its creation)</span>
<span class="hljs-comment">// Here we swap lanes back and forth:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);
<span class="hljs-comment">// Although it is not an instance of it:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>));
<span class="hljs-comment">// Instances are objects created by the constructor:</span>
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
<span class="hljs-comment">// Similarly to what was shown for the constructor, here we have</span>
<span class="hljs-comment">// the same for the object created by the constructor:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-comment">// Here we swap lanes, and look at the constructor</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif3" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<h3>Adding levels to the prototype chain</h3>

<p>Although a prototype object is created when you create a constructor function, you can ignore that object, and assign another object that should be used as prototype for any subsequent instances created by that constructor.</p>

<p>For instance:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Thief</span>(<span class="hljs-params"></span>) { }
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
<span class="hljs-title class_">Thief</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p; <span class="hljs-comment">// this determines the prototype for any new Thief objects:</span>
<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thief</span>();
</code></pre>

<p>Now the prototype chain of <em>t</em> is one step longer than that of <em>p</em>:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>t</code>  <code>p</code>  <code>Person.prototype</code>  <code>Object.prototype</code> (end point)</p>

<p>The other prototype chain is not longer: <code>Thief</code> and <code>Person</code> are siblings sharing the same parent in their prototype chain:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Person</code>}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>Thief</code>&nbsp; }  <code>Function.prototype</code>  <code>Object.prototype</code> (end point)</p>

<p>The earlier presented graphic can then be extended to this (the original <code>Thief.prototype</code> is left out):</p>

<p><a href="https://i.stack.imgur.com/m5DXc.png" rel="noreferrer"><img src="https://i.stack.imgur.com/m5DXc.png" alt="enter image description here"></a></p>

<p>The blue lines represent prototype chains, the other coloured lines represent other relationships:</p>

<ul>
<li>between an object and its constructor</li>
<li>between a constructor and the prototype object that will be used for constructing objects</li>
</ul>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The concept of <code>prototypal</code> inheritance is one of the most complicated for many developers. Let's try to understand the root of problem to understand <code>prototypal inheritance</code> better. Let's start with a <code>plain</code> function. </p>

<p><a href="https://i.stack.imgur.com/BsHT0.png" rel="noreferrer"><img src="https://i.stack.imgur.com/BsHT0.png" alt="enter image description here"></a></p>

<p>If we use a <code>new</code> operator on the <code>Tree function</code>, we call it as a <code>constructor</code> function. </p>

<p><a href="https://i.stack.imgur.com/cU6Qh.png" rel="noreferrer"><img src="https://i.stack.imgur.com/cU6Qh.png" alt="enter image description here"></a></p>

<p>Every <code>JavaScript</code> function has a <code>prototype</code>. When you log the <code>Tree.prototype</code>, you get...</p>

<p><a href="https://i.stack.imgur.com/Xop8c.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Xop8c.png" alt="enter image description here"></a></p>

<p>If you look at the above <code>console.log()</code> output, you could a see a constructor property on <code>Tree.prototype</code> and a <code>__proto__</code> property too. The <code>__proto__</code> represents the <code>prototype</code> that this <code>function</code> is based off, and since this is just a plain <code>JavaScript function</code> with no <code>inheritance</code> set up yet, it refers to the <code>Object prototype</code> which is something just built in to JavaScript...</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype</a></p>

<p>This has things like <code>.toString, .toValue, .hasOwnProperty</code> etc...</p>

<p><code>__proto__</code> which was brought my mozilla is deprecated and is replaced by <code>Object.getPrototypeOf</code> method to get the <code>object's prototype</code>. </p>

<p><a href="https://i.stack.imgur.com/GtcJO.png" rel="noreferrer"><img src="https://i.stack.imgur.com/GtcJO.png" alt="enter image description here"></a></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Tree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Object {} </span>
</code></pre>

<p>Let's add a method to our <code>Tree</code> <code>prototype</code>. </p>

<p><a href="https://i.stack.imgur.com/BsHT0.png" rel="noreferrer"><img src="https://i.stack.imgur.com/BsHT0.png" alt="enter image description here"></a></p>

<p>We have modified the <code>Root</code> and added a <code>function</code> branch to it. </p>

<p><a href="https://i.stack.imgur.com/cU6Qh.png" rel="noreferrer"><img src="https://i.stack.imgur.com/cU6Qh.png" alt="enter image description here"></a></p>

<p>That means when you create an <code>instance</code> of <code>Tree</code>, you can call it's <code>branch</code> method.</p>

<p><a href="https://i.stack.imgur.com/Xop8c.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Xop8c.png" alt="enter image description here"></a></p>

<p>We can also add <code>primitives</code> or <code>objects</code> to our <code>Prototype</code>. </p>

<p><a href="https://i.stack.imgur.com/GtcJO.png" rel="noreferrer"><img src="https://i.stack.imgur.com/GtcJO.png" alt="enter image description here"></a></p>

<p>Let's add a <code>child-tree</code> to our <code>Tree</code>. </p>

<p><a href="https://i.stack.imgur.com/ggFON.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ggFON.png" alt="enter image description here"></a></p>

<p>Here the <code>Child</code> inherits its <code>prototype</code> from Tree, what we are doing here is using <code>Object.create()</code> method to create a new object based off what you pass, here it is <code>Tree.prototype</code>. In this case what we're doing is setting the prototype of Child to a new object that looks identical to the <code>Tree</code> prototype. Next we are setting the <code>Child's constructor to Child</code>, if we don't it would point to <code>Tree()</code>. </p>

<p><a href="https://i.stack.imgur.com/yiZcY.png" rel="noreferrer"><img src="https://i.stack.imgur.com/yiZcY.png" alt="enter image description here"></a></p>

<p><code>Child</code> now has its own <code>prototype</code>, its <code>__proto__</code> points to <code>Tree</code> and <code>Tree's prototype</code> points to base <code>Object</code>. </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Child</span>  
|
 \
  \
   <span class="hljs-title class_">Tree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
   - branch
   |
   |
    \
     \
      <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
      -toString
      -valueOf
      -etc., etc.
</code></pre>

<p>Now you create an <code>instance</code> of <code>Child</code> and call <code>branch</code> which is originally available in <code>Tree</code>. We haven't actually defined our <code>branch</code> on the <code>Child prototype</code>. BUT, in the <code>Root prototype</code> which Child inherits from. </p>

<p><a href="https://i.stack.imgur.com/k6BNb.png" rel="noreferrer"><img src="https://i.stack.imgur.com/k6BNb.png" alt="enter image description here"></a></p>

<p><strong>In JS everything is not an object, everything can act like an object.</strong></p>

<p><code>Javascript</code> has primitives like <code>strings, number, booleans, undefined, null.</code> They are not <code>object(i.e reference types)</code>, but certainly can act like an <code>object</code>. Let's look at an example here.</p>

<p><a href="https://i.stack.imgur.com/WVjiv.png" rel="noreferrer"><img src="https://i.stack.imgur.com/WVjiv.png" alt="enter image description here"></a></p>

<p>In the first line of this listing, a <code>primitive</code> string value is assigned to name. The second line treats name like an <code>object</code> and calls <code>charAt(0)</code> using dot notation.</p>

<p>This is what happens behind the scenes:
// what the <code>JavaScript</code> engine does</p>

<p><a href="https://i.stack.imgur.com/l6MHc.png" rel="noreferrer"><img src="https://i.stack.imgur.com/l6MHc.png" alt="enter image description here"></a></p>

<p>The <code>String object</code> exists only for one statement before its destroyed (a process called <code>autoboxing</code>). Let's again get back to our <code>prototypal</code> <code>inheritance</code>. </p>

<ul>
<li><code>Javascript</code> supports inheritance via <code>delegation</code> based on
<code>prototypes</code>.</li>
<li>Each <code>Function</code> has a <code>prototype</code> property, which refers to another
object.</li>
<li><code>properties/functions</code> are looked from the <code>object</code> itself or via
<code>prototype</code> chain if it does not exist</li>
</ul>

<p>A <code>prototype</code> in JS is an object which <code>yields</code> you to the parent of another <code>object</code>. <strong>[ie.. delegation]</strong> <code>Delegation</code> means that if you are unable to do something, youll tell someone else to do it for you.</p>

<p><a href="https://i.stack.imgur.com/W0NUA.png" rel="noreferrer"><img src="https://i.stack.imgur.com/W0NUA.png" alt="enter image description here"></a></p>

<p><a href="https://jsfiddle.net/say0tzpL/1/" rel="noreferrer">https://jsfiddle.net/say0tzpL/1/</a></p>

<p>If you look up the above fiddle, dog has access to <code>toString</code> method, but its not available in it, but available via the prototype chain which delegates to <code>Object.prototype</code></p>

<p><a href="https://i.stack.imgur.com/lWILf.png" rel="noreferrer"><img src="https://i.stack.imgur.com/lWILf.png" alt="enter image description here"></a></p>

<p>If you look at the below one, we are trying to access the <code>call</code> method which is available in every <code>function</code>.</p>

<p><a href="https://i.stack.imgur.com/iF4RN.png" rel="noreferrer"><img src="https://i.stack.imgur.com/iF4RN.png" alt="enter image description here"></a></p>

<p><a href="https://jsfiddle.net/rknffckc/" rel="noreferrer">https://jsfiddle.net/rknffckc/</a></p>

<p>If you look up the above fiddle, <code>Profile</code> Function has access to <code>call</code> method, but its not available in it, but available via the prototype chain which delegates to <code>Function.prototype</code></p>

<p><a href="https://i.stack.imgur.com/Mijkj.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Mijkj.png" alt="enter image description here"></a></p>

<p><strong>Note:</strong> <code>prototype</code> is a property of the function constructor, whereas <code>__proto__</code> is a property of the objects constructed from the function constructor. Every function comes with a <code>prototype</code> property whose value is an empty <code>object</code>. When we create an instance of the function, we get an internal property <code>[[Prototype]]</code> or <code>__proto__</code> whose reference is the prototype of the Function <code>constructor</code>.</p>

<p><a href="https://i.stack.imgur.com/HvzDP.png" rel="noreferrer"><img src="https://i.stack.imgur.com/HvzDP.png" alt="enter image description here"></a></p>

<p>The above diagram looks bit complicated, but brings out the whole picture on how <code>prototype chaining</code> works. Let's walk through this slowly:</p>

<p>There are two instance <code>b1</code> and <code>b2</code>, whose constructor is <code>Bar</code> and parent is Foo and has two methods from prototype chain <code>identify</code> and <code>speak</code> via <code>Bar</code> and <code>Foo</code></p>

<p><a href="https://i.stack.imgur.com/EllEL.png" rel="noreferrer"><img src="https://i.stack.imgur.com/EllEL.png" alt="enter image description here"></a></p>

<p><a href="https://jsfiddle.net/kbp7jr7n/" rel="noreferrer">https://jsfiddle.net/kbp7jr7n/</a></p>

<p>If you look up the code above, we have <code>Foo</code> constructor who has the method <code>identify()</code> and <code>Bar</code> constructor which has <code>speak</code> method. We create two <code>Bar</code> instance <code>b1</code> and <code>b2</code> whose parent type is <code>Foo</code>. Now while calling <code>speak</code> method of <code>Bar</code>, we are able to identify the who is calling the speak via <code>prototype</code> chain. </p>

<p><a href="https://i.stack.imgur.com/V7fH7.png" rel="noreferrer"><img src="https://i.stack.imgur.com/V7fH7.png" alt="enter image description here"></a></p>

<p><code>Bar</code> now has all the methods of <code>Foo</code> which are defined in its <code>prototype</code>. Let's dig further in understanding the <code>Object.prototype</code> and <code>Function.prototype</code> and how they are related. If you look up the constructor of <code>Foo</code>, <code>Bar</code> and <code>Object</code> are <code>Function constructor</code>.</p>

<p><a href="https://i.stack.imgur.com/wzzRu.png" rel="noreferrer"><img src="https://i.stack.imgur.com/wzzRu.png" alt="enter image description here"></a></p>

<p>The <code>prototype</code> of <code>Bar</code> is <code>Foo</code>, <code>prototype</code> of <code>Foo</code> is <code>Object</code> and if you look closely the <code>prototype</code> of <code>Foo</code> is related to <code>Object.prototype</code>.</p>

<p><a href="https://i.stack.imgur.com/wEOxo.png" rel="noreferrer"><img src="https://i.stack.imgur.com/wEOxo.png" alt="enter image description here"></a></p>

<p>Before we close this down, let's just wrap with a small piece of code here to <strong>summarize everything above</strong>. We are using <code>instanceof</code> operator here to check whether an <code>object</code> has in its <code>prototype</code> chain the <code>prototype</code> property of a <code>constructor</code> which below summarizes the entire big diagram. </p>

<p><a href="https://i.stack.imgur.com/n84uV.png" rel="noreferrer"><img src="https://i.stack.imgur.com/n84uV.png" alt="enter image description here"></a></p>

<p>I hope this add's some information, I know this kinda could be big to grasp... in simple words its <strong>it's just objects linked to objects!!!!</strong> </p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>what is the exact purpose of this ".prototype" property?</p>
</blockquote>

<p>The interface to standard classes become extensible. For example, you are using the <code>Array</code> class and you also need to add a custom serializer for all your array objects. Would you spend time coding up a subclass, or use composition or ... The prototype property solves this by letting the users control the exact set of members/methods available to a class.</p>

<p>Think of prototypes as an extra vtable-pointer. When some members are missing from the original class, the prototype is looked up at runtime.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://www.youtube.com/watch?v=PMfcsYzj-9M">The Definitive Guide to Object-Oriented JavaScript</a> - a very concise and clear ~30min video explanation of the asked question (Prototypal Inheritance topic begins from <a href="https://youtu.be/PMfcsYzj-9M?t=344">5:45</a>, although I'd rather listen to the whole video). The author of this video also made JavaScript object visualizer website <a href="http://www.objectplayground.com/">http://www.objectplayground.com/</a>.<a href="https://i.stack.imgur.com/Vf4qR.jpg"><img src="https://i.stack.imgur.com/Vf4qR.jpg" alt="enter image description here"></a>
<a href="https://i.stack.imgur.com/xcRpT.jpg"><img src="https://i.stack.imgur.com/xcRpT.jpg" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I found it helpful to explain the "prototype chain" as recursive convention when <code>obj_n.prop_X</code> is being referenced:</p>

<p>if <code>obj_n.prop_X</code> doesn't exist, check <code>obj_n+1.prop_X</code> where <code>obj_n+1 = obj_n.[[prototype]]</code></p>

<p>If the <code>prop_X</code> is finally found in the k-th prototype object then</p>

<p><code>obj_1.prop_X = obj_1.[[prototype]].[[prototype]]..(k-times)..[[prototype]].prop_X</code></p>

<p>You can find a graph of the relation of Javascript objects by their properties here:</p>

<p> <img src="https://i.stack.imgur.com/2tGyY.jpg" alt="js objects graph"> </p>

<p><a href="http://jsobjects.org" rel="noreferrer">http://jsobjects.org</a></p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When a constructor creates an object, that object implicitly references the constructors prototype property for the purpose of resolving property references. The constructors prototype property can be referenced by the program expression constructor.prototype, and properties added to an objects prototype are shared, through inheritance, by all objects sharing the prototype.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There's two distinct but related entities here that need explaining:</p>

<ul>
<li>The <code>.prototype</code> property of functions.</li>
<li>The <code>[[Prototype]]</code><sup><sup>[1]</sup></sup> property of all objects<sup><sup>[2]</sup></sup>. </li>
</ul>

<p>These are two different things. </p>

<h2>The <code>[[Prototype]]</code> property:</h2>

<p>This is a property that exists on all<sup><sup>[2]</sup></sup> objects.</p>

<p>What's stored here is another object, which, as an object itself, has a <code>[[Prototype]]</code> of its own that points to another object. That other object has a <code>[[Prototype]]</code> of its own. This story continues until you reach the prototypical object that provides methods that are accessible on all objects (like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" rel="noreferrer"><code>.toString</code></a>).</p>

<p>The <code>[[Prototype]]</code> property is part of what forms the <code>[[Prototype]]</code> chain. This chain of <code>[[Prototype]]</code> objects is what is examined when, for example, <code>[[Get]]</code> or <code>[[Set]]</code> operations are performed on an object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> obj = {}
obj.<span class="hljs-property">a</span>         <span class="hljs-comment">// [[Get]] consults prototype chain</span>
obj.<span class="hljs-property">b</span> = <span class="hljs-number">20</span>    <span class="hljs-comment">// [[Set]] consults prototype chain</span>
</code></pre>

<h2>The <code>.prototype</code> property:</h2>

<p><em>This is a property that is only found on functions.</em> Using a very simple function:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params"></span>){};
</code></pre>

<p>The <code>.prototype</code> property <em>holds an object</em> that will be assigned to <code>b.[[Prototype]]</code> when you do <code>var b = new Bar</code>. You can easily examine this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Both assign Bar.prototype to b1/b2[[Prototype]]</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>;
<span class="hljs-comment">// Object.getPrototypeOf grabs the objects [[Prototype]]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(b) === <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span>
</code></pre>

<p>One of the most important <code>.prototype</code>s is that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" rel="noreferrer">of the <code>Object</code> function</a>. This prototype holds the prototypical object that all <code>[[Prototype]]</code> chains contain. On it, all the available methods for new objects are defined:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Get properties that are defined on this object</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>))
</code></pre>

<p>Now, since <code>.prototype</code> is an object, it has a <code>[[Prototype]]</code> property. When you don't make any assignments to <code>Function.prototype</code>, the <code>.prototype</code>'s <code>[[Prototype]]</code> points to the prototypical object (<code>Object.prototype</code>). This is automatically performed anytime you create a new function. </p>

<p>This way, any time you do <code>new Bar;</code> the prototype chain is set up for you, you get everything defined on <code>Bar.prototype</code> and everything defined on <code>Object.prototype</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>;
<span class="hljs-comment">// Get all Bar.prototype properties</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
<span class="hljs-comment">// Get all Object.prototype properties</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
</code></pre>

<p>When you <em>do</em> make assignments to <code>Function.prototype</code> all you are doing is extending the prototype chain to include another object. It's like an insertion in a singly linked list. </p>

<p>This basically alters the <code>[[Prototype]]</code> chain allowing properties that are defined on the object assigned to <code>Function.prototype</code> to be seen by any object created by the function.</p>

<hr>

<p><sup>[1: That won't confuse anyone; made available via <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" rel="noreferrer">the <code>__proto__</code> property</a> in many implementations.</sup><br>
<sup>[2]: All except <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noreferrer"><code>null</code></a>.</sup></p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let me tell you my understanding of prototypes. I am not going to compare the inheritance here with other languages. I wish people would stop comparing languages, and just understand the language as itself. Understanding prototypes and prototypal inheritance is so simple, as I will show you below.</p>

<p>Prototype is like a model, based on which you create a product. The crucial point to understand is that when you create an object using another object as it's prototype, the link between the prototype and the product is ever-lasting. For instance:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> model = {<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>};
<span class="hljs-keyword">var</span> product = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(model);
model.<span class="hljs-property">y</span> = <span class="hljs-number">5</span>;
product.<span class="hljs-property">y</span>
=&gt;<span class="hljs-number">5</span>
</code></pre>

<p>Every object contains an internal property called the [[prototype]], which can be accessed by the <code>Object.getPrototypeOf()</code> function. <code>Object.create(model)</code> creates a new object and sets it's [[prototype]] property to the object <strong>model</strong>. Hence when you do <code>Object.getPrototypeOf(product)</code>, you will get the object <strong>model</strong>.</p>

<p>Properties in the <strong>product</strong> are handled in the following way:</p>

<ul>
<li>When a property is accessed to just read it's value, its looked up in the scope chain. The search for the variable starts from the <strong>product</strong> upwards to it's prototype. If such a variable is found in the search, the search is stopped right there, and the value is returned. If such a variable cannot be found in the scope chain, undefined is returned.</li>
<li>When a property is written(altered), then the property is always written on the <strong>product</strong> object. If the <strong>product</strong> does not have such a property already, it is implicitly created and written.</li>
</ul>

<p>Such a linking of objects using the prototype property is called prototypal inheritance. There, it is so simple, agree?</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another attempt to explain <a href="https://github.com/rus0000/jsinheritance" rel="noreferrer">JavaScript prototype-based inheritance</a> with better pictures</p>

<p><a href="https://github.com/rus0000/jsinheritance" rel="noreferrer"><img src="https://i.stack.imgur.com/6gEKe.png" alt="Simple objects inheritanse"></a></p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider the following <code>keyValueStore</code> object :</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> keyValueStore = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> kvs = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        count++;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = {};
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key]; };
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key] = value; };
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">delete</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) { <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key]; };
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">getLength</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">var</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>) l++;
            <span class="hljs-keyword">return</span> l;
        }
    };

    <span class="hljs-keyword">return</span>  { <span class="hljs-comment">// Singleton public properties</span>
        <span class="hljs-string">'create'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">kvs</span>(); },
        <span class="hljs-string">'count'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> count; }
    };
})();
</code></pre>

<p>I can create a new instance of this object by doing this :</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">kvs = keyValueStore.<span class="hljs-title function_">create</span>();
</code></pre>

<p>Each instance of this object would have the following public properties :</p>

<ul>
<li><code>data</code></li>
<li><code>get</code> </li>
<li><code>set</code></li>
<li><code>delete</code></li>
<li><code>getLength</code></li>
</ul>

<p>Now, suppose we create 100 instances of this <code>keyValueStore</code> object. Even though <code>get</code>, <code>set</code>, <code>delete</code>, <code>getLength</code> will do the exact same thing for each of these 100 instances, every instance has its own copy of this function.</p>

<p>Now, imagine if you could have just a single <code>get</code>, <code>set</code>, <code>delete</code> and <code>getLength</code> copy, and each instance would reference that same function. This would be better for performance and require less memory.</p>

<p>That's where prototypes come in. A prototype is a "blueprint" of properties that is inherited but not copied by instances. So this means that it exists only once in memory for all instances of an object and is shared by all of those instances.</p>

<p>Now, consider the <code>keyValueStore</code> object again. I could rewrite it like this :</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> keyValueStore = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> kvs = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        count++;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = {};
    };

    kvs.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
        <span class="hljs-string">'get'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key]; },
        <span class="hljs-string">'set'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key] = value; },
        <span class="hljs-string">'delete'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) { <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[key]; },
        <span class="hljs-string">'getLength'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">var</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>) l++;
            <span class="hljs-keyword">return</span> l;
        }
    };

    <span class="hljs-keyword">return</span>  {
        <span class="hljs-string">'create'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">kvs</span>(); },
        <span class="hljs-string">'count'</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> count; }
    };
})();
</code></pre>

<p>This does EXACTLY the same as the previous version of the <code>keyValueStore</code> object, except that all of its methods are now put in a prototype. What this means, is that all of the 100 instances now share these four methods instead of each having their own copy.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Summary:</h2>

<ul>
<li>Functions are objects in javascript and thus can have properties</li>
<li>(Constructor) functions <strong>always</strong> have a prototype property</li>
<li>When a function is used as a constructor with the <code>new</code> keyword the object gets  prototype. A reference to this prototype can be found on the <code>__proto__</code> property of the newly created object.</li>
<li>This <code>__proto__</code> property refers to the <code>prototype</code> property of the constructor function.</li>
</ul>

<h2>Example:</h2>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'willem'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// Person has a prototype property</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === me.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">// the __proto__ property of the instance refers to prototype property of the function.</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif4" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<h2>Why is this usefull:</h2>

<p>Javascript has a mechanism when looking up properties on Objects which is called <strong>'prototypal inheritance'</strong>, here is what is basically does:</p>

<ul>
<li>First is checked if the property is located on the Object itself. If so this property is returned.</li>
<li>If the property is not located on the object itself it will 'climb up the protochain'. It basically looks at the object referred to by the <strong>proto</strong> property. There it checks if the property is available on the object referred to by <strong>proto</strong></li>
<li>If the property isn't located on the <strong>proto</strong> object it will climb up the <strong>proto</strong> chain all the way up to Object object.</li>
<li>If it cannot find the property nowhere on the object and its prototype chain it will return undefined.</li>
</ul>

<p><strong>For example:</strong></p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">let</span> mySelf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Willem'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySelf.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySelf.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif5" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p><strong>Update:</strong></p>

<p>The  <code>__proto__</code> property has been deprecated, although it is implemented in most modern browsers a better way to obtain the prototype object reference would be:</p>

<p><code>Object.getPrototypeOf()</code></p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I always like analogies when it comes to understand this type of stuff. 'Prototypical inheritance' is pretty confusing in comparison to class bass inheritance in my opinion, even though prototypes are much simpler paradigm. In fact with prototypes, there really is no inheritance, so the name in and of itself misleading, it's more a type of 'delegation'.</p>

<p>Imagine this ....</p>

<p>You're in high-school, and you're in class and have a quiz that's due today, but you don't have a pen to fill out your answers. Doh!</p>

<p>You're sitting next to your friend Finnius, who might have a pen. You ask, and he looks around his desk unsuccessfully, but instead of saying "I don't have a pen", he's a nice friend he checks with his other friend Derp if he has a pen. Derp does indeed have a spare pen and passes it back to Finnius, who passes it over to you to complete your quiz. Derp has entrusted the pen to Finnius, who has delegated the pen to you for use.</p>

<p>What is important here is that Derp does not give the pen to you, as you don't have a direct <em>relationship</em> with him.</p>

<p>This, is a simplified example of how prototypes work, where a tree of data is searched for the thing you're looking for.</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>another scheme showing <strong>__proto__</strong>, <strong>prototype</strong> and <strong>constructor</strong> relations:
<a href="https://i.stack.imgur.com/uy5ce.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/uy5ce.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's just that you already have an object with <code>Object.new</code> but you still don't have an object when using the constructor syntax.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>It's important to understand that there is a distinction between an object's prototype (which is available via <code>Object.getPrototypeOf(obj)</code>, or via the deprecated <code>__proto__</code> property) and the <code>prototype</code> property on constructor functions. The former is the property on each instance, and the latter is the property on the constructor. That is, <code>Object.getPrototypeOf(new Foobar())</code> refers to the same object as <code>Foobar.prototype</code>.</p>
</blockquote>

<p>Reference: <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes</a></p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <strong>Prototype</strong> creates <strong>new object</strong> by cloning existing <strong>object</strong>. So really when we think about prototype we can really think <strong>cloning or making</strong> a copy of something instead of making it up.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want to understand the concept of prototype and prototype based inheritance from the basics, check the official <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="nofollow noreferrer">MDN</a> docs, they explain it pretty well.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<blockquote>
<p>When it comes to inheritance, JavaScript only has one construct:
objects. Each object has a private property which holds a link to
another object called its prototype. That prototype object has a
prototype of its own, and so on until an object is reached with null
as its prototype. By definition, null has no prototype, and acts as
the final link in this prototype chain.</p>
</blockquote>
<p>Also, here's another good resource that explains using simple examples - <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes</a></p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It\u0026apos;s not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Define a functional object to hold persons in JavaScript\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Add dynamically to the already defined object a new getter\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new object of type Person\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; john = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Try the getter\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(john.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//If now I modify person, also John gets the updates\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello, my name is \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;());\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Call the new method on john\u0026lt;/span\u0026gt;\njohn.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Until now I\u0026apos;ve been extending the base object, now I create another object and then inheriting from Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new object of type Customer by defining its constructor. It\u0026apos;s not \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//related to Person for now.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Now I link the objects and to do so, we link the prototype of Customer to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//a new instance of Person. The prototype is the base that will be used to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//construct all new instances and also, will modify dynamically all already \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//constructed objects because in JavaScript objects retain a pointer to the \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;();     \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Now I can call the methods of Person on the Customer, let\u0026apos;s try, first \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//I need to create a Customer.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myCustomer = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Dream Inc.\u0026apos;\u0026lt;/span\u0026gt;);\nmyCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//If I add new methods to Person, they will be added to Customer, but if I\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//add new methods to Customer they won\u0026apos;t be added to Person. Example:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setAmountDue\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt; = amountDue;\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getAmountDue\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Let\u0026apos;s try:       \u0026lt;/span\u0026gt;\nmyCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAmountDue\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(myCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAmountDue\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;true\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-display\u0026quot; style=\u0026quot;vertical-align: center\u0026quot;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link-chevron\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;expander-arrow-hide\u0026quot; style=\u0026quot;vertical-align: middle;\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a class=\u0026quot;snippet-show-link\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;show-hide\u0026quot; data-ishidden=\u0026quot;true\u0026quot; style=\u0026quot;vertical-align: middle\u0026quot;\u0026gt;Show code snippet\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code snippet-currently-hidden\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; john = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(john.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello, my name is \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;());\n};\njohn.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myCustomer = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Dream Inc.\u0026apos;\u0026lt;/span\u0026gt;);\nmyCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayMyName\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setAmountDue\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt; = amountDue;\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getAmountDue\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;amountDue\u0026lt;/span\u0026gt;;\n};\nmyCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAmountDue\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(myCustomer.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAmountDue\u0026lt;/span\u0026gt;());\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While as said I can\u0026apos;t call setAmountDue(), getAmountDue() on a Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The following statement generates an error.\u0026lt;/span\u0026gt;\njohn.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAmountDue\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every JavaScript object \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;has an internal \u0026quot;slot\u0026quot;\u0026lt;/a\u0026gt; called \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; whose value is either \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; or an \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;. You can think of a slot as a property on an object, internal to the JavaScript engine, hidden from the code you write. The square brackets around \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; are deliberate, and are an ECMAScript specification convention to denote internal slots. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The value pointed at by the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; of an object, is colloquially known as \u0026quot;the prototype of that object.\u0026quot; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you access a property via the dot (\u0026lt;code\u0026gt;obj.propName\u0026lt;/code\u0026gt;) or bracket (\u0026lt;code\u0026gt;obj[\u0026apos;propName\u0026apos;]\u0026lt;/code\u0026gt;) notation, and the object does not directly have such a property (ie. an \u0026lt;em\u0026gt;own property\u0026lt;/em\u0026gt;, checkable via \u0026lt;code\u0026gt;obj.hasOwnProperty(\u0026apos;propName\u0026apos;)\u0026lt;/code\u0026gt;), the runtime looks for a property with that name on the object referenced by the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; instead. If the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; does not have such a property, its \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; is checked in turn, and so on. In this way, the original object\u0026apos;s \u0026lt;em\u0026gt;prototype chain\u0026lt;/em\u0026gt; is walked until a match is found, or its end is reached. At the top of the prototype chain is the \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Modern JavaScript implementations allow read and/or write access to the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; in the following ways:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator (configures the prototype chain on the default object returned from a constructor function),\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;extends\u0026lt;/code\u0026gt; keyword (configures the prototype chain when using the class syntax),\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Object.create\u0026lt;/code\u0026gt; will set the supplied argument as the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; of the resulting object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Object.getPrototypeOf\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Object.setPrototypeOf\u0026lt;/code\u0026gt; (get/set the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; object creation), and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The standardized accessor (ie. getter/setter) property named \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; (similar to 4.)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Object.getPrototypeOf\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Object.setPrototypeOf\u0026lt;/code\u0026gt; are preferred over \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;, in part because the behavior of \u0026lt;code\u0026gt;o.__proto__\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/35458348/38522\u0026quot;\u0026gt;is unusual\u0026lt;/a\u0026gt; when an object has a prototype of \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An object\u0026apos;s \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; is initially set during object creation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you create a new object via \u0026lt;code\u0026gt;new Func()\u0026lt;/code\u0026gt;, the object\u0026apos;s \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; will, by default, be set to the object referenced by \u0026lt;code\u0026gt;Func.prototype\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that, therefore, \u0026lt;strong\u0026gt;all classes, and all functions that can be used with the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator, have a property named \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; in addition to their own \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; internal slot.\u0026lt;/strong\u0026gt; This dual use of the word \u0026quot;prototype\u0026quot; is the source of endless confusion amongst newcomers to the language.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; with constructor functions allows us to simulate classical inheritance in JavaScript; although JavaScript\u0026apos;s inheritance system is - as we have seen - prototypical, and not class-based.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Prior to the introduction of class syntax to JavaScript, constructor functions were the only way to simulate classes. We can think of properties of the object referenced by the constructor function\u0026apos;s \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; property as shared members; ie. members which are the same for each instance. In class-based systems, methods are implemented the same way for each instance, so methods are conceptually added to the \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; property; an object\u0026apos;s fields, however, are instance-specific and are therefore added to the object itself during construction.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Without the class syntax, developers had to manually configure the prototype chain to achieve similar functionality to classical inheritance. This led to a preponderance of different ways to achieve this. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s one way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inherit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;child, parent\u0026lt;/span\u0026gt;) {\n  child.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(parent.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n  child.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; = child\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; child;\n}\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inherit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; o = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(o.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...and here\u0026apos;s another way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inherit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;child, parent\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n    tmp.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = parent.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; proto = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;()\n    proto.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; = child\n    child.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = proto\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; child\n}\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inherit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; o = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(o.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The class syntax introduced in ES2015 simplifies things, by providing \u0026lt;code\u0026gt;extends\u0026lt;/code\u0026gt; as the \u0026quot;one true way\u0026quot; to configure the prototype chain in order to simulate classical inheritance in JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, similar to the code above, if you use the class syntax to create a new object like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt; } }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; o = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(o.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inheritedMethod\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026apos;this is inherited\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...the resulting object\u0026apos;s \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; will be set to an instance of \u0026lt;code\u0026gt;Parent\u0026lt;/code\u0026gt;, whose \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt;, in turn, is \u0026lt;code\u0026gt;Parent.prototype\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, if you create a new object via \u0026lt;code\u0026gt;Object.create(foo)\u0026lt;/code\u0026gt;, the resulting object\u0026apos;s \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; will be set to \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a very simple prototype based object model that would be considered as a sample during the explanation, with no comment yet:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n}\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;);\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; person = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There are some crucial points that we have to consider before going through the prototype concept.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;1- How JavaScript functions actually work:\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;To take the first step we have to figure out, how JavaScript functions actually work , as a class like function using \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; keyword in it or just as a regular function with its arguments, what it does and what it returns.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we want to create a \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; object model. but in this step I\u0026apos;m gonna be trying to \u0026lt;strong\u0026gt;do the same exact thing without using \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So in this step \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;functions\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;objects\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; keyword, are all we have.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The first question would be \u0026lt;strong\u0026gt;how \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; keyword could be useful without using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So to answer that let\u0026apos;s say we have an empty object, and two functions like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; person = {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;){  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and now \u0026lt;strong\u0026gt;without using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword\u0026lt;/strong\u0026gt; how we could use these functions. So JavaScript has 3 different ways to do that:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;a. first way is just to call the function as a regular function:\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;();\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//would print the \u0026quot;George\u0026quot; in the console\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in this case, this would be the current context object, which is usually is the global  \u0026lt;code\u0026gt;window\u0026lt;/code\u0026gt; object in the browser or \u0026lt;code\u0026gt;GLOBAL\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;Node.js\u0026lt;/code\u0026gt;. It means we would have, window.name in browser or GLOBAL.name in Node.js, with \u0026quot;George\u0026quot; as its value.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;b. We can \u0026lt;strong\u0026gt;attach\u0026lt;/strong\u0026gt; them to an object, as its properties\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;-\u0026lt;strong\u0026gt;The easiest way\u0026lt;/strong\u0026gt; to do this is modifying the empty \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object, like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;person.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;;\nperson.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt; = getName;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;this way we can call them like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;person.\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;);\nperson.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;();\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// --\u0026amp;gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and now the \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object is like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt; {\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;-\u0026lt;strong\u0026gt;The other way to attach a property\u0026lt;/strong\u0026gt; to an object is using the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; of that object that can be find in any JavaScript object with the name of \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;, and I have tried to explain it a bit on the summary part. So we could get the similar result by doing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;person.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;;\nperson.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt; = getName;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;But\u0026lt;/strong\u0026gt; this way what we actually are doing is modifying the \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;, because whenever we create a JavaScript object using literals (\u0026lt;code\u0026gt;{ ... }\u0026lt;/code\u0026gt;), it gets created based on \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;, which means it gets attached to the newly created object as an attribute named \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; , so if we change it, as we have done on our previous code snippet, all the JavaScript objects would get changed, not a good practice. So what could be the better practice now:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;person.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; = {\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;: getName\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and now other objects are in peace, but it still doesn\u0026apos;t seem to be a good practice. So we have still one more solutions, but to use this solution we should get back to that line of code where \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object got created (\u0026lt;code\u0026gt;var person = {};\u0026lt;/code\u0026gt;) then change it like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; propertiesObject = {\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;: getName\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; person = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(propertiesObject);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what it does is creating a new JavaScript \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; and attach the \u0026lt;code\u0026gt;propertiesObject\u0026lt;/code\u0026gt; to the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; attribute. So to make sure you can do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(person.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;===propertiesObject); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But the tricky point here is you have access to all the properties defined in \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; on the first level of the \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object(read the summary part for more detail).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;as you see using any of these two way \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; would exactly point to the \u0026lt;code\u0026gt;person\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;c. JavaScript has another way to provide the function with \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt;, which is using \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;call\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;apply\u0026lt;/a\u0026gt; to invoke the function.\u0026lt;/h2\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The apply() method calls a function with a given this value and\n  arguments provided as an array (or an array-like object).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The call() method calls a function with a given this value and\n  arguments provided individually.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;this way which is my favorite, we can easily call our functions like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(person, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//apply is more useful when params count is not fixed\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;(person, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;]);\n\ngetName.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(person);   \ngetName.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;(person);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;these 3 methods are the important initial steps to figure out the .prototype functionality.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;2- How does the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword work?\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;this is the second step to understand the \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; functionality.this is what I use to simulate the process:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;){  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;  }\nmy_person_prototype = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){ \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;); } };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in this part I\u0026apos;m gonna be trying to take all the steps which JavaScript takes, without using the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword and \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;, when you use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword. so when we do \u0026lt;code\u0026gt;new Person(\u0026quot;George\u0026quot;)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; function serves as a constructor, These are what JavaScript does, one by one:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;a. first of all it makes an empty object, basically an empty hash like:\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newObject = {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;b. the next step that JavaScript takes is to \u0026lt;strong\u0026gt;attach\u0026lt;/strong\u0026gt; the all prototype objects to the newly created object\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;we have \u0026lt;code\u0026gt;my_person_prototype\u0026lt;/code\u0026gt; here similar to the prototype object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; my_person_prototype){\n    newObject[key] = my_person_prototype[key];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is not the way that JavaScript actually attaches the properties that are defined in the prototype. The actual way is related to the prototype chain concept.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;a. \u0026amp;amp; b. Instead of these two steps you can have the exact same result by doing:\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newObject = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(my_person_prototype);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//here you can check out the __proto__ attribute\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(newObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === my_person_prototype); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//and also check if you have access to your desired properties\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; newObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026quot;function\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;now we can call the \u0026lt;code\u0026gt;getName\u0026lt;/code\u0026gt; function in our \u0026lt;code\u0026gt;my_person_prototype\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;newObject.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;c. then it gives that object to the constructor,\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;we can do this with our sample like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(newObject, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;(newObject, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;George\u0026quot;\u0026lt;/span\u0026gt;]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then the constructor can do whatever it wants, because \u0026lt;strong\u0026gt;this\u0026lt;/strong\u0026gt; inside of that constructor is the object that was just created.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;now the end result before simulating the other steps:\n    Object {name: \u0026quot;George\u0026quot;}\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Summary:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, when you use the \u0026lt;strong\u0026gt;new\u0026lt;/strong\u0026gt; keyword on a function, you are calling on that and that function serves as a constructor, so when you say:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;FunctionName\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;JavaScript internally makes an object, an empty hash and then it gives that object to the constructor, then the constructor can do whatever it wants, because \u0026lt;strong\u0026gt;this\u0026lt;/strong\u0026gt; inside of that constructor is the object that was just created and then it gives you that object of course if you haven\u0026apos;t used the return statement in your function or if you\u0026apos;ve put a \u0026lt;code\u0026gt;return undefined;\u0026lt;/code\u0026gt; at the end of your function body.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So when JavaScript goes to look up a property on an object, the first thing it does, is it looks it up on that object. And then there is a secret property \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;[[prototype]]\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; which we usually have it like \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; and that property is what JavaScript looks at next. And when it looks through the \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;, as far as it is again another JavaScript object, it has its own \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; attribute, it goes up and up until it gets to the point where the next \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; is null. The point is the only object in JavaScript that its \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; attribute is null is \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and that\u0026apos;s how inheritance works in JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/JnpBV.png\u0026quot; alt=\u0026quot;The prototype chain\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In other words, when you have a prototype property on a function and you call a new on that, after JavaScript finishes looking at that newly created object for properties, it will go look at the function\u0026apos;s \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; and also it is possible that this object has its own internal prototype. and so on.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; allows you to make classes. if you do not use \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; then it becomes a static.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a short example.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;();\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello?\u0026apos;\u0026lt;/span\u0026gt;); };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the above case, you have static funcation call test. This function can be accessed only by obj.test where you can imagine obj to be a class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;where as in the below code\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{\n}\n\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello?\u0026apos;\u0026lt;/span\u0026gt;); };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;();\nobj2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The obj has become a class which can now be instantiated. Multiple instances of obj can exist and they all have the \u0026lt;code\u0026gt;test\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The above is my understanding. I am making it a community wiki, so people can correct me if I am wrong.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;The seven Koans of prototype\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;As Ciro San descended Mount Fire Fox after deep meditation, his mind was clear and peaceful.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;His hand however, was restless, and by itself grabbed a brush and jotted down the following notes.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;0)\u0026lt;/strong\u0026gt; Two different things can be called \u0026quot;prototype\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;the prototype property, as in \u0026lt;code\u0026gt;obj.prototype\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;the prototype internal property, denoted as \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;in ES5\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It can be retrieved via the ES5 \u0026lt;code\u0026gt;Object.getPrototypeOf()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Firefox makes it accessible through the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property as an extension. \u0026lt;a href=\u0026quot;http://www.ecma-international.org/ecma-262/6.0/#sec-additional-ecmascript-features-for-web-browsers\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ES6 now mentions\u0026lt;/a\u0026gt; some optional requirements for \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1)\u0026lt;/strong\u0026gt; Those concepts exist to answer the question:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When I do \u0026lt;code\u0026gt;obj.property\u0026lt;/code\u0026gt;, where does JS look for \u0026lt;code\u0026gt;.property\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Intuitively, classical inheritance should affect property lookup.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; is used for the dot \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; property lookup as in \u0026lt;code\u0026gt;obj.property\u0026lt;/code\u0026gt;. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; used for lookup directly, only indirectly as it determines \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; at object creation with \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Lookup order is:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;obj\u0026lt;/code\u0026gt; properties added with \u0026lt;code\u0026gt;obj.p = ...\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;Object.defineProperty(obj, ...)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;properties of \u0026lt;code\u0026gt;obj.__proto__\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;properties of \u0026lt;code\u0026gt;obj.__proto__.__proto__\u0026lt;/code\u0026gt;, and so on\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if some \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;, return \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;This is the so-called \u0026lt;em\u0026gt;prototype chain\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can avoid \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; lookup with \u0026lt;code\u0026gt;obj.hasOwnProperty(\u0026apos;key\u0026apos;)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Object.getOwnPropertyNames(f)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3)\u0026lt;/strong\u0026gt; There are two main ways to set \u0026lt;code\u0026gt;obj.__proto__\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; F = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; has set:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;f.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === F.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;This\u0026lt;/em\u0026gt; is where \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; gets used.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Object.create\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(proto)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;sets:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;f.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === proto\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;4)\u0026lt;/strong\u0026gt; The code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; F = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; = i }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Corresponds to the following diagram (some \u0026lt;code\u0026gt;Number\u0026lt;/code\u0026gt; stuff is omitted):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;)       (  F  )                                      (f)-----\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n |  ^             | | ^                                        |   i    |\n |  |             | | |                                        |        |\n |  |             | | +-------------------------+              |        |\n |  |constructor  | |                           |              |        |\n |  |             | +--------------+            |              |        |\n |  |             |                |            |              |        |\n |  |             |                |            |              |        |\n |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]   |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]   |prototype   |constructor   |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]\n |  |             |                |            |              |        |\n |  |             |                |            |              |        |\n |  |             |                | +----------+              |        |\n |  |             |                | |                         |        |\n |  |             |                | | +-----------------------+        |\n |  |             |                | | |                                |\n v  |             v                v | v                                |\n(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)              (F.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)                         |\n |                                 |                                    |\n |                                 |                                    |\n |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]                    |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]          [[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]|\n |                                 |                                    |\n |                                 |                                    |\n | +-------------------------------+                                    |\n | |                                                                    |\n v v                                                                    v\n(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)                                       (\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n | | ^\n | | |\n | | +---------------------------+\n | |                             |\n | +--------------+              |\n |                |              |\n |                |              |\n |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]   |constructor   |prototype\n |                |              |\n |                |              |\n |                | -------------+\n |                | |\n v                v |\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)           (\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This diagram shows many language predefined object nodes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Function\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Number.prototype\u0026lt;/code\u0026gt; (can be found with \u0026lt;code\u0026gt;(1).__proto__\u0026lt;/code\u0026gt;, parenthesis mandatory to satisfy syntax)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Our 2 lines of code only created the following new objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;F\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;F.prototype\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is now a property of \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; because when you do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;it evaluates \u0026lt;code\u0026gt;F\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; being the value that \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; will return, which then gets assigned to \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;5)\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;.constructor\u0026lt;/code\u0026gt; normally comes from \u0026lt;code\u0026gt;F.prototype\u0026lt;/code\u0026gt; through the \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; lookup:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;f.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === F\n!f.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasOwnProperty\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;constructor\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(f) === F.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\nF.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasOwnProperty\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;constructor\u0026apos;\u0026lt;/span\u0026gt;)\nF.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === f.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When we write \u0026lt;code\u0026gt;f.constructor\u0026lt;/code\u0026gt;, JavaScript does the \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; lookup as:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; does not have \u0026lt;code\u0026gt;.constructor\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;f.__proto__ === F.prototype\u0026lt;/code\u0026gt; has \u0026lt;code\u0026gt;.constructor === F\u0026lt;/code\u0026gt;, so take it\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The result \u0026lt;code\u0026gt;f.constructor == F\u0026lt;/code\u0026gt; is intuitively correct, since \u0026lt;code\u0026gt;F\u0026lt;/code\u0026gt; is used to construct \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;, e.g. set fields, much like in classic OOP languages. \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;6)\u0026lt;/strong\u0026gt; Classical inheritance syntax can be achieved by manipulating prototypes chains.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ES6 adds the \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;extends\u0026lt;/code\u0026gt; keywords, which are mostly syntax sugar for previously possible prototype manipulation madness.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; = i\n    }\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;(i)\n    }\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Inheritance syntax works as expected.\u0026lt;/span\u0026gt;\nc = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\nc.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;() === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;() === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc2\u0026lt;/span\u0026gt;() === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;Classes\u0026quot; are just function objects.\u0026lt;/span\u0026gt;\nC.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;\nC.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\nD.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// D is a function \u0026quot;indirectly\u0026quot; through the chain.\u0026lt;/span\u0026gt;\nD.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === C\nD.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;extends\u0026quot; sets up the prototype chain so that base class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// lookups will work as expected\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\nd.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === D.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\nD.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === C.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is what `d.inc` actually does.\u0026lt;/span\u0026gt;\nd.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt; === C.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Class variables\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No ES6 syntax sugar apparently:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives\u0026lt;/span\u0026gt;\nC.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nC.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Because `D.__proto__ === C`.\u0026lt;/span\u0026gt;\nD.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Nothing makes this work.\u0026lt;/span\u0026gt;\nd.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Simplified diagram without all predefined objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(c)-----\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n |   i\n |\n |\n |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]\n |\n |\n v    __proto__\n(C)\u0026amp;lt;--------------(D)         (d)\n| |                |           |\n| |                |           |\n| |prototype       |prototype  |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]] \n| |                |           |\n| |                |           |\n| |                | +---------+\n| |                | |\n| |                | |\n| |                v v\n|[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]    (D.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)--------\u0026amp;gt; (inc2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; object)\n| |                |             inc2\n| |                |\n| |                |[[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]\n| |                |\n| |                |\n| | +--------------+\n| | |\n| | |\n| v v\n| (C.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)-------\u0026amp;gt;(inc \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; object)\n|                inc\nv\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s take a moment to study how the following works:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\nc.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;() === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The first line sets \u0026lt;code\u0026gt;c.i\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; as explained in \u0026quot;4)\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the second line, when we do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;c.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inc\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;.inc\u0026lt;/code\u0026gt; is found through the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; chain: \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;C.prototype\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;inc\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when we call a function in Javascript as \u0026lt;code\u0026gt;X.Y()\u0026lt;/code\u0026gt;, JavaScript automatically sets \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; to equal \u0026lt;code\u0026gt;X\u0026lt;/code\u0026gt; inside the \u0026lt;code\u0026gt;Y()\u0026lt;/code\u0026gt; function call! \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The exact same logic also explains \u0026lt;code\u0026gt;d.inc\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;d.inc2\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This article \u0026lt;a href=\u0026quot;https://javascript.info/class#not-just-a-syntax-sugar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://javascript.info/class#not-just-a-syntax-sugar\u0026lt;/a\u0026gt; mentions further effects of \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; worth knowing. Some of them may not be achievable without the \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; keyword (TODO check which):\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[[FunctionKind]]:\u0026quot;classConstructor\u0026quot;\u0026lt;/code\u0026gt;, which forces the constructor to be called with new: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/44446650/what-is-the-reason-es6-class-constructors-cant-be-called-as-normal-functions\u0026quot;\u0026gt;What is the reason ES6 class constructors can\u0026apos;t be called as normal functions?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Class methods are non-enumerable. Can be done with \u0026lt;code\u0026gt;Object.defineProperty\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Classes always \u0026lt;code\u0026gt;use strict\u0026lt;/code\u0026gt;. Can be done with an explicit \u0026lt;code\u0026gt;use strict\u0026lt;/code\u0026gt; for every function, which is admittedly tedious.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;After reading this thread, I feel confused with JavaScript Prototype Chain, then I found these charts \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance\u0026lt;/a\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/rcGmc.png\u0026quot; alt=\u0026quot;*[[protytype]]* and \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of function objects\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;it\u0026apos;s a clear chart to show JavaScript Inheritance by Prototype Chain\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;this one contains a example with code and several nice diagrams.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;prototype chain ultimately falls back to Object.prototype. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;prototype chain can be technically extended as long as you want, each time by setting the prototype of the subclass equal to an object of the parent class.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Hope it\u0026apos;s also helpful for you to understand JavaScript Prototype Chain.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every object has an internal property, \u0026lt;em\u0026gt;[[Prototype]]\u0026lt;/em\u0026gt;, linking it to another object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;object [[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]  anotherObject\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In traditional javascript, the linked object is the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;object [[\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Prototype\u0026lt;/span\u0026gt;]]  aFunction.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Some environments expose \u0026lt;em\u0026gt;[[Prototype]]\u0026lt;/em\u0026gt; as \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;anObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === anotherObject\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You create the \u0026lt;em\u0026gt;[[Prototype]]\u0026lt;/em\u0026gt; link when creating an object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (1) Object.create:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(anotherObject)\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object.__proto__ = anotherObject\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (2) ES6 object initializer:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;: anotherObject };\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object.__proto__ = anotherObject\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (3) Traditional JavaScript:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; aFunction;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object.__proto__ = aFunction.prototype\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So these statements are equivalent:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ES6 only\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can\u0026apos;t actually see the link target (\u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;) in a \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;new\u0026lt;/a\u0026gt; statement; instead the target is implied by the constructor (\u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Remember:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Every object has a link, \u0026lt;em\u0026gt;[[Prototype]]\u0026lt;/em\u0026gt;, sometimes exposed as \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;__proto__\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Every function has a \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property, initially holding an empty object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Objects created with \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;new\u0026lt;/a\u0026gt; are linked to the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of their constructor.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a function is never used as a constructor, its \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property will go unused.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you don\u0026apos;t need a constructor, use \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Object.create\u0026lt;/a\u0026gt; instead of \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Javascript doesn\u0026apos;t have inheritance in the usual sense, but it has the prototype chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;prototype chain\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If a member of an object can\u0026apos;t be found in the object it looks for it in the prototype chain. The chain consists of other objects. The prototype of a given instance can be accessed with the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; variable. Every object has one, as there is no difference between classes and instances in javascript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The advantage of adding a function / variable to the prototype is that it has to be in the memory only once, not for every instance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s also useful for inheritance, because the prototype chain can consist of many other objects.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This article is long. But I am sure it will clear most of your queries \nregarding the \u0026quot;prototypical\u0026quot; nature of JavaScript Inheritance. And even more. Please read the complete article.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;JavaScript basically has two kinds of data types\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Non objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Non objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Following are the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Non object\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; data types\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;string\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;number (including NaN and Infinity)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;boolean values(true,false)\u0026lt;/strong\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These data types return following when you use the \u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; operator \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;\u0026quot;string literal\u0026quot;\u0026lt;/em\u0026gt; (or a variable containing string literal)  === \u0026lt;strong\u0026gt;\u0026apos;string\u0026apos;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;5\u0026lt;/em\u0026gt; (or any numeric literal or a variable containing numeric literal or \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;NaN or Infynity\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;)  === \u0026lt;strong\u0026gt;\u0026apos;number\u0026apos;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; (or \u0026lt;em\u0026gt;false\u0026lt;/em\u0026gt; or a variable containing \u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;false\u0026lt;/em\u0026gt;)  === \u0026lt;strong\u0026gt;\u0026apos;boolean\u0026apos;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt; (or an undefined variable or a variable containing \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt;) === \u0026lt;strong\u0026gt;\u0026apos;undefined\u0026apos;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;string\u0026lt;/strong\u0026gt;,\u0026lt;strong\u0026gt;number\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;boolean\u0026lt;/strong\u0026gt; data types can be represented both as \u0026lt;strong\u0026gt;Objects\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Non objects\u0026lt;/strong\u0026gt;.When they are represented as objects their typeof is always === \u0026apos;object\u0026apos;. We shall come back to this once we understand the object data types.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The object datatypes can be further divided into two types\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Function type objects\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Non Function type objects\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Function type objects\u0026lt;/strong\u0026gt; are the ones that return the string \u0026lt;strong\u0026gt;\u0026apos;function\u0026apos;\u0026lt;/strong\u0026gt; with \u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt; operator. \nAll the user defined functions and all the JavaScript built in objects that can create new objects by using new operator fall into this category. For eg.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Object\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;String\u0026lt;/strong\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Number\u0026lt;/strong\u0026gt;  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Boolean\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Array\u0026lt;/strong\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Typed Arrays\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;RegExp\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Function\u0026lt;/strong\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All the other built in objects that can create new objects by using new operator\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;function\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;UserDefinedFunction\u0026lt;/strong\u0026gt;(){ /*user defined code */ }\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So,\n\u0026lt;strong\u0026gt;typeof(Object)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;typeof(String)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;typeof(Number)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;typeof(Boolean)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;typeof(Array)\u0026lt;/strong\u0026gt;  === \u0026lt;strong\u0026gt;typeof(RegExp)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;typeof(Function)\u0026lt;/strong\u0026gt;  === \u0026lt;strong\u0026gt;typeof(UserDefinedFunction)\u0026lt;/strong\u0026gt; === \u0026lt;strong\u0026gt;\u0026apos;function\u0026apos;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; are actually instances of the built in JavaScript object \u0026lt;strong\u0026gt;Function\u0026lt;/strong\u0026gt; (including the \u0026lt;strong\u0026gt;Function\u0026lt;/strong\u0026gt; object i.e it is recursively defined). It is as if the these objects have been defined in the following way\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Boolean\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Boolean\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Array\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Array\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;RegExp\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;RegExp\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; ([native code  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; object \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;user defined code\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As mentioned, the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; can further create new objects using the \u0026lt;strong\u0026gt;new operator\u0026lt;/strong\u0026gt;. For e.g an object of type \u0026lt;strong\u0026gt;Object\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;String\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;Number\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;Boolean\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;Array\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;RegExp\u0026lt;/strong\u0026gt;  Or \u0026lt;strong\u0026gt;UserDefinedFunction\u0026lt;/strong\u0026gt; can be created by using\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;() or \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;() or \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a={} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type Object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type String\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type Number\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Boolean\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type Boolean\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Array\u0026lt;/span\u0026gt;() or \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Array\u0026lt;/span\u0026gt;() or \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=[]  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type Array\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;RegExp\u0026lt;/span\u0026gt;() or \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;RegExp\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create object of type RegExp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;() \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The objects thus created are all \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Non Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; and return their \u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt;===\u0026lt;strong\u0026gt;\u0026apos;object\u0026apos;\u0026lt;/strong\u0026gt;. In all these cases the object \u0026quot;a\u0026quot; cannot further create \nobjects using operator new. So the following is wrong\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error. a is not typeof===\u0026apos;function\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The built in object \u0026lt;strong\u0026gt;Math\u0026lt;/strong\u0026gt; is \u0026lt;strong\u0026gt;typeof\u0026lt;/strong\u0026gt;===\u0026lt;strong\u0026gt;\u0026apos;object\u0026apos;\u0026lt;/strong\u0026gt;. Hence a new object of type Math cannot be created by new operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error. Math is not typeof===\u0026apos;function\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also notice that \u0026lt;strong\u0026gt;Object\u0026lt;/strong\u0026gt;,\u0026lt;strong\u0026gt;Array\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;RegExp\u0026lt;/strong\u0026gt; functions can create a new object without even using \u0026lt;strong\u0026gt;operator new\u0026lt;/strong\u0026gt;. However the follwing ones don\u0026apos;t.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create a new Non Object string. returns a typeof===\u0026apos;string\u0026apos; \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create a new Non Object Number. returns a typeof===\u0026apos;number\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Boolean\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new Non Object Boolean. returns a typeof===\u0026apos;boolean\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The user defined functions are special case. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//may or may not create an object of type UserDefinedFunction() based on how it is defined.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; can create new objects they are also called \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Constructors\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Every \u0026lt;strong\u0026gt;Constructor/Function\u0026lt;/strong\u0026gt; (whether built in or user defined) when defined automatically has a property called \u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot;\u0026lt;/strong\u0026gt; whose value by default is set as an object. This object itself has a property called \u0026lt;strong\u0026gt;\u0026quot;constructor\u0026quot;\u0026lt;/strong\u0026gt; which by default references back the \u0026lt;strong\u0026gt;Constructor/Function\u0026lt;/strong\u0026gt; .\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example when we define a function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;following automatically happens\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;={\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This \u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot; property\u0026lt;/strong\u0026gt; is only present in the \u0026lt;strong\u0026gt;Function type objects\u0026lt;/strong\u0026gt; \n(and never in \u0026lt;strong\u0026gt;Non Function type objects\u0026lt;/strong\u0026gt;). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is because \u0026lt;strong\u0026gt;when a new object is created (using new operator)it inherits all properties and methods from Constructor function\u0026apos;s current prototype object i.e. an\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;internal reference\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;is created in the newly created object that references the object referenced by Constructor function\u0026apos;s current prototype object.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This \u0026lt;strong\u0026gt;\u0026quot;internal reference\u0026quot;\u0026lt;/strong\u0026gt; that is created in the object for referencing inherited properties is known as the \u0026lt;strong\u0026gt;object\u0026apos;s prototype\u0026lt;/strong\u0026gt; (which references the object referenced by Constructor\u0026apos;s \u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot;\u0026lt;/strong\u0026gt; property but is different from it). For any object (Function or Non Function) this can be retrieved using \u0026lt;strong\u0026gt;Object.getPrototypeOf()\u0026lt;/strong\u0026gt; method. Using this method one can trace the prototype chain of an object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, \u0026lt;strong\u0026gt;every object that is created\u0026lt;/strong\u0026gt; (\u0026lt;strong\u0026gt;Function type\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;Non Function type\u0026lt;/strong\u0026gt;) has a \u0026lt;strong\u0026gt;\u0026quot;constructor\u0026quot;\u0026lt;/strong\u0026gt; property which is inherited from the object referenced by prototype  property of the Constructor function. By default this \u0026lt;strong\u0026gt;\u0026quot;constructor\u0026quot;\u0026lt;/strong\u0026gt; property references the \u0026lt;strong\u0026gt;Constructor function\u0026lt;/strong\u0026gt; that created it (if the \u0026lt;strong\u0026gt;Constructor Function\u0026apos;s\u0026lt;/strong\u0026gt; default \u0026quot;prototype\u0026quot; is not changed). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For all \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; the constructor function is always\n\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;function Function(){}\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Non Function type objects\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; (e.g Javascript Built in  Math object) the constructor function is the function that created it.\nFor \u0026lt;strong\u0026gt;Math\u0026lt;/strong\u0026gt; object it is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;function Object(){}\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All the concept explained above can be a little daunting to understand without any supporting code. Please go through the following code line by line to understand the concept. Try to execute it to have a better understanding.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{ \n\n} \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* creating the above function automatically does the following as mentioned earlier\n\nUserDefinedFunction.prototype={constructor:UserDefinedFunction}\n\n*/\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newObj_1=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;()\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_1)===\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays true\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays function UserDefinedFunction\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new property in UserDefinedFunction.prototype object\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;TestProperty\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;TestProperty\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays \u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_1).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;TestProperty\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays \u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new Object\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; objA = {\n        property1 : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Property1\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Array\u0026lt;/span\u0026gt;\n\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//assign a new object to UserDefinedFunction.prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;=objA\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_1)===\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays false. The object referenced by UserDefinedFunction.prototype has changed\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The internal reference does not change\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This shall still Display function UserDefinedFunction\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;TestProperty\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//This shall still Display \u0026quot;test\u0026quot; \u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_1).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;TestProperty\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//This shall still Display \u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create another object of type UserDefinedFunction\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newObj_2= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_2)===objA) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays true.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays function Array()\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property1\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays \u0026quot;Property1\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_2).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property1\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays \u0026quot;Property1\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create a new property in objA\u0026lt;/span\u0026gt;\nobjA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property2\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;property2\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(objA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property2\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays \u0026quot;Property2\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property2\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays \u0026quot;Property2\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(newObj_2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property2\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays Property2\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(newObj_2).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property2\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays  \u0026quot;Property2\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The prototype chain of every object ultimately traces back to Object.prototype (which itself does not have any prototype object) .\nFollowing code can be used for tracing the prototype chain of an object\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; o=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Starting\u0026lt;/span\u0026gt; object;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(o + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOwnPropertyNames\u0026lt;/span\u0026gt;(o))\n\n}\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(o=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(o))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The prototype chain for various objects work out as follows.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Every Function object (including built in Function object)-\u0026amp;gt;\nFunction.prototype -\u0026amp;gt; Object.prototype -\u0026amp;gt; null   \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Simple Objects (created By new Object() or {} including built in Math  object)-\u0026amp;gt;   Object.prototype -\u0026amp;gt; null\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Object created with new or Object.create -\u0026amp;gt; One or More prototype chains -\u0026amp;gt; Object.prototype -\u0026amp;gt; null\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For creating an object without any prototype use the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; o=\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(o)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays null\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One might think that setting the prototype property of the Constructor to null shall create an object with a null prototype. However in such cases the newly created object\u0026apos;s prototype is set to Object.prototype and its constructor is set to function Object. This is demonstrated by the following code\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){}\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Can be set to any non object value (number,string,undefined etc.)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; o=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UserDefinedFunction\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(o)==\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(o.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays Function Object\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Following in the summary of this article\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;There are two types of objects \u0026lt;strong\u0026gt;Function types\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Non Function types\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Only \u0026lt;strong\u0026gt;Function type objects\u0026lt;/strong\u0026gt; can create a new object using the \u0026lt;strong\u0026gt;operator new\u0026lt;/strong\u0026gt;. The objects thus created are \u0026lt;strong\u0026gt;Non Function type\u0026lt;/strong\u0026gt; objects. The \u0026lt;strong\u0026gt;Non Function type objects\u0026lt;/strong\u0026gt; cannot further create an object using \u0026lt;strong\u0026gt;operator new\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;All \u0026lt;strong\u0026gt;Function type objects\u0026lt;/strong\u0026gt; by default have a \u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot;\u0026lt;/strong\u0026gt; property. This \u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot;\u0026lt;/strong\u0026gt; property references an object that has a \u0026lt;strong\u0026gt;\u0026quot;constructor\u0026quot;\u0026lt;/strong\u0026gt; property that by default references the \u0026lt;strong\u0026gt;Function type object\u0026lt;/strong\u0026gt; itself.  \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;All objects (\u0026lt;strong\u0026gt;Function type\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Non Function type\u0026lt;/strong\u0026gt;) have a \u0026quot;constructor\u0026quot; property that by default references the \u0026lt;strong\u0026gt;Function type object\u0026lt;/strong\u0026gt;/\u0026lt;strong\u0026gt;Constructor\u0026lt;/strong\u0026gt; that created it.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Every object that gets created internally references the object referenced by\n\u0026lt;strong\u0026gt;\u0026quot;prototype\u0026quot;\u0026lt;/strong\u0026gt; property of the Constructor that created it. This object is known as the created \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;object\u0026apos;s prototype\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; (which is different from Function type objects \u0026quot;prototype\u0026quot; property which it references) . This way the created object can directly access the methods and properties defined in object referenced by the Constructor\u0026apos;s \u0026quot;prototype\u0026quot; property (at the time of object creation).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;An \u0026lt;strong\u0026gt;object\u0026apos;s prototype\u0026lt;/strong\u0026gt; (and hence its inherited property names) can be retrieved using the \u0026lt;strong\u0026gt;Object.getPrototypeOf()\u0026lt;/strong\u0026gt;   method. In fact this method \ncan be used for navigating the entire prototype chain of the object.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The prototype chain of every object ultimately traces back to Object.prototype (Unless the object is created using Object.create(null) in which case the object has no prototype).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;typeof(new Array())===\u0026apos;object\u0026apos;\u0026lt;/strong\u0026gt; is by design of language and not a mistake as pointed by \u0026lt;a href=\u0026quot;http://javascript.crockford.com/survey.html\u0026quot;\u0026gt;Douglas Crockford\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Setting the prototype property of the Constructor to null(or undefined,number,true,false,string) shall not create an object with a null prototype. In such cases the newly created object\u0026apos;s prototype is set to Object.prototype and its constructor is set to function Object. \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Hope this helps.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It may help to categorise prototype chains into two categories.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the constructor:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The value of \u0026lt;code\u0026gt;Object.getPrototypeOf(Person)\u0026lt;/code\u0026gt; is a function. In fact, it is \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;. Since \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; was created as a function, it shares the same prototype function object that all functions have. It is the same as \u0026lt;code\u0026gt;Person.__proto__\u0026lt;/code\u0026gt;, but that property should not be used. Anyway, with \u0026lt;code\u0026gt;Object.getPrototypeOf(Person)\u0026lt;/code\u0026gt; you effectively walk up the ladder of what is called the prototype chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The chain in upward direction looks like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; (end point)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Important is that this prototype chain has little to do with the objects that \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; can \u0026lt;em\u0026gt;construct\u0026lt;/em\u0026gt;. Those constructed objects have their own prototype chain, and this chain can potentially have no close ancestor in common with the one mentioned above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take for example this object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;p\u0026lt;/em\u0026gt; has no direct prototype-chain relationship with \u0026lt;em\u0026gt;Person\u0026lt;/em\u0026gt;. Their relationship is a different one. The object \u0026lt;em\u0026gt;p\u0026lt;/em\u0026gt; has its own prototype chain. Using \u0026lt;code\u0026gt;Object.getPrototypeOf\u0026lt;/code\u0026gt;, you\u0026apos;ll find the chain is as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Person.prototype\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; (end point)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is no function object in this chain (although that could be).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; seems related to two kinds of chains, which live their own lives. To \u0026quot;jump\u0026quot; from one chain to the other, you use:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt;: jump from the constructor\u0026apos;s chain to the created-object\u0026apos;s chain. This property is thus only defined for function objects (as \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; can only be used on functions).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;.constructor\u0026lt;/code\u0026gt;: jump from the created-object\u0026apos;s chain to the constructor\u0026apos;s chain.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a visual presentation of the two prototype chains involved, represented as columns:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/FPPdI.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/FPPdI.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarise:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property gives no information of the \u0026lt;em\u0026gt;subject\u0026apos;s\u0026lt;/em\u0026gt; prototype chain, but of objects \u0026lt;em\u0026gt;created by\u0026lt;/em\u0026gt; the subject. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It is no surprise that the name of the property \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; can lead to confusion. It would maybe have been clearer if this property had been named \u0026lt;code\u0026gt;prototypeOfConstructedInstances\u0026lt;/code\u0026gt; or something along that line.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can jump back and forth between the two prototype chains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This symmetry can be broken by explicitly assigning a different object to the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property (more about that later).\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Create one Function, Get Two Objects\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Person.prototype\u0026lt;/code\u0026gt; is an object that was created at the same time the function \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; was created. It has \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; as constructor, even though that constructor did not actually execute yet. So two objects are created at the same time:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The function \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; itself\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The object that will act as prototype when the function is called as a constructor\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Both are objects, but they have different roles: the function object \u0026lt;em\u0026gt;constructs\u0026lt;/em\u0026gt;, while the other object represents the prototype of any object that function will construct. The prototype object will become the parent of the constructed object in its prototype chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since a function is also an object, it also has its own parent in its own prototype chain, but recall that these two chains are about different things. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here are some equalities that could help grasp the issue -- all of these print \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is prototype chain info for the constructor (the function object):\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;) === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Step further up in the same hierarchy:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here we swap lanes, and look at the constructor of the constructor\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;instanceof\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Function\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Person.prototype was created by Person (at the time of its creation)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here we swap lanes back and forth:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Although it is not an instance of it:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(!(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;instanceof\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;));\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Instances are objects created by the constructor:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Similarly to what was shown for the constructor, here we have\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the same for the object created by the constructor:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(p) === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here we swap lanes, and look at the constructor\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;instanceof\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif3\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Adding levels to the prototype chain\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Although a prototype object is created when you create a constructor function, you can ignore that object, and assign another object that should be used as prototype for any subsequent instances created by that constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Thief\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thief\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = p; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this determines the prototype for any new Thief objects:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; t = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thief\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the prototype chain of \u0026lt;em\u0026gt;t\u0026lt;/em\u0026gt; is one step longer than that of \u0026lt;em\u0026gt;p\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Person.prototype\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; (end point)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The other prototype chain is not longer: \u0026lt;code\u0026gt;Thief\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; are siblings sharing the same parent in their prototype chain:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt;}\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;code\u0026gt;Thief\u0026lt;/code\u0026gt;\u0026amp;nbsp; }  \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; (end point)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The earlier presented graphic can then be extended to this (the original \u0026lt;code\u0026gt;Thief.prototype\u0026lt;/code\u0026gt; is left out):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/m5DXc.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/m5DXc.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The blue lines represent prototype chains, the other coloured lines represent other relationships:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;between an object and its constructor\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;between a constructor and the prototype object that will be used for constructing objects\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The concept of \u0026lt;code\u0026gt;prototypal\u0026lt;/code\u0026gt; inheritance is one of the most complicated for many developers. Let\u0026apos;s try to understand the root of problem to understand \u0026lt;code\u0026gt;prototypal inheritance\u0026lt;/code\u0026gt; better. Let\u0026apos;s start with a \u0026lt;code\u0026gt;plain\u0026lt;/code\u0026gt; function. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/BsHT0.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/BsHT0.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we use a \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator on the \u0026lt;code\u0026gt;Tree function\u0026lt;/code\u0026gt;, we call it as a \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt; function. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/cU6Qh.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/cU6Qh.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Every \u0026lt;code\u0026gt;JavaScript\u0026lt;/code\u0026gt; function has a \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;. When you log the \u0026lt;code\u0026gt;Tree.prototype\u0026lt;/code\u0026gt;, you get...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Xop8c.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Xop8c.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you look at the above \u0026lt;code\u0026gt;console.log()\u0026lt;/code\u0026gt; output, you could a see a constructor property on \u0026lt;code\u0026gt;Tree.prototype\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property too. The \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; represents the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; that this \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt; is based off, and since this is just a plain \u0026lt;code\u0026gt;JavaScript function\u0026lt;/code\u0026gt; with no \u0026lt;code\u0026gt;inheritance\u0026lt;/code\u0026gt; set up yet, it refers to the \u0026lt;code\u0026gt;Object prototype\u0026lt;/code\u0026gt; which is something just built in to JavaScript...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has things like \u0026lt;code\u0026gt;.toString, .toValue, .hasOwnProperty\u0026lt;/code\u0026gt; etc...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; which was brought my mozilla is deprecated and is replaced by \u0026lt;code\u0026gt;Object.getPrototypeOf\u0026lt;/code\u0026gt; method to get the \u0026lt;code\u0026gt;object\u0026apos;s prototype\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/GtcJO.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/GtcJO.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Tree\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object {} \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s add a method to our \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/BsHT0.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/BsHT0.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We have modified the \u0026lt;code\u0026gt;Root\u0026lt;/code\u0026gt; and added a \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt; branch to it. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/cU6Qh.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/cU6Qh.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That means when you create an \u0026lt;code\u0026gt;instance\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt;, you can call it\u0026apos;s \u0026lt;code\u0026gt;branch\u0026lt;/code\u0026gt; method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Xop8c.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Xop8c.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can also add \u0026lt;code\u0026gt;primitives\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;objects\u0026lt;/code\u0026gt; to our \u0026lt;code\u0026gt;Prototype\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/GtcJO.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/GtcJO.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s add a \u0026lt;code\u0026gt;child-tree\u0026lt;/code\u0026gt; to our \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/ggFON.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ggFON.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here the \u0026lt;code\u0026gt;Child\u0026lt;/code\u0026gt; inherits its \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; from Tree, what we are doing here is using \u0026lt;code\u0026gt;Object.create()\u0026lt;/code\u0026gt; method to create a new object based off what you pass, here it is \u0026lt;code\u0026gt;Tree.prototype\u0026lt;/code\u0026gt;. In this case what we\u0026apos;re doing is setting the prototype of Child to a new object that looks identical to the \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt; prototype. Next we are setting the \u0026lt;code\u0026gt;Child\u0026apos;s constructor to Child\u0026lt;/code\u0026gt;, if we don\u0026apos;t it would point to \u0026lt;code\u0026gt;Tree()\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/yiZcY.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/yiZcY.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Child\u0026lt;/code\u0026gt; now has its own \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;, its \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; points to \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Tree\u0026apos;s prototype\u0026lt;/code\u0026gt; points to base \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;  \n|\n \\\n  \\\n   \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Tree\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n   - branch\n   |\n   |\n    \\\n     \\\n      \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n      -toString\n      -valueOf\n      -etc., etc.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now you create an \u0026lt;code\u0026gt;instance\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Child\u0026lt;/code\u0026gt; and call \u0026lt;code\u0026gt;branch\u0026lt;/code\u0026gt; which is originally available in \u0026lt;code\u0026gt;Tree\u0026lt;/code\u0026gt;. We haven\u0026apos;t actually defined our \u0026lt;code\u0026gt;branch\u0026lt;/code\u0026gt; on the \u0026lt;code\u0026gt;Child prototype\u0026lt;/code\u0026gt;. BUT, in the \u0026lt;code\u0026gt;Root prototype\u0026lt;/code\u0026gt; which Child inherits from. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/k6BNb.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/k6BNb.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In JS everything is not an object, everything can act like an object.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Javascript\u0026lt;/code\u0026gt; has primitives like \u0026lt;code\u0026gt;strings, number, booleans, undefined, null.\u0026lt;/code\u0026gt; They are not \u0026lt;code\u0026gt;object(i.e reference types)\u0026lt;/code\u0026gt;, but certainly can act like an \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;. Let\u0026apos;s look at an example here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/WVjiv.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/WVjiv.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the first line of this listing, a \u0026lt;code\u0026gt;primitive\u0026lt;/code\u0026gt; string value is assigned to name. The second line treats name like an \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt; and calls \u0026lt;code\u0026gt;charAt(0)\u0026lt;/code\u0026gt; using dot notation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is what happens behind the scenes:\n// what the \u0026lt;code\u0026gt;JavaScript\u0026lt;/code\u0026gt; engine does\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/l6MHc.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/l6MHc.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;String object\u0026lt;/code\u0026gt; exists only for one statement before its destroyed (a process called \u0026lt;code\u0026gt;autoboxing\u0026lt;/code\u0026gt;). Let\u0026apos;s again get back to our \u0026lt;code\u0026gt;prototypal\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;inheritance\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Javascript\u0026lt;/code\u0026gt; supports inheritance via \u0026lt;code\u0026gt;delegation\u0026lt;/code\u0026gt; based on\n\u0026lt;code\u0026gt;prototypes\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Each \u0026lt;code\u0026gt;Function\u0026lt;/code\u0026gt; has a \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property, which refers to another\nobject.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;properties/functions\u0026lt;/code\u0026gt; are looked from the \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt; itself or via\n\u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; chain if it does not exist\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; in JS is an object which \u0026lt;code\u0026gt;yields\u0026lt;/code\u0026gt; you to the parent of another \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;. \u0026lt;strong\u0026gt;[ie.. delegation]\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;Delegation\u0026lt;/code\u0026gt; means that if you are unable to do something, youll tell someone else to do it for you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/W0NUA.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/W0NUA.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jsfiddle.net/say0tzpL/1/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://jsfiddle.net/say0tzpL/1/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you look up the above fiddle, dog has access to \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; method, but its not available in it, but available via the prototype chain which delegates to \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/lWILf.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/lWILf.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you look at the below one, we are trying to access the \u0026lt;code\u0026gt;call\u0026lt;/code\u0026gt; method which is available in every \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/iF4RN.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/iF4RN.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jsfiddle.net/rknffckc/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://jsfiddle.net/rknffckc/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you look up the above fiddle, \u0026lt;code\u0026gt;Profile\u0026lt;/code\u0026gt; Function has access to \u0026lt;code\u0026gt;call\u0026lt;/code\u0026gt; method, but its not available in it, but available via the prototype chain which delegates to \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Mijkj.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Mijkj.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; is a property of the function constructor, whereas \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; is a property of the objects constructed from the function constructor. Every function comes with a \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property whose value is an empty \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;. When we create an instance of the function, we get an internal property \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; whose reference is the prototype of the Function \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/HvzDP.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/HvzDP.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The above diagram looks bit complicated, but brings out the whole picture on how \u0026lt;code\u0026gt;prototype chaining\u0026lt;/code\u0026gt; works. Let\u0026apos;s walk through this slowly:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two instance \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt;, whose constructor is \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; and parent is Foo and has two methods from prototype chain \u0026lt;code\u0026gt;identify\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;speak\u0026lt;/code\u0026gt; via \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/EllEL.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/EllEL.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jsfiddle.net/kbp7jr7n/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://jsfiddle.net/kbp7jr7n/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you look up the code above, we have \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; constructor who has the method \u0026lt;code\u0026gt;identify()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; constructor which has \u0026lt;code\u0026gt;speak\u0026lt;/code\u0026gt; method. We create two \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; instance \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; whose parent type is \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;. Now while calling \u0026lt;code\u0026gt;speak\u0026lt;/code\u0026gt; method of \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt;, we are able to identify the who is calling the speak via \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; chain. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/V7fH7.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/V7fH7.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; now has all the methods of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; which are defined in its \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;. Let\u0026apos;s dig further in understanding the \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt; and how they are related. If you look up the constructor of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; are \u0026lt;code\u0026gt;Function constructor\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/wzzRu.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/wzzRu.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; and if you look closely the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; is related to \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/wEOxo.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/wEOxo.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Before we close this down, let\u0026apos;s just wrap with a small piece of code here to \u0026lt;strong\u0026gt;summarize everything above\u0026lt;/strong\u0026gt;. We are using \u0026lt;code\u0026gt;instanceof\u0026lt;/code\u0026gt; operator here to check whether an \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt; has in its \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; chain the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of a \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt; which below summarizes the entire big diagram. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/n84uV.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/n84uV.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this add\u0026apos;s some information, I know this kinda could be big to grasp... in simple words its \u0026lt;strong\u0026gt;it\u0026apos;s just objects linked to objects!!!!\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;what is the exact purpose of this \u0026quot;.prototype\u0026quot; property?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The interface to standard classes become extensible. For example, you are using the \u0026lt;code\u0026gt;Array\u0026lt;/code\u0026gt; class and you also need to add a custom serializer for all your array objects. Would you spend time coding up a subclass, or use composition or ... The prototype property solves this by letting the users control the exact set of members/methods available to a class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Think of prototypes as an extra vtable-pointer. When some members are missing from the original class, the prototype is looked up at runtime.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.youtube.com/watch?v=PMfcsYzj-9M\u0026quot;\u0026gt;The Definitive Guide to Object-Oriented JavaScript\u0026lt;/a\u0026gt; - a very concise and clear ~30min video explanation of the asked question (Prototypal Inheritance topic begins from \u0026lt;a href=\u0026quot;https://youtu.be/PMfcsYzj-9M?t=344\u0026quot;\u0026gt;5:45\u0026lt;/a\u0026gt;, although I\u0026apos;d rather listen to the whole video). The author of this video also made JavaScript object visualizer website \u0026lt;a href=\u0026quot;http://www.objectplayground.com/\u0026quot;\u0026gt;http://www.objectplayground.com/\u0026lt;/a\u0026gt;.\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Vf4qR.jpg\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Vf4qR.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/xcRpT.jpg\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/xcRpT.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found it helpful to explain the \u0026quot;prototype chain\u0026quot; as recursive convention when \u0026lt;code\u0026gt;obj_n.prop_X\u0026lt;/code\u0026gt; is being referenced:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;if \u0026lt;code\u0026gt;obj_n.prop_X\u0026lt;/code\u0026gt; doesn\u0026apos;t exist, check \u0026lt;code\u0026gt;obj_n+1.prop_X\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;obj_n+1 = obj_n.[[prototype]]\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the \u0026lt;code\u0026gt;prop_X\u0026lt;/code\u0026gt; is finally found in the k-th prototype object then\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;obj_1.prop_X = obj_1.[[prototype]].[[prototype]]..(k-times)..[[prototype]].prop_X\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can find a graph of the relation of Javascript objects by their properties here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt; \u0026lt;img src=\u0026quot;https://i.stack.imgur.com/2tGyY.jpg\u0026quot; alt=\u0026quot;js objects graph\u0026quot;\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://jsobjects.org\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://jsobjects.org\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When a constructor creates an object, that object implicitly references the constructors prototype property for the purpose of resolving property references. The constructors prototype property can be referenced by the program expression constructor.prototype, and properties added to an objects prototype are shared, through inheritance, by all objects sharing the prototype.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There\u0026apos;s two distinct but related entities here that need explaining:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; property of functions.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;sup\u0026gt;[1]\u0026lt;/sup\u0026gt;\u0026lt;/sup\u0026gt; property of all objects\u0026lt;sup\u0026gt;\u0026lt;sup\u0026gt;[2]\u0026lt;/sup\u0026gt;\u0026lt;/sup\u0026gt;. \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These are two different things. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; property:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This is a property that exists on all\u0026lt;sup\u0026gt;\u0026lt;sup\u0026gt;[2]\u0026lt;/sup\u0026gt;\u0026lt;/sup\u0026gt; objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What\u0026apos;s stored here is another object, which, as an object itself, has a \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; of its own that points to another object. That other object has a \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; of its own. This story continues until you reach the prototypical object that provides methods that are accessible on all objects (like \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;.toString\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; property is part of what forms the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; chain. This chain of \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; objects is what is examined when, for example, \u0026lt;code\u0026gt;[[Get]]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;[[Set]]\u0026lt;/code\u0026gt; operations are performed on an object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = {}\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [[Get]] consults prototype chain\u0026lt;/span\u0026gt;\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [[Set]] consults prototype chain\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; property:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;This is a property that is only found on functions.\u0026lt;/em\u0026gt; Using a very simple function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; property \u0026lt;em\u0026gt;holds an object\u0026lt;/em\u0026gt; that will be assigned to \u0026lt;code\u0026gt;b.[[Prototype]]\u0026lt;/code\u0026gt; when you do \u0026lt;code\u0026gt;var b = new Bar\u0026lt;/code\u0026gt;. You can easily examine this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Both assign Bar.prototype to b1/b2[[Prototype]]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object.getPrototypeOf grabs the objects [[Prototype]]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getPrototypeOf\u0026lt;/span\u0026gt;(b) === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One of the most important \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt;s is that \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;of the \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; function\u0026lt;/a\u0026gt;. This prototype holds the prototypical object that all \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; chains contain. On it, all the available methods for new objects are defined:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get properties that are defined on this object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getOwnPropertyDescriptors\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, since \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt; is an object, it has a \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; property. When you don\u0026apos;t make any assignments to \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;, the \u0026lt;code\u0026gt;.prototype\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; points to the prototypical object (\u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;). This is automatically performed anytime you create a new function. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This way, any time you do \u0026lt;code\u0026gt;new Bar;\u0026lt;/code\u0026gt; the prototype chain is set up for you, you get everything defined on \u0026lt;code\u0026gt;Bar.prototype\u0026lt;/code\u0026gt; and everything defined on \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get all Bar.prototype properties\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get all Object.prototype properties\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When you \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; make assignments to \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt; all you are doing is extending the prototype chain to include another object. It\u0026apos;s like an insertion in a singly linked list. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This basically alters the \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; chain allowing properties that are defined on the object assigned to \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt; to be seen by any object created by the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;[1: That won\u0026apos;t confuse anyone; made available via \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property\u0026lt;/a\u0026gt; in many implementations.\u0026lt;/sup\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;sup\u0026gt;[2]: All except \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let me tell you my understanding of prototypes. I am not going to compare the inheritance here with other languages. I wish people would stop comparing languages, and just understand the language as itself. Understanding prototypes and prototypal inheritance is so simple, as I will show you below.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Prototype is like a model, based on which you create a product. The crucial point to understand is that when you create an object using another object as it\u0026apos;s prototype, the link between the prototype and the product is ever-lasting. For instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; model = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; product = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(model);\nmodel.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\nproduct.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;\n=\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Every object contains an internal property called the [[prototype]], which can be accessed by the \u0026lt;code\u0026gt;Object.getPrototypeOf()\u0026lt;/code\u0026gt; function. \u0026lt;code\u0026gt;Object.create(model)\u0026lt;/code\u0026gt; creates a new object and sets it\u0026apos;s [[prototype]] property to the object \u0026lt;strong\u0026gt;model\u0026lt;/strong\u0026gt;. Hence when you do \u0026lt;code\u0026gt;Object.getPrototypeOf(product)\u0026lt;/code\u0026gt;, you will get the object \u0026lt;strong\u0026gt;model\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Properties in the \u0026lt;strong\u0026gt;product\u0026lt;/strong\u0026gt; are handled in the following way:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When a property is accessed to just read it\u0026apos;s value, its looked up in the scope chain. The search for the variable starts from the \u0026lt;strong\u0026gt;product\u0026lt;/strong\u0026gt; upwards to it\u0026apos;s prototype. If such a variable is found in the search, the search is stopped right there, and the value is returned. If such a variable cannot be found in the scope chain, undefined is returned.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When a property is written(altered), then the property is always written on the \u0026lt;strong\u0026gt;product\u0026lt;/strong\u0026gt; object. If the \u0026lt;strong\u0026gt;product\u0026lt;/strong\u0026gt; does not have such a property already, it is implicitly created and written.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Such a linking of objects using the prototype property is called prototypal inheritance. There, it is so simple, agree?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another attempt to explain \u0026lt;a href=\u0026quot;https://github.com/rus0000/jsinheritance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript prototype-based inheritance\u0026lt;/a\u0026gt; with better pictures\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/rus0000/jsinheritance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/6gEKe.png\u0026quot; alt=\u0026quot;Simple objects inheritanse\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider the following \u0026lt;code\u0026gt;keyValueStore\u0026lt;/code\u0026gt; object :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; keyValueStore = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; kvs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        count++;\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; = {};\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key]; };\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key, value\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key] = value; };\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key]; };\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getLength\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; l = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;) l++;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; l;\n        }\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;  { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Singleton public properties\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;create\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;kvs\u0026lt;/span\u0026gt;(); },\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;count\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; count; }\n    };\n})();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I can create a new instance of this object by doing this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;kvs = keyValueStore.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Each instance of this object would have the following public properties :\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;data\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;getLength\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Now, suppose we create 100 instances of this \u0026lt;code\u0026gt;keyValueStore\u0026lt;/code\u0026gt; object. Even though \u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;getLength\u0026lt;/code\u0026gt; will do the exact same thing for each of these 100 instances, every instance has its own copy of this function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, imagine if you could have just a single \u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;getLength\u0026lt;/code\u0026gt; copy, and each instance would reference that same function. This would be better for performance and require less memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s where prototypes come in. A prototype is a \u0026quot;blueprint\u0026quot; of properties that is inherited but not copied by instances. So this means that it exists only once in memory for all instances of an object and is shared by all of those instances.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, consider the \u0026lt;code\u0026gt;keyValueStore\u0026lt;/code\u0026gt; object again. I could rewrite it like this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; keyValueStore = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; kvs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        count++;\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; = {};\n    };\n\n    kvs.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = {\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;get\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key]; },\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;set\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key, value\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key] = value; },\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;delete\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[key]; },\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;getLength\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; l = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (p \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;) l++;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; l;\n        }\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;  {\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;create\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;kvs\u0026lt;/span\u0026gt;(); },\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;count\u0026apos;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; count; }\n    };\n})();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This does EXACTLY the same as the previous version of the \u0026lt;code\u0026gt;keyValueStore\u0026lt;/code\u0026gt; object, except that all of its methods are now put in a prototype. What this means, is that all of the 100 instances now share these four methods instead of each having their own copy.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Summary:\u0026lt;/h2\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Functions are objects in javascript and thus can have properties\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;(Constructor) functions \u0026lt;strong\u0026gt;always\u0026lt;/strong\u0026gt; have a prototype property\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When a function is used as a constructor with the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword the object gets  prototype. A reference to this prototype can be found on the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property of the newly created object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property refers to the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of the constructor function.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Example:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; (name) {\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; me = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;willem\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Person has a prototype property\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; === me.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the __proto__ property of the instance refers to prototype property of the function.\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif4\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Why is this usefull:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Javascript has a mechanism when looking up properties on Objects which is called \u0026lt;strong\u0026gt;\u0026apos;prototypal inheritance\u0026apos;\u0026lt;/strong\u0026gt;, here is what is basically does:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;First is checked if the property is located on the Object itself. If so this property is returned.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the property is not located on the object itself it will \u0026apos;climb up the protochain\u0026apos;. It basically looks at the object referred to by the \u0026lt;strong\u0026gt;proto\u0026lt;/strong\u0026gt; property. There it checks if the property is available on the object referred to by \u0026lt;strong\u0026gt;proto\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the property isn\u0026apos;t located on the \u0026lt;strong\u0026gt;proto\u0026lt;/strong\u0026gt; object it will climb up the \u0026lt;strong\u0026gt;proto\u0026lt;/strong\u0026gt; chain all the way up to Object object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it cannot find the property nowhere on the object and its prototype chain it will return undefined.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;For example:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = name;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; mySelf = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Willem\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(mySelf.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(mySelf.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif5\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The  \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property has been deprecated, although it is implemented in most modern browsers a better way to obtain the prototype object reference would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Object.getPrototypeOf()\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I always like analogies when it comes to understand this type of stuff. \u0026apos;Prototypical inheritance\u0026apos; is pretty confusing in comparison to class bass inheritance in my opinion, even though prototypes are much simpler paradigm. In fact with prototypes, there really is no inheritance, so the name in and of itself misleading, it\u0026apos;s more a type of \u0026apos;delegation\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Imagine this ....\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;re in high-school, and you\u0026apos;re in class and have a quiz that\u0026apos;s due today, but you don\u0026apos;t have a pen to fill out your answers. Doh!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;re sitting next to your friend Finnius, who might have a pen. You ask, and he looks around his desk unsuccessfully, but instead of saying \u0026quot;I don\u0026apos;t have a pen\u0026quot;, he\u0026apos;s a nice friend he checks with his other friend Derp if he has a pen. Derp does indeed have a spare pen and passes it back to Finnius, who passes it over to you to complete your quiz. Derp has entrusted the pen to Finnius, who has delegated the pen to you for use.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What is important here is that Derp does not give the pen to you, as you don\u0026apos;t have a direct \u0026lt;em\u0026gt;relationship\u0026lt;/em\u0026gt; with him.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This, is a simplified example of how prototypes work, where a tree of data is searched for the thing you\u0026apos;re looking for.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;another scheme showing \u0026lt;strong\u0026gt;__proto__\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;prototype\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;constructor\u0026lt;/strong\u0026gt; relations:\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/uy5ce.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/uy5ce.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s just that you already have an object with \u0026lt;code\u0026gt;Object.new\u0026lt;/code\u0026gt; but you still don\u0026apos;t have an object when using the constructor syntax.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;It\u0026apos;s important to understand that there is a distinction between an object\u0026apos;s prototype (which is available via \u0026lt;code\u0026gt;Object.getPrototypeOf(obj)\u0026lt;/code\u0026gt;, or via the deprecated \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property) and the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property on constructor functions. The former is the property on each instance, and the latter is the property on the constructor. That is, \u0026lt;code\u0026gt;Object.getPrototypeOf(new Foobar())\u0026lt;/code\u0026gt; refers to the same object as \u0026lt;code\u0026gt;Foobar.prototype\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Reference: \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Prototype\u0026lt;/strong\u0026gt; creates \u0026lt;strong\u0026gt;new object\u0026lt;/strong\u0026gt; by cloning existing \u0026lt;strong\u0026gt;object\u0026lt;/strong\u0026gt;. So really when we think about prototype we can really think \u0026lt;strong\u0026gt;cloning or making\u0026lt;/strong\u0026gt; a copy of something instead of making it up.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want to understand the concept of prototype and prototype based inheritance from the basics, check the official \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MDN\u0026lt;/a\u0026gt; docs, they explain it pretty well.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;When it comes to inheritance, JavaScript only has one construct:\nobjects. Each object has a private property which holds a link to\nanother object called its prototype. That prototype object has a\nprototype of its own, and so on until an object is reached with null\nas its prototype. By definition, null has no prototype, and acts as\nthe final link in this prototype chain.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Also, here\u0026apos;s another good resource that explains using simple examples - \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":491,"title":"How does JavaScript .prototype work?","content":"\n                \n\u0026lt;p\u0026gt;I\u0026apos;m not that into dynamic programming languages but I\u0026apos;ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;();\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello?\u0026apos;\u0026lt;/span\u0026gt;); };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;();\nobj2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I remember a lot discussion I had with people a while back (I\u0026apos;m not exactly sure what I\u0026apos;m doing) but as I understand it, there\u0026apos;s no concept of a class. It\u0026apos;s just an object, and instances of those objects are clones of the original, right?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But what is the exact purpose of this \u0026quot;.prototype\u0026quot; property in JavaScript? How does it relate to instantiating objects?\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Update: correct way\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not a functional object\u0026lt;/span\u0026gt;\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello?\u0026apos;\u0026lt;/span\u0026gt;); }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is wrong!\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a first class functional object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;OK\u0026apos;\u0026lt;/span\u0026gt;); } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Also these \u0026lt;a href=\u0026quot;http://ejohn.org/apps/learn/#64\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;slides\u0026lt;/a\u0026gt; really helped a lot.\u0026lt;/p\u0026gt;\n    ","slug":"how-does-javascript-.prototype-work-1657388169270","postType":"QUESTION","createdAt":"2022-07-09T17:36:09.000Z","updatedAt":"2022-07-09T17:36:09.000Z","tags":[{"id":2466,"name":"prototype-oriented","slug":"prototype-oriented","createdAt":"2022-07-09T17:36:09.000Z","updatedAt":"2022-07-09T17:36:09.000Z","Questions_Tags":{"questionId":491,"tagId":2466}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-does-javascript-.prototype-work-1657388169270"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>