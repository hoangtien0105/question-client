<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_buildManifest.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-iostream%3A%3Aeof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/iostream">iostream</a></div></div><div class="question-content mt-5">
                
<p>I just found a comment in <a href="https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649">this</a> answer saying that using <code>iostream::eof</code> in a loop condition is "almost certainly wrong". I generally use something like <code>while(cin&gt;&gt;n)</code> - which I guess implicitly checks for EOF.</p>

<p>Why is checking for eof explicitly using <code>while (!cin.eof())</code> wrong?  </p>

<p>How is it different from using <code>scanf("...",...)!=EOF</code> in C (which I often use with no problems)?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because <code>iostream::eof</code> will only return <code>true</code> <em>after</em> reading the end of the stream. It does <em>not</em> indicate, that the next read will be the end of the stream.</p>

<p>Consider this (and assume then next read will be at the end of the stream):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!inStream.<span class="hljs-built_in">eof</span>()){
  <span class="hljs-type">int</span> data;
  <span class="hljs-comment">// yay, not end of stream yet, now read ...</span>
  inStream &gt;&gt; data;
  <span class="hljs-comment">// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)</span>
  <span class="hljs-comment">// do stuff with (now uninitialized) data</span>
}
</code></pre>

<p>Against this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(inStream &gt;&gt; data){
  <span class="hljs-comment">// when we land here, we can be sure that the read was successful.</span>
  <span class="hljs-comment">// if it wasn't, the returned stream from operator&gt;&gt; would be converted to false</span>
  <span class="hljs-comment">// and the loop wouldn't even be entered</span>
  <span class="hljs-comment">// do stuff with correctly initialized data (hopefully)</span>
}
</code></pre>

<p>And on your second question: Because</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"..."</span>,...)!=EOF)
</code></pre>

<p>is the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!(inStream &gt;&gt; data).<span class="hljs-built_in">eof</span>())
</code></pre>

<p>and <strong>not</strong> the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!inStream.<span class="hljs-built_in">eof</span>())
    inFile &gt;&gt; data
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Bottom-line top:</strong>  With proper handling of white-space, the following is how <code>eof</code> can be used (and even, be more reliable than <code>fail()</code> for error checking):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;std::ws).<span class="hljs-built_in">eof</span>() ) {  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>(<em>Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.</em>)</p>

<hr>

<p>The main argument against using <code>eof()</code> seems to be missing an important subtlety about the role of white space. My proposition is that, checking <code>eof()</code> explicitly is not only not "<em>always wrong</em>" -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the <em>always correct</em> solution (although, not necessarily the tersest).</p>

<p>To summarize what is being suggested as the "proper" termination and read order is the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(in &gt;&gt; data) {  <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// which is equivalent to </span>
<span class="hljs-keyword">while</span>( !(in &gt;&gt; data).<span class="hljs-built_in">fail</span>() )  {  <span class="hljs-comment">/* ... */</span> }
</code></pre>

<p>The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: </p>

<ul>
<li><code>1 2 3 4 5&lt;eof&gt;</code></li>
<li><code>1 2 a 3 4 5&lt;eof&gt;</code> </li>
<li><code>a&lt;eof&gt;</code></li>
</ul>

<p><code>while(in&gt;&gt;data)</code> terminates with a set <code>failbit</code> for <em>all</em> three input. In the first and third, <code>eofbit</code> is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).</p>

<p>Whereas, take the following: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>Here, <code>in.fail()</code> verifies that as long as there is something to read, it is the correct one. It's purpose is not a mere while-loop terminator. </p>

<p>So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against <code>eof()</code> as terminator?</p>

<p>We don't need to surrender our error handling; just eat up the white-space:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data &gt;&gt; ws; <span class="hljs-comment">// eat whitespace with std::ws</span>
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><code>std::ws</code> skips any potential (zero or more) trailing space in the stream while setting the <code>eofbit</code>, and <strong>not the <code>failbit</code></strong>.  So, <code>in.fail()</code> works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;ws).<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data; 
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">/* this will never fire if the eof is reached cleanly */</span>
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><strong>Summary:</strong> A properly constructed <code>while(!eof)</code> is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, <code>while(!fail)</code> is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because if programmers don't write <code>while(stream &gt;&gt; n)</code>, they possibly write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!stream.<span class="hljs-built_in">eof</span>())
{
    stream &gt;&gt; n;
    <span class="hljs-comment">//some work on n;</span>
}
</code></pre>

<p>Here the problem is, you cannot do <code>some work on n</code> without first checking if the stream read was successful, because if it was unsuccessful, your <code>some work on n</code> would produce undesired result.</p>

<p>The whole point is that, <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> are set <strong>after an attempt is made to read from the stream.</strong> So if <code>stream &gt;&gt; n</code> fails, then <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> is set immediately, so its more idiomatic if you write <code>while (stream &gt;&gt; n)</code>, because the returned object <code>stream</code> converts to <code>false</code> if there was some failure in reading from the stream and consequently the loop stops. And it converts to <code>true</code> if the read was successful and the loop continues.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The other answers have explained why the logic is wrong in <code>while (!stream.eof())</code> and how to fix it. I want to focus on something different:</p>

<blockquote>
  <p>why is checking for eof explicitly using <code>iostream::eof</code> wrong?</p>
</blockquote>

<p>In general terms, checking for <code>eof</code> <em>only</em> is wrong because stream extraction (<code>&gt;&gt;</code>) can fail without hitting the end of the file. If you have e.g. <code>int n; cin &gt;&gt; n;</code> and the stream contains <code>hello</code>, then <code>h</code> is not a valid digit, so extraction will fail without reaching the end of the input.</p>

<p>This issue, combined with the general logic error of checking the stream state <em>before</em> attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:</p>

<ul>
<li><p>If the stream is empty, the loop will run once. <code>&gt;&gt;</code> will fail (there is no input to be read) and all variables that were supposed to be set (by <code>stream &gt;&gt; x</code>) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).</p>

<p>(If your standard library conforms to C++11, things are a bit different now: A failed <code>&gt;&gt;</code> now sets numeric variables to <code>0</code> instead of leaving them uninitialized (except for <code>char</code>s).)</p></li>
<li><p>If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all <code>&gt;&gt;</code> operations fail, variables are likely to keep their value from the previous iteration. This can manifest as "the last line is printed twice" or "the last input record is processed twice".</p>

<p>(This should manifest a bit differently since C++11 (see above): Now you get a "phantom record" of zeroes instead of a repeated last line.)</p></li>
<li><p>If the stream contains malformed data but you only check for <code>.eof</code>, you end up with an infinite loop. <code>&gt;&gt;</code> will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.</p></li>
</ul>

<hr>

<p>To recap: The solution is to test the success of the <code>&gt;&gt;</code> operation itself, not to use a separate <code>.eof()</code> method: <code>while (stream &gt;&gt; n &gt;&gt; m) { ... }</code>, just as in C you test the success of the <code>scanf</code> call itself: <code>while (scanf("%d%d", &amp;n, &amp;m) == 2) { ... }</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The important thing to remember is that, <code>inFile.eof()</code> doesnt become <code>True</code> until <em><strong>after</strong></em> an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()){
    inFile &gt;&gt; x;
        <span class="hljs-built_in">process</span>(x);
}
</code></pre>
<p>The way to make this loop correct, is to combine reading and checking into a single operation, like so</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)&nbsp;
    <span class="hljs-built_in">process</span>(x);&nbsp;
</code></pre>
<p>By convention, <code>operator&gt;&gt;</code> returns the stream we read from, and a Boolean test on a stream returns <code>False</code> when the stream fails (such as reaching end of file).</p>
<p><strong>So this gives us the correct sequence :</strong></p>
<ul>
<li>read</li>
<li>test whether the read succeeds</li>
<li>if and only if the test succeeds, process what weve read</li>
</ul>
<p>If you happen to encounter some <em>other</em> problem that prevents you from reading from the file correctly, you will not be able to reach <code>eof()</code> as such. For example, lets look at something like this</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x;&nbsp;
<span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()) {&nbsp;
    inFile &gt;&gt; x;&nbsp;
    <span class="hljs-built_in">process</span>(x);
}&nbsp;
    
</code></pre>
<p>Let us trace through the working of the above code, with an example</p>
<ul>
<li>Assume the contents of the file are <code>'1', '2', '3', 'a', 'b'</code>.</li>
<li>The loop will read the 1, 2, and 3 correctly.</li>
<li>Then itll get to <code>a</code>.</li>
<li>When it tries to extract <code>a</code> as an int, itll fail.</li>
<li>The stream is now in a failed state, until or unless we <code>clear</code> the stream, all attempts at reading from it will fail.</li>
<li>But, when we test for eof(), itll return <code>False</code>, because were not at the end of the file, because theres still <code>a</code> waiting to be read.</li>
<li>The loop will keep trying to read from the file, and fail every time, so it <strong>never</strong> reaches the end of the file.</li>
<li>So, the loop above will run forever.</li>
</ul>
<p>But, if we use a loop like this, we will get the required output.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)
    <span class="hljs-built_in">process</span>(x);
</code></pre>
<p>In this case, the stream will convert to <code>False</code> not only in case of end of file, but also in case of a failed conversion, such as the <code>a</code> that we cant read as an integer.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; will only return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; reading the end of the stream. It does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; indicate, that the next read will be the end of the stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this (and assume then next read will be at the end of the stream):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, not end of stream yet, now read ...\u0026lt;/span\u0026gt;\n  inStream \u0026amp;gt;\u0026amp;gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with (now uninitialized) data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Against this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(inStream \u0026amp;gt;\u0026amp;gt; data){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when we land here, we can be sure that the read was successful.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if it wasn\u0026apos;t, the returned stream from operator\u0026amp;gt;\u0026amp;gt; would be converted to false\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the loop wouldn\u0026apos;t even be entered\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with correctly initialized data (hopefully)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And on your second question: Because\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;...\u0026quot;\u0026lt;/span\u0026gt;,...)!=EOF)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!(inStream \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n    inFile \u0026amp;gt;\u0026amp;gt; data\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bottom-line top:\u0026lt;/strong\u0026gt;  With proper handling of white-space, the following is how \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; can be used (and even, be more reliable than \u0026lt;code\u0026gt;fail()\u0026lt;/code\u0026gt; for error checking):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;std::ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) {  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(\u0026lt;em\u0026gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The main argument against using \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; explicitly is not only not \u0026quot;\u0026lt;em\u0026gt;always wrong\u0026lt;/em\u0026gt;\u0026quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the \u0026lt;em\u0026gt;always correct\u0026lt;/em\u0026gt; solution (although, not necessarily the tersest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize what is being suggested as the \u0026quot;proper\u0026quot; termination and read order is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in \u0026amp;gt;\u0026amp;gt; data) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is equivalent to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() )  {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 a 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(in\u0026amp;gt;\u0026amp;gt;data)\u0026lt;/code\u0026gt; terminates with a set \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; for \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; three input. In the first and third, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas, take the following: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; verifies that as long as there is something to read, it is the correct one. It\u0026apos;s purpose is not a mere while-loop terminator. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as terminator?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We don\u0026apos;t need to surrender our error handling; just eat up the white-space:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data \u0026amp;gt;\u0026amp;gt; ws; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// eat whitespace with std::ws\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; skips any potential (zero or more) trailing space in the stream while setting the \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, and \u0026lt;strong\u0026gt;not the \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.  So, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data; \n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* this will never fire if the eof is reached cleanly */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary:\u0026lt;/strong\u0026gt; A properly constructed \u0026lt;code\u0026gt;while(!eof)\u0026lt;/code\u0026gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, \u0026lt;code\u0026gt;while(!fail)\u0026lt;/code\u0026gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because if programmers don\u0026apos;t write \u0026lt;code\u0026gt;while(stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, they possibly write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!stream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n{\n    stream \u0026amp;gt;\u0026amp;gt; n;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some work on n;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the problem is, you cannot do \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; without first checking if the stream read was successful, because if it was unsuccessful, your \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; would produce undesired result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole point is that, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set \u0026lt;strong\u0026gt;after an attempt is made to read from the stream.\u0026lt;/strong\u0026gt; So if \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; n\u0026lt;/code\u0026gt; fails, then \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set immediately, so its more idiomatic if you write \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, because the returned object \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; converts to \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the read was successful and the loop continues.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The other answers have explained why the logic is wrong in \u0026lt;code\u0026gt;while (!stream.eof())\u0026lt;/code\u0026gt; and how to fix it. I want to focus on something different:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;why is checking for eof explicitly using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In general terms, checking for \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; is wrong because stream extraction (\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;) can fail without hitting the end of the file. If you have e.g. \u0026lt;code\u0026gt;int n; cin \u0026amp;gt;\u0026amp;gt; n;\u0026lt;/code\u0026gt; and the stream contains \u0026lt;code\u0026gt;hello\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; is not a valid digit, so extraction will fail without reaching the end of the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue, combined with the general logic error of checking the stream state \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is empty, the loop will run once. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail (there is no input to be read) and all variables that were supposed to be set (by \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; x\u0026lt;/code\u0026gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If your standard library conforms to C++11, things are a bit different now: A failed \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; now sets numeric variables to \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; instead of leaving them uninitialized (except for \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s).)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as \u0026quot;the last line is printed twice\u0026quot; or \u0026quot;the last input record is processed twice\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(This should manifest a bit differently since C++11 (see above): Now you get a \u0026quot;phantom record\u0026quot; of zeroes instead of a repeated last line.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream contains malformed data but you only check for \u0026lt;code\u0026gt;.eof\u0026lt;/code\u0026gt;, you end up with an infinite loop. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To recap: The solution is to test the success of the \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operation itself, not to use a separate \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; method: \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; m) { ... }\u0026lt;/code\u0026gt;, just as in C you test the success of the \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; call itself: \u0026lt;code\u0026gt;while (scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;amp;n, \u0026amp;amp;m) == 2) { ... }\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The important thing to remember is that, \u0026lt;code\u0026gt;inFile.eof()\u0026lt;/code\u0026gt; doesnt become \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; until \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n    inFile \u0026amp;gt;\u0026amp;gt; x;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\u0026amp;nbsp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By convention, \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returns the stream we read from, and a Boolean test on a stream returns \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; when the stream fails (such as reaching end of file).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So this gives us the correct sequence :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;read\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;test whether the read succeeds\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if and only if the test succeeds, process what weve read\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;If you happen to encounter some \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; problem that prevents you from reading from the file correctly, you will not be able to reach \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as such. For example, lets look at something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\u0026amp;nbsp;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\u0026amp;nbsp;\n    inFile \u0026amp;gt;\u0026amp;gt; x;\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\u0026amp;nbsp;\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Let us trace through the working of the above code, with an example\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assume the contents of the file are \u0026lt;code\u0026gt;\u0026apos;1\u0026apos;, \u0026apos;2\u0026apos;, \u0026apos;3\u0026apos;, \u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will read the 1, 2, and 3 correctly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then itll get to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it tries to extract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; as an int, itll fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The stream is now in a failed state, until or unless we \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; the stream, all attempts at reading from it will fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But, when we test for eof(), itll return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;, because were not at the end of the file, because theres still \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; waiting to be read.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will keep trying to read from the file, and fail every time, so it \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; reaches the end of the file.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, the loop above will run forever.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;But, if we use a loop like this, we will get the required output.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, the stream will convert to \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; not only in case of end of file, but also in case of a failed conversion, such as the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that we cant read as an integer.\u0026lt;/p\u0026gt;\n    "],"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","content":"\n                \n\u0026lt;p\u0026gt;I just found a comment in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; answer saying that using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; in a loop condition is \u0026quot;almost certainly wrong\u0026quot;. I generally use something like \u0026lt;code\u0026gt;while(cin\u0026amp;gt;\u0026amp;gt;n)\u0026lt;/code\u0026gt; - which I guess implicitly checks for EOF.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why is checking for eof explicitly using \u0026lt;code\u0026gt;while (!cin.eof())\u0026lt;/code\u0026gt; wrong?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How is it different from using \u0026lt;code\u0026gt;scanf(\u0026quot;...\u0026quot;,...)!=EOF\u0026lt;/code\u0026gt; in C (which I often use with no problems)?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},"buildId":"8pZkyd0U8-Y2Qf3QK9j7l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>