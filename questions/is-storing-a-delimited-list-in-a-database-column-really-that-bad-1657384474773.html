<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Is storing a delimited list in a database column really that bad? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.

Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.

I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?

Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I&#x27;m also asking because I&#x27;m thinking about cleaning up the program and make it more maintainable. There are some things in there I&#x27;m not entirely happy with, one of them is the topic of this question.
    "/><meta property="og:title" content="Is storing a delimited list in a database column really that bad? | Solutions Checker"/><meta property="og:description" content="Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.

Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.

I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?

Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I&#x27;m also asking because I&#x27;m thinking about cleaning up the program and make it more maintainable. There are some things in there I&#x27;m not entirely happy with, one of them is the topic of this question.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is storing a delimited list in a database column really that bad?","text":"Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.\n\nNow, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.\n\nI thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?\n\nSome more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I&apos;m also asking because I&apos;m thinking about cleaning up the program and make it more maintainable. There are some things in there I&apos;m not entirely happy with, one of them is the topic of this question.\n    ","answerCount":10,"upVoteCount":500,"suggestedAnswer":[{"text":"In addition to violating First Normal Form because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:\n\nCant ensure that each value is the right data type: no way to prevent 1,2,3,banana,5\nCant use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.\nCant enforce uniqueness: no way to prevent 1,2,3,3,3,5\nCant delete a value from the list without fetching the whole list.\nCan&apos;t store a list longer than what fits in the string column.\nHard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:\nidlist REGEXP &apos;[[:&lt;:]]2[[:&gt;:]]&apos; or in MySQL 8.0: idlist REGEXP &apos;\\\\b2\\\\b&apos;\nHard to count elements in the list, or do other aggregate queries.\nHard to join the values to the lookup table they reference.\nHard to fetch the list in sorted order.\nHard to choose a separator that is guaranteed not to appear in the values\n\nTo solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS already provides much more efficiently.\nComma-separated lists are wrong enough that I made this the first chapter in my book: SQL Antipatterns, Volume 1: Avoiding the Pitfalls of Database Programming.\nThere are times when you need to employ denormalization, but as @OMG Ponies mentions, these are exception cases.  Any non-relational optimization benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"&quot;One reason was laziness&quot;.\n\nThis rings alarm bells. The only reason you should do something like this is that you know how to do it &quot;the right way&quot; but you have come to the conclusion that there is a tangible reason not to do it that way.\n\nHaving said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.\n\n(Some users would dispute the statement in my previous paragraph, saying that &quot;you can never know what requirements will be added in the future&quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"There are numerous questions on SO asking:\n\n\nhow to get a count of specific values from the comma separated list\nhow to get records that have only the same 2/3/etc specific value from that comma separated list\n\n\nAnother problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...\n\nThese are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization can be a query optimization, to be applied when the need actually presents itself.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"In general anything can be defensible if it meets the requirements of your project.  This doesn&apos;t mean that people will agree with or want to defend your decision...\n\nIn general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Yes, I would say that it really is that bad.  It&apos;s a defensible choice, but that doesn&apos;t make it correct or good.\n\nIt breaks first normal form.\n\nA second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.\n\nWhat you&apos;re calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I&apos;d recommend taking the time to do it properly and view it as an opportunity to learn.\n\nOr leave it as it is and learn the painful lesson of a SQL injection attack.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I needed a multi-value column, it could be implemented as an xml field\n\nIt could be converted to a comma delimited as necessary\n\nquerying an XML list in sql server using Xquery.\n\nBy being an xml field, some of the concerns can be addressed.\n\nWith CSV: Can&apos;t ensure that each value is the right data type: no way to prevent 1,2,3,banana,5\n\nWith XML: values in a tag can be forced to be the correct type\n\n\n\nWith CSV: Can&apos;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.\n\nWith XML: still an issue\n\n\n\nWith CSV: Can&apos;t enforce uniqueness: no way to prevent 1,2,3,3,3,5\n\nWith XML: still an issue\n\n\n\nWith CSV: Can&apos;t delete a value from the list without fetching the whole list.\n\nWith XML: single items can be removed\n\n\n\nWith CSV: Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.\n\nWith XML: xml field can be indexed\n\n\n\nWith CSV: Hard to count elements in the list, or do other aggregate queries.**\n\nWith XML: not particularly hard \n\n\n\nWith CSV: Hard to join the values to the lookup table they reference.**\n\nWith XML: not particularly hard \n\n\n\nWith CSV: Hard to fetch the list in sorted order.\n\nWith XML: not particularly hard \n\n\n\nWith CSV: Storing integers as strings takes about twice as much space as storing binary integers.\n\nWith XML: storage is even worse than a csv \n\n\n\nWith CSV: Plus a lot of comma characters.\n\nWith XML: tags are used instead of commas\n\n\n\nIn short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Yes, it is that bad.  My view is that if you don&apos;t like using relational databases then look for an alternative that suits you better, there are lots of interesting &quot;NOSQL&quot; projects out there with some really advanced features.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Well I&apos;ve been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it&apos;s not a that bad idea.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization might become interesting, but with all the data shoved into a single column you&apos;re gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"If you have a fixed number of boolean fields, you could use a INT(1) NOT NULL (or BIT NOT NULL if it exists) or CHAR (0) (nullable) for each. You could also use a SET (I forget the exact syntax).\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773">Is storing a delimited list in a database column really that bad?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/database">database</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/database-design">database-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/database-normalization">database-normalization</a></div></div><div class="question-content mt-5">
                
<p>Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.</p>

<p>Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.</p>

<p>I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?</p>

<p>Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I'm also asking because I'm thinking about cleaning up the program and make it more maintainable. There are some things in there I'm not entirely happy with, one of them is the topic of this question.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In addition to violating <a href="http://en.wikipedia.org/wiki/1NF" rel="nofollow noreferrer">First Normal Form</a> because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:</p>
<ul>
<li>Cant ensure that each value is the right data type: no way to prevent <em>1,2,3,banana,5</em></li>
<li>Cant use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</li>
<li>Cant enforce uniqueness: no way to prevent <em>1,2,3,3,3,5</em></li>
<li>Cant delete a value from the list without fetching the whole list.</li>
<li>Can't store a list longer than what fits in the string column.</li>
<li>Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:<br>
<code>idlist REGEXP '[[:&lt;:]]2[[:&gt;:]]'</code> or in MySQL 8.0: <code>idlist REGEXP '\\b2\\b'</code></li>
<li>Hard to count elements in the list, or do other aggregate queries.</li>
<li>Hard to join the values to the lookup table they reference.</li>
<li>Hard to fetch the list in sorted order.</li>
<li>Hard to choose a separator that is guaranteed not to appear in the values</li>
</ul>
<p>To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS <em>already provides much more efficiently</em>.</p>
<p>Comma-separated lists are wrong enough that I made this the first chapter in my book: <a href="https://pragprog.com/titles/bksap1/" rel="nofollow noreferrer">SQL Antipatterns, Volume 1: Avoiding the Pitfalls of Database Programming</a>.</p>
<p>There are times when you need to employ denormalization, but as <a href="https://stackoverflow.com/a/3653507/578288">@OMG Ponies mentions</a>, these are exception cases.  Any non-relational optimization benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"One reason was laziness".</p>

<p>This rings alarm bells. The only reason you should do something like this is that you know how to do it "the right way" but you have come to the conclusion that there is a tangible reason not to do it that way.</p>

<p>Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.</p>

<p>(Some users would dispute the statement in my previous paragraph, saying that "you can never know what requirements will be added in the future". These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are numerous questions on SO asking:</p>

<ul>
<li>how to get a count of specific values from the comma separated list</li>
<li>how to get records that have only the same 2/3/etc specific value from that comma separated list</li>
</ul>

<p>Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...</p>

<p>These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization <em>can</em> be a query optimization, <strong><em>to be applied when the need actually presents itself</em></strong>.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In general anything can be defensible if it meets the requirements of your project.  This doesn't mean that people will agree with or want to defend your decision...</p>

<p>In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yes, I would say that it really is that bad.  It's a defensible choice, but that doesn't make it correct or good.</p>

<p>It breaks first normal form.</p>

<p>A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.</p>

<p>What you're calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I'd recommend taking the time to do it properly and view it as an opportunity to learn.</p>

<p>Or leave it as it is and learn the painful lesson of a SQL injection attack.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed a multi-value column, it could be implemented as an xml field</p>

<p>It could be converted to a comma delimited as necessary</p>

<p><a href="https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery">querying an XML list in sql server using Xquery</a>.</p>

<p>By being an xml field, some of the concerns can be addressed.</p>

<p><strong>With CSV:</strong> Can't ensure that each value is the right data type: no way to prevent 1,2,3,banana,5</p>

<p><strong>With XML:</strong> values in a tag can be forced to be the correct type</p>

<hr>

<p><strong>With CSV:</strong> Can't use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</p>

<p><strong>With XML:</strong> still an issue</p>

<hr>

<p><strong>With CSV:</strong> Can't enforce uniqueness: no way to prevent 1,2,3,3,3,5</p>

<p><strong>With XML:</strong> still an issue</p>

<hr>

<p><strong>With CSV:</strong> Can't delete a value from the list without fetching the whole list.</p>

<p><strong>With XML:</strong> single items can be removed</p>

<hr>

<p><strong>With CSV:</strong> Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.</p>

<p><strong>With XML:</strong> xml field can be indexed</p>

<hr>

<p><strong>With CSV:</strong> Hard to count elements in the list, or do other aggregate queries.**</p>

<p><strong>With XML:</strong> not particularly hard </p>

<hr>

<p><strong>With CSV:</strong> Hard to join the values to the lookup table they reference.**</p>

<p><strong>With XML:</strong> not particularly hard </p>

<hr>

<p><strong>With CSV:</strong> Hard to fetch the list in sorted order.</p>

<p><strong>With XML:</strong> not particularly hard </p>

<hr>

<p><strong>With CSV:</strong> Storing integers as strings takes about twice as much space as storing binary integers.</p>

<p><strong>With XML:</strong> storage is even worse than a csv </p>

<hr>

<p><strong>With CSV:</strong> Plus a lot of comma characters.</p>

<p><strong>With XML:</strong> tags are used instead of commas</p>

<hr>

<p>In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yes, it <em>is</em> that bad.  My view is that if you don't like using relational databases then look for an alternative that suits you better, there are lots of interesting "NOSQL" projects out there with some really advanced features.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well I've been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it's not a that bad idea.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization <em>might</em> become interesting, but with all the data shoved into a single column you're gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you have a fixed number of boolean fields, you could use a <code>INT(1) NOT NULL</code> (or <code>BIT NOT NULL</code> if it exists) or <code>CHAR (0)</code> (nullable) for each. You could also use a <code>SET</code> (I forget the exact syntax).</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In addition to violating \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/1NF\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;First Normal Form\u0026lt;/a\u0026gt; because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Cant ensure that each value is the right data type: no way to prevent \u0026lt;em\u0026gt;1,2,3,banana,5\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Cant use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Cant enforce uniqueness: no way to prevent \u0026lt;em\u0026gt;1,2,3,3,3,5\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Cant delete a value from the list without fetching the whole list.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Can\u0026apos;t store a list longer than what fits in the string column.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;idlist REGEXP \u0026apos;[[:\u0026amp;lt;:]]2[[:\u0026amp;gt;:]]\u0026apos;\u0026lt;/code\u0026gt; or in MySQL 8.0: \u0026lt;code\u0026gt;idlist REGEXP \u0026apos;\\\\b2\\\\b\u0026apos;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hard to count elements in the list, or do other aggregate queries.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hard to join the values to the lookup table they reference.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hard to fetch the list in sorted order.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hard to choose a separator that is guaranteed not to appear in the values\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS \u0026lt;em\u0026gt;already provides much more efficiently\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Comma-separated lists are wrong enough that I made this the first chapter in my book: \u0026lt;a href=\u0026quot;https://pragprog.com/titles/bksap1/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SQL Antipatterns, Volume 1: Avoiding the Pitfalls of Database Programming\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are times when you need to employ denormalization, but as \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/3653507/578288\u0026quot;\u0026gt;@OMG Ponies mentions\u0026lt;/a\u0026gt;, these are exception cases.  Any non-relational optimization benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026quot;One reason was laziness\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This rings alarm bells. The only reason you should do something like this is that you know how to do it \u0026quot;the right way\u0026quot; but you have come to the conclusion that there is a tangible reason not to do it that way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Some users would dispute the statement in my previous paragraph, saying that \u0026quot;you can never know what requirements will be added in the future\u0026quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are numerous questions on SO asking:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;how to get a count of specific values from the comma separated list\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;how to get records that have only the same 2/3/etc specific value from that comma separated list\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; be a query optimization, \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;to be applied when the need actually presents itself\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In general anything can be defensible if it meets the requirements of your project.  This doesn\u0026apos;t mean that people will agree with or want to defend your decision...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yes, I would say that it really is that bad.  It\u0026apos;s a defensible choice, but that doesn\u0026apos;t make it correct or good.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It breaks first normal form.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What you\u0026apos;re calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I\u0026apos;d recommend taking the time to do it properly and view it as an opportunity to learn.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Or leave it as it is and learn the painful lesson of a SQL injection attack.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed a multi-value column, it could be implemented as an xml field\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It could be converted to a comma delimited as necessary\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery\u0026quot;\u0026gt;querying an XML list in sql server using Xquery\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By being an xml field, some of the concerns can be addressed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Can\u0026apos;t ensure that each value is the right data type: no way to prevent 1,2,3,banana,5\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; values in a tag can be forced to be the correct type\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Can\u0026apos;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; still an issue\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Can\u0026apos;t enforce uniqueness: no way to prevent 1,2,3,3,3,5\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; still an issue\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Can\u0026apos;t delete a value from the list without fetching the whole list.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; single items can be removed\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; xml field can be indexed\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Hard to count elements in the list, or do other aggregate queries.**\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; not particularly hard \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Hard to join the values to the lookup table they reference.**\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; not particularly hard \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Hard to fetch the list in sorted order.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; not particularly hard \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Storing integers as strings takes about twice as much space as storing binary integers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; storage is even worse than a csv \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With CSV:\u0026lt;/strong\u0026gt; Plus a lot of comma characters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;With XML:\u0026lt;/strong\u0026gt; tags are used instead of commas\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yes, it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; that bad.  My view is that if you don\u0026apos;t like using relational databases then look for an alternative that suits you better, there are lots of interesting \u0026quot;NOSQL\u0026quot; projects out there with some really advanced features.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well I\u0026apos;ve been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it\u0026apos;s not a that bad idea.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; become interesting, but with all the data shoved into a single column you\u0026apos;re gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you have a fixed number of boolean fields, you could use a \u0026lt;code\u0026gt;INT(1) NOT NULL\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;BIT NOT NULL\u0026lt;/code\u0026gt; if it exists) or \u0026lt;code\u0026gt;CHAR (0)\u0026lt;/code\u0026gt; (nullable) for each. You could also use a \u0026lt;code\u0026gt;SET\u0026lt;/code\u0026gt; (I forget the exact syntax).\u0026lt;/p\u0026gt;\n    "],"id":68,"title":"Is storing a delimited list in a database column really that bad?","content":"\n                \n\u0026lt;p\u0026gt;Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I\u0026apos;m also asking because I\u0026apos;m thinking about cleaning up the program and make it more maintainable. There are some things in there I\u0026apos;m not entirely happy with, one of them is the topic of this question.\u0026lt;/p\u0026gt;\n    ","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773","postType":"QUESTION","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","tags":[{"id":249,"name":"database","slug":"database","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","Questions_Tags":{"questionId":68,"tagId":249}},{"id":250,"name":"database-design","slug":"database-design","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","Questions_Tags":{"questionId":68,"tagId":250}},{"id":251,"name":"database-normalization","slug":"database-normalization","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","Questions_Tags":{"questionId":68,"tagId":251}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>