<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why does my function that calls an API or launches a coroutine return an empty or null value? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="(Disclaimer: There are a ton of questions which arise from people asking about data being null/incorrect when using asynchronous operations through requests such as facebook,firebase, etc. My intention for this question was to provide a simple answer for that problem to everyone starting out with asynchronous operations in android)
I&#x27;m trying to get data from one of my operations, when I debug it using breakpoints or logs, the values are there, but when I run it they are always null, how can I solve this ?
Firebase
firebaseFirestore.collection(&quot;some collection&quot;).get()
    .addOnSuccessListener(new OnSuccessListener&lt;QuerySnapshot&gt;() {
        @Override
        public void onSuccess(QuerySnapshot documentSnapshots) {
            //I want to return these values I receive here... 
        });
//...and use the returned value here.

Facebook
GraphRequest request = GraphRequest.newGraphPathRequest(
    accessToken,
    &quot;some path&quot;,
    new GraphRequest.Callback() {
        @Override
        public void onCompleted(GraphResponse response) {
            //I want to return these values I receive here...
        }
    });
request.executeAsync();
//...and use the returned value here.

Kotlin coroutine
var result: SomeResultType? = null
someScope.launch {
    result = someSuspendFunctionToRetrieveSomething()
    //I want to return the value I received here... 
}
Log.d(&quot;result&quot;, result.toString()) //...but it is still null here.

Etc.
    "/><meta property="og:title" content="Why does my function that calls an API or launches a coroutine return an empty or null value? | Solutions Checker"/><meta property="og:description" content="(Disclaimer: There are a ton of questions which arise from people asking about data being null/incorrect when using asynchronous operations through requests such as facebook,firebase, etc. My intention for this question was to provide a simple answer for that problem to everyone starting out with asynchronous operations in android)
I&#x27;m trying to get data from one of my operations, when I debug it using breakpoints or logs, the values are there, but when I run it they are always null, how can I solve this ?
Firebase
firebaseFirestore.collection(&quot;some collection&quot;).get()
    .addOnSuccessListener(new OnSuccessListener&lt;QuerySnapshot&gt;() {
        @Override
        public void onSuccess(QuerySnapshot documentSnapshots) {
            //I want to return these values I receive here... 
        });
//...and use the returned value here.

Facebook
GraphRequest request = GraphRequest.newGraphPathRequest(
    accessToken,
    &quot;some path&quot;,
    new GraphRequest.Callback() {
        @Override
        public void onCompleted(GraphResponse response) {
            //I want to return these values I receive here...
        }
    });
request.executeAsync();
//...and use the returned value here.

Kotlin coroutine
var result: SomeResultType? = null
someScope.launch {
    result = someSuspendFunctionToRetrieveSomething()
    //I want to return the value I received here... 
}
Log.d(&quot;result&quot;, result.toString()) //...but it is still null here.

Etc.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why does my function that calls an API or launches a coroutine return an empty or null value?","text":"(Disclaimer: There are a ton of questions which arise from people asking about data being null/incorrect when using asynchronous operations through requests such as facebook,firebase, etc. My intention for this question was to provide a simple answer for that problem to everyone starting out with asynchronous operations in android)\nI&apos;m trying to get data from one of my operations, when I debug it using breakpoints or logs, the values are there, but when I run it they are always null, how can I solve this ?\nFirebase\nfirebaseFirestore.collection(&quot;some collection&quot;).get()\n    .addOnSuccessListener(new OnSuccessListener&lt;QuerySnapshot&gt;() {\n        @Override\n        public void onSuccess(QuerySnapshot documentSnapshots) {\n            //I want to return these values I receive here... \n        });\n//...and use the returned value here.\n\nFacebook\nGraphRequest request = GraphRequest.newGraphPathRequest(\n    accessToken,\n    &quot;some path&quot;,\n    new GraphRequest.Callback() {\n        @Override\n        public void onCompleted(GraphResponse response) {\n            //I want to return these values I receive here...\n        }\n    });\nrequest.executeAsync();\n//...and use the returned value here.\n\nKotlin coroutine\nvar result: SomeResultType? = null\nsomeScope.launch {\n    result = someSuspendFunctionToRetrieveSomething()\n    //I want to return the value I received here... \n}\nLog.d(&quot;result&quot;, result.toString()) //...but it is still null here.\n\nEtc.\n    ","answerCount":4,"upVoteCount":500,"suggestedAnswer":[{"text":"What is a Synchronous/Asynchronous operation ?\nWell, Synchronous waits until the task has completed. Your code executes &quot;top-down&quot; in this situation.\nAsynchronous completes a task in the background and can notify you when it is complete.\nIf you want to return the values from an async operation through a  method/function, you can define your own callbacks in your method/function to use these values as they are returned from these operations.\nHere&apos;s how for Java\nStart off by defining an interface :\ninterface Callback {\n    void myResponseCallback(YourReturnType result);//whatever your return type is: string, integer, etc.\n}\n\nnext, change your method signature to be like this :\npublic void foo(final Callback callback) { // make your method, which was previously returning something, return void, and add in the new callback interface.\n\nnext up, wherever you previously wanted to use those values, add this line :\ncallback.myResponseCallback(yourResponseObject);\n\nas an example :\n@Override\npublic void onSuccess(QuerySnapshot documentSnapshots) {\n    // create your object you want to return here\n    String bar = document.get(&quot;something&quot;).toString();\n    callback.myResponseCallback(bar);\n})\n\nnow, where you were previously calling your method called foo:\nfoo(new Callback() {\n        @Override\n        public void myResponseCallback(YourReturnType result) {\n            //here, this result parameter that comes through is your api call result to use, so use this result right here to do any operation you previously wanted to do. \n        }\n    });\n}\n\nHow do you do this for Kotlin ?\n(as a basic example where you only care for a single result)\nstart off by changing your method signature to something like this:\nfun foo(callback:(YourReturnType) -&gt; Unit) {\n.....\n\nthen, inside your asynchronous operation&apos;s result :\nfirestore.collection(&quot;something&quot;)\n         .document(&quot;document&quot;).get()\n         .addOnSuccessListener { \n             val bar = it.get(&quot;something&quot;).toString()\n             callback(bar)\n         }\n\nthen, where you would have previously called your method called foo, you now do this :\nfoo() { result-&gt;\n    // here, this result parameter that comes through is \n    // whatever you passed to the callback in the code aboce, \n    // so use this result right here to do any operation \n    // you previously wanted to do. \n}\n// Be aware that code outside the callback here will run\n// BEFORE the code above, and cannot rely on any data that may\n// be set inside the callback.\n\nif your foo method previously took in parameters :\nfun foo(value:SomeType, callback:(YourType) -&gt; Unit)\n\nyou simply change it to :\nfoo(yourValueHere) { result -&gt;\n    // here, this result parameter that comes through is \n    // whatever you passed to the callback in the code aboce, \n    // so use this result right here to do any operation \n    // you previously wanted to do. \n}\n\nthese solutions show how you can create a method/function to return values from async operations you&apos;ve performed through the use of callbacks.\n\nHowever, it is important to understand that, should you not be interested in creating a method/function for these:\n@Override\npublic void onSuccess(SomeApiObjectType someApiResult) {\n    // here, this `onSuccess` callback provided by the api \n    // already has the data you&apos;re looking for (in this example, \n    // that data would be `someApiResult`).\n    // you can simply add all your relevant code which would \n    // be using this result inside this block here, this will \n    // include any manipulation of data, populating adapters, etc. \n    // this is the only place where you will have access to the\n    // data returned by the api call, assuming your api follows\n    // this pattern\n})\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"There&apos;s a particular pattern of this nature I&apos;ve seen repeatedly, and I think an explanation of what&apos;s happening would help. The pattern is a function/method that calls an API, assigning the result to a variable in the callback, and returns that variable.\nThe following function/method always returns null, even if the result from the API is not null.\nKotlin\nfun foo(): String? {\n   var myReturnValue: String? = null\n   someApi.addOnSuccessListener { result -&gt;\n       myReturnValue = result.value\n   }.execute()\n   return myReturnValue\n}\n\nKotlin coroutine\nfun foo(): String? {\n   var myReturnValue: String? = null\n   lifecycleScope.launch { \n       myReturnValue = someApiSuspendFunction()\n   }\n   return myReturnValue\n}\n\nJava 8\nprivate String fooValue = null;\n\nprivate String foo() {\n    someApi.addOnSuccessListener(result -&gt; fooValue = result.getValue())\n        .execute();\n    return fooValue;\n}\n\nJava 7\nprivate String fooValue = null;\n\nprivate String foo() {\n    someApi.addOnSuccessListener(new OnSuccessListener&lt;String&gt;() {\n        public void onSuccess(Result&lt;String&gt; result) {\n            fooValue = result.getValue();\n        }\n    }).execute();\n    return fooValue;\n}\n\nThe reason is that when you pass a callback or listener to an API function, that callback code will only be run some time in the future, when the API is done with its work. By passing the callback to the API function, you are queuing up work, but the current function (foo() in this case) returns immediately before that work begins and before that callback code is run.\nOr in the case of the coroutine example above, the launched coroutine is very unlikely to complete before the function that started it.\nYour function that calls the API cannot return the result that is returned in the callback (unless it&apos;s a Kotlin coroutine suspend function). The solution, explained in the other answer, is to make your own function take a callback parameter and not return anything.\nAlternatively, if you&apos;re working with coroutines, you can make your function suspend instead of launching a separate coroutine. When you have suspend functions, somewhere in your code you must launch a coroutine and handle the results within the coroutine. Typically, you would launch a coroutine in a lifecycle function like onCreate(), or in a UI callback like in an OnClickListener.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Other answer explains how to consume APIs based on callbacks by exposing a similar callbacks-based API in the outer function. However, recently Kotlin coroutines become more and more popular, especially on Android and while using them, callbacks are generally discouraged for such purposes. Kotlin approach is to use suspend functions instead. Therefore, if our application uses coroutines already, I suggest not propagating callbacks APIs from 3rd party libraries to the rest of our code, but converting them to suspend functions.\nConverting callbacks to suspend\nLet&apos;s assume we have this callback API:\ninterface Service {\n    fun getData(callback: Callback&lt;String&gt;)\n}\n\ninterface Callback&lt;in T&gt; {\n    fun onSuccess(value: T)\n    fun onFailure(throwable: Throwable)\n}\n\nWe can convert it to suspend function using suspendCoroutine():\nprivate val service: Service\n\nsuspend fun getData(): String {\n    return suspendCoroutine { cont -&gt;\n        service.getData(object : Callback&lt;String&gt; {\n            override fun onSuccess(value: String) {\n                cont.resume(value)\n            }\n\n            override fun onFailure(throwable: Throwable) {\n                cont.resumeWithException(throwable)\n            }\n        })\n    }\n}\n\nThis way getData() can return the data directly and synchronously, so other suspend functions can use it very easily:\nsuspend fun otherFunction() {\n    val data = getData()\n    println(data)\n}\n\nNote that we don&apos;t have to use withContext(Dispatchers.IO) { ... } here. We can even invoke getData() from the main thread as long as we are inside the coroutine context (e.g. inside Dispatchers.Main) - main thread won&apos;t be blocked.\nCancellations\nIf the callback service supports cancelling of background tasks then it is best to cancel when the calling coroutine is itself cancelled. Let&apos;s add a cancelling feature to our callback API:\ninterface Service {\n    fun getData(callback: Callback&lt;String&gt;): Task\n}\n\ninterface Task {\n    fun cancel();\n}\n\nNow, Service.getData() returns Task that we can use to cancel the operation. We can consume it almost the same as previously, but with small changes:\nsuspend fun getData(): String {\n    return suspendCancellableCoroutine { cont -&gt;\n        val task = service.getData(object : Callback&lt;String&gt; {\n            ...\n        })\n\n        cont.invokeOnCancellation {\n            task.cancel()\n        }\n    }\n}\n\nWe only need to switch from suspendCoroutine() to suspendCancellableCoroutine() and add invokeOnCancellation() block.\nExample using Retrofit\ninterface GitHubService {\n    @GET(&quot;users/{user}/repos&quot;)\n    fun listRepos(@Path(&quot;user&quot;) user: String): Call&lt;List&lt;Repo&gt;&gt;\n}\n\nsuspend fun listRepos(user: String): List&lt;Repo&gt; {\n    val retrofit = Retrofit.Builder()\n        .baseUrl(&quot;https://api.github.com/&quot;)\n        .build()\n\n    val service = retrofit.create&lt;GitHubService&gt;()\n\n    return suspendCancellableCoroutine { cont -&gt;\n        val call = service.listRepos(user)\n\n        call.enqueue(object : Callback&lt;List&lt;Repo&gt;&gt; {\n            override fun onResponse(call: Call&lt;List&lt;Repo&gt;&gt;, response: Response&lt;List&lt;Repo&gt;&gt;) {\n                if (response.isSuccessful) {\n                    cont.resume(response.body()!!)\n                } else {\n                    // just an example\n                    cont.resumeWithException(Exception(&quot;Received error response: ${response.message()}&quot;))\n                }\n            }\n\n            override fun onFailure(call: Call&lt;List&lt;Repo&gt;&gt;, t: Throwable) {\n                cont.resumeWithException(t)\n            }\n        })\n\n        cont.invokeOnCancellation {\n            call.cancel()\n        }\n    }\n}\n\nNative support\nBefore we start converting callbacks to suspend functions, it is worth checking whether the library that we use does support suspend functions already: natively or with some extension. Many popular libraries like Retrofit or Firebase support coroutines and suspend functions. Usually, they either provide/handle suspend functions directly or they provide suspendable waiting on top of their asynchronous task/call/etc. object. Such waiting is very often named await().\nFor example, Retrofit supports suspend functions directly since 2.6.0:\ninterface GitHubService {\n    @GET(&quot;users/{user}/repos&quot;)\n    suspend fun listRepos(@Path(&quot;user&quot;) user: String): List&lt;Repo&gt;\n}\n\nNote that we not only added suspend, but also we no longer return Call, but the result directly. Now, we can use it without all this enqueue() boilerplate:\nval repos = service.listRepos(user)\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"TL;DR The code you pass to these APIs (e.g. in the onSuccessListener) is a callback, and it runs asynchronously (not in the order it is written in your file). It runs at some point later in the future to &quot;call back&quot; into your code. Without using a coroutine to suspend the program, you cannot &quot;return&quot; data retrieved in a callback from a function.\nWhat is a callback?\nA callback is a piece of code you pass to some third party library that it will run later when some event happens (e.g. when it gets data from a server). It is important to remember that the callback is not run in the order you wrote it - it may be run much later in the future, could run multiple times, or may never run at all. The example callback below will run Point A, start the server fetching process, run Point C, exit the function, then some time in the distant future may run Point B when the data is retrieved. The printout at Point C will always be empty.\nfun getResult() {\n    // Point A\n    var r = &quot;&quot;\n    doc.get().addOnSuccessListener { result -&gt;\n       // The code inside the {} here is the &quot;callback&quot;\n       // Point B - handle result\n       r = result // don&apos;t do this!\n    }\n    // Point C - r=&quot;&quot; still here, point B hasn&apos;t run yet\n    println(r)\n}\n\nHow do I get the data from the callback then?\nMake your own interface/callback\nMaking your own custom interface/callback can sometimes make things cleaner looking but it doesn&apos;t really help with the core question of how to use the data outside the callback - it just moves the aysnc call to another location. It can help if the primary API call is somewhere else (e.g. in another class).\n// you made your own callback to use in the\n// async API\nfun getResultImpl(callback: (String)-&gt;Unit) {\n    doc.get().addOnSuccessListener { result -&gt;\n        callback(result)\n    }\n}\n\n// but if you use it like this, you still have\n// the EXACT same problem as before - the printout \n// will always be empty\nfun getResult() {\n    var r = &quot;&quot;\n    getResultImpl { result -&gt;\n        // this part is STILL an async callback,\n        // and runs later in the future\n        r = result\n    }\n    println(r) // always empty here\n}\n\n// you still have to do things INSIDE the callback,\n// you could move getResultImpl to another class now,\n// but still have the same potential pitfalls as before\nfun getResult() {\n    getResultImpl { result -&gt;\n        println(result)\n    }\n}\n\nSome examples of how to properly use a custom callback: example 1, example 2, example 3\nMake the callback a suspend function\nAnother option is to turn the async method into a suspend function using coroutines so it can wait for the callback to complete. This lets you write linear-looking functions again.\nsuspend fun getResult() {\n    val result = suspendCoroutine { cont -&gt;\n        doc.get().addOnSuccessListener { result -&gt;\n            cont.resume(result)\n        }\n    }\n    // the first line will suspend the coroutine and wait\n    // until the async method returns a result. If the \n    // callback could be called multiple times this may not\n    // be the best pattern to use\n    println(result)\n}\n\nRe-arrange your program into smaller functions\nInstead of writing monolithic linear functions, break the work up into several functions and call them from within the callbacks. You should not try to modify local variables within the callback and return or use them after the callback (e.g. Point C). You have to move away from the idea of returning data from a function when it comes from an async API - without a coroutine this generally isn&apos;t possible.\nFor example, you could handle the async data in a separate method (a &quot;processing method&quot;) and do as little as possible in the callback itself other than call the processing method with the received result. This helps avoid a lot of the common errors with async APIs where you attempt to modify local variables declared outside the callback scope or try to return things modified from within the callback. When you call getResult it starts the process of getting the data. When that process is complete (some time in the future) the callback calls showResult to show it.\nfun getResult() {\n   doc.get().addOnSuccessListener { result -&gt;\n      showResult(result)\n   }\n   // don&apos;t try to show or return the result here!\n}\n\nfun showResult(result: String) {\n    println(result)\n}\n\nExample\nAs a concrete example here is a minimal ViewModel showing how one could include an async API into a program flow to fetch data, process it, and display it in an Activity or Fragment. This is written in Kotlin but is equally applicable to Java.\nclass MainViewModel : ViewModel() {\n    private val textLiveData = MutableLiveData&lt;String&gt;()\n    val text: LiveData&lt;String&gt;\n        get() = textLiveData\n\n    fun fetchData() {\n        // Use a coroutine here to make a dummy async call,\n        // this is where you could call Firestore or other API\n        // Note that this method does not _return_ the requested data!\n        viewModelScope.launch {\n            delay(3000)\n            // pretend this is a slow network call, this part\n            // won&apos;t run until 3000 ms later\n            val t = Calendar.getInstance().time\n            processData(t.toString())\n        }\n\n        // anything out here will run immediately, it will not\n        // wait for the &quot;slow&quot; code above to run first\n    }\n\n    private fun processData(d: String) {\n        // Once you get the data you may want to modify it before displaying it.\n        val p = &quot;The time is $d&quot;\n        textLiveData.postValue(p)\n    }\n}\n\nA real API call in fetchData() might look something more like this\nfun fetchData() {\n    firestoreDB.collection(&quot;data&quot;)\n               .document(&quot;mydoc&quot;)\n               .get()\n               .addOnCompleteListener { task -&gt;\n                   if (task.isSuccessful) {\n                       val data = task.result.data\n                       processData(data[&quot;time&quot;])\n                   }\n                   else {\n                       textLiveData.postValue(&quot;ERROR&quot;)\n                   }\n               }\n}\n\nThe Activity or Fragment that goes along with this doesn&apos;t need to know anything about these calls, it just passes actions in by calling methods on the ViewModel and observes the LiveData to update its views when new data is available. It cannot assume that the data is available immediately after a call to fetchData(), but with this pattern it doesn&apos;t need to.\nThe view layer can also do things like show and hide a progress bar while the data is being loaded so the user knows it&apos;s working in the background.\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        val model: MainViewModel by viewModels()\n\n        // Observe the LiveData and when it changes, update the\n        // state of the Views\n        model.text.observe(this) { processedData -&gt;\n            binding.text.text = processedData \n            binding.progress.visibility = View.GONE\n        }\n\n        // When the user clicks the button, pass that action to the\n        // ViewModel by calling &quot;fetchData()&quot;\n        binding.getText.setOnClickListener {\n            binding.progress.visibility = View.VISIBLE\n            model.fetchData()\n        }\n\n        binding.progress.visibility = View.GONE\n    }\n}\n\nThe ViewModel is not strictly necessary for this type of async workflow - here is an example of how to do the same thing in the activity\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // When the user clicks the button, trigger the async\n        // data call\n        binding.getText.setOnClickListener {\n            binding.progress.visibility = View.VISIBLE\n            fetchData()\n        }\n\n        binding.progress.visibility = View.GONE\n    }\n    \n    private fun fetchData() {\n        lifecycleScope.launch {\n            delay(3000)\n            val t = Calendar.getInstance().time\n            processData(t.toString())\n        }\n    }\n    \n    private fun processData(d: String) {\n        binding.progress.visibility = View.GONE\n        val p = &quot;The time is $d&quot;\n        binding.text.text = p\n    }\n}\n\n\n(and, for completeness, the activity XML)\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;.MainActivity&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/text&quot;\n        android:layout_margin=&quot;16dp&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/get_text&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_margin=&quot;16dp&quot;\n        android:text=&quot;Get Text&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@+id/text&quot;\n        /&gt;\n\n    &lt;ProgressBar\n        android:id=&quot;@+id/progress&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:padding=&quot;48dp&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@+id/get_text&quot;\n        /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/google-cloud-firestore">google-cloud-firestore</a></div></div><div class="question-content mt-5">
                
<p><em>(Disclaimer: There are a ton of questions which arise from people asking about data being null/incorrect when using asynchronous operations through requests such as facebook,firebase, etc. My intention for this question was to provide a simple answer for that problem to everyone starting out with asynchronous operations in android)</em></p>
<p>I'm trying to get data from one of my operations, when I debug it using breakpoints or logs, the values are there, but when I run it they are always null, how can I solve this ?</p>
<p><strong>Firebase</strong></p>
<pre class="lang-java s-code-block"><code class="hljs language-java">firebaseFirestore.collection(<span class="hljs-string">"some collection"</span>).get()
    .addOnSuccessListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnSuccessListener</span>&lt;QuerySnapshot&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(QuerySnapshot documentSnapshots)</span> {
            <span class="hljs-comment">//I want to return these values I receive here... </span>
        });
<span class="hljs-comment">//...and use the returned value here.</span>
</code></pre>
<p><strong>Facebook</strong></p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">GraphRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GraphRequest.newGraphPathRequest(
    accessToken,
    <span class="hljs-string">"some path"</span>,
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphRequest</span>.Callback() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompleted</span><span class="hljs-params">(GraphResponse response)</span> {
            <span class="hljs-comment">//I want to return these values I receive here...</span>
        }
    });
request.executeAsync();
<span class="hljs-comment">//...and use the returned value here.</span>
</code></pre>
<p><strong>Kotlin coroutine</strong></p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> result: SomeResultType? = <span class="hljs-literal">null</span>
someScope.launch {
    result = someSuspendFunctionToRetrieveSomething()
    <span class="hljs-comment">//I want to return the value I received here... </span>
}
Log.d(<span class="hljs-string">"result"</span>, result.toString()) <span class="hljs-comment">//...but it is still null here.</span>
</code></pre>
<p>Etc.</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>What is a Synchronous/Asynchronous operation ?</strong></p>
<p>Well, <strong>Synchronous</strong> waits until the task has completed. Your code executes "top-down" in this situation.</p>
<p><strong>Asynchronous</strong> completes a task in the background and can notify you when it is complete.</p>
<p>If you want to return the values from an async operation through a  method/function, you can define your own callbacks in your method/function to use these values as they are returned from these operations.</p>
<p><strong>Here's how for Java</strong></p>
<p>Start off by defining an interface :</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callback</span> {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myResponseCallback</span>(<span class="hljs-params">YourReturnType result</span>)</span>;<span class="hljs-comment">//whatever your return type is: string, integer, etc.</span>
}
</code></pre>
<p>next, change your method signature to be like this :</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback callback)</span> </span>{ <span class="hljs-comment">// make your method, which was previously returning something, return void, and add in the new callback interface.</span>
</code></pre>
<p>next up, wherever you previously wanted to use those values, add this line :</p>
<pre class="default s-code-block"><code class="hljs language-scss">callback<span class="hljs-selector-class">.myResponseCallback</span>(yourResponseObject);
</code></pre>
<p>as an example :</p>
<pre class="default s-code-block"><code class="hljs language-typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSuccess</span>(<span class="hljs-params">QuerySnapshot documentSnapshots</span>) {
    <span class="hljs-comment">// create your object you want to return here</span>
    <span class="hljs-title class_">String</span> bar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"something"</span>).<span class="hljs-title function_">toString</span>();
    callback.<span class="hljs-title function_">myResponseCallback</span>(bar);
})
</code></pre>
<p>now, where you were previously calling your method called <code>foo</code>:</p>
<pre class="default s-code-block"><code class="hljs language-typescript"><span class="hljs-title function_">foo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myResponseCallback</span>(<span class="hljs-params">YourReturnType result</span>) {
            <span class="hljs-comment">//here, this result parameter that comes through is your api call result to use, so use this result right here to do any operation you previously wanted to do. </span>
        }
    });
}
</code></pre>
<p><strong>How do you do this for Kotlin ?</strong>
(as a basic example where you only care for a single result)</p>
<p>start off by changing your method signature to something like this:</p>
<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(callback:(<span class="hljs-type">YourReturnType</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
.....
</code></pre>
<p>then, inside your asynchronous operation's result :</p>
<pre class="default s-code-block"><code class="hljs language-kotlin">firestore.collection(<span class="hljs-string">"something"</span>)
         .document(<span class="hljs-string">"document"</span>).<span class="hljs-keyword">get</span>()
         .addOnSuccessListener { 
             <span class="hljs-keyword">val</span> bar = it.<span class="hljs-keyword">get</span>(<span class="hljs-string">"something"</span>).toString()
             callback(bar)
         }
</code></pre>
<p>then, where you would have previously called your method called <code>foo</code>, you now do this :</p>
<pre class="default s-code-block"><code class="hljs language-scss"><span class="hljs-built_in">foo</span>() { result-&gt;
    <span class="hljs-comment">// here, this result parameter that comes through is </span>
    <span class="hljs-comment">// whatever you passed to the callback in the code aboce, </span>
    <span class="hljs-comment">// so use this result right here to do any operation </span>
    <span class="hljs-comment">// you previously wanted to do. </span>
}
<span class="hljs-comment">// Be aware that code outside the callback here will run</span>
<span class="hljs-comment">// BEFORE the code above, and cannot rely on any data that may</span>
<span class="hljs-comment">// be set inside the callback.</span>
</code></pre>
<p>if your <code>foo</code> method previously took in parameters :</p>
<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(value:<span class="hljs-type">SomeType</span>, callback:(<span class="hljs-type">YourType</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>
</code></pre>
<p>you simply change it to :</p>
<pre class="default s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">foo</span>(<span class="hljs-params">yourValueHere</span>) { result -&gt;
    <span class="hljs-comment">// here, this result parameter that comes through is </span>
    <span class="hljs-comment">// whatever you passed to the callback in the code aboce, </span>
    <span class="hljs-comment">// so use this result right here to do any operation </span>
    <span class="hljs-comment">// you previously wanted to do. </span>
}
</code></pre>
<p>these solutions show how you can create a method/function to return values from async operations you've performed through the use of callbacks.</p>
<hr>
<p>However, it is important to understand that, should you not be interested in creating a method/function for these:</p>
<pre class="default s-code-block"><code class="hljs language-typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSuccess</span>(<span class="hljs-params">SomeApiObjectType someApiResult</span>) {
    <span class="hljs-comment">// here, this `onSuccess` callback provided by the api </span>
    <span class="hljs-comment">// already has the data you're looking for (in this example, </span>
    <span class="hljs-comment">// that data would be `someApiResult`).</span>
    <span class="hljs-comment">// you can simply add all your relevant code which would </span>
    <span class="hljs-comment">// be using this result inside this block here, this will </span>
    <span class="hljs-comment">// include any manipulation of data, populating adapters, etc. </span>
    <span class="hljs-comment">// this is the only place where you will have access to the</span>
    <span class="hljs-comment">// data returned by the api call, assuming your api follows</span>
    <span class="hljs-comment">// this pattern</span>
})
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There's a particular pattern of this nature I've seen repeatedly, and I think an explanation of what's happening would help. The pattern is a function/method that calls an API, assigning the result to a variable in the callback, and returns that variable.</p>
<p>The following function/method always returns null, even if the result from the API is not null.</p>
<p><strong>Kotlin</strong></p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>: String? {
   <span class="hljs-keyword">var</span> myReturnValue: String? = <span class="hljs-literal">null</span>
   someApi.addOnSuccessListener { result -&gt;
       myReturnValue = result.value
   }.execute()
   <span class="hljs-keyword">return</span> myReturnValue
}
</code></pre>
<p><strong>Kotlin coroutine</strong></p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>: String? {
   <span class="hljs-keyword">var</span> myReturnValue: String? = <span class="hljs-literal">null</span>
   lifecycleScope.launch { 
       myReturnValue = someApiSuspendFunction()
   }
   <span class="hljs-keyword">return</span> myReturnValue
}
</code></pre>
<p><strong>Java 8</strong></p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">fooValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

<span class="hljs-keyword">private</span> String <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> {
    someApi.addOnSuccessListener(result -&gt; fooValue = result.getValue())
        .execute();
    <span class="hljs-keyword">return</span> fooValue;
}
</code></pre>
<p><strong>Java 7</strong></p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">fooValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

<span class="hljs-keyword">private</span> String <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> {
    someApi.addOnSuccessListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnSuccessListener</span>&lt;String&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Result&lt;String&gt; result)</span> {
            fooValue = result.getValue();
        }
    }).execute();
    <span class="hljs-keyword">return</span> fooValue;
}
</code></pre>
<p>The reason is that when you pass a callback or listener to an API function, that callback code will only be run some time in the future, when the API is done with its work. By passing the callback to the API function, you are <em>queuing</em> up work, but the current function (<code>foo()</code> in this case) returns immediately before that work begins and before that callback code is run.</p>
<p>Or in the case of the coroutine example above, the launched coroutine is very unlikely to complete before the function that started it.</p>
<p>Your function that calls the API cannot return the result that is returned in the callback (unless it's a Kotlin coroutine suspend function). The solution, explained in the other answer, is to make your own function take a callback parameter and not return anything.</p>
<p>Alternatively, if you're working with coroutines, you can make your function suspend instead of launching a separate coroutine. When you have suspend functions, somewhere in your code you must launch a coroutine and handle the results <em>within</em> the coroutine. Typically, you would launch a coroutine in a lifecycle function like <code>onCreate()</code>, or in a UI callback like in an OnClickListener.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Other answer explains how to consume APIs based on callbacks by exposing a similar callbacks-based API in the outer function. However, recently Kotlin coroutines become more and more popular, especially on Android and while using them, callbacks are generally discouraged for such purposes. Kotlin approach is to use suspend functions instead. Therefore, if our application uses coroutines already, I suggest not propagating callbacks APIs from 3rd party libraries to the rest of our code, but converting them to suspend functions.</p>
<p><strong>Converting callbacks to suspend</strong></p>
<p>Let's assume we have this callback API:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">(callback: <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callback</span>&lt;<span class="hljs-type">in T</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(throwable: <span class="hljs-type">Throwable</span>)</span></span>
}
</code></pre>
<p>We can convert it to suspend function using <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/" rel="nofollow noreferrer">suspendCoroutine()</a>:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> service: Service

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> suspendCoroutine { cont -&gt;
        service.getData(<span class="hljs-keyword">object</span> : Callback&lt;String&gt; {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {
                cont.resume(value)
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(throwable: <span class="hljs-type">Throwable</span>)</span></span> {
                cont.resumeWithException(throwable)
            }
        })
    }
}
</code></pre>
<p>This way <code>getData()</code> can return the data directly and synchronously, so other suspend functions can use it very easily:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">otherFunction</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = getData()
    println(<span class="hljs-keyword">data</span>)
}
</code></pre>
<p>Note that we don't have to use <code>withContext(Dispatchers.IO) { ... }</code> here. We can even invoke <code>getData()</code> from the main thread as long as we are inside the coroutine context (e.g. inside <code>Dispatchers.Main</code>) - main thread won't be blocked.</p>
<p><strong>Cancellations</strong></p>
<p>If the callback service supports cancelling of background tasks then it is best to cancel when the calling coroutine is itself cancelled. Let's add a cancelling feature to our callback API:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">(callback: <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Task
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Task</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p>Now, <code>Service.getData()</code> returns <code>Task</code> that we can use to cancel the operation. We can consume it almost the same as previously, but with small changes:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> suspendCancellableCoroutine { cont -&gt;
        <span class="hljs-keyword">val</span> task = service.getData(<span class="hljs-keyword">object</span> : Callback&lt;String&gt; {
            ...
        })

        cont.invokeOnCancellation {
            task.cancel()
        }
    }
}
</code></pre>
<p>We only need to switch from <code>suspendCoroutine()</code> to <code>suspendCancellableCoroutine()</code> and add <code>invokeOnCancellation()</code> block.</p>
<p><strong>Example using Retrofit</strong></p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GitHubService</span> </span>{
    <span class="hljs-meta">@GET(<span class="hljs-string">"users/{user}/repos"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">listRepos</span><span class="hljs-params">(<span class="hljs-meta">@Path(<span class="hljs-string">"user"</span>)</span> user: <span class="hljs-type">String</span>)</span></span>: Call&lt;List&lt;Repo&gt;&gt;
}

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">listRepos</span><span class="hljs-params">(user: <span class="hljs-type">String</span>)</span></span>: List&lt;Repo&gt; {
    <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()
        .baseUrl(<span class="hljs-string">"https://api.github.com/"</span>)
        .build()

    <span class="hljs-keyword">val</span> service = retrofit.create&lt;GitHubService&gt;()

    <span class="hljs-keyword">return</span> suspendCancellableCoroutine { cont -&gt;
        <span class="hljs-keyword">val</span> call = service.listRepos(user)

        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;List&lt;Repo&gt;&gt; {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Repo</span>&gt;&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Repo</span>&gt;&gt;)</span></span> {
                <span class="hljs-keyword">if</span> (response.isSuccessful) {
                    cont.resume(response.body()!!)
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// just an example</span>
                    cont.resumeWithException(Exception(<span class="hljs-string">"Received error response: <span class="hljs-subst">${response.message()}</span>"</span>))
                }
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Repo</span>&gt;&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> {
                cont.resumeWithException(t)
            }
        })

        cont.invokeOnCancellation {
            call.cancel()
        }
    }
}
</code></pre>
<p><strong>Native support</strong></p>
<p>Before we start converting callbacks to suspend functions, it is worth checking whether the library that we use does support suspend functions already: natively or with some extension. Many popular libraries like Retrofit or Firebase support coroutines and suspend functions. Usually, they either provide/handle suspend functions directly or they provide suspendable waiting on top of their asynchronous task/call/etc. object. Such waiting is very often named <code>await()</code>.</p>
<p>For example, Retrofit supports suspend functions directly since 2.6.0:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GitHubService</span> </span>{
    <span class="hljs-meta">@GET(<span class="hljs-string">"users/{user}/repos"</span>)</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">listRepos</span><span class="hljs-params">(<span class="hljs-meta">@Path(<span class="hljs-string">"user"</span>)</span> user: <span class="hljs-type">String</span>)</span></span>: List&lt;Repo&gt;
}
</code></pre>
<p>Note that we not only added <code>suspend</code>, but also we no longer return <code>Call</code>, but the result directly. Now, we can use it without all this <code>enqueue()</code> boilerplate:</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> repos = service.listRepos(user)
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>TL;DR</strong> The code you pass to these APIs (e.g. in the onSuccessListener) is a <strong>callback</strong>, and it runs <em>asynchronously</em> (not in the order it is written in your file). It runs at some point later in the future to "call back" into your code. Without using a coroutine to suspend the program, you cannot "return" data retrieved in a callback from a function.</p>
<h2>What is a callback?</h2>
<p>A callback is a piece of code you pass to some third party library that it will run later when some event happens (e.g. when it gets data from a server). It is important to remember that the callback is not run in the order you wrote it - it may be run much later in the future, could run multiple times, or may never run at all. The example callback below will run Point A, start the server fetching process, run Point C, exit the function, then some time in the distant future may run Point B when the data is retrieved. The printout at Point C will always be empty.</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Point A</span>
    <span class="hljs-keyword">var</span> r = <span class="hljs-string">""</span>
    doc.<span class="hljs-keyword">get</span>().addOnSuccessListener { result -&gt;
       <span class="hljs-comment">// The code inside the {} here is the "callback"</span>
       <span class="hljs-comment">// Point B - handle result</span>
       r = result <span class="hljs-comment">// don't do this!</span>
    }
    <span class="hljs-comment">// Point C - r="" still here, point B hasn't run yet</span>
    println(r)
}
</code></pre>
<h2>How do I get the data from the callback then?</h2>
<p><strong>Make your own interface/callback</strong></p>
<p>Making your own custom interface/callback can sometimes make things cleaner looking but it doesn't really help with the core question of how to use the data outside the callback - it just moves the aysnc call to another location. It can help if the primary API call is somewhere else (e.g. in another class).</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-comment">// you made your own callback to use in the</span>
<span class="hljs-comment">// async API</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResultImpl</span><span class="hljs-params">(callback: (<span class="hljs-type">String</span>)-&gt;<span class="hljs-type">Unit</span>)</span></span> {
    doc.<span class="hljs-keyword">get</span>().addOnSuccessListener { result -&gt;
        callback(result)
    }
}

<span class="hljs-comment">// but if you use it like this, you still have</span>
<span class="hljs-comment">// the EXACT same problem as before - the printout </span>
<span class="hljs-comment">// will always be empty</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> r = <span class="hljs-string">""</span>
    getResultImpl { result -&gt;
        <span class="hljs-comment">// this part is STILL an async callback,</span>
        <span class="hljs-comment">// and runs later in the future</span>
        r = result
    }
    println(r) <span class="hljs-comment">// always empty here</span>
}

<span class="hljs-comment">// you still have to do things INSIDE the callback,</span>
<span class="hljs-comment">// you could move getResultImpl to another class now,</span>
<span class="hljs-comment">// but still have the same potential pitfalls as before</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span> {
    getResultImpl { result -&gt;
        println(result)
    }
}
</code></pre>
<p><em>Some examples of how to properly use a custom callback</em>: <a href="https://stackoverflow.com/questions/47847694/how-to-return-datasnapshot-value-as-a-result-of-a-method">example 1</a>, <a href="https://stackoverflow.com/questions/72334154/android-recyclerview-does-not-show-any-data/72334281#72334281">example 2</a>, <a href="https://stackoverflow.com/a/57330767/9473786">example 3</a></p>
<p><strong>Make the callback a suspend function</strong></p>
<p>Another option is to turn the async method into a <a href="https://stackoverflow.com/a/69966845/9473786">suspend function</a> using coroutines so it can wait for the callback to complete. This lets you write linear-looking functions again.</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> result = suspendCoroutine { cont -&gt;
        doc.<span class="hljs-keyword">get</span>().addOnSuccessListener { result -&gt;
            cont.resume(result)
        }
    }
    <span class="hljs-comment">// the first line will suspend the coroutine and wait</span>
    <span class="hljs-comment">// until the async method returns a result. If the </span>
    <span class="hljs-comment">// callback could be called multiple times this may not</span>
    <span class="hljs-comment">// be the best pattern to use</span>
    println(result)
}
</code></pre>
<p><strong>Re-arrange your program into smaller functions</strong></p>
<p>Instead of writing monolithic linear functions, break the work up into several functions and call them from within the callbacks. You should not try to modify local variables within the callback and return or use them after the callback (e.g. Point C). You have to move away from the idea of <em>returning data</em> from a function when it comes from an async API - without a coroutine this generally isn't possible.</p>
<p>For example, you could handle the async data in a separate method (a "processing method") and do as little as possible in the callback itself other than call the processing method with the received result. This helps avoid a lot of the common errors with async APIs where you attempt to modify local variables declared outside the callback scope or try to return things modified from within the callback. When you call <code>getResult</code> it <em>starts</em> the process of getting the data. When that process is complete (some time in the future) the callback calls <code>showResult</code> to show it.</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span> {
   doc.<span class="hljs-keyword">get</span>().addOnSuccessListener { result -&gt;
      showResult(result)
   }
   <span class="hljs-comment">// don't try to show or return the result here!</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showResult</span><span class="hljs-params">(result: <span class="hljs-type">String</span>)</span></span> {
    println(result)
}
</code></pre>
<h2>Example</h2>
<p>As a concrete example here is a minimal ViewModel showing how one could include an async API into a program flow to fetch data, process it, and display it in an Activity or Fragment. This is written in Kotlin but is equally applicable to Java.</p>
<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> : <span class="hljs-type">ViewModel</span></span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> textLiveData = MutableLiveData&lt;String&gt;()
    <span class="hljs-keyword">val</span> text: LiveData&lt;String&gt;
        <span class="hljs-keyword">get</span>() = textLiveData

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// Use a coroutine here to make a dummy async call,</span>
        <span class="hljs-comment">// this is where you could call Firestore or other API</span>
        <span class="hljs-comment">// Note that this method does not _return_ the requested data!</span>
        viewModelScope.launch {
            delay(<span class="hljs-number">3000</span>)
            <span class="hljs-comment">// pretend this is a slow network call, this part</span>
            <span class="hljs-comment">// won't run until 3000 ms later</span>
            <span class="hljs-keyword">val</span> t = Calendar.getInstance().time
            processData(t.toString())
        }

        <span class="hljs-comment">// anything out here will run immediately, it will not</span>
        <span class="hljs-comment">// wait for the "slow" code above to run first</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processData</span><span class="hljs-params">(d: <span class="hljs-type">String</span>)</span></span> {
        <span class="hljs-comment">// Once you get the data you may want to modify it before displaying it.</span>
        <span class="hljs-keyword">val</span> p = <span class="hljs-string">"The time is <span class="hljs-variable">$d</span>"</span>
        textLiveData.postValue(p)
    }
}
</code></pre>
<p>A real API call in <code>fetchData()</code> might look something more like this</p>
<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span> {
    firestoreDB.collection(<span class="hljs-string">"data"</span>)
               .document(<span class="hljs-string">"mydoc"</span>)
               .<span class="hljs-keyword">get</span>()
               .addOnCompleteListener { task -&gt;
                   <span class="hljs-keyword">if</span> (task.isSuccessful) {
                       <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = task.result.<span class="hljs-keyword">data</span>
                       processData(<span class="hljs-keyword">data</span>[<span class="hljs-string">"time"</span>])
                   }
                   <span class="hljs-keyword">else</span> {
                       textLiveData.postValue(<span class="hljs-string">"ERROR"</span>)
                   }
               }
}
</code></pre>
<p>The Activity or Fragment that goes along with this doesn't need to know anything about these calls, it just passes actions in by calling methods on the ViewModel and observes the LiveData to update its views when new data is available. It cannot assume that the data is available immediately after a call to <code>fetchData()</code>, but with this pattern it doesn't need to.</p>
<p>The view layer can also do things like show and hide a progress bar while the data is being loaded so the user knows it's working in the background.</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        <span class="hljs-keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        <span class="hljs-keyword">val</span> model: MainViewModel <span class="hljs-keyword">by</span> viewModels()

        <span class="hljs-comment">// Observe the LiveData and when it changes, update the</span>
        <span class="hljs-comment">// state of the Views</span>
        model.text.observe(<span class="hljs-keyword">this</span>) { processedData -&gt;
            binding.text.text = processedData 
            binding.progress.visibility = View.GONE
        }

        <span class="hljs-comment">// When the user clicks the button, pass that action to the</span>
        <span class="hljs-comment">// ViewModel by calling "fetchData()"</span>
        binding.getText.setOnClickListener {
            binding.progress.visibility = View.VISIBLE
            model.fetchData()
        }

        binding.progress.visibility = View.GONE
    }
}
</code></pre>
<p>The ViewModel is not strictly necessary for this type of async workflow - here is an example of how to do the same thing in the activity</p>
<pre class="lang-kotlin s-code-block"><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityMainBinding

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        <span class="hljs-comment">// When the user clicks the button, trigger the async</span>
        <span class="hljs-comment">// data call</span>
        binding.getText.setOnClickListener {
            binding.progress.visibility = View.VISIBLE
            fetchData()
        }

        binding.progress.visibility = View.GONE
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span> {
        lifecycleScope.launch {
            delay(<span class="hljs-number">3000</span>)
            <span class="hljs-keyword">val</span> t = Calendar.getInstance().time
            processData(t.toString())
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processData</span><span class="hljs-params">(d: <span class="hljs-type">String</span>)</span></span> {
        binding.progress.visibility = View.GONE
        <span class="hljs-keyword">val</span> p = <span class="hljs-string">"The time is <span class="hljs-variable">$d</span>"</span>
        binding.text.text = p
    }
}

</code></pre>
<p>(and, for completeness, the activity XML)</p>
<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">".MainActivity"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/text"</span>
        <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">"16dp"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">"parent"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/get_text"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">"16dp"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"Get Text"</span>
        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">"@+id/text"</span>
        /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/progress"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:padding</span>=<span class="hljs-string">"48dp"</span>
        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">"@+id/get_text"</span>
        /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span>
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is a Synchronous/Asynchronous operation ?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Well, \u0026lt;strong\u0026gt;Synchronous\u0026lt;/strong\u0026gt; waits until the task has completed. Your code executes \u0026quot;top-down\u0026quot; in this situation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Asynchronous\u0026lt;/strong\u0026gt; completes a task in the background and can notify you when it is complete.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you want to return the values from an async operation through a  method/function, you can define your own callbacks in your method/function to use these values as they are returned from these operations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Here\u0026apos;s how for Java\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Start off by defining an interface :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Callback\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;myResponseCallback\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;YourReturnType result\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//whatever your return type is: string, integer, etc.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;next, change your method signature to be like this :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Callback callback)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make your method, which was previously returning something, return void, and add in the new callback interface.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;next up, wherever you previously wanted to use those values, add this line :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;callback\u0026lt;span class=\u0026quot;hljs-selector-class\u0026quot;\u0026gt;.myResponseCallback\u0026lt;/span\u0026gt;(yourResponseObject);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;as an example :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-typescript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;QuerySnapshot documentSnapshots\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create your object you want to return here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; bar = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;something\u0026quot;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    callback.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myResponseCallback\u0026lt;/span\u0026gt;(bar);\n})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;now, where you were previously calling your method called \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-typescript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Callback\u0026lt;/span\u0026gt;() {\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myResponseCallback\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;YourReturnType result\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//here, this result parameter that comes through is your api call result to use, so use this result right here to do any operation you previously wanted to do. \u0026lt;/span\u0026gt;\n        }\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How do you do this for Kotlin ?\u0026lt;/strong\u0026gt;\n(as a basic example where you only care for a single result)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;start off by changing your method signature to something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(callback:(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;YourReturnType\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Unit\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n.....\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;then, inside your asynchronous operation\u0026apos;s result :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;firestore.collection(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;something\u0026quot;\u0026lt;/span\u0026gt;)\n         .document(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;document\u0026quot;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;()\n         .addOnSuccessListener { \n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; bar = it.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;something\u0026quot;\u0026lt;/span\u0026gt;).toString()\n             callback(bar)\n         }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;then, where you would have previously called your method called \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, you now do this :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;() { result-\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// here, this result parameter that comes through is \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// whatever you passed to the callback in the code aboce, \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so use this result right here to do any operation \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you previously wanted to do. \u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Be aware that code outside the callback here will run\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BEFORE the code above, and cannot rely on any data that may\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// be set inside the callback.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;if your \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; method previously took in parameters :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(value:\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;SomeType\u0026lt;/span\u0026gt;, callback:(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;YourType\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Unit\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;you simply change it to :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;yourValueHere\u0026lt;/span\u0026gt;) { result -\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// here, this result parameter that comes through is \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// whatever you passed to the callback in the code aboce, \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so use this result right here to do any operation \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you previously wanted to do. \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;these solutions show how you can create a method/function to return values from async operations you\u0026apos;ve performed through the use of callbacks.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;However, it is important to understand that, should you not be interested in creating a method/function for these:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-typescript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;SomeApiObjectType someApiResult\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// here, this `onSuccess` callback provided by the api \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// already has the data you\u0026apos;re looking for (in this example, \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// that data would be `someApiResult`).\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you can simply add all your relevant code which would \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// be using this result inside this block here, this will \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// include any manipulation of data, populating adapters, etc. \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is the only place where you will have access to the\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// data returned by the api call, assuming your api follows\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this pattern\u0026lt;/span\u0026gt;\n})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There\u0026apos;s a particular pattern of this nature I\u0026apos;ve seen repeatedly, and I think an explanation of what\u0026apos;s happening would help. The pattern is a function/method that calls an API, assigning the result to a variable in the callback, and returns that variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following function/method always returns null, even if the result from the API is not null.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Kotlin\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: String? {\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myReturnValue: String? = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n   someApi.addOnSuccessListener { result -\u0026amp;gt;\n       myReturnValue = result.value\n   }.execute()\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; myReturnValue\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Kotlin coroutine\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: String? {\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myReturnValue: String? = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n   lifecycleScope.launch { \n       myReturnValue = someApiSuspendFunction()\n   }\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; myReturnValue\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Java 8\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fooValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    someApi.addOnSuccessListener(result -\u0026amp;gt; fooValue = result.getValue())\n        .execute();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fooValue;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Java 7\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fooValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    someApi.addOnSuccessListener(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;OnSuccessListener\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Result\u0026amp;lt;String\u0026amp;gt; result)\u0026lt;/span\u0026gt; {\n            fooValue = result.getValue();\n        }\n    }).execute();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fooValue;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The reason is that when you pass a callback or listener to an API function, that callback code will only be run some time in the future, when the API is done with its work. By passing the callback to the API function, you are \u0026lt;em\u0026gt;queuing\u0026lt;/em\u0026gt; up work, but the current function (\u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; in this case) returns immediately before that work begins and before that callback code is run.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Or in the case of the coroutine example above, the launched coroutine is very unlikely to complete before the function that started it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Your function that calls the API cannot return the result that is returned in the callback (unless it\u0026apos;s a Kotlin coroutine suspend function). The solution, explained in the other answer, is to make your own function take a callback parameter and not return anything.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, if you\u0026apos;re working with coroutines, you can make your function suspend instead of launching a separate coroutine. When you have suspend functions, somewhere in your code you must launch a coroutine and handle the results \u0026lt;em\u0026gt;within\u0026lt;/em\u0026gt; the coroutine. Typically, you would launch a coroutine in a lifecycle function like \u0026lt;code\u0026gt;onCreate()\u0026lt;/code\u0026gt;, or in a UI callback like in an OnClickListener.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Other answer explains how to consume APIs based on callbacks by exposing a similar callbacks-based API in the outer function. However, recently Kotlin coroutines become more and more popular, especially on Android and while using them, callbacks are generally discouraged for such purposes. Kotlin approach is to use suspend functions instead. Therefore, if our application uses coroutines already, I suggest not propagating callbacks APIs from 3rd party libraries to the rest of our code, but converting them to suspend functions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Converting callbacks to suspend\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s assume we have this callback API:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Service\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(callback: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Callback\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;\u0026amp;gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Callback\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;in T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(value: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onFailure\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(throwable: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Throwable\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We can convert it to suspend function using \u0026lt;a href=\u0026quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;suspendCoroutine()\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; service: Service\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: String {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; suspendCoroutine { cont -\u0026amp;gt;\n        service.getData(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; : Callback\u0026amp;lt;String\u0026amp;gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(value: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n                cont.resume(value)\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onFailure\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(throwable: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Throwable\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n                cont.resumeWithException(throwable)\n            }\n        })\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This way \u0026lt;code\u0026gt;getData()\u0026lt;/code\u0026gt; can return the data directly and synchronously, so other suspend functions can use it very easily:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;otherFunction\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; = getData()\n    println(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that we don\u0026apos;t have to use \u0026lt;code\u0026gt;withContext(Dispatchers.IO) { ... }\u0026lt;/code\u0026gt; here. We can even invoke \u0026lt;code\u0026gt;getData()\u0026lt;/code\u0026gt; from the main thread as long as we are inside the coroutine context (e.g. inside \u0026lt;code\u0026gt;Dispatchers.Main\u0026lt;/code\u0026gt;) - main thread won\u0026apos;t be blocked.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Cancellations\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If the callback service supports cancelling of background tasks then it is best to cancel when the calling coroutine is itself cancelled. Let\u0026apos;s add a cancelling feature to our callback API:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Service\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(callback: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Callback\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;\u0026amp;gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: Task\n}\n\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Task\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cancel\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, \u0026lt;code\u0026gt;Service.getData()\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;Task\u0026lt;/code\u0026gt; that we can use to cancel the operation. We can consume it almost the same as previously, but with small changes:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: String {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; suspendCancellableCoroutine { cont -\u0026amp;gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; task = service.getData(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; : Callback\u0026amp;lt;String\u0026amp;gt; {\n            ...\n        })\n\n        cont.invokeOnCancellation {\n            task.cancel()\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We only need to switch from \u0026lt;code\u0026gt;suspendCoroutine()\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;suspendCancellableCoroutine()\u0026lt;/code\u0026gt; and add \u0026lt;code\u0026gt;invokeOnCancellation()\u0026lt;/code\u0026gt; block.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example using Retrofit\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GitHubService\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@GET(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;users/{user}/repos\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;listRepos\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Path(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;user\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; user: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: Call\u0026amp;lt;List\u0026amp;lt;Repo\u0026amp;gt;\u0026amp;gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;listRepos\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(user: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: List\u0026amp;lt;Repo\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; retrofit = Retrofit.Builder()\n        .baseUrl(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;https://api.github.com/\u0026quot;\u0026lt;/span\u0026gt;)\n        .build()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; service = retrofit.create\u0026amp;lt;GitHubService\u0026amp;gt;()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; suspendCancellableCoroutine { cont -\u0026amp;gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; call = service.listRepos(user)\n\n        call.enqueue(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; : Callback\u0026amp;lt;List\u0026amp;lt;Repo\u0026amp;gt;\u0026amp;gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onResponse\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(call: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Call\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Repo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;, response: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Response\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Repo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (response.isSuccessful) {\n                    cont.resume(response.body()!!)\n                } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// just an example\u0026lt;/span\u0026gt;\n                    cont.resumeWithException(Exception(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Received error response: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${response.message()}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;))\n                }\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onFailure\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(call: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Call\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Repo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;, t: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Throwable\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n                cont.resumeWithException(t)\n            }\n        })\n\n        cont.invokeOnCancellation {\n            call.cancel()\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Native support\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Before we start converting callbacks to suspend functions, it is worth checking whether the library that we use does support suspend functions already: natively or with some extension. Many popular libraries like Retrofit or Firebase support coroutines and suspend functions. Usually, they either provide/handle suspend functions directly or they provide suspendable waiting on top of their asynchronous task/call/etc. object. Such waiting is very often named \u0026lt;code\u0026gt;await()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, Retrofit supports suspend functions directly since 2.6.0:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GitHubService\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@GET(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;users/{user}/repos\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;listRepos\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Path(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;user\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; user: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;: List\u0026amp;lt;Repo\u0026amp;gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that we not only added \u0026lt;code\u0026gt;suspend\u0026lt;/code\u0026gt;, but also we no longer return \u0026lt;code\u0026gt;Call\u0026lt;/code\u0026gt;, but the result directly. Now, we can use it without all this \u0026lt;code\u0026gt;enqueue()\u0026lt;/code\u0026gt; boilerplate:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; repos = service.listRepos(user)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TL;DR\u0026lt;/strong\u0026gt; The code you pass to these APIs (e.g. in the onSuccessListener) is a \u0026lt;strong\u0026gt;callback\u0026lt;/strong\u0026gt;, and it runs \u0026lt;em\u0026gt;asynchronously\u0026lt;/em\u0026gt; (not in the order it is written in your file). It runs at some point later in the future to \u0026quot;call back\u0026quot; into your code. Without using a coroutine to suspend the program, you cannot \u0026quot;return\u0026quot; data retrieved in a callback from a function.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;What is a callback?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;A callback is a piece of code you pass to some third party library that it will run later when some event happens (e.g. when it gets data from a server). It is important to remember that the callback is not run in the order you wrote it - it may be run much later in the future, could run multiple times, or may never run at all. The example callback below will run Point A, start the server fetching process, run Point C, exit the function, then some time in the distant future may run Point B when the data is retrieved. The printout at Point C will always be empty.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Point A\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    doc.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;().addOnSuccessListener { result -\u0026amp;gt;\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The code inside the {} here is the \u0026quot;callback\u0026quot;\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Point B - handle result\u0026lt;/span\u0026gt;\n       r = result \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// don\u0026apos;t do this!\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Point C - r=\u0026quot;\u0026quot; still here, point B hasn\u0026apos;t run yet\u0026lt;/span\u0026gt;\n    println(r)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;How do I get the data from the callback then?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Make your own interface/callback\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Making your own custom interface/callback can sometimes make things cleaner looking but it doesn\u0026apos;t really help with the core question of how to use the data outside the callback - it just moves the aysnc call to another location. It can help if the primary API call is somewhere else (e.g. in another class).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you made your own callback to use in the\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// async API\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResultImpl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(callback: (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Unit\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    doc.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;().addOnSuccessListener { result -\u0026amp;gt;\n        callback(result)\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but if you use it like this, you still have\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the EXACT same problem as before - the printout \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will always be empty\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    getResultImpl { result -\u0026amp;gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this part is STILL an async callback,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and runs later in the future\u0026lt;/span\u0026gt;\n        r = result\n    }\n    println(r) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// always empty here\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you still have to do things INSIDE the callback,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you could move getResultImpl to another class now,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but still have the same potential pitfalls as before\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    getResultImpl { result -\u0026amp;gt;\n        println(result)\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Some examples of how to properly use a custom callback\u0026lt;/em\u0026gt;: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/47847694/how-to-return-datasnapshot-value-as-a-result-of-a-method\u0026quot;\u0026gt;example 1\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/72334154/android-recyclerview-does-not-show-any-data/72334281#72334281\u0026quot;\u0026gt;example 2\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/57330767/9473786\u0026quot;\u0026gt;example 3\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Make the callback a suspend function\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another option is to turn the async method into a \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/69966845/9473786\u0026quot;\u0026gt;suspend function\u0026lt;/a\u0026gt; using coroutines so it can wait for the callback to complete. This lets you write linear-looking functions again.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;suspend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; result = suspendCoroutine { cont -\u0026amp;gt;\n        doc.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;().addOnSuccessListener { result -\u0026amp;gt;\n            cont.resume(result)\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the first line will suspend the coroutine and wait\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// until the async method returns a result. If the \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// callback could be called multiple times this may not\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// be the best pattern to use\u0026lt;/span\u0026gt;\n    println(result)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Re-arrange your program into smaller functions\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Instead of writing monolithic linear functions, break the work up into several functions and call them from within the callbacks. You should not try to modify local variables within the callback and return or use them after the callback (e.g. Point C). You have to move away from the idea of \u0026lt;em\u0026gt;returning data\u0026lt;/em\u0026gt; from a function when it comes from an async API - without a coroutine this generally isn\u0026apos;t possible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, you could handle the async data in a separate method (a \u0026quot;processing method\u0026quot;) and do as little as possible in the callback itself other than call the processing method with the received result. This helps avoid a lot of the common errors with async APIs where you attempt to modify local variables declared outside the callback scope or try to return things modified from within the callback. When you call \u0026lt;code\u0026gt;getResult\u0026lt;/code\u0026gt; it \u0026lt;em\u0026gt;starts\u0026lt;/em\u0026gt; the process of getting the data. When that process is complete (some time in the future) the callback calls \u0026lt;code\u0026gt;showResult\u0026lt;/code\u0026gt; to show it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n   doc.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;().addOnSuccessListener { result -\u0026amp;gt;\n      showResult(result)\n   }\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// don\u0026apos;t try to show or return the result here!\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;showResult\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(result: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    println(result)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Example\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;As a concrete example here is a minimal ViewModel showing how one could include an async API into a program flow to fetch data, process it, and display it in an Activity or Fragment. This is written in Kotlin but is equally applicable to Java.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MainViewModel\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ViewModel\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; textLiveData = MutableLiveData\u0026amp;lt;String\u0026amp;gt;()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; text: LiveData\u0026amp;lt;String\u0026amp;gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;() = textLiveData\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fetchData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use a coroutine here to make a dummy async call,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is where you could call Firestore or other API\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note that this method does not _return_ the requested data!\u0026lt;/span\u0026gt;\n        viewModelScope.launch {\n            delay(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3000\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pretend this is a slow network call, this part\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// won\u0026apos;t run until 3000 ms later\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; t = Calendar.getInstance().time\n            processData(t.toString())\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// anything out here will run immediately, it will not\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// wait for the \u0026quot;slow\u0026quot; code above to run first\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;processData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(d: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Once you get the data you may want to modify it before displaying it.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The time is \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$d\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n        textLiveData.postValue(p)\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A real API call in \u0026lt;code\u0026gt;fetchData()\u0026lt;/code\u0026gt; might look something more like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fetchData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n    firestoreDB.collection(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;data\u0026quot;\u0026lt;/span\u0026gt;)\n               .document(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;mydoc\u0026quot;\u0026lt;/span\u0026gt;)\n               .\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;()\n               .addOnCompleteListener { task -\u0026amp;gt;\n                   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (task.isSuccessful) {\n                       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; = task.result.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\n                       processData(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;time\u0026quot;\u0026lt;/span\u0026gt;])\n                   }\n                   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                       textLiveData.postValue(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ERROR\u0026quot;\u0026lt;/span\u0026gt;)\n                   }\n               }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The Activity or Fragment that goes along with this doesn\u0026apos;t need to know anything about these calls, it just passes actions in by calling methods on the ViewModel and observes the LiveData to update its views when new data is available. It cannot assume that the data is available immediately after a call to \u0026lt;code\u0026gt;fetchData()\u0026lt;/code\u0026gt;, but with this pattern it doesn\u0026apos;t need to.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The view layer can also do things like show and hide a progress bar while the data is being loaded so the user knows it\u0026apos;s working in the background.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MainActivity\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;AppCompatActivity\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onCreate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(savedInstanceState: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Bundle\u0026lt;/span\u0026gt;?)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.onCreate(savedInstanceState)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; model: MainViewModel \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;by\u0026lt;/span\u0026gt; viewModels()\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Observe the LiveData and when it changes, update the\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// state of the Views\u0026lt;/span\u0026gt;\n        model.text.observe(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;) { processedData -\u0026amp;gt;\n            binding.text.text = processedData \n            binding.progress.visibility = View.GONE\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// When the user clicks the button, pass that action to the\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ViewModel by calling \u0026quot;fetchData()\u0026quot;\u0026lt;/span\u0026gt;\n        binding.getText.setOnClickListener {\n            binding.progress.visibility = View.VISIBLE\n            model.fetchData()\n        }\n\n        binding.progress.visibility = View.GONE\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The ViewModel is not strictly necessary for this type of async workflow - here is an example of how to do the same thing in the activity\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MainActivity\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;AppCompatActivity\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lateinit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; binding: ActivityMainBinding\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;onCreate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(savedInstanceState: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Bundle\u0026lt;/span\u0026gt;?)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// When the user clicks the button, trigger the async\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// data call\u0026lt;/span\u0026gt;\n        binding.getText.setOnClickListener {\n            binding.progress.visibility = View.VISIBLE\n            fetchData()\n        }\n\n        binding.progress.visibility = View.GONE\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fetchData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        lifecycleScope.launch {\n            delay(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3000\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; t = Calendar.getInstance().time\n            processData(t.toString())\n        }\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;processData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(d: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {\n        binding.progress.visibility = View.GONE\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The time is \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$d\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n        binding.text.text = p\n    }\n}\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(and, for completeness, the activity XML)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?xml version=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1.0\u0026quot;\u0026lt;/span\u0026gt; encoding=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;utf-8\u0026quot;\u0026lt;/span\u0026gt;?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;androidx.constraintlayout.widget.ConstraintLayout\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;xmlns:android\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;xmlns:app\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;xmlns:tools\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://schemas.android.com/tools\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_width\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;match_parent\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_height\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;match_parent\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;tools:context\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.MainActivity\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;TextView\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;@+id/text\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_margin\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;16dp\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_width\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrap_content\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_height\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrap_content\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintLeft_toLeftOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintRight_toRightOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintTop_toTopOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;/\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;Button\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;@+id/get_text\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_width\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrap_content\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_height\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrap_content\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_margin\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;16dp\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:text\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Get Text\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintLeft_toLeftOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintRight_toRightOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintTop_toBottomOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;@+id/text\u0026quot;\u0026lt;/span\u0026gt;\n        /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ProgressBar\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;@+id/progress\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_width\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;match_parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:layout_height\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrap_content\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;android:padding\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;48dp\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintLeft_toLeftOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintRight_toRightOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;parent\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;app:layout_constraintTop_toBottomOf\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;@+id/get_text\u0026quot;\u0026lt;/span\u0026gt;\n        /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;androidx.constraintlayout.widget.ConstraintLayout\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":583,"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","content":"\n                \n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;(Disclaimer: There are a ton of questions which arise from people asking about data being null/incorrect when using asynchronous operations through requests such as facebook,firebase, etc. My intention for this question was to provide a simple answer for that problem to everyone starting out with asynchronous operations in android)\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;m trying to get data from one of my operations, when I debug it using breakpoints or logs, the values are there, but when I run it they are always null, how can I solve this ?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Firebase\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;firebaseFirestore.collection(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;some collection\u0026quot;\u0026lt;/span\u0026gt;).get()\n    .addOnSuccessListener(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;OnSuccessListener\u0026lt;/span\u0026gt;\u0026amp;lt;QuerySnapshot\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onSuccess\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(QuerySnapshot documentSnapshots)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//I want to return these values I receive here... \u0026lt;/span\u0026gt;\n        });\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...and use the returned value here.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Facebook\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;GraphRequest\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;request\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; GraphRequest.newGraphPathRequest(\n    accessToken,\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;some path\u0026quot;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;GraphRequest\u0026lt;/span\u0026gt;.Callback() {\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onCompleted\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(GraphResponse response)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//I want to return these values I receive here...\u0026lt;/span\u0026gt;\n        }\n    });\nrequest.executeAsync();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...and use the returned value here.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Kotlin coroutine\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-kotlin s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result: SomeResultType? = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\nsomeScope.launch {\n    result = someSuspendFunctionToRetrieveSomething()\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//I want to return the value I received here... \u0026lt;/span\u0026gt;\n}\nLog.d(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;result\u0026quot;\u0026lt;/span\u0026gt;, result.toString()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...but it is still null here.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Etc.\u0026lt;/p\u0026gt;\n    ","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820","postType":"QUESTION","createdAt":"2022-07-09T17:41:23.000Z","updatedAt":"2022-07-09T17:41:23.000Z","tags":[{"id":2785,"name":"google-cloud-firestore","slug":"google-cloud-firestore","createdAt":"2022-07-09T17:41:23.000Z","updatedAt":"2022-07-09T17:41:23.000Z","Questions_Tags":{"questionId":583,"tagId":2785}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>