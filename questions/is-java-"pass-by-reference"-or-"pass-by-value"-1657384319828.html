<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I always thought Java uses pass-by-reference.
However, I&#x27;ve seen a blog post that claims that Java uses pass-by-value.
I don&#x27;t think I understand the distinction they&#x27;re making.
What is the explanation?
    "/><meta property="og:title" content="Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;? | Solutions Checker"/><meta property="og:description" content="I always thought Java uses pass-by-reference.
However, I&#x27;ve seen a blog post that claims that Java uses pass-by-value.
I don&#x27;t think I understand the distinction they&#x27;re making.
What is the explanation?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;?","text":"I always thought Java uses pass-by-reference.\nHowever, I&apos;ve seen a blog post that claims that Java uses pass-by-value.\nI don&apos;t think I understand the distinction they&apos;re making.\nWhat is the explanation?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Java is always pass-by-value.  Unfortunately, when we deal with objects we are really dealing with object-handles called references which are passed-by-value as well.  This terminology and semantics easily confuse many beginners.\nIt goes like this:\npublic static void main(String[] args) {\n    Dog aDog = new Dog(&quot;Max&quot;);\n    Dog oldDog = aDog;\n\n    // we pass the object to foo\n    foo(aDog);\n    // aDog variable is still pointing to the &quot;Max&quot; dog when foo(...) returns\n    aDog.getName().equals(&quot;Max&quot;); // true\n    aDog.getName().equals(&quot;Fifi&quot;); // false\n    aDog == oldDog; // true\n}\n\npublic static void foo(Dog d) {\n    d.getName().equals(&quot;Max&quot;); // true\n    // change d inside of foo() to point to a new Dog instance &quot;Fifi&quot;\n    d = new Dog(&quot;Fifi&quot;);\n    d.getName().equals(&quot;Fifi&quot;); // true\n}\n\nIn the example above aDog.getName() will still return &quot;Max&quot;. The value aDog within main is not changed in the function foo with the Dog &quot;Fifi&quot; as the object reference is passed by value. If it were passed by reference, then the aDog.getName() in main would return &quot;Fifi&quot; after the call to foo.\nLikewise:\npublic static void main(String[] args) {\n    Dog aDog = new Dog(&quot;Max&quot;);\n    Dog oldDog = aDog;\n\n    foo(aDog);\n    // when foo(...) returns, the name of the dog has been changed to &quot;Fifi&quot;\n    aDog.getName().equals(&quot;Fifi&quot;); // true\n    // but it is still the same dog:\n    aDog == oldDog; // true\n}\n\npublic static void foo(Dog d) {\n    d.getName().equals(&quot;Max&quot;); // true\n    // this changes the name of d to be &quot;Fifi&quot;\n    d.setName(&quot;Fifi&quot;);\n}\n\nIn the above example, Fifi is the dog&apos;s name after call to foo(aDog) because the object&apos;s name was set inside of foo(...). Any operations that foo performs on d are such that, for all practical purposes, they are performed on aDog, but it is not possible to change the value of the variable aDog itself.\nFor more information on pass by reference and pass by value, consult the following SO answer: https://stackoverflow.com/a/430958/6005228. This explains more thoroughly the semantics and history behind the two and also explains why Java and many other modern languages appear to do both in certain cases.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"I just noticed you referenced my article.\nThe Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.\nThe key to understanding this is that something like\nDog myDog;\n\nis not a Dog; it&apos;s actually a pointer to a Dog. The use of the term &quot;reference&quot; in Java is very misleading and is what causes most of the confusion here. What they call &quot;references&quot; act/feel more like what we&apos;d call &quot;pointers&quot; in most other languages.\nWhat that means, is when you have\nDog myDog = new Dog(&quot;Rover&quot;);\nfoo(myDog);\n\nyou&apos;re essentially passing the address of the created Dog object to the foo method.\n(I say essentially because Java pointers/references aren&apos;t direct addresses, but it&apos;s easiest to think of them that way.)\nSuppose the Dog object resides at memory address 42. This means we pass 42 to the method.\nif the Method were defined as\npublic void foo(Dog someDog) {\n    someDog.setName(&quot;Max&quot;);     // AAA\n    someDog = new Dog(&quot;Fifi&quot;);  // BBB\n    someDog.setName(&quot;Rowlf&quot;);   // CCC\n}\n\nlet&apos;s look at what&apos;s happening.\n\nthe parameter someDog is set to the value 42\nat line &quot;AAA&quot;\n\nsomeDog is followed to the Dog it points to (the Dog object at address 42)\nthat Dog (the one at address 42) is asked to change his name to Max\n\n\nat line &quot;BBB&quot;\n\na new Dog is created. Let&apos;s say he&apos;s at address 74\nwe assign the parameter someDog to 74\n\n\nat line &quot;CCC&quot;\n\nsomeDog is followed to the Dog it points to (the Dog object at address 74)\nthat Dog (the one at address 74) is asked to change his name to Rowlf\n\n\nthen, we return\n\nNow let&apos;s think about what happens outside the method:\nDid myDog change?\nThere&apos;s the key.\nKeeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO. myDog still has the value 42; it&apos;s still pointing to the original Dog (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; myDog&apos;s value has not changed.)\nIt&apos;s perfectly valid to follow an address and change what&apos;s at the end of it; that does not change the variable, however.\nJava works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, the caller will not see any changes you make to where that pointer points. (In a language with pass-by-reference semantics, the method function can change the pointer and the caller will see that change.)\nIn C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.\nIf Java had pass-by-reference semantics, the foo method we defined above would have changed where myDog was pointing when it assigned someDog on line BBB.\nThink of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Java always passes arguments by value, NOT by reference.\n\nLet me explain this through an example:\npublic class Main {\n\n     public static void main(String[] args) {\n          Foo f = new Foo(&quot;f&quot;);\n          changeReference(f); // It won&apos;t change the reference!\n          modifyReference(f); // It will modify the object that the reference variable &quot;f&quot; refers to!\n     }\n\n     public static void changeReference(Foo a) {\n          Foo b = new Foo(&quot;b&quot;);\n          a = b;\n     }\n\n     public static void modifyReference(Foo c) {\n          c.setAttribute(&quot;c&quot;);\n     }\n\n}\n\nI will explain this in steps:\n\nDeclaring a reference named f of type Foo and assign it a new object of type Foo with an attribute &quot;f&quot;.\nFoo f = new Foo(&quot;f&quot;);\n\n\n\nFrom the method side, a reference of type Foo with a name a is declared and it&apos;s initially assigned null.\npublic static void changeReference(Foo a)\n\n\n\nAs you call the method changeReference, the reference a will be assigned the object which is passed as an argument.\nchangeReference(f);\n\n\n\nDeclaring a reference named b of type Foo and assign it a new object of type Foo with an attribute &quot;b&quot;.\nFoo b = new Foo(&quot;b&quot;);\n\n\n\na = b makes a new assignment to the reference a, not f, of the object whose attribute is &quot;b&quot;.\n\n\nAs you call modifyReference(Foo c) method, a reference c is created and assigned the object with attribute &quot;f&quot;.\n\n\nc.setAttribute(&quot;c&quot;); will change the attribute of the object that reference c points to it, and it&apos;s the same object that reference f points to it.\n\n\n\nI hope you understand now how passing objects as arguments works in Java :)\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Java is always pass by value, with no exceptions, ever.\n\nSo how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java never provides direct access to the values of objects themselves, in any circumstances. The only access to objects is through a reference to that object. Because Java objects are always accessed through a reference, rather than directly, it is common to talk about fields and variables and method arguments as being objects, when pedantically they are only references to objects. The confusion stems from this (strictly speaking, incorrect) change in nomenclature.\n\nSo, when calling a method\n\n\nFor primitive arguments (int, long, etc.), the pass by value is the actual value of the primitive (for example, 3).\nFor objects, the pass by value is the value of the reference to the object.\n\n\nSo if you have doSomething(foo) and public void doSomething(Foo foo) { .. } the two Foos have copied references that point to the same objects.\n\nNaturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you&apos;ll just smile :-)\n\nStep one please erase from your mind that word that starts with &apos;p&apos; &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and &apos;p&apos; cannot be written in the same book, forum, or even txt.\n\nStep two remember that when you pass an Object into a method you&apos;re passing the Object reference and not the Object itself.\n\n\nStudent: Master, does this mean that Java is pass-by-reference?\nMaster: Grasshopper, No.\n\n\nNow think of what an Object&apos;s reference/variable does/is:\n\n\nA variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).\nWhen passing arguments to a method you ARE NOT passing the reference variable, but a copy of the bits in the reference variable. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.\nSo you&apos;re just passing 3bad086a that it&apos;s the value of the reference.\nYou&apos;re passing the value of the reference and not the reference itself (and not the object).\nThis value is actually COPIED and given to the method. \n\n\nIn the following (please don&apos;t try to compile/execute this...):\n\n1. Person person;\n2. person = new Person(&quot;Tom&quot;);\n3. changeName(person);\n4.\n5. //I didn&apos;t use Person person below as an argument to be nice\n6. static void changeName(Person anotherReferenceToTheSamePersonObject) {\n7.     anotherReferenceToTheSamePersonObject.setName(&quot;Jerry&quot;);\n8. }\n\n\nWhat happens?\n\n\nThe variable person is created in line #1 and it&apos;s null at the beginning.\nA new Person Object is created in line #2, stored in memory, and the variable person is given the reference to the Person object. That is, its address. Let&apos;s say 3bad086a.\nThe variable person holding the address of the Object is passed to the function in line #3.\nIn line #4 you can listen to the sound of silence \nCheck the comment on line #5\nA method local variable -anotherReferenceToTheSamePersonObject- is created and then comes the magic in line #6:\n\n\nThe variable/reference person is copied bit-by-bit and passed to anotherReferenceToTheSamePersonObject inside the function.\nNo new instances of Person are created.\nBoth &quot;person&quot; and &quot;anotherReferenceToTheSamePersonObject&quot; hold the same value of 3bad086a.\nDon&apos;t try this but person==anotherReferenceToTheSamePersonObject would be true.\nBoth variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.\n\n\n\nA picture is worth a thousand words:\n\n\n\nNote that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!\n\nIf you didn&apos;t get it then just trust me and remember that it&apos;s better to say that Java is pass by value. Well, pass by reference value. Oh well, even better is pass-by-copy-of-the-variable-value! ;)\n\nNow feel free to hate me but note that given this there is no difference between passing primitive data types and Objects when talking about method arguments.\n\nYou always pass a copy of the bits of the value of the reference!\n\n\nIf it&apos;s a primitive data type these bits will contain the value of the primitive data type itself.\nIf it&apos;s an Object the bits will contain the value of the address that tells the JVM how to get to the Object.\n\n\n\n  Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you&apos;ll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!\n\n\n\n\n\n  The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.\n\n\n\n\nOf course you can cut it short and just say that  Java is pass-by-value!\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Java passes references by value.\n\nSo you can&apos;t change the reference that gets passed in.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.\n\nIf you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you&apos;re not provide a complete answer. Here&apos;s some additional information that will hopefully aid in understanding what&apos;s happening in memory.\n\nCrash course on stack/heap before we get to the Java implementation:\nValues go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.\nMemory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.\n\nOkay. First off, local primitives go on the stack. So this code:\n\nint x = 3;\nfloat y = 101.1f;\nboolean amIAwesome = true;\n\n\nresults in this:\n\n\n\nWhen you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.\n\nLike so:\n\nint problems = 99;\nString name = &quot;Jay-Z&quot;;\n\n\n\n\nAn array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.\n\nJButton[] marxBros = new JButton[3];\nmarxBros[0] = new JButton(&quot;Groucho&quot;);\nmarxBros[1] = new JButton(&quot;Zeppo&quot;);\nmarxBros[2] = new JButton(&quot;Harpo&quot;);\n\n\n\n\nSo, what gets passed in when you call a method? If you pass in an object, what you&apos;re actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it&apos;s just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn&apos;t as important as that you understand that what&apos;s getting passed in is the address to the object.\n\nprivate static void shout(String name){\n    System.out.println(&quot;There goes &quot; + name + &quot;!&quot;);\n}\n\npublic static void main(String[] args){\n    String hisName = &quot;John J. Jingleheimerschmitz&quot;;\n    String myName = hisName;\n    shout(myName);\n}\n\n\nOne String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier hisName, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call shout(): a new stack frame is created and a new identifier, name is created and assigned the address of the already-existing String.\n\n\n\nSo, value, reference? You say &quot;potato&quot;.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Basically, reassigning Object parameters doesn&apos;t affect the argument, e.g.,\nprivate static void foo(Object bar) {\n    bar = null;\n}\n\npublic static void main(String[] args) {\n    String baz = &quot;Hah!&quot;;\n    foo(baz);\n    System.out.println(baz);\n}\n\nwill print out &quot;Hah!&quot; instead of null. The reason this works is because bar is a copy of the value of baz, which is just a reference to &quot;Hah!&quot;. If it were the actual reference itself, then foo would have redefined baz to null.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Just to show the contrast, compare the following C++ and Java snippets:\n\nIn C++: Note: Bad code - memory leaks!  But it demonstrates the point.\n\nvoid cppMethod(int val, int &amp;ref, Dog obj, Dog &amp;objRef, Dog *objPtr, Dog *&amp;objPtrRef)\n{\n    val = 7; // Modifies the copy\n    ref = 7; // Modifies the original variable\n    obj.SetName(&quot;obj&quot;); // Modifies the copy of Dog passed\n    objRef.SetName(&quot;objRef&quot;); // Modifies the original Dog passed\n    objPtr-&gt;SetName(&quot;objPtr&quot;); // Modifies the original Dog pointed to \n                               // by the copy of the pointer passed.\n    objPtr = new Dog(&quot;newObjPtr&quot;);  // Modifies the copy of the pointer, \n                                   // leaving the original object alone.\n    objPtrRef-&gt;SetName(&quot;objRefPtr&quot;); // Modifies the original Dog pointed to \n                                    // by the original pointer passed. \n    objPtrRef = new Dog(&quot;newObjPtrRef&quot;); // Modifies the original pointer passed\n}\n\nint main()\n{\n    int a = 0;\n    int b = 0;\n    Dog d0 = Dog(&quot;d0&quot;);\n    Dog d1 = Dog(&quot;d1&quot;);\n    Dog *d2 = new Dog(&quot;d2&quot;);\n    Dog *d3 = new Dog(&quot;d3&quot;);\n    cppMethod(a, b, d0, d1, d2, d3);\n    // a is still set to 0\n    // b is now set to 7\n    // d0 still have name &quot;d0&quot;\n    // d1 now has name &quot;objRef&quot;\n    // d2 now has name &quot;objPtr&quot;\n    // d3 now has name &quot;newObjPtrRef&quot;\n}\n\n\nIn Java, \n\npublic static void javaMethod(int val, Dog objPtr)\n{\n   val = 7; // Modifies the copy\n   objPtr.SetName(&quot;objPtr&quot;) // Modifies the original Dog pointed to \n                            // by the copy of the pointer passed.\n   objPtr = new Dog(&quot;newObjPtr&quot;);  // Modifies the copy of the pointer, \n                                  // leaving the original object alone.\n}\n\npublic static void main()\n{\n    int a = 0;\n    Dog d0 = new Dog(&quot;d0&quot;);\n    javaMethod(a, d0);\n    // a is still set to 0\n    // d0 now has name &quot;objPtr&quot;\n}\n\n\nJava only has the two types of passing: by value for built-in types, and by value of the pointer for object types.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Java passes references to objects by value.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"I can&apos;t believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term call by sharing (also known as call by object-sharing and call by object) for this specific case of &quot;call by value where the value is a reference&quot;.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"The crux of the matter is that the word reference in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word reference in Java. \n\nUsually in Java reference means a a reference to an object. But the technical terms pass by reference/value from programming language theory is talking about a reference to the memory cell holding the variable, which is something completely different.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"In java everything is reference, so when you have something like:\n    Point pnt1 = new Point(0,0); Java does following:\n\n\nCreates new Point object\nCreates new Point reference and initialize that reference to point (refer to) on previously created Point object.\nFrom here, through Point object life, you will access to that object through pnt1\n reference. So we can say that in Java you manipulate object through its reference.\n\n\n\n\nJava doesn&apos;t pass method arguments by reference; it passes them by value. I will use example from this site: \n\npublic static void tricky(Point arg1, Point arg2) {\n  arg1.x = 100;\n  arg1.y = 100;\n  Point temp = arg1;\n  arg1 = arg2;\n  arg2 = temp;\n}\npublic static void main(String [] args) {\n  Point pnt1 = new Point(0,0);\n  Point pnt2 = new Point(0,0);\n  System.out.println(&quot;X1: &quot; + pnt1.x + &quot; Y1: &quot; +pnt1.y); \n  System.out.println(&quot;X2: &quot; + pnt2.x + &quot; Y2: &quot; +pnt2.y);\n  System.out.println(&quot; &quot;);\n  tricky(pnt1,pnt2);\n  System.out.println(&quot;X1: &quot; + pnt1.x + &quot; Y1:&quot; + pnt1.y); \n  System.out.println(&quot;X2: &quot; + pnt2.x + &quot; Y2: &quot; +pnt2.y);  \n}\n\n\nFlow of the program:\n\nPoint pnt1 = new Point(0,0);\nPoint pnt2 = new Point(0,0);\n\n\nCreating two different Point object with two different reference associated.\n\n\nSystem.out.println(&quot;X1: &quot; + pnt1.x + &quot; Y1: &quot; +pnt1.y); \nSystem.out.println(&quot;X2: &quot; + pnt2.x + &quot; Y2: &quot; +pnt2.y);\nSystem.out.println(&quot; &quot;);\n\n\nAs expected output will be:\n\nX1: 0     Y1: 0\nX2: 0     Y2: 0\n\n\nOn this line &apos;pass-by-value&apos; goes into the play... \n\ntricky(pnt1,pnt2);           public void tricky(Point arg1, Point arg2);\n\n\nReferences pnt1 and pnt2 are passed by value to the tricky method, which means that now yours references pnt1 and pnt2 have their copies named arg1 and arg2.So pnt1 and arg1 points to the same object. (Same for the pnt2 and arg2)\n\n\nIn the tricky method:\n\n arg1.x = 100;\n arg1.y = 100;\n\n\n\n\nNext in the tricky method\n\nPoint temp = arg1;\narg1 = arg2;\narg2 = temp;\n\n\nHere, you first create new temp Point reference which will point on same place like arg1 reference. Then you move reference arg1 to point to the same place like arg2 reference.\nFinally arg2 will point to the same place like temp.\n\n\n\nFrom here scope of tricky method is gone and you don&apos;t have access any more to the references: arg1, arg2, temp. But important note is that everything you do with these references when they are &apos;in life&apos; will permanently affect object on which they are point to. \n\nSo after executing method tricky, when you return to main, you have this situation:\n\n\nSo now, completely execution of program will be:\n\nX1: 0         Y1: 0\nX2: 0         Y2: 0\nX1: 100       Y1: 100\nX2: 0         Y2: 0\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Java is always pass by value, not pass by reference\nFirst of all, we need to understand what pass by value and pass by reference are.\nPass by value means that you are making a copy in memory of the actual parameter&apos;s value that is passed in. This is a copy of the contents of the actual parameter.\nPass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored.\nSometimes Java can give the illusion of pass by reference. Let&apos;s see how it works by using the example below:\npublic class PassByValue {\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.name = &quot;initialvalue&quot;;\n        new PassByValue().changeValue(t);\n        System.out.println(t.name);\n    }\n    \n    public void changeValue(Test f) {\n        f.name = &quot;changevalue&quot;;\n    }\n}\n\nclass Test {\n    String name;\n}\n\nThe output of this program is:\n\nchangevalue\n\n\nLet&apos;s understand step by step:\nTest t = new Test();\n\nAs we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is 0x100234 (we don&apos;t know the actual JVM internal value, this is just an example) .\n\nnew PassByValue().changeValue(t);\n\nWhen passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is passing by value, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was 0x100234, both t and f will have the same value and hence they will point to the same object.\n\nIf you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output changevalue,   which is updated in the function.\nTo understand this more clearly, consider the following example:\npublic class PassByValue {\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.name = &quot;initialvalue&quot;;\n        new PassByValue().changeRefence(t);\n        System.out.println(t.name);\n    }\n    \n    public void changeRefence(Test f) {\n        f = null;\n    }\n}\n\nclass Test {\n    String name;\n}\n\nWill this throw a NullPointerException? No, because it only passes a copy of the reference.\nIn the case of passing by reference, it could have thrown a NullPointerException, as seen below:\n\nHopefully this will help.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"There are already great answers that cover this. I wanted to make a small contribution by sharing a very simple example (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.\n\nA few points:\n\n\nThe term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.\nJava is Pass-by-value. Java is a descendent of C (among other languages). Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. PBR allowed these other languages to make changes to the passed variables inside sub-routines. In order to accomplish the same thing (i.e. change the values of variables inside functions), C programmers passed pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to pass pointer to methods as C did, except that Java calls its pointers References. Again, this is a different use of the word &quot;Reference&quot; than in &quot;Pass-By-Reference&quot;.\nC++ allows Pass-by-reference by declaring a reference parameter using the &quot;&amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.\nIn the C++ example below I&apos;m passing a pointer to a null terminated string by reference. And in the Java example below I&apos;m passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.\n\n\nC++ pass by reference example:\n\nusing namespace std;\n#include &lt;iostream&gt;\n\nvoid change (char *&amp;str){   // the &apos;&amp;&apos; makes this a reference parameter\n    str = NULL;\n}\n\nint main()\n{\n    char *str = &quot;not Null&quot;;\n    change(str);\n    cout&lt;&lt;&quot;str is &quot; &lt;&lt; str;      // ==&gt;str is &lt;null&gt;\n}\n\n\nJava pass &quot;a Java reference&quot; by value example\n\npublic class ValueDemo{\n\n    public void change (String str){\n        str = null;\n    }\n\n     public static void main(String []args){\n        ValueDemo vd = new ValueDemo();\n        String str = &quot;not null&quot;;\n        vd.change(str);\n        System.out.println(&quot;str is &quot; + str);    // ==&gt; str is not null!!\n                                                // Note that if &quot;str&quot; was\n                                                // passed-by-reference, it\n                                                // WOULD BE NULL after the\n                                                // call to change().\n     }\n}\n\n\nEDIT\n\nSeveral people have written comments which seem to indicate that either they are not looking at my examples or they don&apos;t get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I&apos;m posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.\n\nIn pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword &apos;var&apos; which precedes the parameter &apos;ptr&apos;. When a pointer is passed to this procedure, it will be passed by reference. Note the behavior: when this procedure sets ptr to nil (that&apos;s pascal speak for NULL), it will set the argument to nil--you can&apos;t do that in Java.\n\nprogram passByRefDemo;\ntype \n   iptr = ^integer;\nvar\n   ptr: iptr;\n\n   procedure setToNil(var ptr : iptr);\n   begin\n       ptr := nil;\n   end;\n\nbegin\n   new(ptr);\n   ptr^ := 10;\n   setToNil(ptr);\n   if (ptr = nil) then\n       writeln(&apos;ptr seems to be nil&apos;);     { ptr should be nil, so this line will run. }\nend.\n\n\nEDIT 2\n\nSome excerpts from &quot;THE Java Programming Language&quot; by Ken Arnold, James Gosling (the guy who invented Java), and David Holmes, chapter 2, section 2.6.5\n\n\n  All parameters to methods are passed &quot;by value&quot;. In other words,\n  values of parameter variables in a method are copies of the invoker\n  specified as arguments.\n\n\nHe goes on to make the same point regarding objects . . . \n\n\n  You should note that when the parameter is an object reference, it is\n  the object reference-not the object itself-that is passed &quot;by value&quot;.\n\n\nAnd towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.\n\n\n  The Java programming language does not pass objects by reference; it\n  passes object references by value. Because two copies of the same\n  reference refer to the same actual object, changes made through one\n  reference variable are visible through the other. There is exactly one\n  parameter passing mode-pass by value-and that helps keep things\n  simple.\n\n\nThis section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it&apos;s by the creator of Java. I would encourage anyone to read it, especially if you&apos;re still not convinced.\n\nI think the difference between the two models is very subtle and unless you&apos;ve done programming where you actually used pass-by-reference, it&apos;s easy to miss where two models differ.\n\nI hope this settles the debate, but probably won&apos;t.\n\nEDIT 3\n\nI might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say \ndingleberry, there would&apos;ve been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused.\n\nThat&apos;s the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don&apos;t even bother to consider the opposing argument.\n\nAnyway, I noticed a comment in an older post, which made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.\n\nPassing a reference by value--Changes to the reference are not reflected in the caller&apos;s scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.\n\n\nPass by reference--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object&apos;s data are reflected in the caller&apos;s scope.\n\n\nEDIT 4\n\nI have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about the behavior described in the language specification than about the technical implementation of the behavior. This is an exerpt from the Java Language Specification, section 8.4.1 :\n\n\n  When the method or constructor is invoked (ยง15.12), the values of the\n  actual argument expressions initialize newly created parameter\n  variables, each of the declared type, before execution of the body of\n  the method or constructor. The Identifier that appears in the\n  DeclaratorId may be used as a simple name in the body of the method or\n  constructor to refer to the formal parameter.\n\n\nWhich means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &quot;The Dragon Book&quot; which is THE compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.\n\nBack when I studied compilers-in the 90&apos;s, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the 2nd Eddition from 2007 which actually mentions Java! Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:\n\n\n  In call-by-value, the actual parameter is evaluated (if it is an\n  expression) or copied (if it is a variable). The value is placed in\n  the location belonging to the corresponding formal parameter of the\n  called procedure. This method is used in C and Java, and is a common\n  option in C++ , as well as in most other languages.\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Java is a pass by value(stack memory)\nHow it works\n\nLet&apos;s first understand that where java stores primitive data type and object data type.\n\nPrimitive data types itself and object references are stored in the stack.\nObjects themselves are stored in the heap.\n\nIt means, Stack memory stores primitive data types and also the\naddresses of objects.\n\nAnd you always pass a copy of the bits of the value of the reference.\n\nIf it&apos;s a primitive data type then these copied bits contain the value of the primitive data type itself, That&apos;s why when we change the value of argument inside the method then it does not reflect the changes outside.\n\nIf it&apos;s an object data type like Foo foo=new Foo() then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file abc.txt at C:\\desktop and suppose we make shortcut of the same file and put this inside C:\\desktop\\abc-shortcut so when you access the file from C:\\desktop\\abc.txt and write &apos;Stack Overflow&apos; and close the file and again you open the file from shortcut then you write &apos; is the largest online community for programmers to learn&apos; then total file change will be &apos;Stack Overflow is the largest online community for programmers to learn&apos; which means it doesn&apos;t matter from where you open the file , each time we were accessing the same file , here we can assume Foo as a file and suppose foo stored at 123hd7h(original address like C:\\desktop\\abc.txt ) address and 234jdid(copied address like C:\\desktop\\abc-shortcut which actually contains the original address of the file inside) ..\nSo for better understanding make shortcut file and feel.\n\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"A reference is always a value when represented, no matter what language you use.\n\nGetting an outside of the box view, let&apos;s look at Assembly or some low level memory management. At the CPU level a reference to anything immediately becomes a value if it gets written to memory or to one of the CPU registers. (That is why pointer is a good definition. It is a value, which has a purpose at the same time).\n\nData in memory has a Location and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a Name to certain Location (aka variable), but when compiling the code, the assembler simply replaces Name with the designated location just like your browser replaces domain names with IP addresses.\n\nDown to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).\n\nLets say we have a variable Foo, its Location is at the 47th byte in memory and its Value is 5. We have another variable Ref2Foo which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two Values.\nIf you use them as references then to reach to 5 we have to travel:\n\n(Name)[Location] -&gt; [Value at the Location]\n---------------------\n(Ref2Foo)[223]  -&gt; 47\n(Foo)[47]       -&gt; 5\n\n\nThis is how jump-tables work. \n\nIf we want to call a method/function/procedure with Foo&apos;s value, there are a few possible way to pass the variable to the method, depending on the language and its several method invocation modes:\n\n\n5 gets copied to one of the CPU registers (ie. EAX).\n5 gets PUSHd to the stack.\n47 gets copied to one of the CPU registers\n47 PUSHd to the stack.\n223 gets copied to one of the CPU registers.\n223 gets PUSHd to the stack.\n\n\nIn every cases above a value - a copy of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  dereferenced, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a reference is a value when represented, because a reference is a value that has to be processed (at language level).\n\nNow we have passed Foo to the method:\n\n\nin case 1. and 2. if you change Foo (Foo = 9) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.\nin case 3. and 4. if you use default language constructs and change Foo (Foo = 11), it could change Foo globally (depends on the language, ie. Java or like Pascal&apos;s procedure findMin(x, y, z: integer;var m: integer);). However if the language allows you to circumvent the dereference process, you can change 47, say to 49. At that point Foo seems to have been changed if you read it, because you have changed the local pointer to it. And if you were to modify this Foo inside the method (Foo = 12) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at 47). BUT Foo&apos;s value of 47 did not change globally, only the one inside the method, because 47 was also a copy to the method.\nin case 5. and 6. if you modify 223 inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was copied. However if you are able to dereference Ref2Foo (that is 223), reach to and modify the pointed value 47, say, to 49, it will affect Foo globally, because in this case the methods got a copy of 223  but the referenced 47 exists only once, and changing that to 49 will lead every Ref2Foo double-dereferencing to a wrong value.\n\n\nNitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only pass-by-reference.\n\nStrict pass-by-value is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller&apos;s view) and a few languages allows to modify the Value of the reference itself.\n\nSo in short and in Java&apos;s own terminology, Java is pass-by-value where value can be: either a real value or a value that is a representation of a reference. \n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"In Java, method arguments are all passed by value :\nJava arguments are all passed by value (the value  or reference is copied when used by the method) :\nIn the case of primitive types, Java behaviour is simple:\nThe value is copied in another instance of the primitive type.\nIn case of Objects, this is the same:\nObject variables are references (mem buckets holding only Objects address instead of a primitive value) that was created using the &quot;new&quot; keyword, and are copied like primitive types.\nThe behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).\nObject&apos;s content/members might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.\n&quot;String&quot; Objects appear to be a good counter-example to the urban legend saying that &quot;Objects are passed by reference&quot;:\nIn effect, using a method, you will never be able, to update the value of a String passed as argument:\nA String Object, holds characters by an array declared final that can&apos;t be modified.\nOnly the address of the Object might be replaced by another using &quot;new&quot;.\nUsing &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:\n\npublic static void swap(StringBuffer s1, StringBuffer s2) {\n    StringBuffer temp = s1;\n    s1 = s2;\n    s2 = temp;\n}\n\n\npublic static void main(String[] args) {\n    StringBuffer s1 = new StringBuffer(&quot;Hello&quot;);\n    StringBuffer s2 = new StringBuffer(&quot;World&quot;);\n    swap(s1, s2);\n    System.out.println(s1);\n    System.out.println(s2);\n}\n\n\nThis will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:\n\npublic static void appendWorld(StringBuffer s1) {\n    s1.append(&quot; World&quot;);\n}\n\npublic static void main(String[] args) {\n    StringBuffer s = new StringBuffer(&quot;Hello&quot;);\n    appendWorld(s);\n    System.out.println(s);\n}\n\n\nThis will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:\n\npublic static void appendWorld(String s){\n    s = s+&quot; World&quot;;\n}\n\npublic static void main(String[] args) {\n    String s = new String(&quot;Hello&quot;);\n    appendWorld(s);\n    System.out.println(s);\n}\n\n\nHowever you could make a wrapper for String like this which would make it able to use it with Strings:\n\nclass StringWrapper {\n    public String value;\n\n    public StringWrapper(String value) {\n        this.value = value;\n    }\n}\n\npublic static void appendWorld(StringWrapper s){\n    s.value = s.value +&quot; World&quot;;\n}\n\npublic static void main(String[] args) {\n    StringWrapper s = new StringWrapper(&quot;Hello&quot;);\n    appendWorld(s);\n    System.out.println(s.value);\n}\n\n\nedit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can&apos;t with immutable objects like String is.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"No, it&apos;s not pass by reference.\n\nJava is pass by value according to the Java Language Specification:\n\n\n  When the method or constructor is invoked (ยง15.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the formal parameter. \n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference\n\n/**\n\nPass By Value\n\nIn Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.\n\n*/\n\nExample 1:\n\npublic class PassByValueString {\n    public static void main(String[] args) {\n        new PassByValueString().caller();\n    }\n\n    public void caller() {\n        String value = &quot;Nikhil&quot;;\n        boolean valueflag = false;\n        String output = method(value, valueflag);\n        /*\n         * &apos;output&apos; is insignificant in this example. we are more interested in\n         * &apos;value&apos; and &apos;valueflag&apos;\n         */\n        System.out.println(&quot;output : &quot; + output);\n        System.out.println(&quot;value : &quot; + value);\n        System.out.println(&quot;valueflag : &quot; + valueflag);\n\n    }\n\n    public String method(String value, boolean valueflag) {\n        value = &quot;Anand&quot;;\n        valueflag = true;\n        return &quot;output&quot;;\n    }\n}\n\n\nResult\n\noutput : output\nvalue : Nikhil\nvalueflag : false\n\n\nExample 2:\n\n/**\n * \n * Pass By Value\n *\n */\n\npublic class PassByValueNewString {\n    public static void main(String[] args) {\n        new PassByValueNewString().caller();\n    }\n\n    public void caller() {\n        String value = new String(&quot;Nikhil&quot;);\n        boolean valueflag = false;\n        String output = method(value, valueflag);\n        /*\n         * &apos;output&apos; is insignificant in this example. we are more interested in\n         * &apos;value&apos; and &apos;valueflag&apos;\n         */\n        System.out.println(&quot;output : &quot; + output);\n        System.out.println(&quot;value : &quot; + value);\n        System.out.println(&quot;valueflag : &quot; + valueflag);\n\n    }\n\n    public String method(String value, boolean valueflag) {\n        value = &quot;Anand&quot;;\n        valueflag = true;\n        return &quot;output&quot;;\n    }\n}\n\n\nResult\n\noutput : output\nvalue : Nikhil\nvalueflag : false\n\n\nExample 3:\n\n/**\n  This &apos;Pass By Value has a feeling of &apos;Pass By Reference&apos;\n\nSome people say primitive types and &apos;String&apos; are &apos;pass by value&apos;\n  and objects are &apos;pass by reference&apos;.\n\nBut from this example, we can understand that it is infact pass by value only,\n  keeping in mind that here we are passing the reference as the value.\n  ie: reference is passed by value.\n  That&apos;s why are able to change and still it holds true after the local scope.\n  But we cannot change the actual reference outside the original scope.\n  what that means is demonstrated by next example of PassByValueObjectCase2.\n\n*/\n\npublic class PassByValueObjectCase1 {\n\n    private class Student {\n        int id;\n        String name;\n        public Student() {\n        }\n        public Student(int id, String name) {\n            super();\n            this.id = id;\n            this.name = name;\n        }\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        @Override\n        public String toString() {\n            return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;\n        }\n    }\n\n    public static void main(String[] args) {\n        new PassByValueObjectCase1().caller();\n    }\n\n    public void caller() {\n        Student student = new Student(10, &quot;Nikhil&quot;);\n        String output = method(student);\n        /*\n         * &apos;output&apos; is insignificant in this example. we are more interested in\n         * &apos;student&apos;\n         */\n        System.out.println(&quot;output : &quot; + output);\n        System.out.println(&quot;student : &quot; + student);\n    }\n\n    public String method(Student student) {\n        student.setName(&quot;Anand&quot;);\n        return &quot;output&quot;;\n    }\n}\n\n\nResult\n\noutput : output\nstudent : Student [id=10, name=Anand]\n\n\nExample 4:\n\n/**\n\nIn addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;\n\nNote: I am not pasting the code for private class Student. The class definition for Student is same as Example3.\n\n*/\n\npublic class PassByValueObjectCase2 {\n\n    public static void main(String[] args) {\n        new PassByValueObjectCase2().caller();\n    }\n\n    public void caller() {\n        // student has the actual reference to a Student object created\n        // can we change this actual reference outside the local scope? Let&apos;s see\n        Student student = new Student(10, &quot;Nikhil&quot;);\n        String output = method(student);\n        /*\n         * &apos;output&apos; is insignificant in this example. we are more interested in\n         * &apos;student&apos;\n         */\n        System.out.println(&quot;output : &quot; + output);\n        System.out.println(&quot;student : &quot; + student); // Will it print Nikhil or Anand?\n    }\n\n    public String method(Student student) {\n        student = new Student(20, &quot;Anand&quot;);\n        return &quot;output&quot;;\n    }\n\n}\n\n\nResult\n\noutput : output\nstudent : Student [id=10, name=Nikhil]\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"I thought I&apos;d contribute this answer to add more details from the Specifications.\nFirst, What&apos;s the difference between passing by reference vs. passing by value?\n\nPassing by reference means the called functions&apos; parameter will be the\nsame as the callers&apos; passed argument (not the value, but the identity\n\nthe variable itself).\n\nPass by value means the called functions&apos; parameter will be a copy of\nthe callers&apos; passed argument.\n\nOr from wikipedia, on the subject of pass-by-reference\n\nIn call-by-reference evaluation (also referred to as\npass-by-reference), a function receives an implicit reference to a\nvariable used as argument, rather than a copy of its value. This\ntypically means that the function can modify (i.e. assign to) the\nvariable used as argumentsomething that will be seen by its caller.\n\nAnd on the subject of pass-by-value\n\nIn call-by-value, the argument expression is evaluated, and the\nresulting value is bound to the corresponding variable in the function [...].\nIf the function or procedure is able to assign values to its\nparameters, only its local copy is assigned [...].\n\nSecond, we need to know what Java uses in its method invocations. The Java Language Specification states\n\nWhen the method or constructor is invoked (ยง15.12), the values of the\nactual argument expressions initialize newly created parameter\nvariables, each of the declared type, before execution of the body of\nthe method or constructor.\n\nSo it assigns (or binds) the value of the argument to the corresponding parameter variable.\nWhat is the value of the argument?\nLet&apos;s consider reference types, the Java Virtual Machine Specification states\n\nThere are three kinds of reference types: class types, array types,\nand interface types. Their values are references to dynamically\ncreated class instances, arrays, or class instances or arrays that\nimplement interfaces, respectively.\n\nThe Java Language Specification also states\n\nThe reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.\n\nThe value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (new ...) all resolve to a reference type value.\nSo\npublic void method (String param) {}\n...\nString variable = new String(&quot;ref&quot;);\nmethod(variable);\nmethod(variable.toString());\nmethod(new String(&quot;ref&quot;));\n\nall bind the value of a reference to a String instance to the method&apos;s newly created parameter, param. This is exactly what the definition of pass-by-value describes. As such, Java is pass-by-value.\nThe fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation. The definition of pass-by-reference was\n\nThis typically means that the function can modify (i.e. assign to) the\nvariable used as argumentsomething that will be seen by its caller.\n\nIn Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. Modifying the object referenced by the variable is a different concept entirely.\n\nPrimitive values are also defined in the Java Virtual Machine Specification, here. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:\n\nvoid getValues(int&amp; arg1, int&amp; arg2) {\n    arg1 = 1;\n    arg2 = 2;\n}\nvoid caller() {\n    int x;\n    int y;\n    getValues(x, y);\n    cout &lt;&lt; &quot;Result: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n}\n\n\nSometimes you want to use the same pattern in Java, but you can&apos;t; at least not directly. Instead you could do something like this:\n\nvoid getValues(int[] arg1, int[] arg2) {\n    arg1[0] = 1;\n    arg2[0] = 2;\n}\nvoid caller() {\n    int[] x = new int[1];\n    int[] y = new int[1];\n    getValues(x, y);\n    System.out.println(&quot;Result: &quot; + x[0] + &quot; &quot; + y[0]);\n}\n\n\nAs was explained in previous answers, in Java you&apos;re passing a pointer to the array as a value into getValues. That is enough, because the method then modifies the array element, and by convention you&apos;re expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn&apos;t necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"As many people mentioned it before, Java is always pass-by-value\n\nHere is another example that will help you understand the difference (the classic swap example):\n\npublic class Test {\n  public static void main(String[] args) {\n    Integer a = new Integer(2);\n    Integer b = new Integer(3);\n    System.out.println(&quot;Before: a = &quot; + a + &quot;, b = &quot; + b);\n    swap(a,b);\n    System.out.println(&quot;After: a = &quot; + a + &quot;, b = &quot; + b);\n  }\n\n  public static swap(Integer iA, Integer iB) {\n    Integer tmp = iA;\n    iA = iB;\n    iB = tmp;\n  }\n}\n\n\nPrints:  \n\n\n  Before: a = 2, b = 3\n  After: a = 2, b = 3\n\n\nThis happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.\n\npublic class PassByCopy{\n    public static void changeName(Dog d){\n        d.name = &quot;Fido&quot;;\n    }\n    public static void main(String[] args){\n        Dog d = new Dog(&quot;Maxx&quot;);\n        System.out.println(&quot;name= &quot;+ d.name);\n        changeName(d);\n        System.out.println(&quot;name= &quot;+ d.name);\n    }\n}\nclass Dog{\n    public String name;\n    public Dog(String s){\n        this.name = s;\n    }\n}\n\n\noutput of java PassByCopy:\n\n\n  name= Maxx\n  name= Fido\n\n\nPrimitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-referenceall arguments are passed by value. A method call can pass two types of values to a methodcopies of primitive values (e.g., values of int and double) and copies of references to objects.\n\nWhen a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.\n\nWhen it comes to objects, objects themselves cannot be passed to methods. So we pass the reference(address) of the object. We can manipulate the original object using this reference.\n\nHow Java creates and stores objects: When we create an object we store the objects address in a reference variable. Let&apos;s analyze the following statement.\n\nAccount account1 = new Account();\n\n\nAccount account1 is the type and name of the reference variable, = is the assignment operator, new asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right value, which is an expression called &quot;class instance creation expression&quot;) is assigned to the left value (which is a reference variable with a name and a type specified) using the assign operator.\n\nAlthough an objects reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the objects reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.\n\nPassing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,\na copy of each element would be passed. For large arrays, this would waste time and consume\nconsiderable storage for the copies of the elements.\n\nIn the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).\n\n\n\nIf we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a). \n\npublic class Test\n{\n    public static void reverseArray(int[] array1)\n    {\n        // ...\n    }\n\n    public static void main(String[] args)\n    {\n        int[] array1 = { 1, 10, -7 };\n        int[] array2 = { 5, -190, 0 };\n\n        reverseArray(array1);\n    }\n}\n\n\n\n\nSo, if we say \n\narray1[0] = 5;\n\n\nin reverseArray method, it will make a change in array a.\n\nWe have another reference variable in reverseArray method (array2) that points to an array c. If we were to say \n\narray1 = array2;\n\n\nin reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).\n\nIf we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.\n\nSo let&apos;s write all the things we have done at once now.\n\npublic class Test\n{\n    public static int[] reverseArray(int[] array1)\n    {\n        int[] array2 = { -7, 0, -1 };\n\n        array1[0] = 5; // array a becomes 5, 10, -7\n\n        array1 = array2; /* array1 of reverseArray starts\n          pointing to c instead of a (not shown in image below) */\n        return array2;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] array1 = { 1, 10, -7 };\n        int[] array2 = { 5, -190, 0 };\n\n        array1 = reverseArray(array1); /* array1 of \n         main starts pointing to c instead of a */\n    }\n}\n\n\n\n\nAnd now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.\n\nYou could also assign value of array2 in main to array1. array1 would start pointing to b.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Java has only pass by value. A very simple example to validate this.\n\npublic void test() {\n    MyClass obj = null;\n    init(obj);\n    //After calling init method, obj still points to null\n    //this is because obj is passed as value and not as reference.\n}\nprivate void init(MyClass objVar) {\n    objVar = new MyClass();\n}\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"To make a long story short, Java objects have some very peculiar properties.\n\nIn general, Java has primitive types (int, bool, char, double, etc) that are passed directly by value. Then Java has objects (everything that derives from java.lang.Object). Objects are actually always handled through a reference (a reference being a pointer that you can&apos;t touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.\n\nDoes this sound strange and confusing? Let&apos;s consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. void foo(int x) passes an int by value. void foo(int *x) is a function that does not want an int a, but a pointer to an int: foo(&amp;a). One would use this with the &amp; operator to pass a variable address.\n\nTake this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: void foo(int &amp;x) is called by foo(a), where the compiler itself knows that it is a reference and the address of the non-reference a should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"I have created a thread devoted to these kind of questions for any programming languages here.\n\nJava is also mentioned. Here is the short summary:\n\n\nJava passes it parameters by value\n&quot;by value&quot; is the only way in java to pass a parameter to a method\nusing methods from the object given as parameter will alter the\nobject as the references point to\nthe original objects. (if that\nmethod itself alters some values)\n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-java-%22pass-by-reference%22-or-%22pass-by-value%22-1657384319828#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-java-%22pass-by-reference%22-or-%22pass-by-value%22-1657384319828">Is Java &quot;pass-by-reference&quot; or &quot;pass-by-value&quot;?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/methods">methods</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/parameter-passing">parameter-passing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/pass-by-reference">pass-by-reference</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/pass-by-value">pass-by-value</a></div></div><div class="question-content mt-5">
                
<p>I always thought Java uses <strong>pass-by-reference</strong>.</p>
<p>However, I've seen <a href="http://javadude.com/articles/passbyvalue.htm" rel="noreferrer">a blog post</a> that claims that Java uses <strong>pass-by-value</strong>.</p>
<p>I don't think I understand the distinction they're making.</p>
<p>What is the explanation?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java is always <strong>pass-by-value</strong>.  Unfortunately, when we deal with objects we are really dealing with object-handles called <em>references</em> which are passed-by-value as well.  This terminology and semantics easily confuse many beginners.</p>
<p>It goes like this:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">Dog</span> <span class="hljs-variable">aDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Max"</span>);
    <span class="hljs-type">Dog</span> <span class="hljs-variable">oldDog</span> <span class="hljs-operator">=</span> aDog;

    <span class="hljs-comment">// we pass the object to foo</span>
    foo(aDog);
    <span class="hljs-comment">// aDog variable is still pointing to the "Max" dog when foo(...) returns</span>
    aDog.getName().equals(<span class="hljs-string">"Max"</span>); <span class="hljs-comment">// true</span>
    aDog.getName().equals(<span class="hljs-string">"Fifi"</span>); <span class="hljs-comment">// false</span>
    aDog == oldDog; <span class="hljs-comment">// true</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Dog d)</span> {
    d.getName().equals(<span class="hljs-string">"Max"</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// change d inside of foo() to point to a new Dog instance "Fifi"</span>
    d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Fifi"</span>);
    d.getName().equals(<span class="hljs-string">"Fifi"</span>); <span class="hljs-comment">// true</span>
}
</code></pre>
<p>In the example above <code>aDog.getName()</code> will still return <code>"Max"</code>. The value <code>aDog</code> within <code>main</code> is not changed in the function <code>foo</code> with the <code>Dog</code> <code>"Fifi"</code> as the object reference is passed by value. If it were passed by reference, then the <code>aDog.getName()</code> in <code>main</code> would return <code>"Fifi"</code> after the call to <code>foo</code>.</p>
<p>Likewise:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">Dog</span> <span class="hljs-variable">aDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Max"</span>);
    <span class="hljs-type">Dog</span> <span class="hljs-variable">oldDog</span> <span class="hljs-operator">=</span> aDog;

    foo(aDog);
    <span class="hljs-comment">// when foo(...) returns, the name of the dog has been changed to "Fifi"</span>
    aDog.getName().equals(<span class="hljs-string">"Fifi"</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// but it is still the same dog:</span>
    aDog == oldDog; <span class="hljs-comment">// true</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Dog d)</span> {
    d.getName().equals(<span class="hljs-string">"Max"</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// this changes the name of d to be "Fifi"</span>
    d.setName(<span class="hljs-string">"Fifi"</span>);
}
</code></pre>
<p>In the above example, <code>Fifi</code> is the dog's name after call to <code>foo(aDog)</code> because the object's name was set inside of <code>foo(...)</code>. Any operations that <code>foo</code> performs on <code>d</code> are such that, for all practical purposes, they are performed on <code>aDog</code>, but it is <strong>not</strong> possible to change the value of the variable <code>aDog</code> itself.</p>
<p>For more information on pass by reference and pass by value, consult the following SO answer: <a href="https://stackoverflow.com/a/430958/6005228">https://stackoverflow.com/a/430958/6005228</a>. This explains more thoroughly the semantics and history behind the two and also explains why Java and many other modern languages appear to do both in certain cases.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just noticed you referenced <a href="http://javadude.com/articles/passbyvalue.htm" rel="noreferrer">my article</a>.</p>
<p>The Java Spec says that everything in Java is pass-by-value. There is no such thing as "pass-by-reference" in Java.</p>
<p>The key to understanding this is that something like</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Dog myDog;
</code></pre>
<p>is <em>not</em> a Dog; it's actually a <em>pointer</em> to a Dog. The use of the term "reference" in Java is very misleading and is what causes most of the confusion here. What they call "references" act/feel more like what we'd call "pointers" in most other languages.</p>
<p>What that means, is when you have</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Dog</span> <span class="hljs-variable">myDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Rover"</span>);
foo(myDog);
</code></pre>
<p>you're essentially passing the <em>address</em> of the created <code>Dog</code> object to the <code>foo</code> method.</p>
<p>(I say essentially because Java pointers/references aren't direct addresses, but it's easiest to think of them that way.)</p>
<p>Suppose the <code>Dog</code> object resides at memory address 42. This means we pass 42 to the method.</p>
<p>if the Method were defined as</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Dog someDog)</span> {
    someDog.setName(<span class="hljs-string">"Max"</span>);     <span class="hljs-comment">// AAA</span>
    someDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Fifi"</span>);  <span class="hljs-comment">// BBB</span>
    someDog.setName(<span class="hljs-string">"Rowlf"</span>);   <span class="hljs-comment">// CCC</span>
}
</code></pre>
<p>let's look at what's happening.</p>
<ul>
<li>the parameter <code>someDog</code> is set to the value 42</li>
<li>at line "AAA"
<ul>
<li><code>someDog</code> is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 42)</li>
<li>that <code>Dog</code> (the one at address 42) is asked to change his name to Max</li>
</ul>
</li>
<li>at line "BBB"
<ul>
<li>a new <code>Dog</code> is created. Let's say he's at address 74</li>
<li>we assign the parameter <code>someDog</code> to 74</li>
</ul>
</li>
<li>at line "CCC"
<ul>
<li>someDog is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 74)</li>
<li>that <code>Dog</code> (the one at address 74) is asked to change his name to Rowlf</li>
</ul>
</li>
<li>then, we return</li>
</ul>
<p>Now let's think about what happens outside the method:</p>
<p><em>Did <code>myDog</code> change?</em></p>
<p>There's the key.</p>
<p>Keeping in mind that <code>myDog</code> is a <em>pointer</em>, and not an actual <code>Dog</code>, the answer is NO. <code>myDog</code> still has the value 42; it's still pointing to the original <code>Dog</code> (but note that because of line "AAA", its name is now "Max" - still the same Dog; <code>myDog</code>'s value has not changed.)</p>
<p>It's perfectly valid to <em>follow</em> an address and change what's at the end of it; that does not change the variable, however.</p>
<p>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, the caller will not see any changes you make to where that pointer points. (In a language with pass-by-reference semantics, the method function <em>can</em> change the pointer and the caller will see that change.)</p>
<p>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</p>
<p>If Java had pass-by-reference semantics, the <code>foo</code> method we defined above would have changed where <code>myDog</code> was pointing when it assigned <code>someDog</code> on line BBB.</p>
<p>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java always passes arguments <em>by value</em>, NOT by reference.</p>
<hr>
<p>Let me explain this through an <a href="https://stackoverflow.com/a/9404727/597657">example</a>:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
          <span class="hljs-type">Foo</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">"f"</span>);
          changeReference(f); <span class="hljs-comment">// It won't change the reference!</span>
          modifyReference(f); <span class="hljs-comment">// It will modify the object that the reference variable "f" refers to!</span>
     }

     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeReference</span><span class="hljs-params">(Foo a)</span> {
          <span class="hljs-type">Foo</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">"b"</span>);
          a = b;
     }

     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyReference</span><span class="hljs-params">(Foo c)</span> {
          c.setAttribute(<span class="hljs-string">"c"</span>);
     }

}
</code></pre>
<p>I will explain this in steps:</p>
<ol>
<li><p>Declaring a reference named <code>f</code> of type <code>Foo</code> and assign it a new object of type <code>Foo</code> with an attribute <code>"f"</code>.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Foo</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">"f"</span>);
</code></pre>
<p><img src="https://i.stack.imgur.com/arXpP.png" alt="enter image description here"></p>
</li>
<li><p>From the method side, a reference of type <code>Foo</code> with a name <code>a</code> is declared and it's initially assigned <code>null</code>.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeReference</span><span class="hljs-params">(Foo a)</span>
</code></pre>
<p><img src="https://i.stack.imgur.com/k2LBD.png" alt="enter image description here"></p>
</li>
<li><p>As you call the method <code>changeReference</code>, the reference <code>a</code> will be assigned the object which is passed as an argument.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">changeReference(f);
</code></pre>
<p><img src="https://i.stack.imgur.com/1Ez74.png" alt="enter image description here"></p>
</li>
<li><p>Declaring a reference named <code>b</code> of type <code>Foo</code> and assign it a new object of type <code>Foo</code> with an attribute <code>"b"</code>.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Foo</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">"b"</span>);
</code></pre>
<p><img src="https://i.stack.imgur.com/Krx4N.png" alt="enter image description here"></p>
</li>
<li><p><code>a = b</code> makes a new assignment to the reference <code>a</code>, <strong>not</strong> <code>f</code>, of the object whose attribute is <code>"b"</code>.</p>
<p><img src="https://i.stack.imgur.com/rCluu.png" alt="enter image description here"></p>
</li>
<li><p>As you call <code>modifyReference(Foo c)</code> method, a reference <code>c</code> is created and assigned the object with attribute <code>"f"</code>.</p>
<p><img src="https://i.stack.imgur.com/PRZPg.png" alt="enter image description here"></p>
</li>
<li><p><code>c.setAttribute("c");</code> will change the attribute of the object that reference <code>c</code> points to it, and it's the same object that reference <code>f</code> points to it.</p>
<p><img src="https://i.stack.imgur.com/H9Qsf.png" alt="enter image description here"></p>
</li>
</ol>
<p>I hope you understand now how passing objects as arguments works in Java :)</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java is always pass by value, with no exceptions, <strong>ever</strong>.</p>

<p>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java <strong>never</strong> provides direct access to the values of <em>objects themselves</em>, in <em>any</em> circumstances. The only access to objects is through a <em>reference</em> to that object. Because Java objects are <em>always</em> accessed through a reference, rather than directly, it is common to talk about fields and variables <em>and method arguments</em> as being <em>objects</em>, when pedantically they are only <em>references to objects</em>. <strong>The confusion stems from this (strictly speaking, incorrect) change in nomenclature.</strong></p>

<p>So, when calling a method</p>

<ul>
<li>For primitive arguments (<code>int</code>, <code>long</code>, etc.), the pass by value is <em>the actual value</em> of the primitive (for example, 3).</li>
<li>For objects, the pass by value is the value of <em>the reference to the object</em>.</li>
</ul>

<p>So if you have <code>doSomething(foo)</code> and <code>public void doSomething(Foo foo) { .. }</code> the two Foos have copied <em>references</em> that point to the same objects.</p>

<p>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)</strong></p>

<p>Step one please erase from your mind that word that starts with 'p' "_ _ _ _ _ _ _", especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</p>

<p>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</p>

<ul>
<li><em>Student</em>: Master, does this mean that Java is pass-by-reference?</li>
<li><em>Master</em>: Grasshopper, No.</li>
</ul>

<p>Now think of what an Object's reference/variable does/is:</p>

<ol>
<li><strong>A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).</strong></li>
<li>When passing arguments to a method <strong>you ARE NOT passing the reference variable, but a copy of the bits in the reference variable</strong>. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</li>
<li>So you're just passing 3bad086a that it's the value of the reference.</li>
<li>You're passing the value of the reference and not the reference itself (and not the object).</li>
<li><strong><em>This value is actually COPIED and given to the method</em></strong>. </li>
</ol>

<p>In the following (please don't try to compile/execute this...):</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-number">1.</span> Person person;
<span class="hljs-number">2.</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Tom"</span>);
<span class="hljs-number">3.</span> changeName(person);
<span class="hljs-number">4.</span>
<span class="hljs-number">5.</span> <span class="hljs-comment">//I didn't use Person person below as an argument to be nice</span>
<span class="hljs-number">6.</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeName</span><span class="hljs-params">(Person anotherReferenceToTheSamePersonObject)</span> {
<span class="hljs-number">7.</span>     anotherReferenceToTheSamePersonObject.setName(<span class="hljs-string">"Jerry"</span>);
<span class="hljs-number">8.</span> }
</code></pre>

<p>What happens?</p>

<ul>
<li>The variable <em>person</em> is created in line #1 and it's null at the beginning.</li>
<li>A new Person Object is created in line #2, stored in memory, and the variable <em>person</em> is given the reference to the Person object. That is, its address. Let's say 3bad086a.</li>
<li>The variable <em>person</em> holding the address of the Object is passed to the function in line #3.</li>
<li>In line #4 you can listen to the sound of silence </li>
<li>Check the comment on line #5</li>
<li>A method local variable -<em>anotherReferenceToTheSamePersonObject</em>- is created and then comes the magic in line #6:

<ul>
<li>The variable/reference <em>person</em> is copied bit-by-bit and passed to <em>anotherReferenceToTheSamePersonObject</em> inside the function.</li>
<li>No new instances of Person are created.</li>
<li>Both "<em>person</em>" and "<em>anotherReferenceToTheSamePersonObject</em>" hold the same value of 3bad086a.</li>
<li>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</li>
<li>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</li>
</ul></li>
</ul>

<p>A picture is worth a thousand words:</p>

<p><img src="https://i.stack.imgur.com/Ba3hJ.jpg" alt="Pass by Value"></p>

<p><strong>Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!</strong></p>

<p>If you didn't get it then just trust me and remember that it's better to say that <strong>Java is pass by value</strong>. Well, <strong>pass by reference value</strong>. Oh well, even better is <strong><em>pass-by-copy-of-the-variable-value! ;)</em></strong></p>

<p>Now feel free to hate me but note that given this <strong>there is no difference between passing primitive data types and Objects</strong> when talking about method arguments.</p>

<p>You always pass a copy of the bits of the value of the reference!</p>

<ul>
<li>If it's a primitive data type these bits will contain the value of the primitive data type itself.</li>
<li>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</li>
</ul>

<blockquote>
  <p>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</p>
</blockquote>

<hr>

<blockquote>
  <p>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</p>
</blockquote>

<hr>

<p>Of course you can cut it short and just say that  <strong>Java is pass-by-value!</strong></p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java passes references by value.</p>

<p>So you can't change the reference that gets passed in.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I feel like arguing about "pass-by-reference vs pass-by-value" is not super-helpful.</p>

<p>If you say, "Java is pass-by-whatever (reference/value)", in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</p>

<p>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</p>

<p>Okay. First off, local primitives go on the stack. So this code:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
<span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">101.1f</span>;
<span class="hljs-type">boolean</span> <span class="hljs-variable">amIAwesome</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
</code></pre>

<p>results in this:</p>

<p><img src="https://i.stack.imgur.com/7nGKU.png" alt="primitives on the stack"></p>

<p>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word "pointer". Whatever. Just know that the address of the object goes on the stack.</p>

<p>Like so:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-variable">problems</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Jay-Z"</span>;
</code></pre>

<p><img src="https://i.stack.imgur.com/yTIYp.png" alt="a b*7ch aint one!"></p>

<p>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">JButton[] marxBros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>[<span class="hljs-number">3</span>];
marxBros[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">"Groucho"</span>);
marxBros[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">"Zeppo"</span>);
marxBros[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">"Harpo"</span>);
</code></pre>

<p><img src="https://i.stack.imgur.com/v2b33.png" alt="marx brothers"></p>

<p>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the "value" of the address, and some say it's just a reference to the object. This is the genesis of the holy war between "reference" and "value" proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">(String name)</span>{
    System.out.println(<span class="hljs-string">"There goes "</span> + name + <span class="hljs-string">"!"</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
    <span class="hljs-type">String</span> <span class="hljs-variable">hisName</span> <span class="hljs-operator">=</span> <span class="hljs-string">"John J. Jingleheimerschmitz"</span>;
    <span class="hljs-type">String</span> <span class="hljs-variable">myName</span> <span class="hljs-operator">=</span> hisName;
    shout(myName);
}
</code></pre>

<p>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier <code>hisName</code>, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call <code>shout()</code>: a new stack frame is created and a new identifier, <code>name</code> is created and assigned the address of the already-existing String.</p>

<p><img src="https://i.stack.imgur.com/q0prc.png" alt="la da di da da da da"></p>

<p>So, value, reference? You say "potato".</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Object bar)</span> {
    bar = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">baz</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hah!"</span>;
    foo(baz);
    System.out.println(baz);
}
</code></pre>
<p>will print out <code>"Hah!"</code> instead of <code>null</code>. The reason this works is because <code>bar</code> is a copy of the value of <code>baz</code>, which is just a reference to <code>"Hah!"</code>. If it were the actual reference itself, then <code>foo</code> would have redefined <code>baz</code> to <code>null</code>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to show the contrast, compare the following <a href="https://en.wikipedia.org/wiki/C++" rel="noreferrer">C++</a> and <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="noreferrer">Java</a> snippets:</p>

<p>In C++: <strong>Note: Bad code - memory leaks!</strong>  But it demonstrates the point.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">cppMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> &amp;ref, Dog obj, Dog &amp;objRef, Dog *objPtr, Dog *&amp;objPtrRef)</span>
{
    val = <span class="hljs-number">7</span>; <span class="hljs-comment">// Modifies the copy</span>
    ref = <span class="hljs-number">7</span>; <span class="hljs-comment">// Modifies the original variable</span>
    obj.SetName(<span class="hljs-string">"obj"</span>); <span class="hljs-comment">// Modifies the copy of Dog passed</span>
    objRef.SetName(<span class="hljs-string">"objRef"</span>); <span class="hljs-comment">// Modifies the original Dog passed</span>
    objPtr-&gt;SetName(<span class="hljs-string">"objPtr"</span>); <span class="hljs-comment">// Modifies the original Dog pointed to </span>
                               <span class="hljs-comment">// by the copy of the pointer passed.</span>
    objPtr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"newObjPtr"</span>);  <span class="hljs-comment">// Modifies the copy of the pointer, </span>
                                   <span class="hljs-comment">// leaving the original object alone.</span>
    objPtrRef-&gt;SetName(<span class="hljs-string">"objRefPtr"</span>); <span class="hljs-comment">// Modifies the original Dog pointed to </span>
                                    <span class="hljs-comment">// by the original pointer passed. </span>
    objPtrRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"newObjPtrRef"</span>); <span class="hljs-comment">// Modifies the original pointer passed</span>
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">Dog</span> <span class="hljs-variable">d0</span> <span class="hljs-operator">=</span> Dog(<span class="hljs-string">"d0"</span>);
    <span class="hljs-type">Dog</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Dog(<span class="hljs-string">"d1"</span>);
    Dog *d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"d2"</span>);
    Dog *d3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"d3"</span>);
    cppMethod(a, b, d0, d1, d2, d3);
    <span class="hljs-comment">// a is still set to 0</span>
    <span class="hljs-comment">// b is now set to 7</span>
    <span class="hljs-comment">// d0 still have name "d0"</span>
    <span class="hljs-comment">// d1 now has name "objRef"</span>
    <span class="hljs-comment">// d2 now has name "objPtr"</span>
    <span class="hljs-comment">// d3 now has name "newObjPtrRef"</span>
}
</code></pre>

<p>In Java, </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">javaMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Dog objPtr)</span>
{
   val = <span class="hljs-number">7</span>; <span class="hljs-comment">// Modifies the copy</span>
   objPtr.SetName(<span class="hljs-string">"objPtr"</span>) <span class="hljs-comment">// Modifies the original Dog pointed to </span>
                            <span class="hljs-comment">// by the copy of the pointer passed.</span>
   objPtr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"newObjPtr"</span>);  <span class="hljs-comment">// Modifies the copy of the pointer, </span>
                                  <span class="hljs-comment">// leaving the original object alone.</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">Dog</span> <span class="hljs-variable">d0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"d0"</span>);
    javaMethod(a, d0);
    <span class="hljs-comment">// a is still set to 0</span>
    <span class="hljs-comment">// d0 now has name "objPtr"</span>
}
</code></pre>

<p>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java passes references to objects by value.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term <em>call by sharing</em> (also known as <em>call by object-sharing</em> and <em>call by object</em>) for this specific case of "call by value where the value is a reference".</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The crux of the matter is that the word <em>reference</em> in the expression "pass by reference" means something completely different from the usual meaning of the word <em>reference</em> in Java. </p>

<p>Usually in Java <em>reference</em> means a a <em>reference to an object</em>. But the technical terms <em>pass by reference/value</em> from programming language theory is talking about a <em>reference to the memory cell holding the variable</em>, which is something completely different.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In java everything is reference, so when you have something like:
    <code>Point pnt1 = new Point(0,0);</code> Java does following:</p>

<ol>
<li>Creates new Point object</li>
<li>Creates new Point reference and initialize that reference to <em>point (refer to)</em> on previously created Point object.</li>
<li>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.<br></li>
</ol>

<p><img src="https://i.stack.imgur.com/jM54f.png" alt="enter image description here"></p>

<p><strong>Java doesn't pass method arguments by reference; it passes them by value.</strong> I will use example from <a href="http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html" rel="noreferrer">this site</a>: </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tricky</span><span class="hljs-params">(Point arg1, Point arg2)</span> {
  arg1.x = <span class="hljs-number">100</span>;
  arg1.y = <span class="hljs-number">100</span>;
  <span class="hljs-type">Point</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arg1;
  arg1 = arg2;
  arg2 = temp;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> {
  <span class="hljs-type">Point</span> <span class="hljs-variable">pnt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
  <span class="hljs-type">Point</span> <span class="hljs-variable">pnt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
  System.out.println(<span class="hljs-string">"X1: "</span> + pnt1.x + <span class="hljs-string">" Y1: "</span> +pnt1.y); 
  System.out.println(<span class="hljs-string">"X2: "</span> + pnt2.x + <span class="hljs-string">" Y2: "</span> +pnt2.y);
  System.out.println(<span class="hljs-string">" "</span>);
  tricky(pnt1,pnt2);
  System.out.println(<span class="hljs-string">"X1: "</span> + pnt1.x + <span class="hljs-string">" Y1:"</span> + pnt1.y); 
  System.out.println(<span class="hljs-string">"X2: "</span> + pnt2.x + <span class="hljs-string">" Y2: "</span> +pnt2.y);  
}
</code></pre>

<p>Flow of the program:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Point</span> <span class="hljs-variable">pnt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
<span class="hljs-type">Point</span> <span class="hljs-variable">pnt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
</code></pre>

<p>Creating two different Point object with two different reference associated.
<img src="https://i.stack.imgur.com/5LIKC.png" alt="enter image description here"></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">System.out.println(<span class="hljs-string">"X1: "</span> + pnt1.x + <span class="hljs-string">" Y1: "</span> +pnt1.y); 
System.out.println(<span class="hljs-string">"X2: "</span> + pnt2.x + <span class="hljs-string">" Y2: "</span> +pnt2.y);
System.out.println(<span class="hljs-string">" "</span>);
</code></pre>

<p>As expected output will be:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">X1: <span class="hljs-number">0</span>     Y1: <span class="hljs-number">0</span>
X2: <span class="hljs-number">0</span>     Y2: <span class="hljs-number">0</span>
</code></pre>

<p><strong>On this line 'pass-by-value' goes into the play...</strong> <br></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">tricky(pnt1,pnt2);           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tricky</span><span class="hljs-params">(Point arg1, Point arg2)</span>;
</code></pre>

<p>References <code>pnt1</code> and <code>pnt2</code> are <strong>passed by value</strong> to the tricky method, which means that now yours references <code>pnt1</code> and <code>pnt2</code> have their <code>copies</code> named <code>arg1</code> and <code>arg2</code>.So <code>pnt1</code> and <code>arg1</code> <em>points</em> to the same object. (Same for the <code>pnt2</code> and <code>arg2</code>)
<img src="https://i.stack.imgur.com/qd1GH.png" alt="enter image description here"></p>

<p>In the <code>tricky</code> method:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"> arg1.x = <span class="hljs-number">100</span>;
 arg1.y = <span class="hljs-number">100</span>;
</code></pre>

<p><img src="https://i.stack.imgur.com/o4WT0.png" alt="enter image description here"></p>

<p>Next in the <code>tricky</code> method</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Point</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arg1;
arg1 = arg2;
arg2 = temp;
</code></pre>

<p>Here, you first create new <code>temp</code> Point reference which will <em>point</em> on same place like <code>arg1</code> reference. Then you move reference <code>arg1</code> to <em>point</em> to the same place like <code>arg2</code> reference.
Finally <code>arg2</code> will <em>point</em> to the same place like <code>temp</code>.</p>

<p><img src="https://i.stack.imgur.com/fX5Q3.png" alt="enter image description here"></p>

<p>From here scope of <code>tricky</code> method is gone and you don't have access any more to the references: <code>arg1</code>, <code>arg2</code>, <code>temp</code>. <strong>But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are <em>point</em> to.</strong> </p>

<p>So after executing method <code>tricky</code>, when you return to <code>main</code>, you have this situation:
<img src="https://i.stack.imgur.com/LRETe.png" alt="enter image description here"></p>

<p>So now, completely execution of program will be:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">X1: <span class="hljs-number">0</span>         Y1: <span class="hljs-number">0</span>
X2: <span class="hljs-number">0</span>         Y2: <span class="hljs-number">0</span>
X1: <span class="hljs-number">100</span>       Y1: <span class="hljs-number">100</span>
X2: <span class="hljs-number">0</span>         Y2: <span class="hljs-number">0</span>
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Java is always pass by value, not pass by reference</strong></p>
<p>First of all, we need to understand what pass by value and pass by reference are.</p>
<p><strong>Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter</strong>.</p>
<p><strong>Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored</strong>.</p>
<p>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValue</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();
        t.name = <span class="hljs-string">"initialvalue"</span>;
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValue</span>().changeValue(t);
        System.out.println(t.name);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeValue</span><span class="hljs-params">(Test f)</span> {
        f.name = <span class="hljs-string">"changevalue"</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
    String name;
}
</code></pre>
<p>The output of this program is:</p>
<blockquote>
<pre class="lang-java s-code-block"><code class="hljs language-java">changevalue
</code></pre>
</blockquote>
<p>Let's understand step by step:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();
</code></pre>
<p>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is <code>0x100234</code> (we don't know the actual JVM internal value, this is just an example) .</p>
<p><img src="https://i.stack.imgur.com/AVrhI.png" alt="first illustration"></p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValue</span>().changeValue(t);
</code></pre>
<p>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is <strong>passing by value</strong>, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was <code>0x100234</code>, both t and f will have the same value and hence they will point to the same object.</p>
<p><img src="https://i.stack.imgur.com/WwdPh.png" alt="second illustration"></p>
<p>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output <code>changevalue</code>,   which is updated in the function.</p>
<p>To understand this more clearly, consider the following example:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValue</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();
        t.name = <span class="hljs-string">"initialvalue"</span>;
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValue</span>().changeRefence(t);
        System.out.println(t.name);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeRefence</span><span class="hljs-params">(Test f)</span> {
        f = <span class="hljs-literal">null</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
    String name;
}
</code></pre>
<p>Will this throw a <code>NullPointerException</code>? No, because it only passes a copy of the reference.
In the case of passing by reference, it could have thrown a <code>NullPointerException</code>, as seen below:</p>
<p><img src="https://i.stack.imgur.com/jH6KP.png" alt="third illustration"></p>
<p>Hopefully this will help.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are already great answers that cover this. I wanted to make a small contribution by sharing a <strong>very simple example</strong> (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</p>

<p>A few points:</p>

<ol>
<li>The term "reference" is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of "Pass-by-reference" it means a handle to the original variable which was passed in.</li>
<li><strong>Java is Pass-by-value</strong>. Java is a descendent of C (among other languages). Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. PBR allowed these other languages to make changes to the passed variables inside sub-routines. In order to accomplish the same thing (i.e. change the values of variables inside functions), C programmers passed pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to pass pointer to methods as C did, except that Java calls its pointers References. Again, this is a different use of the word "Reference" than in "Pass-By-Reference".</li>
<li><strong>C++ allows Pass-by-reference</strong> by declaring a reference parameter using the "&amp;" character (which happens to be the same character used to indicate "the address of a variable" in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</li>
<li>In the C++ example below I'm passing a <strong>pointer</strong> to a null terminated string <strong>by reference</strong>. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</li>
</ol>

<p>C++ pass by reference example:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">using namespace std;
#include &lt;iostream&gt;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span> <span class="hljs-params">(<span class="hljs-type">char</span> *&amp;str)</span>{   <span class="hljs-comment">// the '&amp;' makes this a reference parameter</span>
    str = NULL;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> *str = <span class="hljs-string">"not Null"</span>;
    change(str);
    cout&lt;&lt;<span class="hljs-string">"str is "</span> &lt;&lt; str;      <span class="hljs-comment">// ==&gt;str is &lt;null&gt;</span>
}
</code></pre>

<p>Java pass "a Java reference" by value example</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueDemo</span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span> <span class="hljs-params">(String str)</span>{
        str = <span class="hljs-literal">null</span>;
    }

     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>{
        <span class="hljs-type">ValueDemo</span> <span class="hljs-variable">vd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueDemo</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"not null"</span>;
        vd.change(str);
        System.out.println(<span class="hljs-string">"str is "</span> + str);    <span class="hljs-comment">// ==&gt; str is not null!!</span>
                                                <span class="hljs-comment">// Note that if "str" was</span>
                                                <span class="hljs-comment">// passed-by-reference, it</span>
                                                <span class="hljs-comment">// WOULD BE NULL after the</span>
                                                <span class="hljs-comment">// call to change().</span>
     }
}
</code></pre>

<p><strong>EDIT</strong></p>

<p>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</p>

<p>In pascal, parameters passed-by-reference are called "var parameters". In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed <strong>by reference</strong>. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">program passByRefDemo;
<span class="hljs-type">type</span> 
   <span class="hljs-variable">iptr</span> <span class="hljs-operator">=</span> ^integer;
<span class="hljs-keyword">var</span>
   ptr: iptr;

   procedure <span class="hljs-title function_">setToNil</span><span class="hljs-params">(<span class="hljs-keyword">var</span> ptr : iptr)</span>;
   begin
       ptr := nil;
   end;

begin
   <span class="hljs-title function_">new</span><span class="hljs-params">(ptr)</span>;
   ptr^ := <span class="hljs-number">10</span>;
   setToNil(ptr);
   <span class="hljs-keyword">if</span> (ptr = nil) then
       <span class="hljs-title function_">writeln</span><span class="hljs-params">(<span class="hljs-string">'ptr seems to be nil'</span>)</span>;     { ptr should be nil, so <span class="hljs-built_in">this</span> line will run. }
end.
</code></pre>

<p><strong>EDIT 2</strong></p>

<p>Some excerpts from <strong>"THE Java Programming Language"</strong> by Ken Arnold, <strong>James Gosling (the guy who invented Java)</strong>, and David Holmes, chapter 2, section 2.6.5</p>

<blockquote>
  <p><strong>All parameters to methods are passed "by value"</strong>. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</p>
</blockquote>

<p>He goes on to make the same point regarding objects . . . </p>

<blockquote>
  <p>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is <strong>passed "by value"</strong>.</p>
</blockquote>

<p>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</p>

<blockquote>
  <p>The Java programming language <strong>does not pass objects by reference; it</strong>
  <strong>passes object references by value</strong>. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-<strong>pass by value</strong>-and that helps keep things
  simple.</p>
</blockquote>

<p>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</p>

<p>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</p>

<p>I hope this settles the debate, but probably won't.</p>

<p><strong>EDIT 3</strong></p>

<p>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word "reference" for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, "Java passes dingleberries by value and not by reference", and nobody would be confused.</p>

<p>That's the reason only Java developers have issue with this. They look at the word "reference" and think they know exactly what that means, so they don't even bother to consider the opposing argument.</p>

<p>Anyway, I noticed a comment in an older post, which made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</p>

<p><strong>Passing a reference by value</strong>--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.
<a href="https://i.stack.imgur.com/RvkqU.png" rel="noreferrer"><img src="https://i.stack.imgur.com/RvkqU.png" alt="Passing Object references By Value"></a></p>

<p><strong>Pass by reference</strong>--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.
<a href="https://i.stack.imgur.com/SHXkC.png" rel="noreferrer"><img src="https://i.stack.imgur.com/SHXkC.png" alt="Pass by reference"></a></p>

<p><strong>EDIT 4</strong></p>

<p>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about <strong>the behavior described in the language specification</strong> than about the technical implementation of the behavior. This is an exerpt from the <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1" rel="noreferrer">Java Language Specification, section 8.4.1</a> :</p>

<blockquote>
  <p>When the method or constructor is invoked (ยง15.12), <strong>the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.</strong> The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</p>
</blockquote>

<p>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used <a href="https://rads.stackoverflow.com/amzn/click/com/0201100886" rel="noreferrer">"The Dragon Book"</a> which is <strong>THE</strong> compilers book. It has a good description of "Call-by-value" and "Call-by-Reference" in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</p>

<p>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the <a href="https://rads.stackoverflow.com/amzn/click/com/B009TGD06W" rel="noreferrer">2nd Eddition</a> from 2007 <strong>which actually mentions Java!</strong> Section 1.6.6 labeled "Parameter Passing Mechanisms" describes parameter passing pretty nicely. Here is an excerpt under the heading "Call-by-value" which mentions Java:</p>

<blockquote>
  <p>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. <strong>This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.</strong></p>
</blockquote>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java is a pass by value(stack memory)</p>
<p>How it works</p>
<ul>
<li><p>Let's first understand that where java stores primitive data type and object data type.</p>
</li>
<li><p>Primitive data types itself and object references are stored in the stack.
Objects themselves are stored in the heap.</p>
</li>
<li><p>It means, Stack memory stores primitive data types and also the
addresses of objects.</p>
</li>
<li><p>And you always pass a copy of the bits of the value of the reference.</p>
</li>
<li><p>If it's a primitive data type then these copied bits contain the value of the primitive data type itself, That's why when we change the value of argument inside the method then it does not reflect the changes outside.</p>
</li>
<li><p>If it's an object data type like <strong>Foo foo=new Foo()</strong> then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file <strong>abc.txt</strong> at <strong>C:\desktop</strong> and suppose we make shortcut of the same file and put this inside <strong>C:\desktop\abc-shortcut</strong> so when you access the file from <strong>C:\desktop\abc.txt</strong> and write <strong>'Stack Overflow'</strong> and close the file and again you open the file from shortcut then you write <strong>' is the largest online community for programmers to learn'</strong> then total file change will be <strong>'Stack Overflow is the largest online community for programmers to learn'</strong> which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume <strong>Foo</strong> as a file and suppose foo stored at <strong>123hd7h</strong>(original address like <strong>C:\desktop\abc.txt</strong> ) address and <strong>234jdid</strong>(copied address like <strong>C:\desktop\abc-shortcut</strong> which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel.</p>
</li>
</ul>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>A reference is always a value when represented, no matter what language you use.</h2>

<p>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a <em>reference</em> to anything immediately becomes a <em>value</em> if it gets written to memory or to one of the CPU registers. (That is why <em>pointer</em> is a good definition. It is a value, which has a purpose at the same time).</p>

<p>Data in memory has a <strong>Location</strong> and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a <strong>Name</strong> to certain <strong>Location</strong> (aka variable), but when compiling the code, the assembler simply replaces <strong>Name</strong> with the designated location just like your browser replaces domain names with IP addresses.</p>

<p>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</p>

<p>Lets say we have a variable Foo, its <strong>Location</strong> is at the 47th byte in memory and its <strong>Value</strong> is 5. We have another variable <strong>Ref2Foo</strong> which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two <strong>Values</strong>.
If you use them as references then to reach to <code>5</code> we have to travel:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">(Name)[Location] -&gt; [Value at the Location]
---------------------
(Ref2Foo)[<span class="hljs-number">223</span>]  -&gt; <span class="hljs-number">47</span>
(Foo)[<span class="hljs-number">47</span>]       -&gt; <span class="hljs-number">5</span>
</code></pre>

<p>This is how jump-tables work. </p>

<p>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the <strong>language</strong> and its several method invocation modes:</p>

<ol>
<li>5 gets copied to one of the CPU registers (ie. EAX).</li>
<li>5 gets PUSHd to the stack.</li>
<li>47 gets copied to one of the CPU registers</li>
<li>47 PUSHd to the stack.</li>
<li>223 gets copied to one of the CPU registers.</li>
<li>223 gets PUSHd to the stack.</li>
</ol>

<p>In every cases above a value - a <strong>copy</strong> of an existing value - has been created, it is now upto the receiving method to handle it. When you write "Foo" inside the method, it is either read out from EAX, or automatically  <strong>dereferenced</strong>, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a <em>reference</em> is a <em>value</em> when represented, because a reference is a value that has to be processed (at language level).</p>

<p>Now we have passed Foo to the method:</p>

<ul>
<li>in case 1. and 2. if you change Foo (<code>Foo = 9</code>) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</li>
<li>in case 3. and 4. if you use default language constructs and change Foo (<code>Foo = 11</code>), it could change Foo globally (depends on the language, ie. Java or like Pascal's <code>procedure findMin(x, y, z: integer;</code><strong>var m</strong><code>: integer);</code>). However if the language allows you to circumvent the dereference process, you can change <code>47</code>, say to <code>49</code>. At that point Foo seems to have been changed if you read it, because you have changed the <strong>local pointer</strong> to it. And if you were to modify this Foo inside the method (<code>Foo = 12</code>) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at <code>47</code>). BUT Foo's value of <code>47</code> did not change globally, only the one inside the method, because <code>47</code> was also a copy to the method.</li>
<li>in case 5. and 6. if you modify <code>223</code> inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was <strong>copied</strong>. However if you are able to dereference <code>Ref2Foo</code> (that is <code>223</code>), reach to and modify the pointed value <code>47</code>, say, to <code>49</code>, it will affect Foo <strong>globally</strong>, because in this case the methods got a copy of <code>223</code>  but the referenced <code>47</code> exists only once, and changing that to <code>49</code> will lead every <code>Ref2Foo</code> double-dereferencing to a wrong value.</li>
</ul>

<p>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only <em>pass-by-reference</em>.</p>

<p>Strict <em>pass-by-value</em> is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</p>

<p>So in short and in Java's own terminology, Java is <em>pass-by-value</em> where <em>value</em> can be: either a <strong>real value</strong> or a <strong>value</strong> that is a representation of a <strong>reference</strong>. </p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>In Java, method arguments are all passed by value :</strong></p>
<p>Java arguments are <strong>all passed by value</strong> (the value  or reference is copied when used by the method) :</p>
<p>In the case of primitive types, Java behaviour is simple:
The value is copied in another instance of the primitive type.</p>
<p>In case of Objects, this is the same:
Object variables are references (mem buckets holding only Objects <strong>address</strong> instead of a primitive value) that was created using the "new" keyword, and are copied like primitive types.</p>
<p>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's <strong>content/members</strong> might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</p>
<p>"String" Objects appear to be a good <strong>counter-example</strong> to the urban legend saying that "Objects are passed by reference":</p>
<p>In effect, using a method, you will never be able, to update the value of a String passed as argument:</p>
<p>A String Object, holds characters by an array declared <strong>final</strong> that can't be modified.
Only the address of the Object might be replaced by another using "new".
Using "new" to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(StringBuffer s1, StringBuffer s2)</span> {
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s1;
    s1 = s2;
    s2 = temp;
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello"</span>);
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"World"</span>);
    swap(s1, s2);
    System.out.println(s1);
    System.out.println(s2);
}
</code></pre>

<p>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendWorld</span><span class="hljs-params">(StringBuffer s1)</span> {
    s1.append(<span class="hljs-string">" World"</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello"</span>);
    appendWorld(s);
    System.out.println(s);
}
</code></pre>

<p>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendWorld</span><span class="hljs-params">(String s)</span>{
    s = s+<span class="hljs-string">" World"</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Hello"</span>);
    appendWorld(s);
    System.out.println(s);
}
</code></pre>

<p>However you could make a wrapper for String like this which would make it able to use it with Strings:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringWrapper</span> {
    <span class="hljs-keyword">public</span> String value;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringWrapper</span><span class="hljs-params">(String value)</span> {
        <span class="hljs-built_in">this</span>.value = value;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendWorld</span><span class="hljs-params">(StringWrapper s)</span>{
    s.value = s.value +<span class="hljs-string">" World"</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">StringWrapper</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWrapper</span>(<span class="hljs-string">"Hello"</span>);
    appendWorld(s);
    System.out.println(s.value);
}
</code></pre>

<p>edit: i believe this is also the reason to use StringBuffer when it comes to "adding" two Strings because you can modifie the original object which u can't with immutable objects like String is.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>No, it's not pass by reference.</p>

<p>Java is pass by value according to the Java Language Specification:</p>

<blockquote>
  <p>When the method or constructor is invoked (ยง15.12), <strong>the values of the actual argument expressions initialize newly created parameter variables</strong>, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" rel="noreferrer">formal parameter</a>. </p>
</blockquote>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</p>

<p>/**</p>

<p>Pass By Value</p>

<p>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</p>

<p>*/</p>

<p><strong>Example 1:</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueString</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValueString</span>().caller();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Nikhil"</span>;
        <span class="hljs-type">boolean</span> <span class="hljs-variable">valueflag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> method(value, valueflag);
        <span class="hljs-comment">/*
         * 'output' is insignificant in this example. we are more interested in
         * 'value' and 'valueflag'
         */</span>
        System.out.println(<span class="hljs-string">"output : "</span> + output);
        System.out.println(<span class="hljs-string">"value : "</span> + value);
        System.out.println(<span class="hljs-string">"valueflag : "</span> + valueflag);

    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">(String value, <span class="hljs-type">boolean</span> valueflag)</span> {
        value = <span class="hljs-string">"Anand"</span>;
        valueflag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"output"</span>;
    }
}
</code></pre>

<p><strong>Result</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">output : output
value : Nikhil
valueflag : <span class="hljs-literal">false</span>
</code></pre>

<p><strong>Example 2:</strong></p>

<p>/**
 * 
 * Pass By Value
 *
 */</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueNewString</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValueNewString</span>().caller();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Nikhil"</span>);
        <span class="hljs-type">boolean</span> <span class="hljs-variable">valueflag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> method(value, valueflag);
        <span class="hljs-comment">/*
         * 'output' is insignificant in this example. we are more interested in
         * 'value' and 'valueflag'
         */</span>
        System.out.println(<span class="hljs-string">"output : "</span> + output);
        System.out.println(<span class="hljs-string">"value : "</span> + value);
        System.out.println(<span class="hljs-string">"valueflag : "</span> + valueflag);

    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">(String value, <span class="hljs-type">boolean</span> valueflag)</span> {
        value = <span class="hljs-string">"Anand"</span>;
        valueflag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"output"</span>;
    }
}
</code></pre>

<p><strong>Result</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">output : output
value : Nikhil
valueflag : <span class="hljs-literal">false</span>
</code></pre>

<p><strong>Example 3:</strong></p>

<p>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</p>

<p>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</p>

<p>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</p>

<p>*/</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueObjectCase1</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
        <span class="hljs-type">int</span> id;
        String name;
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
        }
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> {
            <span class="hljs-built_in">super</span>();
            <span class="hljs-built_in">this</span>.id = id;
            <span class="hljs-built_in">this</span>.name = name;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> id;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> {
            <span class="hljs-built_in">this</span>.id = id;
        }
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> name;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
            <span class="hljs-built_in">this</span>.name = name;
        }
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Student [id="</span> + id + <span class="hljs-string">", name="</span> + name + <span class="hljs-string">"]"</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValueObjectCase1</span>().caller();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">10</span>, <span class="hljs-string">"Nikhil"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> method(student);
        <span class="hljs-comment">/*
         * 'output' is insignificant in this example. we are more interested in
         * 'student'
         */</span>
        System.out.println(<span class="hljs-string">"output : "</span> + output);
        System.out.println(<span class="hljs-string">"student : "</span> + student);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">(Student student)</span> {
        student.setName(<span class="hljs-string">"Anand"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"output"</span>;
    }
}
</code></pre>

<p><strong>Result</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">output : output
student : Student [id=<span class="hljs-number">10</span>, name=Anand]
</code></pre>

<p><strong>Example 4:</strong></p>

<p>/**</p>

<p>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope."</p>

<p>Note: I am not pasting the code for <code>private class Student</code>. The class definition for <code>Student</code> is same as Example3.</p>

<p>*/</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueObjectCase2</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassByValueObjectCase2</span>().caller();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// student has the actual reference to a Student object created</span>
        <span class="hljs-comment">// can we change this actual reference outside the local scope? Let's see</span>
        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">10</span>, <span class="hljs-string">"Nikhil"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> method(student);
        <span class="hljs-comment">/*
         * 'output' is insignificant in this example. we are more interested in
         * 'student'
         */</span>
        System.out.println(<span class="hljs-string">"output : "</span> + output);
        System.out.println(<span class="hljs-string">"student : "</span> + student); <span class="hljs-comment">// Will it print Nikhil or Anand?</span>
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">(Student student)</span> {
        student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">20</span>, <span class="hljs-string">"Anand"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"output"</span>;
    }

}
</code></pre>

<p><strong>Result</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">output : output
student : Student [id=<span class="hljs-number">10</span>, name=Nikhil]
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I thought I'd contribute this answer to add more details from the Specifications.</p>
<p>First, <a href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value">What's the difference between passing by reference vs. passing by value?</a></p>
<blockquote>
<p>Passing by reference means the called functions' parameter will be the
same as the callers' passed argument (not the value, but the identity</p>
<ul>
<li>the variable itself).</li>
</ul>
<p>Pass by value means the called functions' parameter will be a copy of
the callers' passed argument.</p>
</blockquote>
<p>Or from wikipedia, <a href="http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference" rel="nofollow noreferrer">on the subject of pass-by-reference</a></p>
<blockquote>
<p>In call-by-reference evaluation (also referred to as
pass-by-reference), a function receives an implicit reference to a
variable used as argument, rather than a copy of its value. This
typically means that the function can modify (i.e. assign to) the
variable used as argumentsomething that will be seen by its caller.</p>
</blockquote>
<p>And <a href="http://en.wikipedia.org/wiki/Call_by_value#Call_by_value" rel="nofollow noreferrer">on the subject of pass-by-value</a></p>
<blockquote>
<p>In call-by-value, the argument expression is evaluated, and the
resulting value is bound to the corresponding variable in the function [...].
If the function or procedure is able to assign values to its
parameters, only its local copy is assigned [...].</p>
</blockquote>
<p>Second, we need to know what Java uses in its method invocations. The <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1" rel="nofollow noreferrer">Java Language Specification</a> states</p>
<blockquote>
<p>When the method or constructor is invoked (ยง15.12), <strong>the values of the
actual argument expressions initialize newly created parameter
variables</strong>, each of the declared type, before execution of the body of
the method or constructor.</p>
</blockquote>
<p>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</p>
<p><strong>What is the value of the argument?</strong></p>
<p>Let's consider reference types, the <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4" rel="nofollow noreferrer">Java Virtual Machine Specification</a> states</p>
<blockquote>
<p>There are three kinds of <strong>reference types</strong>: class types, array types,
and interface types. <strong>Their values are references to dynamically
created class instances, arrays, or class instances or arrays that
implement interfaces, respectively.</strong></p>
</blockquote>
<p>The <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1" rel="nofollow noreferrer">Java Language Specification</a> also states</p>
<blockquote>
<p><strong>The reference values (often just references) are pointers to these objects</strong>, and a special null reference, which refers to no object.</p>
</blockquote>
<p>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (<code>new ...</code>) all resolve to a reference type value.</p>
<p>So</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span> <span class="hljs-params">(String param)</span> {}
...
<span class="hljs-type">String</span> <span class="hljs-variable">variable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ref"</span>);
method(variable);
method(variable.toString());
method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ref"</span>));
</code></pre>
<p>all bind the value of a reference to a <code>String</code> instance to the method's newly created parameter, <code>param</code>. This is exactly what the definition of pass-by-value describes. As such, <strong>Java is pass-by-value</strong>.</p>
<p><strong>The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.</strong> The definition of pass-by-reference was</p>
<blockquote>
<p>This typically means that the function can modify (i.e. assign to) the
variable used as argumentsomething that will be seen by its caller.</p>
</blockquote>
<p>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. <strong>Modifying the object referenced by the variable is a different concept entirely.</strong></p>
<hr>
<p>Primitive values are also defined in the Java Virtual Machine Specification, <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3" rel="nofollow noreferrer">here</a>. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getValues</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; arg1, <span class="hljs-type">int</span>&amp; arg2)</span> {
    arg1 = <span class="hljs-number">1</span>;
    arg2 = <span class="hljs-number">2</span>;
}
<span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">int</span> y;
    getValues(x, y);
    cout &lt;&lt; <span class="hljs-string">"Result: "</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; y &lt;&lt; endl;
}
</code></pre>

<p>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getValues</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arg1, <span class="hljs-type">int</span>[] arg2)</span> {
    arg1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    arg2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
}
<span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];
    <span class="hljs-type">int</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];
    getValues(x, y);
    System.out.println(<span class="hljs-string">"Result: "</span> + x[<span class="hljs-number">0</span>] + <span class="hljs-string">" "</span> + y[<span class="hljs-number">0</span>]);
}
</code></pre>

<p>As was explained in previous answers, in Java you're passing a pointer to the array as a value into <code>getValues</code>. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As many people mentioned it before, <a href="http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm" rel="noreferrer">Java is always pass-by-value</a></p>

<p>Here is another example that will help you understand the difference (<a href="http://www.javaranch.com/campfire/StoryPassBy.jsp" rel="noreferrer">the classic swap example</a>):</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>);
    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>);
    System.out.println(<span class="hljs-string">"Before: a = "</span> + a + <span class="hljs-string">", b = "</span> + b);
    swap(a,b);
    System.out.println(<span class="hljs-string">"After: a = "</span> + a + <span class="hljs-string">", b = "</span> + b);
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Integer iA, Integer iB)</span> {
    <span class="hljs-type">Integer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> iA;
    iA = iB;
    iB = tmp;
  }
}
</code></pre>

<p>Prints:  </p>

<blockquote>
  <p>Before: a = 2, b = 3<br>
  After: a = 2, b = 3</p>
</blockquote>

<p>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I always think of it as "pass by copy". It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByCopy</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeName</span><span class="hljs-params">(Dog d)</span>{
        d.name = <span class="hljs-string">"Fido"</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Maxx"</span>);
        System.out.println(<span class="hljs-string">"name= "</span>+ d.name);
        changeName(d);
        System.out.println(<span class="hljs-string">"name= "</span>+ d.name);
    }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>{
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String s)</span>{
        <span class="hljs-built_in">this</span>.name = s;
    }
}
</code></pre>

<p>output of java PassByCopy:</p>

<blockquote>
  <p>name= Maxx<br>
  name= Fido</p>
</blockquote>

<p>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-referenceall arguments are passed by value. A method call can pass two types of values to a methodcopies of primitive values (e.g., values of int and double) and copies of references to objects.</p>

<p>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</p>

<p>When it comes to objects, objects themselves cannot be passed to methods. So we pass the reference(address) of the object. We can manipulate the original object using this reference.</p>

<p><strong>How Java creates and stores objects:</strong> When we create an object we store the objects address in a reference variable. Let's analyze the following statement.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Account</span> <span class="hljs-variable">account1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();
</code></pre>

<p>Account account1 is the type and name of the reference variable, = is the assignment operator, new asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right value, which is an expression called "class instance creation expression") is assigned to the left value (which is a reference variable with a name and a type specified) using the assign operator.</p>

<p>Although an objects reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the objects reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</p>

<p>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</p>

<p>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables "point" (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</p>

<p><a href="https://i.stack.imgur.com/sF7QZ.png" rel="noreferrer"><img src="https://i.stack.imgur.com/sF7QZ.png" alt="Pass by value example 1"></a></p>

<p>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a). </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array1)</span>
    {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>
    {
        <span class="hljs-type">int</span>[] array1 = { <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">7</span> };
        <span class="hljs-type">int</span>[] array2 = { <span class="hljs-number">5</span>, -<span class="hljs-number">190</span>, <span class="hljs-number">0</span> };

        reverseArray(array1);
    }
}
</code></pre>

<p><a href="https://i.stack.imgur.com/W1wgZ.png" rel="noreferrer"><img src="https://i.stack.imgur.com/W1wgZ.png" alt="Pass by value example 2"></a></p>

<p>So, if we say </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">array1[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;
</code></pre>

<p>in reverseArray method, it will make a change in array a.</p>

<p>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">array1 = array2;
</code></pre>

<p>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</p>

<p>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</p>

<p>So let's write all the things we have done at once now.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverseArray(<span class="hljs-type">int</span>[] array1)
    {
        <span class="hljs-type">int</span>[] array2 = { -<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> };

        array1[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">// array a becomes 5, 10, -7</span>

        array1 = array2; <span class="hljs-comment">/* array1 of reverseArray starts
          pointing to c instead of a (not shown in image below) */</span>
        <span class="hljs-keyword">return</span> array2;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>
    {
        <span class="hljs-type">int</span>[] array1 = { <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">7</span> };
        <span class="hljs-type">int</span>[] array2 = { <span class="hljs-number">5</span>, -<span class="hljs-number">190</span>, <span class="hljs-number">0</span> };

        array1 = reverseArray(array1); <span class="hljs-comment">/* array1 of 
         main starts pointing to c instead of a */</span>
    }
}
</code></pre>

<p><a href="https://i.stack.imgur.com/5hRyX.png" rel="noreferrer"><img src="https://i.stack.imgur.com/5hRyX.png" alt="enter image description here"></a></p>

<p>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</p>

<p>You could also assign value of array2 in main to array1. array1 would start pointing to b.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java has only pass by value. A very simple example to validate this.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
    <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    init(obj);
    <span class="hljs-comment">//After calling init method, obj still points to null</span>
    <span class="hljs-comment">//this is because obj is passed as value and not as reference.</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(MyClass objVar)</span> {
    objVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
}
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To make a long story short, <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="noreferrer">Java</a> objects have some very peculiar properties.</p>

<p>In general, Java has primitive types (<code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc) that are passed directly by value. Then Java has objects (everything that derives from <code>java.lang.Object</code>). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</p>

<p>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. <code>void foo(int x)</code> passes an int by value. <code>void foo(int *x)</code> is a function that does not want an <code>int a</code>, but a pointer to an int: <code>foo(&amp;a)</code>. One would use this with the <code>&amp;</code> operator to pass a variable address.</p>

<p>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: <code>void foo(int &amp;x)</code> is called by <code>foo(a)</code>, where the compiler itself knows that it is a reference and the address of the non-reference <code>a</code> should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have created a thread devoted to these kind of questions for <em>any</em> programming languages <a href="https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value">here</a>.</p>

<p><a href="https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028">Java is also mentioned</a>. Here is the short summary:</p>

<ul>
<li>Java passes it parameters by value</li>
<li>"by value" is the only way in java to pass a parameter to a method</li>
<li>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</li>
</ul>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Java is always \u0026lt;strong\u0026gt;pass-by-value\u0026lt;/strong\u0026gt;.  Unfortunately, when we deal with objects we are really dealing with object-handles called \u0026lt;em\u0026gt;references\u0026lt;/em\u0026gt; which are passed-by-value as well.  This terminology and semantics easily confuse many beginners.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It goes like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;aDog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;oldDog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; aDog;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// we pass the object to foo\u0026lt;/span\u0026gt;\n    foo(aDog);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// aDog variable is still pointing to the \u0026quot;Max\u0026quot; dog when foo(...) returns\u0026lt;/span\u0026gt;\n    aDog.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    aDog.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    aDog == oldDog; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Dog d)\u0026lt;/span\u0026gt; {\n    d.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// change d inside of foo() to point to a new Dog instance \u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;\n    d = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;);\n    d.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the example above \u0026lt;code\u0026gt;aDog.getName()\u0026lt;/code\u0026gt; will still return \u0026lt;code\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/code\u0026gt;. The value \u0026lt;code\u0026gt;aDog\u0026lt;/code\u0026gt; within \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; is not changed in the function \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; with the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/code\u0026gt; as the object reference is passed by value. If it were passed by reference, then the \u0026lt;code\u0026gt;aDog.getName()\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; would return \u0026lt;code\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/code\u0026gt; after the call to \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Likewise:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;aDog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;oldDog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; aDog;\n\n    foo(aDog);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when foo(...) returns, the name of the dog has been changed to \u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;\n    aDog.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but it is still the same dog:\u0026lt;/span\u0026gt;\n    aDog == oldDog; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Dog d)\u0026lt;/span\u0026gt; {\n    d.getName().equals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this changes the name of d to be \u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;\n    d.setName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the above example, \u0026lt;code\u0026gt;Fifi\u0026lt;/code\u0026gt; is the dog\u0026apos;s name after call to \u0026lt;code\u0026gt;foo(aDog)\u0026lt;/code\u0026gt; because the object\u0026apos;s name was set inside of \u0026lt;code\u0026gt;foo(...)\u0026lt;/code\u0026gt;. Any operations that \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; performs on \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; are such that, for all practical purposes, they are performed on \u0026lt;code\u0026gt;aDog\u0026lt;/code\u0026gt;, but it is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; possible to change the value of the variable \u0026lt;code\u0026gt;aDog\u0026lt;/code\u0026gt; itself.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For more information on pass by reference and pass by value, consult the following SO answer: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/430958/6005228\u0026quot;\u0026gt;https://stackoverflow.com/a/430958/6005228\u0026lt;/a\u0026gt;. This explains more thoroughly the semantics and history behind the two and also explains why Java and many other modern languages appear to do both in certain cases.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just noticed you referenced \u0026lt;a href=\u0026quot;http://javadude.com/articles/passbyvalue.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;my article\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The Java Spec says that everything in Java is pass-by-value. There is no such thing as \u0026quot;pass-by-reference\u0026quot; in Java.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The key to understanding this is that something like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Dog myDog;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a Dog; it\u0026apos;s actually a \u0026lt;em\u0026gt;pointer\u0026lt;/em\u0026gt; to a Dog. The use of the term \u0026quot;reference\u0026quot; in Java is very misleading and is what causes most of the confusion here. What they call \u0026quot;references\u0026quot; act/feel more like what we\u0026apos;d call \u0026quot;pointers\u0026quot; in most other languages.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What that means, is when you have\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;myDog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Rover\u0026quot;\u0026lt;/span\u0026gt;);\nfoo(myDog);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;you\u0026apos;re essentially passing the \u0026lt;em\u0026gt;address\u0026lt;/em\u0026gt; of the created \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; object to the \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; method.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(I say essentially because Java pointers/references aren\u0026apos;t direct addresses, but it\u0026apos;s easiest to think of them that way.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Suppose the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; object resides at memory address 42. This means we pass 42 to the method.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;if the Method were defined as\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Dog someDog)\u0026lt;/span\u0026gt; {\n    someDog.setName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Max\u0026quot;\u0026lt;/span\u0026gt;);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// AAA\u0026lt;/span\u0026gt;\n    someDog = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fifi\u0026quot;\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BBB\u0026lt;/span\u0026gt;\n    someDog.setName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Rowlf\u0026quot;\u0026lt;/span\u0026gt;);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// CCC\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;let\u0026apos;s look at what\u0026apos;s happening.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the parameter \u0026lt;code\u0026gt;someDog\u0026lt;/code\u0026gt; is set to the value 42\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;at line \u0026quot;AAA\u0026quot;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;someDog\u0026lt;/code\u0026gt; is followed to the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; it points to (the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; object at address 42)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; (the one at address 42) is asked to change his name to Max\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;at line \u0026quot;BBB\u0026quot;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a new \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; is created. Let\u0026apos;s say he\u0026apos;s at address 74\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;we assign the parameter \u0026lt;code\u0026gt;someDog\u0026lt;/code\u0026gt; to 74\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;at line \u0026quot;CCC\u0026quot;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;someDog is followed to the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; it points to (the \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; object at address 74)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; (the one at address 74) is asked to change his name to Rowlf\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;then, we return\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Now let\u0026apos;s think about what happens outside the method:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Did \u0026lt;code\u0026gt;myDog\u0026lt;/code\u0026gt; change?\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There\u0026apos;s the key.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Keeping in mind that \u0026lt;code\u0026gt;myDog\u0026lt;/code\u0026gt; is a \u0026lt;em\u0026gt;pointer\u0026lt;/em\u0026gt;, and not an actual \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt;, the answer is NO. \u0026lt;code\u0026gt;myDog\u0026lt;/code\u0026gt; still has the value 42; it\u0026apos;s still pointing to the original \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; (but note that because of line \u0026quot;AAA\u0026quot;, its name is now \u0026quot;Max\u0026quot; - still the same Dog; \u0026lt;code\u0026gt;myDog\u0026lt;/code\u0026gt;\u0026apos;s value has not changed.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s perfectly valid to \u0026lt;em\u0026gt;follow\u0026lt;/em\u0026gt; an address and change what\u0026apos;s at the end of it; that does not change the variable, however.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, the caller will not see any changes you make to where that pointer points. (In a language with pass-by-reference semantics, the method function \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; change the pointer and the caller will see that change.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If Java had pass-by-reference semantics, the \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; method we defined above would have changed where \u0026lt;code\u0026gt;myDog\u0026lt;/code\u0026gt; was pointing when it assigned \u0026lt;code\u0026gt;someDog\u0026lt;/code\u0026gt; on line BBB.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java always passes arguments \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;, NOT by reference.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Let me explain this through an \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/9404727/597657\u0026quot;\u0026gt;example\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Main\u0026lt;/span\u0026gt; {\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n          \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;f\u0026quot;\u0026lt;/span\u0026gt;);\n          changeReference(f); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// It won\u0026apos;t change the reference!\u0026lt;/span\u0026gt;\n          modifyReference(f); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// It will modify the object that the reference variable \u0026quot;f\u0026quot; refers to!\u0026lt;/span\u0026gt;\n     }\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeReference\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Foo a)\u0026lt;/span\u0026gt; {\n          \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;);\n          a = b;\n     }\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;modifyReference\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Foo c)\u0026lt;/span\u0026gt; {\n          c.setAttribute(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;);\n     }\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I will explain this in steps:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declaring a reference named \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; of type \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; and assign it a new object of type \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; with an attribute \u0026lt;code\u0026gt;\u0026quot;f\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;f\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/arXpP.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;From the method side, a reference of type \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; with a name \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is declared and it\u0026apos;s initially assigned \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeReference\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Foo a)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/k2LBD.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As you call the method \u0026lt;code\u0026gt;changeReference\u0026lt;/code\u0026gt;, the reference \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; will be assigned the object which is passed as an argument.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;changeReference(f);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/1Ez74.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declaring a reference named \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; of type \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; and assign it a new object of type \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; with an attribute \u0026lt;code\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Krx4N.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a = b\u0026lt;/code\u0026gt; makes a new assignment to the reference \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;, of the object whose attribute is \u0026lt;code\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/rCluu.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As you call \u0026lt;code\u0026gt;modifyReference(Foo c)\u0026lt;/code\u0026gt; method, a reference \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; is created and assigned the object with attribute \u0026lt;code\u0026gt;\u0026quot;f\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/PRZPg.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;c.setAttribute(\u0026quot;c\u0026quot;);\u0026lt;/code\u0026gt; will change the attribute of the object that reference \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; points to it, and it\u0026apos;s the same object that reference \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; points to it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/H9Qsf.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;I hope you understand now how passing objects as arguments works in Java :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java is always pass by value, with no exceptions, \u0026lt;strong\u0026gt;ever\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; provides direct access to the values of \u0026lt;em\u0026gt;objects themselves\u0026lt;/em\u0026gt;, in \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; circumstances. The only access to objects is through a \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; to that object. Because Java objects are \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; accessed through a reference, rather than directly, it is common to talk about fields and variables \u0026lt;em\u0026gt;and method arguments\u0026lt;/em\u0026gt; as being \u0026lt;em\u0026gt;objects\u0026lt;/em\u0026gt;, when pedantically they are only \u0026lt;em\u0026gt;references to objects\u0026lt;/em\u0026gt;. \u0026lt;strong\u0026gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, when calling a method\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;For primitive arguments (\u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt;, etc.), the pass by value is \u0026lt;em\u0026gt;the actual value\u0026lt;/em\u0026gt; of the primitive (for example, 3).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For objects, the pass by value is the value of \u0026lt;em\u0026gt;the reference to the object\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So if you have \u0026lt;code\u0026gt;doSomething(foo)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;public void doSomething(Foo foo) { .. }\u0026lt;/code\u0026gt; the two Foos have copied \u0026lt;em\u0026gt;references\u0026lt;/em\u0026gt; that point to the same objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you\u0026apos;ll just smile :-)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Step one please erase from your mind that word that starts with \u0026apos;p\u0026apos; \u0026quot;_ _ _ _ _ _ _\u0026quot;, especially if you come from other programming languages. Java and \u0026apos;p\u0026apos; cannot be written in the same book, forum, or even txt.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Step two remember that when you pass an Object into a method you\u0026apos;re passing the Object reference and not the Object itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Student\u0026lt;/em\u0026gt;: Master, does this mean that Java is pass-by-reference?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Master\u0026lt;/em\u0026gt;: Grasshopper, No.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Now think of what an Object\u0026apos;s reference/variable does/is:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When passing arguments to a method \u0026lt;strong\u0026gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable\u0026lt;/strong\u0026gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So you\u0026apos;re just passing 3bad086a that it\u0026apos;s the value of the reference.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You\u0026apos;re passing the value of the reference and not the reference itself (and not the object).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;This value is actually COPIED and given to the method\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. \u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;In the following (please don\u0026apos;t try to compile/execute this...):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt; Person person;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt; person = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tom\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.\u0026lt;/span\u0026gt; changeName(person);\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//I didn\u0026apos;t use Person person below as an argument to be nice\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Person anotherReferenceToTheSamePersonObject)\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7.\u0026lt;/span\u0026gt;     anotherReferenceToTheSamePersonObject.setName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Jerry\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8.\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What happens?\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The variable \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; is created in line #1 and it\u0026apos;s null at the beginning.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A new Person Object is created in line #2, stored in memory, and the variable \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; is given the reference to the Person object. That is, its address. Let\u0026apos;s say 3bad086a.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The variable \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; holding the address of the Object is passed to the function in line #3.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In line #4 you can listen to the sound of silence \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Check the comment on line #5\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A method local variable -\u0026lt;em\u0026gt;anotherReferenceToTheSamePersonObject\u0026lt;/em\u0026gt;- is created and then comes the magic in line #6:\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The variable/reference \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; is copied bit-by-bit and passed to \u0026lt;em\u0026gt;anotherReferenceToTheSamePersonObject\u0026lt;/em\u0026gt; inside the function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;No new instances of Person are created.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Both \u0026quot;\u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt;\u0026quot; and \u0026quot;\u0026lt;em\u0026gt;anotherReferenceToTheSamePersonObject\u0026lt;/em\u0026gt;\u0026quot; hold the same value of 3bad086a.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t try this but person==anotherReferenceToTheSamePersonObject would be true.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;A picture is worth a thousand words:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Ba3hJ.jpg\u0026quot; alt=\u0026quot;Pass by Value\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you didn\u0026apos;t get it then just trust me and remember that it\u0026apos;s better to say that \u0026lt;strong\u0026gt;Java is pass by value\u0026lt;/strong\u0026gt;. Well, \u0026lt;strong\u0026gt;pass by reference value\u0026lt;/strong\u0026gt;. Oh well, even better is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;pass-by-copy-of-the-variable-value! ;)\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now feel free to hate me but note that given this \u0026lt;strong\u0026gt;there is no difference between passing primitive data types and Objects\u0026lt;/strong\u0026gt; when talking about method arguments.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You always pass a copy of the bits of the value of the reference!\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If it\u0026apos;s a primitive data type these bits will contain the value of the primitive data type itself.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it\u0026apos;s an Object the bits will contain the value of the address that tells the JVM how to get to the Object.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you\u0026apos;ll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Of course you can cut it short and just say that  \u0026lt;strong\u0026gt;Java is pass-by-value!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java passes references by value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So you can\u0026apos;t change the reference that gets passed in.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I feel like arguing about \u0026quot;pass-by-reference vs pass-by-value\u0026quot; is not super-helpful.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you say, \u0026quot;Java is pass-by-whatever (reference/value)\u0026quot;, in either case, you\u0026apos;re not provide a complete answer. Here\u0026apos;s some additional information that will hopefully aid in understanding what\u0026apos;s happening in memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Crash course on stack/heap before we get to the Java implementation:\nValues go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.\nMemory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Okay. First off, local primitives go on the stack. So this code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;101.1f\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;amIAwesome\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results in this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/7nGKU.png\u0026quot; alt=\u0026quot;primitives on the stack\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word \u0026quot;pointer\u0026quot;. Whatever. Just know that the address of the object goes on the stack.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;problems\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Jay-Z\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/yTIYp.png\u0026quot; alt=\u0026quot;a b*7ch aint one!\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;JButton[] marxBros = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JButton\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\nmarxBros[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JButton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Groucho\u0026quot;\u0026lt;/span\u0026gt;);\nmarxBros[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JButton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Zeppo\u0026quot;\u0026lt;/span\u0026gt;);\nmarxBros[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JButton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Harpo\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/v2b33.png\u0026quot; alt=\u0026quot;marx brothers\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, what gets passed in when you call a method? If you pass in an object, what you\u0026apos;re actually passing in is the address of the object. Some might say the \u0026quot;value\u0026quot; of the address, and some say it\u0026apos;s just a reference to the object. This is the genesis of the holy war between \u0026quot;reference\u0026quot; and \u0026quot;value\u0026quot; proponents. What you call it isn\u0026apos;t as important as that you understand that what\u0026apos;s getting passed in is the address to the object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;shout\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String name)\u0026lt;/span\u0026gt;{\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There goes \u0026quot;\u0026lt;/span\u0026gt; + name + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;!\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;hisName\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John J. Jingleheimerschmitz\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;myName\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; hisName;\n    shout(myName);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier \u0026lt;code\u0026gt;hisName\u0026lt;/code\u0026gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call \u0026lt;code\u0026gt;shout()\u0026lt;/code\u0026gt;: a new stack frame is created and a new identifier, \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; is created and assigned the address of the already-existing String.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/q0prc.png\u0026quot; alt=\u0026quot;la da di da da da da\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, value, reference? You say \u0026quot;potato\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Basically, reassigning Object parameters doesn\u0026apos;t affect the argument, e.g.,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object bar)\u0026lt;/span\u0026gt; {\n    bar = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;baz\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hah!\u0026quot;\u0026lt;/span\u0026gt;;\n    foo(baz);\n    System.out.println(baz);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;will print out \u0026lt;code\u0026gt;\u0026quot;Hah!\u0026quot;\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;. The reason this works is because \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is a copy of the value of \u0026lt;code\u0026gt;baz\u0026lt;/code\u0026gt;, which is just a reference to \u0026lt;code\u0026gt;\u0026quot;Hah!\u0026quot;\u0026lt;/code\u0026gt;. If it were the actual reference itself, then \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; would have redefined \u0026lt;code\u0026gt;baz\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to show the contrast, compare the following \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C++\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java\u0026lt;/a\u0026gt; snippets:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C++: \u0026lt;strong\u0026gt;Note: Bad code - memory leaks!\u0026lt;/strong\u0026gt;  But it demonstrates the point.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cppMethod\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026amp;amp;ref, Dog obj, Dog \u0026amp;amp;objRef, Dog *objPtr, Dog *\u0026amp;amp;objPtrRef)\u0026lt;/span\u0026gt;\n{\n    val = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the copy\u0026lt;/span\u0026gt;\n    ref = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original variable\u0026lt;/span\u0026gt;\n    obj.SetName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;obj\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the copy of Dog passed\u0026lt;/span\u0026gt;\n    objRef.SetName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;objRef\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original Dog passed\u0026lt;/span\u0026gt;\n    objPtr-\u0026amp;gt;SetName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;objPtr\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original Dog pointed to \u0026lt;/span\u0026gt;\n                               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// by the copy of the pointer passed.\u0026lt;/span\u0026gt;\n    objPtr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;newObjPtr\u0026quot;\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the copy of the pointer, \u0026lt;/span\u0026gt;\n                                   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// leaving the original object alone.\u0026lt;/span\u0026gt;\n    objPtrRef-\u0026amp;gt;SetName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;objRefPtr\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original Dog pointed to \u0026lt;/span\u0026gt;\n                                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// by the original pointer passed. \u0026lt;/span\u0026gt;\n    objPtrRef = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;newObjPtrRef\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original pointer passed\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;d0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Dog(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d0\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;d1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Dog(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d1\u0026quot;\u0026lt;/span\u0026gt;);\n    Dog *d2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d2\u0026quot;\u0026lt;/span\u0026gt;);\n    Dog *d3 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d3\u0026quot;\u0026lt;/span\u0026gt;);\n    cppMethod(a, b, d0, d1, d2, d3);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a is still set to 0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b is now set to 7\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// d0 still have name \u0026quot;d0\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// d1 now has name \u0026quot;objRef\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// d2 now has name \u0026quot;objPtr\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// d3 now has name \u0026quot;newObjPtrRef\u0026quot;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In Java, \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;javaMethod\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val, Dog objPtr)\u0026lt;/span\u0026gt;\n{\n   val = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the copy\u0026lt;/span\u0026gt;\n   objPtr.SetName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;objPtr\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the original Dog pointed to \u0026lt;/span\u0026gt;\n                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// by the copy of the pointer passed.\u0026lt;/span\u0026gt;\n   objPtr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;newObjPtr\u0026quot;\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Modifies the copy of the pointer, \u0026lt;/span\u0026gt;\n                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// leaving the original object alone.\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;d0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d0\u0026quot;\u0026lt;/span\u0026gt;);\n    javaMethod(a, d0);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a is still set to 0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// d0 now has name \u0026quot;objPtr\u0026quot;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java passes references to objects by value.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I can\u0026apos;t believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term \u0026lt;em\u0026gt;call by sharing\u0026lt;/em\u0026gt; (also known as \u0026lt;em\u0026gt;call by object-sharing\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;call by object\u0026lt;/em\u0026gt;) for this specific case of \u0026quot;call by value where the value is a reference\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The crux of the matter is that the word \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; in the expression \u0026quot;pass by reference\u0026quot; means something completely different from the usual meaning of the word \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; in Java. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usually in Java \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; means a a \u0026lt;em\u0026gt;reference to an object\u0026lt;/em\u0026gt;. But the technical terms \u0026lt;em\u0026gt;pass by reference/value\u0026lt;/em\u0026gt; from programming language theory is talking about a \u0026lt;em\u0026gt;reference to the memory cell holding the variable\u0026lt;/em\u0026gt;, which is something completely different.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In java everything is reference, so when you have something like:\n    \u0026lt;code\u0026gt;Point pnt1 = new Point(0,0);\u0026lt;/code\u0026gt; Java does following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Creates new Point object\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Creates new Point reference and initialize that reference to \u0026lt;em\u0026gt;point (refer to)\u0026lt;/em\u0026gt; on previously created Point object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;From here, through Point object life, you will access to that object through pnt1\n reference. So we can say that in Java you manipulate object through its reference.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/jM54f.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Java doesn\u0026apos;t pass method arguments by reference; it passes them by value.\u0026lt;/strong\u0026gt; I will use example from \u0026lt;a href=\u0026quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this site\u0026lt;/a\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tricky\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Point arg1, Point arg2)\u0026lt;/span\u0026gt; {\n  arg1.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n  arg1.y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;temp\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; arg1;\n  arg1 = arg2;\n  arg2 = temp;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String [] args)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;pnt1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;pnt2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X1: \u0026quot;\u0026lt;/span\u0026gt; + pnt1.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y1: \u0026quot;\u0026lt;/span\u0026gt; +pnt1.y); \n  System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X2: \u0026quot;\u0026lt;/span\u0026gt; + pnt2.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y2: \u0026quot;\u0026lt;/span\u0026gt; +pnt2.y);\n  System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n  tricky(pnt1,pnt2);\n  System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X1: \u0026quot;\u0026lt;/span\u0026gt; + pnt1.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y1:\u0026quot;\u0026lt;/span\u0026gt; + pnt1.y); \n  System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X2: \u0026quot;\u0026lt;/span\u0026gt; + pnt2.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y2: \u0026quot;\u0026lt;/span\u0026gt; +pnt2.y);  \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Flow of the program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;pnt1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;pnt2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creating two different Point object with two different reference associated.\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/5LIKC.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X1: \u0026quot;\u0026lt;/span\u0026gt; + pnt1.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y1: \u0026quot;\u0026lt;/span\u0026gt; +pnt1.y); \nSystem.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;X2: \u0026quot;\u0026lt;/span\u0026gt; + pnt2.x + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; Y2: \u0026quot;\u0026lt;/span\u0026gt; +pnt2.y);\nSystem.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As expected output will be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;X1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;     Y1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nX2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;     Y2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;On this line \u0026apos;pass-by-value\u0026apos; goes into the play...\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;tricky(pnt1,pnt2);           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tricky\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Point arg1, Point arg2)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;References \u0026lt;code\u0026gt;pnt1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;pnt2\u0026lt;/code\u0026gt; are \u0026lt;strong\u0026gt;passed by value\u0026lt;/strong\u0026gt; to the tricky method, which means that now yours references \u0026lt;code\u0026gt;pnt1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;pnt2\u0026lt;/code\u0026gt; have their \u0026lt;code\u0026gt;copies\u0026lt;/code\u0026gt; named \u0026lt;code\u0026gt;arg1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;arg2\u0026lt;/code\u0026gt;.So \u0026lt;code\u0026gt;pnt1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;arg1\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;points\u0026lt;/em\u0026gt; to the same object. (Same for the \u0026lt;code\u0026gt;pnt2\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;arg2\u0026lt;/code\u0026gt;)\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/qd1GH.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the \u0026lt;code\u0026gt;tricky\u0026lt;/code\u0026gt; method:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt; arg1.x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n arg1.y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/o4WT0.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Next in the \u0026lt;code\u0026gt;tricky\u0026lt;/code\u0026gt; method\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Point\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;temp\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; arg1;\narg1 = arg2;\narg2 = temp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, you first create new \u0026lt;code\u0026gt;temp\u0026lt;/code\u0026gt; Point reference which will \u0026lt;em\u0026gt;point\u0026lt;/em\u0026gt; on same place like \u0026lt;code\u0026gt;arg1\u0026lt;/code\u0026gt; reference. Then you move reference \u0026lt;code\u0026gt;arg1\u0026lt;/code\u0026gt; to \u0026lt;em\u0026gt;point\u0026lt;/em\u0026gt; to the same place like \u0026lt;code\u0026gt;arg2\u0026lt;/code\u0026gt; reference.\nFinally \u0026lt;code\u0026gt;arg2\u0026lt;/code\u0026gt; will \u0026lt;em\u0026gt;point\u0026lt;/em\u0026gt; to the same place like \u0026lt;code\u0026gt;temp\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/fX5Q3.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From here scope of \u0026lt;code\u0026gt;tricky\u0026lt;/code\u0026gt; method is gone and you don\u0026apos;t have access any more to the references: \u0026lt;code\u0026gt;arg1\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;arg2\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;temp\u0026lt;/code\u0026gt;. \u0026lt;strong\u0026gt;But important note is that everything you do with these references when they are \u0026apos;in life\u0026apos; will permanently affect object on which they are \u0026lt;em\u0026gt;point\u0026lt;/em\u0026gt; to.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So after executing method \u0026lt;code\u0026gt;tricky\u0026lt;/code\u0026gt;, when you return to \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;, you have this situation:\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/LRETe.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So now, completely execution of program will be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;X1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;         Y1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nX2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;         Y2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nX1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;       Y1: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\nX2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;         Y2: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Java is always pass by value, not pass by reference\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First of all, we need to understand what pass by value and pass by reference are.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass by value means that you are making a copy in memory of the actual parameter\u0026apos;s value that is passed in. This is a copy of the contents of the actual parameter\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Sometimes Java can give the illusion of pass by reference. Let\u0026apos;s see how it works by using the example below:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValue\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;();\n        t.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;initialvalue\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValue\u0026lt;/span\u0026gt;().changeValue(t);\n        System.out.println(t.name);\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Test f)\u0026lt;/span\u0026gt; {\n        f.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;changevalue\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; {\n    String name;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The output of this program is:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;changevalue\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s understand step by step:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is \u0026lt;code\u0026gt;0x100234\u0026lt;/code\u0026gt; (we don\u0026apos;t know the actual JVM internal value, this is just an example) .\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/AVrhI.png\u0026quot; alt=\u0026quot;first illustration\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValue\u0026lt;/span\u0026gt;().changeValue(t);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is \u0026lt;strong\u0026gt;passing by value\u0026lt;/strong\u0026gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was \u0026lt;code\u0026gt;0x100234\u0026lt;/code\u0026gt;, both t and f will have the same value and hence they will point to the same object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/WwdPh.png\u0026quot; alt=\u0026quot;second illustration\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output \u0026lt;code\u0026gt;changevalue\u0026lt;/code\u0026gt;,   which is updated in the function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To understand this more clearly, consider the following example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValue\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;();\n        t.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;initialvalue\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValue\u0026lt;/span\u0026gt;().changeRefence(t);\n        System.out.println(t.name);\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeRefence\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Test f)\u0026lt;/span\u0026gt; {\n        f = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; {\n    String name;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Will this throw a \u0026lt;code\u0026gt;NullPointerException\u0026lt;/code\u0026gt;? No, because it only passes a copy of the reference.\nIn the case of passing by reference, it could have thrown a \u0026lt;code\u0026gt;NullPointerException\u0026lt;/code\u0026gt;, as seen below:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/jH6KP.png\u0026quot; alt=\u0026quot;third illustration\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Hopefully this will help.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are already great answers that cover this. I wanted to make a small contribution by sharing a \u0026lt;strong\u0026gt;very simple example\u0026lt;/strong\u0026gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A few points:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The term \u0026quot;reference\u0026quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of \u0026quot;Pass-by-reference\u0026quot; it means a handle to the original variable which was passed in.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Java is Pass-by-value\u0026lt;/strong\u0026gt;. Java is a descendent of C (among other languages). Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. PBR allowed these other languages to make changes to the passed variables inside sub-routines. In order to accomplish the same thing (i.e. change the values of variables inside functions), C programmers passed pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to pass pointer to methods as C did, except that Java calls its pointers References. Again, this is a different use of the word \u0026quot;Reference\u0026quot; than in \u0026quot;Pass-By-Reference\u0026quot;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++ allows Pass-by-reference\u0026lt;/strong\u0026gt; by declaring a reference parameter using the \u0026quot;\u0026amp;amp;\u0026quot; character (which happens to be the same character used to indicate \u0026quot;the address of a variable\u0026quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the C++ example below I\u0026apos;m passing a \u0026lt;strong\u0026gt;pointer\u0026lt;/strong\u0026gt; to a null terminated string \u0026lt;strong\u0026gt;by reference\u0026lt;/strong\u0026gt;. And in the Java example below I\u0026apos;m passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;C++ pass by reference example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;using namespace std;\n#include \u0026amp;lt;iostream\u0026amp;gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026amp;amp;str)\u0026lt;/span\u0026gt;{   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the \u0026apos;\u0026amp;amp;\u0026apos; makes this a reference parameter\u0026lt;/span\u0026gt;\n    str = NULL;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;not Null\u0026quot;\u0026lt;/span\u0026gt;;\n    change(str);\n    cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;str is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; str;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ==\u0026amp;gt;str is \u0026amp;lt;null\u0026amp;gt;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Java pass \u0026quot;a Java reference\u0026quot; by value example\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueDemo\u0026lt;/span\u0026gt;{\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String str)\u0026lt;/span\u0026gt;{\n        str = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    }\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String []args)\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ValueDemo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;vd\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueDemo\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;not null\u0026quot;\u0026lt;/span\u0026gt;;\n        vd.change(str);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;str is \u0026quot;\u0026lt;/span\u0026gt; + str);    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ==\u0026amp;gt; str is not null!!\u0026lt;/span\u0026gt;\n                                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note that if \u0026quot;str\u0026quot; was\u0026lt;/span\u0026gt;\n                                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// passed-by-reference, it\u0026lt;/span\u0026gt;\n                                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// WOULD BE NULL after the\u0026lt;/span\u0026gt;\n                                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call to change().\u0026lt;/span\u0026gt;\n     }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Several people have written comments which seem to indicate that either they are not looking at my examples or they don\u0026apos;t get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I\u0026apos;m posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In pascal, parameters passed-by-reference are called \u0026quot;var parameters\u0026quot;. In the procedure setToNil below, please note the keyword \u0026apos;var\u0026apos; which precedes the parameter \u0026apos;ptr\u0026apos;. When a pointer is passed to this procedure, it will be passed \u0026lt;strong\u0026gt;by reference\u0026lt;/strong\u0026gt;. Note the behavior: when this procedure sets ptr to nil (that\u0026apos;s pascal speak for NULL), it will set the argument to nil--you can\u0026apos;t do that in Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;program passByRefDemo;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt; \n   \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;iptr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; ^integer;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt;\n   ptr: iptr;\n\n   procedure \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setToNil\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ptr : iptr)\u0026lt;/span\u0026gt;;\n   begin\n       ptr := nil;\n   end;\n\nbegin\n   \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ptr)\u0026lt;/span\u0026gt;;\n   ptr^ := \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n   setToNil(ptr);\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ptr = nil) then\n       \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;writeln\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;ptr seems to be nil\u0026apos;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;     { ptr should be nil, so \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; line will run. }\nend.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT 2\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some excerpts from \u0026lt;strong\u0026gt;\u0026quot;THE Java Programming Language\u0026quot;\u0026lt;/strong\u0026gt; by Ken Arnold, \u0026lt;strong\u0026gt;James Gosling (the guy who invented Java)\u0026lt;/strong\u0026gt;, and David Holmes, chapter 2, section 2.6.5\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;All parameters to methods are passed \u0026quot;by value\u0026quot;\u0026lt;/strong\u0026gt;. In other words,\n  values of parameter variables in a method are copies of the invoker\n  specified as arguments.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;He goes on to make the same point regarding objects . . . \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;You should note that when the parameter is an object reference, it is\n  the object reference-not the object itself-that is \u0026lt;strong\u0026gt;passed \u0026quot;by value\u0026quot;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The Java programming language \u0026lt;strong\u0026gt;does not pass objects by reference; it\u0026lt;/strong\u0026gt;\n  \u0026lt;strong\u0026gt;passes object references by value\u0026lt;/strong\u0026gt;. Because two copies of the same\n  reference refer to the same actual object, changes made through one\n  reference variable are visible through the other. There is exactly one\n  parameter passing mode-\u0026lt;strong\u0026gt;pass by value\u0026lt;/strong\u0026gt;-and that helps keep things\n  simple.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it\u0026apos;s by the creator of Java. I would encourage anyone to read it, especially if you\u0026apos;re still not convinced.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think the difference between the two models is very subtle and unless you\u0026apos;ve done programming where you actually used pass-by-reference, it\u0026apos;s easy to miss where two models differ.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this settles the debate, but probably won\u0026apos;t.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT 3\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word \u0026quot;reference\u0026quot; for pointers they had used something else, say \ndingleberry, there would\u0026apos;ve been no problem. You could say, \u0026quot;Java passes dingleberries by value and not by reference\u0026quot;, and nobody would be confused.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s the reason only Java developers have issue with this. They look at the word \u0026quot;reference\u0026quot; and think they know exactly what that means, so they don\u0026apos;t even bother to consider the opposing argument.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Anyway, I noticed a comment in an older post, which made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Passing a reference by value\u0026lt;/strong\u0026gt;--Changes to the reference are not reflected in the caller\u0026apos;s scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/RvkqU.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/RvkqU.png\u0026quot; alt=\u0026quot;Passing Object references By Value\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass by reference\u0026lt;/strong\u0026gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object\u0026apos;s data are reflected in the caller\u0026apos;s scope.\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/SHXkC.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/SHXkC.png\u0026quot; alt=\u0026quot;Pass by reference\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT 4\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about \u0026lt;strong\u0026gt;the behavior described in the language specification\u0026lt;/strong\u0026gt; than about the technical implementation of the behavior. This is an exerpt from the \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java Language Specification, section 8.4.1\u0026lt;/a\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When the method or constructor is invoked (ยง15.12), \u0026lt;strong\u0026gt;the values of the\n  actual argument expressions initialize newly created parameter\n  variables, each of the declared type, before execution of the body of\n  the method or constructor.\u0026lt;/strong\u0026gt; The Identifier that appears in the\n  DeclaratorId may be used as a simple name in the body of the method or\n  constructor to refer to the formal parameter.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201100886\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;The Dragon Book\u0026quot;\u0026lt;/a\u0026gt; which is \u0026lt;strong\u0026gt;THE\u0026lt;/strong\u0026gt; compilers book. It has a good description of \u0026quot;Call-by-value\u0026quot; and \u0026quot;Call-by-Reference\u0026quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Back when I studied compilers-in the 90\u0026apos;s, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;2nd Eddition\u0026lt;/a\u0026gt; from 2007 \u0026lt;strong\u0026gt;which actually mentions Java!\u0026lt;/strong\u0026gt; Section 1.6.6 labeled \u0026quot;Parameter Passing Mechanisms\u0026quot; describes parameter passing pretty nicely. Here is an excerpt under the heading \u0026quot;Call-by-value\u0026quot; which mentions Java:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In call-by-value, the actual parameter is evaluated (if it is an\n  expression) or copied (if it is a variable). The value is placed in\n  the location belonging to the corresponding formal parameter of the\n  called procedure. \u0026lt;strong\u0026gt;This method is used in C and Java, and is a common\n  option in C++ , as well as in most other languages.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java is a pass by value(stack memory)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;How it works\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Let\u0026apos;s first understand that where java stores primitive data type and object data type.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Primitive data types itself and object references are stored in the stack.\nObjects themselves are stored in the heap.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It means, Stack memory stores primitive data types and also the\naddresses of objects.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;And you always pass a copy of the bits of the value of the reference.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If it\u0026apos;s a primitive data type then these copied bits contain the value of the primitive data type itself, That\u0026apos;s why when we change the value of argument inside the method then it does not reflect the changes outside.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If it\u0026apos;s an object data type like \u0026lt;strong\u0026gt;Foo foo=new Foo()\u0026lt;/strong\u0026gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file \u0026lt;strong\u0026gt;abc.txt\u0026lt;/strong\u0026gt; at \u0026lt;strong\u0026gt;C:\\desktop\u0026lt;/strong\u0026gt; and suppose we make shortcut of the same file and put this inside \u0026lt;strong\u0026gt;C:\\desktop\\abc-shortcut\u0026lt;/strong\u0026gt; so when you access the file from \u0026lt;strong\u0026gt;C:\\desktop\\abc.txt\u0026lt;/strong\u0026gt; and write \u0026lt;strong\u0026gt;\u0026apos;Stack Overflow\u0026apos;\u0026lt;/strong\u0026gt; and close the file and again you open the file from shortcut then you write \u0026lt;strong\u0026gt;\u0026apos; is the largest online community for programmers to learn\u0026apos;\u0026lt;/strong\u0026gt; then total file change will be \u0026lt;strong\u0026gt;\u0026apos;Stack Overflow is the largest online community for programmers to learn\u0026apos;\u0026lt;/strong\u0026gt; which means it doesn\u0026apos;t matter from where you open the file , each time we were accessing the same file , here we can assume \u0026lt;strong\u0026gt;Foo\u0026lt;/strong\u0026gt; as a file and suppose foo stored at \u0026lt;strong\u0026gt;123hd7h\u0026lt;/strong\u0026gt;(original address like \u0026lt;strong\u0026gt;C:\\desktop\\abc.txt\u0026lt;/strong\u0026gt; ) address and \u0026lt;strong\u0026gt;234jdid\u0026lt;/strong\u0026gt;(copied address like \u0026lt;strong\u0026gt;C:\\desktop\\abc-shortcut\u0026lt;/strong\u0026gt; which actually contains the original address of the file inside) ..\nSo for better understanding make shortcut file and feel.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;A reference is always a value when represented, no matter what language you use.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Getting an outside of the box view, let\u0026apos;s look at Assembly or some low level memory management. At the CPU level a \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; to anything immediately becomes a \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; if it gets written to memory or to one of the CPU registers. (That is why \u0026lt;em\u0026gt;pointer\u0026lt;/em\u0026gt; is a good definition. It is a value, which has a purpose at the same time).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Data in memory has a \u0026lt;strong\u0026gt;Location\u0026lt;/strong\u0026gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a \u0026lt;strong\u0026gt;Name\u0026lt;/strong\u0026gt; to certain \u0026lt;strong\u0026gt;Location\u0026lt;/strong\u0026gt; (aka variable), but when compiling the code, the assembler simply replaces \u0026lt;strong\u0026gt;Name\u0026lt;/strong\u0026gt; with the designated location just like your browser replaces domain names with IP addresses.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lets say we have a variable Foo, its \u0026lt;strong\u0026gt;Location\u0026lt;/strong\u0026gt; is at the 47th byte in memory and its \u0026lt;strong\u0026gt;Value\u0026lt;/strong\u0026gt; is 5. We have another variable \u0026lt;strong\u0026gt;Ref2Foo\u0026lt;/strong\u0026gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two \u0026lt;strong\u0026gt;Values\u0026lt;/strong\u0026gt;.\nIf you use them as references then to reach to \u0026lt;code\u0026gt;5\u0026lt;/code\u0026gt; we have to travel:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;(Name)[Location] -\u0026amp;gt; [Value at the Location]\n---------------------\n(Ref2Foo)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;223\u0026lt;/span\u0026gt;]  -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;47\u0026lt;/span\u0026gt;\n(Foo)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;47\u0026lt;/span\u0026gt;]       -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is how jump-tables work. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we want to call a method/function/procedure with Foo\u0026apos;s value, there are a few possible way to pass the variable to the method, depending on the \u0026lt;strong\u0026gt;language\u0026lt;/strong\u0026gt; and its several method invocation modes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;5 gets copied to one of the CPU registers (ie. EAX).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;5 gets PUSHd to the stack.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;47 gets copied to one of the CPU registers\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;47 PUSHd to the stack.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;223 gets copied to one of the CPU registers.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;223 gets PUSHd to the stack.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;In every cases above a value - a \u0026lt;strong\u0026gt;copy\u0026lt;/strong\u0026gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write \u0026quot;Foo\u0026quot; inside the method, it is either read out from EAX, or automatically  \u0026lt;strong\u0026gt;dereferenced\u0026lt;/strong\u0026gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; is a \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; when represented, because a reference is a value that has to be processed (at language level).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now we have passed Foo to the method:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;in case 1. and 2. if you change Foo (\u0026lt;code\u0026gt;Foo = 9\u0026lt;/code\u0026gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;in case 3. and 4. if you use default language constructs and change Foo (\u0026lt;code\u0026gt;Foo = 11\u0026lt;/code\u0026gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal\u0026apos;s \u0026lt;code\u0026gt;procedure findMin(x, y, z: integer;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;var m\u0026lt;/strong\u0026gt;\u0026lt;code\u0026gt;: integer);\u0026lt;/code\u0026gt;). However if the language allows you to circumvent the dereference process, you can change \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt;, say to \u0026lt;code\u0026gt;49\u0026lt;/code\u0026gt;. At that point Foo seems to have been changed if you read it, because you have changed the \u0026lt;strong\u0026gt;local pointer\u0026lt;/strong\u0026gt; to it. And if you were to modify this Foo inside the method (\u0026lt;code\u0026gt;Foo = 12\u0026lt;/code\u0026gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt;). BUT Foo\u0026apos;s value of \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt; did not change globally, only the one inside the method, because \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt; was also a copy to the method.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;in case 5. and 6. if you modify \u0026lt;code\u0026gt;223\u0026lt;/code\u0026gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was \u0026lt;strong\u0026gt;copied\u0026lt;/strong\u0026gt;. However if you are able to dereference \u0026lt;code\u0026gt;Ref2Foo\u0026lt;/code\u0026gt; (that is \u0026lt;code\u0026gt;223\u0026lt;/code\u0026gt;), reach to and modify the pointed value \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt;, say, to \u0026lt;code\u0026gt;49\u0026lt;/code\u0026gt;, it will affect Foo \u0026lt;strong\u0026gt;globally\u0026lt;/strong\u0026gt;, because in this case the methods got a copy of \u0026lt;code\u0026gt;223\u0026lt;/code\u0026gt;  but the referenced \u0026lt;code\u0026gt;47\u0026lt;/code\u0026gt; exists only once, and changing that to \u0026lt;code\u0026gt;49\u0026lt;/code\u0026gt; will lead every \u0026lt;code\u0026gt;Ref2Foo\u0026lt;/code\u0026gt; double-dereferencing to a wrong value.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only \u0026lt;em\u0026gt;pass-by-reference\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Strict \u0026lt;em\u0026gt;pass-by-value\u0026lt;/em\u0026gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller\u0026apos;s view) and a few languages allows to modify the Value of the reference itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So in short and in Java\u0026apos;s own terminology, Java is \u0026lt;em\u0026gt;pass-by-value\u0026lt;/em\u0026gt; where \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; can be: either a \u0026lt;strong\u0026gt;real value\u0026lt;/strong\u0026gt; or a \u0026lt;strong\u0026gt;value\u0026lt;/strong\u0026gt; that is a representation of a \u0026lt;strong\u0026gt;reference\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In Java, method arguments are all passed by value :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Java arguments are \u0026lt;strong\u0026gt;all passed by value\u0026lt;/strong\u0026gt; (the value  or reference is copied when used by the method) :\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of primitive types, Java behaviour is simple:\nThe value is copied in another instance of the primitive type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In case of Objects, this is the same:\nObject variables are references (mem buckets holding only Objects \u0026lt;strong\u0026gt;address\u0026lt;/strong\u0026gt; instead of a primitive value) that was created using the \u0026quot;new\u0026quot; keyword, and are copied like primitive types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).\nObject\u0026apos;s \u0026lt;strong\u0026gt;content/members\u0026lt;/strong\u0026gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;String\u0026quot; Objects appear to be a good \u0026lt;strong\u0026gt;counter-example\u0026lt;/strong\u0026gt; to the urban legend saying that \u0026quot;Objects are passed by reference\u0026quot;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In effect, using a method, you will never be able, to update the value of a String passed as argument:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A String Object, holds characters by an array declared \u0026lt;strong\u0026gt;final\u0026lt;/strong\u0026gt; that can\u0026apos;t be modified.\nOnly the address of the Object might be replaced by another using \u0026quot;new\u0026quot;.\nUsing \u0026quot;new\u0026quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(StringBuffer s1, StringBuffer s2)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;temp\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; s1;\n    s1 = s2;\n    s2 = temp;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;World\u0026quot;\u0026lt;/span\u0026gt;);\n    swap(s1, s2);\n    System.out.println(s1);\n    System.out.println(s2);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;appendWorld\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(StringBuffer s1)\u0026lt;/span\u0026gt; {\n    s1.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; World\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;);\n    appendWorld(s);\n    System.out.println(s);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;appendWorld\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String s)\u0026lt;/span\u0026gt;{\n    s = s+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; World\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;);\n    appendWorld(s);\n    System.out.println(s);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However you could make a wrapper for String like this which would make it able to use it with Strings:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringWrapper\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String value;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;StringWrapper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String value)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.value = value;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;appendWorld\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(StringWrapper s)\u0026lt;/span\u0026gt;{\n    s.value = s.value +\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; World\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringWrapper\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringWrapper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;);\n    appendWorld(s);\n    System.out.println(s.value);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;edit: i believe this is also the reason to use StringBuffer when it comes to \u0026quot;adding\u0026quot; two Strings because you can modifie the original object which u can\u0026apos;t with immutable objects like String is.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;No, it\u0026apos;s not pass by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Java is pass by value according to the Java Language Specification:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When the method or constructor is invoked (ยง15.12), \u0026lt;strong\u0026gt;the values of the actual argument expressions initialize newly created parameter variables\u0026lt;/strong\u0026gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;formal parameter\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;/**\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Pass By Value\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;*/\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example 1:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueString\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueString\u0026lt;/span\u0026gt;().caller();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Nikhil\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;valueflag\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; method(value, valueflag);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n         * \u0026apos;output\u0026apos; is insignificant in this example. we are more interested in\n         * \u0026apos;value\u0026apos; and \u0026apos;valueflag\u0026apos;\n         */\u0026lt;/span\u0026gt;\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output : \u0026quot;\u0026lt;/span\u0026gt; + output);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value : \u0026quot;\u0026lt;/span\u0026gt; + value);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;valueflag : \u0026quot;\u0026lt;/span\u0026gt; + valueflag);\n\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String value, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; valueflag)\u0026lt;/span\u0026gt; {\n        value = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Anand\u0026quot;\u0026lt;/span\u0026gt;;\n        valueflag = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;output : output\nvalue : Nikhil\nvalueflag : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example 2:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;/**\n * \n * Pass By Value\n *\n */\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueNewString\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueNewString\u0026lt;/span\u0026gt;().caller();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Nikhil\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;valueflag\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; method(value, valueflag);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n         * \u0026apos;output\u0026apos; is insignificant in this example. we are more interested in\n         * \u0026apos;value\u0026apos; and \u0026apos;valueflag\u0026apos;\n         */\u0026lt;/span\u0026gt;\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output : \u0026quot;\u0026lt;/span\u0026gt; + output);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value : \u0026quot;\u0026lt;/span\u0026gt; + value);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;valueflag : \u0026quot;\u0026lt;/span\u0026gt; + valueflag);\n\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String value, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; valueflag)\u0026lt;/span\u0026gt; {\n        value = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Anand\u0026quot;\u0026lt;/span\u0026gt;;\n        valueflag = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;output : output\nvalue : Nikhil\nvalueflag : \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example 3:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;/**\n  This \u0026apos;Pass By Value has a feeling of \u0026apos;Pass By Reference\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some people say primitive types and \u0026apos;String\u0026apos; are \u0026apos;pass by value\u0026apos;\n  and objects are \u0026apos;pass by reference\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But from this example, we can understand that it is infact pass by value only,\n  keeping in mind that here we are passing the reference as the value.\n  ie: reference is passed by value.\n  That\u0026apos;s why are able to change and still it holds true after the local scope.\n  But we cannot change the actual reference outside the original scope.\n  what that means is demonstrated by next example of PassByValueObjectCase2.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;*/\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueObjectCase1\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; id;\n        String name;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; id, String name)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.id = id;\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.name = name;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getId\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; id;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setId\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; id)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.id = id;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; name;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String name)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.name = name;\n        }\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Student [id=\u0026quot;\u0026lt;/span\u0026gt; + id + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, name=\u0026quot;\u0026lt;/span\u0026gt; + name + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;]\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueObjectCase1\u0026lt;/span\u0026gt;().caller();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;student\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Nikhil\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; method(student);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n         * \u0026apos;output\u0026apos; is insignificant in this example. we are more interested in\n         * \u0026apos;student\u0026apos;\n         */\u0026lt;/span\u0026gt;\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output : \u0026quot;\u0026lt;/span\u0026gt; + output);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;student : \u0026quot;\u0026lt;/span\u0026gt; + student);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Student student)\u0026lt;/span\u0026gt; {\n        student.setName(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Anand\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;output : output\nstudent : Student [id=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, name=Anand]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example 4:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;/**\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note: I am not pasting the code for \u0026lt;code\u0026gt;private class Student\u0026lt;/code\u0026gt;. The class definition for \u0026lt;code\u0026gt;Student\u0026lt;/code\u0026gt; is same as Example3.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;*/\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueObjectCase2\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByValueObjectCase2\u0026lt;/span\u0026gt;().caller();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// student has the actual reference to a Student object created\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// can we change this actual reference outside the local scope? Let\u0026apos;s see\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;student\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Nikhil\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;output\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; method(student);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n         * \u0026apos;output\u0026apos; is insignificant in this example. we are more interested in\n         * \u0026apos;student\u0026apos;\n         */\u0026lt;/span\u0026gt;\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output : \u0026quot;\u0026lt;/span\u0026gt; + output);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;student : \u0026quot;\u0026lt;/span\u0026gt; + student); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Will it print Nikhil or Anand?\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Student student)\u0026lt;/span\u0026gt; {\n        student = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Student\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Anand\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;output\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;output : output\nstudent : Student [id=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, name=Nikhil]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I thought I\u0026apos;d contribute this answer to add more details from the Specifications.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value\u0026quot;\u0026gt;What\u0026apos;s the difference between passing by reference vs. passing by value?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Passing by reference means the called functions\u0026apos; parameter will be the\nsame as the callers\u0026apos; passed argument (not the value, but the identity\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the variable itself).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Pass by value means the called functions\u0026apos; parameter will be a copy of\nthe callers\u0026apos; passed argument.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Or from wikipedia, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;on the subject of pass-by-reference\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In call-by-reference evaluation (also referred to as\npass-by-reference), a function receives an implicit reference to a\nvariable used as argument, rather than a copy of its value. This\ntypically means that the function can modify (i.e. assign to) the\nvariable used as argumentsomething that will be seen by its caller.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;And \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;on the subject of pass-by-value\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In call-by-value, the argument expression is evaluated, and the\nresulting value is bound to the corresponding variable in the function [...].\nIf the function or procedure is able to assign values to its\nparameters, only its local copy is assigned [...].\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Second, we need to know what Java uses in its method invocations. The \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Java Language Specification\u0026lt;/a\u0026gt; states\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;When the method or constructor is invoked (ยง15.12), \u0026lt;strong\u0026gt;the values of the\nactual argument expressions initialize newly created parameter\nvariables\u0026lt;/strong\u0026gt;, each of the declared type, before execution of the body of\nthe method or constructor.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;So it assigns (or binds) the value of the argument to the corresponding parameter variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is the value of the argument?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s consider reference types, the \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Java Virtual Machine Specification\u0026lt;/a\u0026gt; states\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;There are three kinds of \u0026lt;strong\u0026gt;reference types\u0026lt;/strong\u0026gt;: class types, array types,\nand interface types. \u0026lt;strong\u0026gt;Their values are references to dynamically\ncreated class instances, arrays, or class instances or arrays that\nimplement interfaces, respectively.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Java Language Specification\u0026lt;/a\u0026gt; also states\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The reference values (often just references) are pointers to these objects\u0026lt;/strong\u0026gt;, and a special null reference, which refers to no object.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (\u0026lt;code\u0026gt;new ...\u0026lt;/code\u0026gt;) all resolve to a reference type value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String param)\u0026lt;/span\u0026gt; {}\n...\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;variable\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ref\u0026quot;\u0026lt;/span\u0026gt;);\nmethod(variable);\nmethod(variable.toString());\nmethod(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ref\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;all bind the value of a reference to a \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; instance to the method\u0026apos;s newly created parameter, \u0026lt;code\u0026gt;param\u0026lt;/code\u0026gt;. This is exactly what the definition of pass-by-value describes. As such, \u0026lt;strong\u0026gt;Java is pass-by-value\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.\u0026lt;/strong\u0026gt; The definition of pass-by-reference was\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;This typically means that the function can modify (i.e. assign to) the\nvariable used as argumentsomething that will be seen by its caller.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. \u0026lt;strong\u0026gt;Modifying the object referenced by the variable is a different concept entirely.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Primitive values are also defined in the Java Virtual Machine Specification, \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getValues\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;amp; arg1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;amp; arg2)\u0026lt;/span\u0026gt; {\n    arg1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    arg2 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y;\n    getValues(x, y);\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Result: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; x \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; y \u0026amp;lt;\u0026amp;lt; endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes you want to use the same pattern in Java, but you can\u0026apos;t; at least not directly. Instead you could do something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getValues\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] arg1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] arg2)\u0026lt;/span\u0026gt; {\n    arg1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    arg2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;caller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] x = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] y = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n    getValues(x, y);\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Result: \u0026quot;\u0026lt;/span\u0026gt; + x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt; + y[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As was explained in previous answers, in Java you\u0026apos;re passing a pointer to the array as a value into \u0026lt;code\u0026gt;getValues\u0026lt;/code\u0026gt;. That is enough, because the method then modifies the array element, and by convention you\u0026apos;re expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn\u0026apos;t necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As many people mentioned it before, \u0026lt;a href=\u0026quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java is always pass-by-value\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is another example that will help you understand the difference (\u0026lt;a href=\u0026quot;http://www.javaranch.com/campfire/StoryPassBy.jsp\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the classic swap example\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Before: a = \u0026quot;\u0026lt;/span\u0026gt; + a + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, b = \u0026quot;\u0026lt;/span\u0026gt; + b);\n    swap(a,b);\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;After: a = \u0026quot;\u0026lt;/span\u0026gt; + a + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, b = \u0026quot;\u0026lt;/span\u0026gt; + b);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Integer iA, Integer iB)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; iA;\n    iA = iB;\n    iB = tmp;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Prints:  \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Before: a = 2, b = 3\u0026lt;br\u0026gt;\n  After: a = 2, b = 3\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I always think of it as \u0026quot;pass by copy\u0026quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByCopy\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Dog d)\u0026lt;/span\u0026gt;{\n        d.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Fido\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Maxx\u0026quot;\u0026lt;/span\u0026gt;);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name= \u0026quot;\u0026lt;/span\u0026gt;+ d.name);\n        changeName(d);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name= \u0026quot;\u0026lt;/span\u0026gt;+ d.name);\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String name;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String s)\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.name = s;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;output of java PassByCopy:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;name= Maxx\u0026lt;br\u0026gt;\n  name= Fido\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-referenceall arguments are passed by value. A method call can pass two types of values to a methodcopies of primitive values (e.g., values of int and double) and copies of references to objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When it comes to objects, objects themselves cannot be passed to methods. So we pass the reference(address) of the object. We can manipulate the original object using this reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How Java creates and stores objects:\u0026lt;/strong\u0026gt; When we create an object we store the objects address in a reference variable. Let\u0026apos;s analyze the following statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Account\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;account1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Account\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Account account1 is the type and name of the reference variable, = is the assignment operator, new asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right value, which is an expression called \u0026quot;class instance creation expression\u0026quot;) is assigned to the left value (which is a reference variable with a name and a type specified) using the assign operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although an objects reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the objects reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,\na copy of each element would be passed. For large arrays, this would waste time and consume\nconsiderable storage for the copies of the elements.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables \u0026quot;point\u0026quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/sF7QZ.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/sF7QZ.png\u0026quot; alt=\u0026quot;Pass by value example 1\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a). \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;reverseArray\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array1)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array1 = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; };\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array2 = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;190\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; };\n\n        reverseArray(array1);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/W1wgZ.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/W1wgZ.png\u0026quot; alt=\u0026quot;Pass by value example 2\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, if we say \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;array1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in reverseArray method, it will make a change in array a.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;array1 = array2;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So let\u0026apos;s write all the things we have done at once now.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] reverseArray(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array1)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array2 = { -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; };\n\n        array1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// array a becomes 5, 10, -7\u0026lt;/span\u0026gt;\n\n        array1 = array2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* array1 of reverseArray starts\n          pointing to c instead of a (not shown in image below) */\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; array2;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array1 = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; };\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] array2 = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;190\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; };\n\n        array1 = reverseArray(array1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* array1 of \n         main starts pointing to c instead of a */\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/5hRyX.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/5hRyX.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You could also assign value of array2 in main to array1. array1 would start pointing to b.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java has only pass by value. A very simple example to validate this.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyClass\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    init(obj);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//After calling init method, obj still points to null\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//this is because obj is passed as value and not as reference.\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;init\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(MyClass objVar)\u0026lt;/span\u0026gt; {\n    objVar = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyClass\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To make a long story short, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java\u0026lt;/a\u0026gt; objects have some very peculiar properties.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In general, Java has primitive types (\u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from \u0026lt;code\u0026gt;java.lang.Object\u0026lt;/code\u0026gt;). Objects are actually always handled through a reference (a reference being a pointer that you can\u0026apos;t touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Does this sound strange and confusing? Let\u0026apos;s consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. \u0026lt;code\u0026gt;void foo(int x)\u0026lt;/code\u0026gt; passes an int by value. \u0026lt;code\u0026gt;void foo(int *x)\u0026lt;/code\u0026gt; is a function that does not want an \u0026lt;code\u0026gt;int a\u0026lt;/code\u0026gt;, but a pointer to an int: \u0026lt;code\u0026gt;foo(\u0026amp;amp;a)\u0026lt;/code\u0026gt;. One would use this with the \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; operator to pass a variable address.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: \u0026lt;code\u0026gt;void foo(int \u0026amp;amp;x)\u0026lt;/code\u0026gt; is called by \u0026lt;code\u0026gt;foo(a)\u0026lt;/code\u0026gt;, where the compiler itself knows that it is a reference and the address of the non-reference \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have created a thread devoted to these kind of questions for \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; programming languages \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028\u0026quot;\u0026gt;Java is also mentioned\u0026lt;/a\u0026gt;. Here is the short summary:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Java passes it parameters by value\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026quot;by value\u0026quot; is the only way in java to pass a parameter to a method\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;using methods from the object given as parameter will alter the\nobject as the references point to\nthe original objects. (if that\nmethod itself alters some values)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    "],"id":26,"title":"Is Java \"pass-by-reference\" or \"pass-by-value\"?","content":"\n                \n\u0026lt;p\u0026gt;I always thought Java uses \u0026lt;strong\u0026gt;pass-by-reference\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, I\u0026apos;ve seen \u0026lt;a href=\u0026quot;http://javadude.com/articles/passbyvalue.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a blog post\u0026lt;/a\u0026gt; that claims that Java uses \u0026lt;strong\u0026gt;pass-by-value\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I don\u0026apos;t think I understand the distinction they\u0026apos;re making.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What is the explanation?\u0026lt;/p\u0026gt;\n    ","slug":"is-java-\"pass-by-reference\"-or-\"pass-by-value\"-1657384319828","postType":"QUESTION","createdAt":"2022-07-09T16:31:59.000Z","updatedAt":"2022-07-09T16:31:59.000Z","tags":[{"id":83,"name":"methods","slug":"methods","createdAt":"2022-07-09T16:32:00.000Z","updatedAt":"2022-07-09T16:32:00.000Z","Questions_Tags":{"questionId":26,"tagId":83}},{"id":84,"name":"parameter-passing","slug":"parameter-passing","createdAt":"2022-07-09T16:32:00.000Z","updatedAt":"2022-07-09T16:32:00.000Z","Questions_Tags":{"questionId":26,"tagId":84}},{"id":85,"name":"pass-by-reference","slug":"pass-by-reference","createdAt":"2022-07-09T16:32:00.000Z","updatedAt":"2022-07-09T16:32:00.000Z","Questions_Tags":{"questionId":26,"tagId":85}},{"id":86,"name":"pass-by-value","slug":"pass-by-value","createdAt":"2022-07-09T16:32:00.000Z","updatedAt":"2022-07-09T16:32:00.000Z","Questions_Tags":{"questionId":26,"tagId":86}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-java-\"pass-by-reference\"-or-\"pass-by-value\"-1657384319828"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>