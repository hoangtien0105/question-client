<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_buildManifest.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-can-i-read-and-parse-csv-files-in-c%2B%2B-1657387869219#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219">How can I read and parse CSV files in C++?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/csv">csv</a></div></div><div class="question-content mt-5">
                
<p>I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don't worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.</p>

<p>I found this article which looks quite promising:
<a href="http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp" rel="noreferrer">http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp</a></p>

<p>I've never used Boost's Spirit, but am willing to try it. But only if there isn't a more straightforward solution I'm overlooking.</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't care about escaping comma and newline,<br>
AND you can't embed comma and newline in quotes (If you can't escape then...)<br>
then its only about three lines of code (OK 14 -&gt;But its only 15 to read the whole file).</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">getNextLineAndSplitIntoTokens</span><span class="hljs-params">(std::istream&amp; str)</span>
</span>{
    std::vector&lt;std::string&gt;   result;
    std::string                line;
    std::<span class="hljs-built_in">getline</span>(str,line);

    <span class="hljs-function">std::stringstream          <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
    std::string                cell;

    <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(lineStream,cell, <span class="hljs-string">','</span>))
    {
        result.<span class="hljs-built_in">push_back</span>(cell);
    }
    <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
    <span class="hljs-keyword">if</span> (!lineStream &amp;&amp; cell.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-comment">// If there was a trailing comma then add an empty element.</span>
        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>I would just create a class representing a row.<br>
Then stream into that object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRow</span>
{
    <span class="hljs-keyword">public</span>:
        std::string_view <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span>
        {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string_view</span>(&amp;m_line[m_data[index] + <span class="hljs-number">1</span>], m_data[index + <span class="hljs-number">1</span>] -  (m_data[index] + <span class="hljs-number">1</span>));
        }
        <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>
        </span>{
            <span class="hljs-keyword">return</span> m_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNextRow</span><span class="hljs-params">(std::istream&amp; str)</span>
        </span>{
            std::<span class="hljs-built_in">getline</span>(str, m_line);

            m_data.<span class="hljs-built_in">clear</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">-1</span>);
            std::string::size_type pos = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>((pos = m_line.<span class="hljs-built_in">find</span>(<span class="hljs-string">','</span>, pos)) != std::string::npos)
            {
                m_data.<span class="hljs-built_in">emplace_back</span>(pos);
                ++pos;
            }
            <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
            pos   = m_line.<span class="hljs-built_in">size</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(pos);
        }
    <span class="hljs-keyword">private</span>:
        std::string         m_line;
        std::vector&lt;<span class="hljs-type">int</span>&gt;    m_data;
};

std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; str, CSVRow&amp; data)
{
    data.<span class="hljs-built_in">readNextRow</span>(str);
    <span class="hljs-keyword">return</span> str;
}   
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    CSVRow              row;
    <span class="hljs-keyword">while</span>(file &gt;&gt; row)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>But with a little work we could technically create an iterator:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVIterator</span>
{   
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">typedef</span> std::input_iterator_tag     iterator_category;
        <span class="hljs-keyword">typedef</span> CSVRow                      value_type;
        <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>                 difference_type;
        <span class="hljs-keyword">typedef</span> CSVRow*                     pointer;
        <span class="hljs-keyword">typedef</span> CSVRow&amp;                     reference;

        <span class="hljs-built_in">CSVIterator</span>(std::istream&amp; str)  :<span class="hljs-built_in">m_str</span>(str.<span class="hljs-built_in">good</span>()?&amp;str:<span class="hljs-literal">nullptr</span>) { ++(*<span class="hljs-keyword">this</span>); }
        <span class="hljs-built_in">CSVIterator</span>()                   :<span class="hljs-built_in">m_str</span>(<span class="hljs-literal">nullptr</span>) {}

        <span class="hljs-comment">// Pre Increment</span>
        CSVIterator&amp; <span class="hljs-keyword">operator</span>++()               {<span class="hljs-keyword">if</span> (m_str) { <span class="hljs-keyword">if</span> (!((*m_str) &gt;&gt; m_row)){m_str = <span class="hljs-literal">nullptr</span>;}}<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
        <span class="hljs-comment">// Post increment</span>
        CSVIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)             {<span class="hljs-function">CSVIterator    <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;++(*<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> tmp;}
        CSVRow <span class="hljs-type">const</span>&amp; <span class="hljs-keyword">operator</span>*()   <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> m_row;}
        CSVRow <span class="hljs-type">const</span>* <span class="hljs-keyword">operator</span>-&gt;()  <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> &amp;m_row;}

        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-built_in">return</span> ((<span class="hljs-keyword">this</span> == &amp;rhs) || ((<span class="hljs-keyword">this</span>-&gt;m_str == <span class="hljs-literal">nullptr</span>) &amp;&amp; (rhs.m_str == <span class="hljs-literal">nullptr</span>)));}
        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-keyword">return</span> !((*<span class="hljs-keyword">this</span>) == rhs);}
    <span class="hljs-keyword">private</span>:
        std::istream*       m_str;
        CSVRow              m_row;
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(CSVIterator <span class="hljs-built_in">loop</span>(file); loop != <span class="hljs-built_in">CSVIterator</span>(); ++loop)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; (*loop)[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>Now that we are in 2020 lets add a CSVRange object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRange</span>
{
    std::istream&amp;   stream;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">CSVRange</span>(std::istream&amp; str)
            : <span class="hljs-built_in">stream</span>(str)
        {}
        <span class="hljs-function">CSVIterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{stream};}
        <span class="hljs-function">CSVIterator <span class="hljs-title">end</span><span class="hljs-params">()</span>   <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{};}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; row: <span class="hljs-built_in">CSVRange</span>(file))
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">spam eggs,<span class="hljs-string">"foo,bar"</span>,<span class="hljs-string">""</span><span class="hljs-string">"fizz buzz"</span><span class="hljs-string">""</span>
<span class="hljs-number">1.23</span>,<span class="hljs-number">4.567</span>,<span class="hljs-number">-8.00E+09</span>
</code></pre>

<p>The code is written as a finite-state machine and is consuming one character at a time. I think it's easier to reason about.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;istream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">CSVState</span> {
    UnquotedField,
    QuotedField,
    QuotedQuote
};

<span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">readCSVRow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;row)</span> </span>{
    CSVState state = CSVState::UnquotedField;
    std::vector&lt;std::string&gt; fields {<span class="hljs-string">""</span>};
    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// index of the current field</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : row) {
        <span class="hljs-keyword">switch</span> (state) {
            <span class="hljs-keyword">case</span> CSVState::UnquotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// end of field</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedQuote;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedQuote:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// , after closing quote</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: <span class="hljs-comment">// "" -&gt; "</span>
                              fields[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'"'</span>);
                              state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// end of quote</span>
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> fields;
}

<span class="hljs-comment">/// Read CSV file, Excel dialect. Accept "quoted fields ""with quotes"""</span>
std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">readCSV</span>(std::istream &amp;in) {
    std::vector&lt;std::vector&lt;std::string&gt;&gt; table;
    std::string row;
    <span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) {
        std::<span class="hljs-built_in">getline</span>(in, row);
        <span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">bad</span>() || in.<span class="hljs-built_in">fail</span>()) {
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">auto</span> fields = <span class="hljs-built_in">readCSVRow</span>(row);
        table.<span class="hljs-built_in">push_back</span>(fields);
    }
    <span class="hljs-keyword">return</span> table;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Solution using Boost Tokenizer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::vector&lt;std::string&gt; vec;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">tk</span>(
   line, <span class="hljs-built_in">escaped_list_separator</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">'\\'</span>, <span class="hljs-string">','</span>, <span class="hljs-string">'\"'</span>));
<span class="hljs-keyword">for</span> (tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt;::iterator <span class="hljs-built_in">i</span>(tk.<span class="hljs-built_in">begin</span>());
   i!=tk.<span class="hljs-built_in">end</span>();++i) 
{
   vec.<span class="hljs-built_in">push_back</span>(*i);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://www.partow.net/programming/strtk/index.html" rel="nofollow noreferrer">C++ String Toolkit Library (StrTk)</a> has a token grid class that allows you to load data either from <b>text files, strings or char buffers</b>, and to parse/process them in a row-column fashion.</p>

<p>You can specify the row delimiters and column delimiters or just use the defaults.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
   std::string data = <span class="hljs-string">"1,2,3,4,5\n"</span>
                      <span class="hljs-string">"0,2,4,6,8\n"</span>
                      <span class="hljs-string">"1,3,5,7,9\n"</span>;

   <span class="hljs-function">strtk::token_grid <span class="hljs-title">grid</span><span class="hljs-params">(data,data.size(),<span class="hljs-string">","</span>)</span></span>;

   <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">row_count</span>(); ++i)
   {
      strtk::token_grid::row_type r = grid.<span class="hljs-built_in">row</span>(i);
      <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; r.<span class="hljs-built_in">size</span>(); ++j)
      {
         std::cout &lt;&lt; r.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(j) &lt;&lt; <span class="hljs-string">"\t"</span>;
      }
      std::cout &lt;&lt; std::endl;
   }
   std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>More examples can be found <a href="http://www.partow.net/programming/strtk/index.html#tutorial" rel="nofollow noreferrer">Here</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>You can use Boost Tokenizer with escaped_list_separator.</strong></p>
<blockquote>
<p><strong>escaped_list_separator</strong> parses a superset of the csv. <a href="https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm" rel="nofollow noreferrer">Boost::tokenizer</a></p>
</blockquote>
<p>This only uses Boost tokenizer header files, no linking to boost libraries required.</p>
<p>Here is an example, (see <a href="http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html" rel="nofollow noreferrer">Parse CSV File With Boost Tokenizer In C++</a> for details or <code>Boost::tokenizer</code> ):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout, endl</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>      <span class="hljs-comment">// fstream</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>    <span class="hljs-comment">// copy</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// ostream_operator</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tokenizer.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
    <span class="hljs-function">string <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">"data.csv"</span>)</span></span>;

    <span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(data.c_str())</span></span>;
    <span class="hljs-keyword">if</span> (!in.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">typedef</span> tokenizer&lt; escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; Tokenizer;
    vector&lt; string &gt; vec;
    string line;

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(in,line))
    {
        <span class="hljs-function">Tokenizer <span class="hljs-title">tok</span><span class="hljs-params">(line)</span></span>;
        vec.<span class="hljs-built_in">assign</span>(tok.<span class="hljs-built_in">begin</span>(),tok.<span class="hljs-built_in">end</span>());

        <span class="hljs-comment">// vector now contains strings from one row, output to cout here</span>
        <span class="hljs-built_in">copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"|"</span>));

        cout &lt;&lt; <span class="hljs-string">"\n----------------------"</span> &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(first, last,

    <span class="hljs-comment">//  Begin grammar</span>
    (
        double_ % <span class="hljs-string">','</span>
    )
    ,
    <span class="hljs-comment">//  End grammar</span>

    space, v);
</code></pre>

<p>The vector, v, gets stuffed with the values. <a href="http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html" rel="noreferrer">There is a series of tutorials</a> touching on this in the new Spirit 2.1 docs that's just been released with Boost 1.41.</p>

<p>The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you <strong>DO</strong> care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParseCSV</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; csvSource, vector&lt;vector&lt;string&gt; &gt;&amp; lines)</span>
    </span>{
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inQuote</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">newLine</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       string field;
       lines.<span class="hljs-built_in">clear</span>();
       vector&lt;string&gt; line;

       string::const_iterator aChar = csvSource.<span class="hljs-built_in">begin</span>();
       <span class="hljs-keyword">while</span> (aChar != csvSource.<span class="hljs-built_in">end</span>())
       {
          <span class="hljs-keyword">switch</span> (*aChar)
          {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
             newLine = <span class="hljs-literal">false</span>;
             inQuote = !inQuote;
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
             newLine = <span class="hljs-literal">false</span>;
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                line.<span class="hljs-built_in">push_back</span>(field);
                field.<span class="hljs-built_in">clear</span>();
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                <span class="hljs-keyword">if</span> (newLine == <span class="hljs-literal">false</span>)
                {
                   line.<span class="hljs-built_in">push_back</span>(field);
                   lines.<span class="hljs-built_in">push_back</span>(line);
                   field.<span class="hljs-built_in">clear</span>();
                   line.<span class="hljs-built_in">clear</span>();
                   newLine = <span class="hljs-literal">true</span>;
                }
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
             newLine = <span class="hljs-literal">false</span>;
             field.<span class="hljs-built_in">push_back</span>(*aChar);
             <span class="hljs-keyword">break</span>;
          }

          aChar++;
       }

       <span class="hljs-keyword">if</span> (field.<span class="hljs-built_in">size</span>())
          line.<span class="hljs-built_in">push_back</span>(field);

       <span class="hljs-keyword">if</span> (line.<span class="hljs-built_in">size</span>())
          lines.<span class="hljs-built_in">push_back</span>(line);
    }
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:</p>

<ol>
<li>It requires an escape-character (default back-slash - \)</li>
<li>It requires a splitter/seperator-character (default comma - ,)</li>
<li>It requires an quote-character (default quote - ")</li>
</ol>

<p>The CSV format specified by wiki states that data fields can contain separators in quotes (supported):</p>

<blockquote>
  <p>1997,Ford,E350,"Super, luxurious truck"</p>
</blockquote>

<p>The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):</p>

<blockquote>
  <p>1997,Ford,E350,"Super ""luxurious"" truck"</p>
</blockquote>

<p>The CSV format doesn't specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).</p>

<p>A possible work-around to fix the default behavior of the boost escaped_list_separator:</p>

<ol>
<li>First replace all back-slash characters (\) with two back-slash characters (\\) so they are not stripped away.</li>
<li>Secondly replace all double-quotes ("") with a single back-slash character and a quote (\")</li>
</ol>

<p>This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.</p>

<p>Not pretty but it works, as long there are not newlines within the quotes.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://github.com/AriaFallah/csv-parser" rel="noreferrer">I wrote a header-only, C++11 CSV parser</a>. It's well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don't adhere to the specification.</p>

<p>Configuration is done through a fluent interface:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// constructor accepts any input stream</span>
CsvParser parser = <span class="hljs-built_in">CsvParser</span>(std::cin)
  .<span class="hljs-built_in">delimiter</span>(<span class="hljs-string">';'</span>)    <span class="hljs-comment">// delimited by ; instead of ,</span>
  .<span class="hljs-built_in">quote</span>(<span class="hljs-string">'\''</span>)       <span class="hljs-comment">// quoted fields use ' instead of "</span>
  .<span class="hljs-built_in">terminator</span>(<span class="hljs-string">'\0'</span>); <span class="hljs-comment">// terminated by \0 instead of by \r\n, \n, or \r</span>
</code></pre>

<p>Parsing is just a range based for loop:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../parser.hpp"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> aria::csv;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">std::ifstream <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-string">"some_file.csv"</span>)</span></span>;
  <span class="hljs-function">CsvParser <span class="hljs-title">parser</span><span class="hljs-params">(f)</span></span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : parser) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field : row) {
      std::cout &lt;&lt; field &lt;&lt; <span class="hljs-string">" | "</span>;
    }
    std::cout &lt;&lt; std::endl;
  }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As all the CSV questions seem to get redirected here, I thought I'd post my answer here.  This answer does not directly address the asker's question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.</p>

<p>As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from <a href="http://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">wikipedia's page on CSV</a>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> input[] =
<span class="hljs-string">"Year,Make,Model,Description,Price\n"</span>
<span class="hljs-string">"1997,Ford,E350,\"ac, abs, moon\",3000.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",\"\",5000.00\n"</span>
<span class="hljs-string">"1996,Jeep,Grand Cherokee,\"MUST SELL!\n\
air, moon roof, loaded\",4799.00\n"</span>
;
</code></pre>

<p>Then, I wanted to be able to read in the data like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(input)</span></span>;
std::string title[<span class="hljs-number">5</span>];
<span class="hljs-type">int</span> year;
std::string make, model, desc;
<span class="hljs-type">float</span> price;
<span class="hljs-built_in">csv_istream</span>(ss)
    &gt;&gt; title[<span class="hljs-number">0</span>] &gt;&gt; title[<span class="hljs-number">1</span>] &gt;&gt; title[<span class="hljs-number">2</span>] &gt;&gt; title[<span class="hljs-number">3</span>] &gt;&gt; title[<span class="hljs-number">4</span>];
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">csv_istream</span>(ss)
       &gt;&gt; year &gt;&gt; make &gt;&gt; model &gt;&gt; desc &gt;&gt; price) {
    <span class="hljs-comment">//...do something with the record...</span>
}
</code></pre>

<p>This was the solution I ended up with.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_istream</span> {
    std::istream &amp;is_;
    <span class="hljs-built_in">csv_istream</span> (std::istream &amp;is) : <span class="hljs-built_in">is_</span>(is) {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan_ws</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">peek</span>();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) <span class="hljs-keyword">break</span>;
            is_.<span class="hljs-built_in">get</span>();
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span> <span class="hljs-params">(std::string *s = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> </span>{
        std::string ws;
        <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">get</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">','</span> || c == <span class="hljs-string">'\n'</span>) <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">if</span> (s) {
                    ws += c;
                    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) {
                        *s += ws;
                        ws.<span class="hljs-built_in">clear</span>();
                    }
                }
                c = is_.<span class="hljs-built_in">get</span>();
            } <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>());
            <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">eof</span>()) is_.<span class="hljs-built_in">clear</span>();
        }
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span> {
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            std::<span class="hljs-built_in">istringstream</span>(in) &gt;&gt; v;
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span>&lt;T, <span class="hljs-literal">true</span>&gt; {
        <span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> SIGNED&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">convert</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            <span class="hljs-keyword">if</span> (SIGNED) v = ::<span class="hljs-built_in">strtoll</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">else</span> v = ::<span class="hljs-built_in">strtoull</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            convert&lt;is_signed_int&lt;T&gt;::val&gt;(in, v);
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;v) <span class="hljs-type">const</span> {
        std::string tmp;
        <span class="hljs-built_in">scan</span>(&amp;tmp);
        set_value&lt;T, is_int&lt;T&gt;::val&gt;()(tmp, v);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::string &amp;v) <span class="hljs-type">const</span> {
        v.<span class="hljs-built_in">clear</span>();
        <span class="hljs-built_in">scan_ws</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">peek</span>() != <span class="hljs-string">'"'</span>) <span class="hljs-built_in">scan</span>(&amp;v);
        <span class="hljs-keyword">else</span> {
            std::string tmp;
            is_.<span class="hljs-built_in">get</span>();
            std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">'"'</span>) {
                v += tmp;
                v += is_.<span class="hljs-built_in">get</span>();
                std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            }
            v += tmp;
            <span class="hljs-built_in">scan</span>();
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;(*manip)(T &amp;)) <span class="hljs-type">const</span> {
        is_ &gt;&gt; manip;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> !is_.<span class="hljs-built_in">fail</span>(); }
};
</code></pre>

<p>With the following helpers that may be simplified by the new integral traits templates in C++11:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_int</span> {
    <span class="hljs-keyword">enum</span> { val = (is_signed_int&lt;T&gt;::val || is_unsigned_int&lt;T&gt;::val) };
};
</code></pre>

<p><a href="https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8" rel="nofollow noreferrer" title="C++ (gcc)  Try It Online">Try it online!</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You might want to look at my FOSS project <a href="http://code.google.com/p/csvfix/" rel="nofollow noreferrer">CSVfix</a> (<a href="https://bitbucket.org/neilb/csvfix/" rel="nofollow noreferrer"><em>updated link</em></a>), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.</p>

<p>See <a href="https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default" rel="nofollow noreferrer">alib/src/a_csv.cpp</a> for the CSV parser, and <a href="https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348" rel="nofollow noreferrer">csvlib/src/csved_ioman.cpp</a> (<code>IOManager::ReadCSV</code>) for a usage example.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another CSV I/O library can be found here:</p>

<p><a href="http://code.google.com/p/fast-cpp-csv-parser/" rel="noreferrer">http://code.google.com/p/fast-cpp-csv-parser/</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csv.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  <span class="hljs-function">io::CSVReader&lt;3&gt; <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">"ram.csv"</span>)</span></span>;
  in.<span class="hljs-built_in">read_header</span>(io::ignore_extra_column, <span class="hljs-string">"vendor"</span>, <span class="hljs-string">"size"</span>, <span class="hljs-string">"speed"</span>);
  std::string vendor; <span class="hljs-type">int</span> size; <span class="hljs-type">double</span> speed;
  <span class="hljs-keyword">while</span>(in.<span class="hljs-built_in">read_row</span>(vendor, size, speed)){
    <span class="hljs-comment">// do stuff with the data</span>
  }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another solution similar to <a href="https://stackoverflow.com/a/1120224/1749822">Loki Astari's answer</a>, in C++11. Rows here are <code>std::tuple</code>s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : <span class="hljs-built_in">csv</span>&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt;(file, <span class="hljs-string">','</span>)) {
    std::cout &lt;&lt; <span class="hljs-string">"first col: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(row) &lt;&lt; std::endl;
}
</code></pre>

<p><strong>Advanges:</strong></p>

<ul>
<li>quite clean and simple to use, only C++11.</li>
<li>automatic type conversion into <code>std::tuple&lt;t1, ...&gt;</code> via <code>operator&gt;&gt;</code>.</li>
</ul>

<p><strong>What's missing:</strong></p>

<ul>
<li>escaping and quoting</li>
<li>no error handling in case of malformed CSV.</li>
</ul>

<p>The main code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> csvtools {
    <span class="hljs-comment">/// Read the last element of the tuple without calling recursively</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &gt;= std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::type
    <span class="hljs-built_in">read_tuple</span>(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter) {
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
    }

    <span class="hljs-comment">/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to</span>
    <span class="hljs-comment">/// read the next element of the tuple. Automatically falls in the previous case when</span>
    <span class="hljs-comment">/// reaches the last element of the tuple thanks to enable_if</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &lt; std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::<span class="hljs-function">type
    <span class="hljs-title">read_tuple</span><span class="hljs-params">(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter)</span> </span>{
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
        <span class="hljs-built_in">read_tuple</span>&lt;idx + <span class="hljs-number">1</span>, fields...&gt;(in, out, delimiter);
    }
}

<span class="hljs-comment">/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span> {
    std::istream &amp;_in;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> _delim;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::tuple&lt;fields...&gt; value_type;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>;

    <span class="hljs-comment">/// Construct from a stream.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">csv</span><span class="hljs-params">(std::istream &amp;in, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delim)</span> : _in(in), _delim(delim) {</span>}

    <span class="hljs-comment">/// Status of the underlying stream</span>
    <span class="hljs-comment">/// @{</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">good</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in.<span class="hljs-built_in">good</span>();
    }
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> std::istream &amp;<span class="hljs-title">underlying_stream</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in;
    }
    <span class="hljs-comment">/// @}</span>

    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:

    <span class="hljs-comment">/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> value_type <span class="hljs-title">read_row</span><span class="hljs-params">()</span> </span>{
        std::string line;
        std::<span class="hljs-built_in">getline</span>(_in, line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">line_stream</span><span class="hljs-params">(line)</span></span>;
        std::tuple&lt;fields...&gt; retval;
        csvtools::<span class="hljs-built_in">read_tuple</span>&lt;<span class="hljs-number">0</span>, fields...&gt;(line_stream, retval, _delim);
        <span class="hljs-keyword">return</span> retval;
    }
};

<span class="hljs-comment">/// Iterator; just calls recursively @ref csv::read_row and stores the result.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span>&lt;fields...&gt;::iterator {
    csv::value_type _row;
    csv *_parent;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::input_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> csv::value_type         value_type;
    <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>             difference_type;
    <span class="hljs-keyword">typedef</span> csv::value_type *       pointer;
    <span class="hljs-keyword">typedef</span> csv::value_type &amp;       reference;

    <span class="hljs-comment">/// Construct an empty/end iterator</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span> : _parent(nullptr) {</span>}
    <span class="hljs-comment">/// Construct an iterator at the beginning of the @p parent csv object.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">(csv &amp;parent)</span> : _parent(parent.good() ? &amp;parent : nullptr) {</span>
        ++(*<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">/// Read one row, if possible. Set to end if parent is not good anymore.</span>
    <span class="hljs-keyword">inline</span> iterator &amp;<span class="hljs-keyword">operator</span>++() {
        <span class="hljs-keyword">if</span> (_parent != <span class="hljs-literal">nullptr</span>) {
            _row = _parent-&gt;<span class="hljs-built_in">read_row</span>();
            <span class="hljs-keyword">if</span> (!_parent-&gt;<span class="hljs-built_in">good</span>()) {
                _parent = <span class="hljs-literal">nullptr</span>;
            }
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">inline</span> iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) {
        iterator copy = *<span class="hljs-keyword">this</span>;
        ++(*<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> copy;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> _row;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> &amp;_row;
    }

    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-built_in">return</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-built_in">or</span> (_parent == <span class="hljs-literal">nullptr</span> <span class="hljs-keyword">and</span> other._parent == <span class="hljs-literal">nullptr</span>);
    }
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">not</span> (*<span class="hljs-keyword">this</span> == other);
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">begin</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(*<span class="hljs-keyword">this</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">end</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>();
}
</code></pre>

<p>I put a tiny working example on <a href="https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv" rel="nofollow noreferrer">GitHub</a>; I've been using it for parsing some numerical data and it served its purpose.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.</p>

<p>Note: This parser is aimed at replicating Excel's behavior as closely as possible, specifically when importing <strong>broken or malformed</strong> CSV files.</p>

<p>This is the original question - <a href="https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes">Parsing CSV file with multiline fields and escaped double quotes</a></p>

<p>This is the code as a SSCCE (Short, Self-Contained, Correct Example).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wchar.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wctype.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span></span>;

<span class="hljs-comment">// Returns a pointer to the start of the next field,</span>
<span class="hljs-comment">// or zero if this is the last field in the CSV</span>
<span class="hljs-comment">// p is the start position of the field</span>
<span class="hljs-comment">// sep is the separator used, i.e. comma or semicolon</span>
<span class="hljs-comment">// newline says whether the field ends with a newline or with a comma</span>
<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span>
</span>{
    <span class="hljs-comment">// Parse quoted sequences</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'"'</span> == p[<span class="hljs-number">0</span>]) {
        p++;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// Find next double-quote</span>
            p = <span class="hljs-built_in">wcschr</span>(p, <span class="hljs-string">L'"'</span>);
            <span class="hljs-comment">// If we don't find it or it's the last symbol</span>
            <span class="hljs-comment">// then this is the last field</span>
            <span class="hljs-keyword">if</span> (!p || !p[<span class="hljs-number">1</span>])
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-comment">// Check for "", it is an escaped double-quote</span>
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] != <span class="hljs-string">'"'</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// Skip the escaped double-quote</span>
            p += <span class="hljs-number">2</span>;
        }
    }

    <span class="hljs-comment">// Find next newline or comma.</span>
    <span class="hljs-type">wchar_t</span> newline_or_sep[<span class="hljs-number">4</span>] = <span class="hljs-string">L"\n\r "</span>;
    newline_or_sep[<span class="hljs-number">2</span>] = sep;
    p = <span class="hljs-built_in">wcspbrk</span>(p, newline_or_sep);

    <span class="hljs-comment">// If no newline or separator, this is the last field.</span>
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Check if we had newline.</span>
    *newline = (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> || p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\n'</span>);

    <span class="hljs-comment">// Handle "\r\n", otherwise just increment</span>
    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
        p += <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span>
        p++;

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">csvFieldData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_s, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_e, <span class="hljs-type">wchar_t</span> *buffer, <span class="hljs-type">size_t</span> buflen)</span>
</span>{
    <span class="hljs-type">wchar_t</span> *dst = buffer;
    <span class="hljs-type">wchar_t</span> *end = buffer + buflen - <span class="hljs-number">1</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *src = fld_s;

    <span class="hljs-keyword">if</span> (*src == <span class="hljs-string">L'"'</span>)
    {
        <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p = src + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p &lt; fld_e &amp;&amp; dst &lt; end)
        {
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span> &amp;&amp; p+<span class="hljs-number">1</span> &lt; fld_s &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">L'"'</span>)
            {
                *dst++ = p[<span class="hljs-number">0</span>];
                p += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span>)
            {
                p++;
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
                *dst++ = *p++;
        }
        src = p;
    }
    <span class="hljs-keyword">while</span> (src &lt; fld_e &amp;&amp; dst &lt; end)
        *dst++ = *src++;
    <span class="hljs-keyword">if</span> (dst &gt;= end)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *dst = <span class="hljs-string">L'\0'</span>;
    <span class="hljs-keyword">return</span>(buffer);
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dissect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *line)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *start = line;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *next;
    <span class="hljs-type">bool</span>     eol;
    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Input %3zd: [%.*ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(line), <span class="hljs-built_in">wcslen</span>(line)<span class="hljs-number">-1</span>, line);
    <span class="hljs-keyword">while</span> ((next = <span class="hljs-built_in">nextCsvField</span>(start, <span class="hljs-string">L','</span>, &amp;eol)) != <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">wchar_t</span> buffer[<span class="hljs-number">1024</span>];
        <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Raw Field: [%.*ls] (eol = %d)\n"</span>, (next - start - eol), start, eol);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">csvFieldData</span>(start, next<span class="hljs-number">-1</span>, buffer, <span class="hljs-built_in">sizeof</span>(buffer)/<span class="hljs-built_in">sizeof</span>(buffer[<span class="hljs-number">0</span>])) != <span class="hljs-number">0</span>)
            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Field %3zd: [%ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(buffer), buffer);
        start = next;
    }
}

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> multiline[] =
   <span class="hljs-string">L"First field of first row,\"This field is multiline\n"</span>
    <span class="hljs-string">"\n"</span>
    <span class="hljs-string">"but that's OK because it's enclosed in double quotes, and this\n"</span>
    <span class="hljs-string">"is an escaped \"\" double quote\" but this one \"\" is not\n"</span>
    <span class="hljs-string">"   \"This is second field of second row, but it is not multiline\n"</span>
    <span class="hljs-string">"   because it doesn't start \n"</span>
    <span class="hljs-string">"   with an immediate double quote\"\n"</span>
    ;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">wchar_t</span> line[<span class="hljs-number">1024</span>];

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgetws</span>(line, <span class="hljs-built_in">sizeof</span>(line)/<span class="hljs-built_in">sizeof</span>(line[<span class="hljs-number">0</span>]), stdin))
        <span class="hljs-built_in">dissect</span>(line);
    <span class="hljs-built_in">dissect</span>(multiline);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is an old thread but its still at the top of search results, so I'm adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  </p>

<p>The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn't deal with quoted strings.</p>

<p>Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringReplace</span><span class="hljs-params">(std::string&amp; str, <span class="hljs-type">const</span> std::string&amp; oldStr, <span class="hljs-type">const</span> std::string&amp; newStr)</span>
<span class="hljs-comment">// code by  Yves Baumes</span>
<span class="hljs-comment">// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string</span>
</span>{
  <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>((pos = str.<span class="hljs-built_in">find</span>(oldStr, pos)) != std::string::npos)
  {
     str.<span class="hljs-built_in">replace</span>(pos, oldStr.<span class="hljs-built_in">length</span>(), newStr);
     pos += newStr.<span class="hljs-built_in">length</span>();
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadCSV</span><span class="hljs-params">(std::string &amp;filename)</span> </span>{
   <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filename)</span></span>;
   std::string in_line;
   std::string Field;
   std::string Chan;
   <span class="hljs-type">int</span> ChanType;
   <span class="hljs-type">double</span> Scale;
   <span class="hljs-type">int</span> Import;
   <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(stream, in_line)) {
      <span class="hljs-built_in">StringReplace</span>(in_line, <span class="hljs-string">","</span>, <span class="hljs-string">" "</span>);
      <span class="hljs-function">std::stringstream <span class="hljs-title">line</span><span class="hljs-params">(in_line)</span></span>;
      line &gt;&gt; Field &gt;&gt; Chan &gt;&gt; ChanType &gt;&gt; Scale &gt;&gt; Import;
      <span class="hljs-keyword">if</span> (Field.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)!=<span class="hljs-string">"//"</span>) {
         <span class="hljs-comment">// do your stuff </span>
         <span class="hljs-comment">// this is CBuilder code for demonstration, sorry</span>
         <span class="hljs-built_in">ShowMessage</span>((String)Field.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + Chan.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + <span class="hljs-built_in">IntToStr</span>(ChanType) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">FloatToStr</span>(Scale) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">IntToStr</span>(Import));
      }
   }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed an easy-to-use C++ library for parsing CSV files but couldn't find any available, so I ended up building one.
<a href="https://github.com/d99kris/rapidcsv/" rel="nofollow noreferrer">Rapidcsv</a> is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rapidcsv.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-function">rapidcsv::Document <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-string">"../tests/msft.csv"</span>)</span></span>;

  std::vector&lt;<span class="hljs-type">float</span>&gt; close = doc.<span class="hljs-built_in">GetColumn</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-string">"Close"</span>);
  std::cout &lt;&lt; <span class="hljs-string">"Read "</span> &lt;&lt; close.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">" values."</span> &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the header-only <a href="https://github.com/ashaduri/csv-parser" rel="nofollow noreferrer">Csv::Parser</a> library.</p>
<ul>
<li>It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.</li>
<li>It requires only standard C++ (C++17).</li>
<li>It supports reading CSV data from <code>std::string_view</code> at compile-time.</li>
<li>It's extensively tested using <a href="https://github.com/catchorg/Catch2" rel="nofollow noreferrer">Catch2</a>.</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is code for reading a matrix, note you also have a csvwrite function in matlab</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadFromCSV</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string&amp; filename )</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">( filename.c_str() )</span></span>;
    std::vector&lt; std::vector&lt;std::string&gt; &gt;   matrix;
    std::vector&lt;std::string&gt;   row;
    std::string                line;
    std::string                cell;

    <span class="hljs-keyword">while</span>( file )
    {
        std::<span class="hljs-built_in">getline</span>(file,line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
        row.<span class="hljs-built_in">clear</span>();

        <span class="hljs-keyword">while</span>( std::<span class="hljs-built_in">getline</span>( lineStream, cell, <span class="hljs-string">','</span> ) )
            row.<span class="hljs-built_in">push_back</span>( cell );

        <span class="hljs-keyword">if</span>( !row.<span class="hljs-built_in">empty</span>() )
            matrix.<span class="hljs-built_in">push_back</span>( row );
    }

    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">int</span>(matrix.<span class="hljs-built_in">size</span>()); i++ )
    {
        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">int</span>(matrix[i].<span class="hljs-built_in">size</span>()); j++ )
            std::cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="hljs-string">" "</span>;

        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.</p>

<p>Why not this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/**

  Read line from a CSV file

  @param[in] fp file pointer to open file
  @param[in] vls reference to vector of strings to hold next line

  */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readCSV</span><span class="hljs-params">( FILE *fp, std::vector&lt;std::string&gt;&amp; vls )</span>
</span>{
    vls.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span>;
    <span class="hljs-type">char</span> buf[<span class="hljs-number">10000</span>];
    <span class="hljs-keyword">if</span>( ! <span class="hljs-built_in">fgets</span>( buf,<span class="hljs-number">999</span>,fp) )
        <span class="hljs-keyword">return</span>;
    std::string s = buf;
    <span class="hljs-type">int</span> p,q;
    q = <span class="hljs-number">-1</span>;
    <span class="hljs-comment">// loop over columns</span>
    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> ) {
        p = q;
        q = s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">",\n"</span>,p+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>( q == <span class="hljs-number">-1</span> ) 
            <span class="hljs-keyword">break</span>;
        vls.<span class="hljs-built_in">push_back</span>( s.<span class="hljs-built_in">substr</span>(p+<span class="hljs-number">1</span>,q-p<span class="hljs-number">-1</span>) );
    }
}

<span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])
{
    std::vector&lt;std::string&gt; vls;
    FILE * fp = <span class="hljs-built_in">fopen</span>( argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span> );
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    std::cout &lt;&lt; <span class="hljs-string">"row 3, col 4 is "</span> &lt;&lt; vls[<span class="hljs-number">3</span>].<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is ','.</p>

<p>Suppose your data1.csv file is as follows : </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A,<span class="hljs-number">45</span>,<span class="hljs-number">76</span>,<span class="hljs-number">01</span>
B,<span class="hljs-number">77</span>,<span class="hljs-number">67</span>,<span class="hljs-number">02</span>
C,<span class="hljs-number">63</span>,<span class="hljs-number">76</span>,<span class="hljs-number">03</span>
D,<span class="hljs-number">65</span>,<span class="hljs-number">44</span>,<span class="hljs-number">04</span>
</code></pre>

<p>you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">FILE *fp;
<span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>], str2[<span class="hljs-number">10</span>], str3[<span class="hljs-number">10</span>], str4[<span class="hljs-number">10</span>];

fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"G:\\data1.csv"</span>, <span class="hljs-string">"r"</span>);
<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == fp)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nError in opening file."</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">while</span>(EOF != <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">" %[^,], %[^,], %[^,], %s, %s, %s, %s "</span>, str1, str2, str3, str4))
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%s %s %s %s"</span>, str1, str2, str3, str4);
}
<span class="hljs-built_in">fclose</span>(fp);
</code></pre>

<p>[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The first thing you need to do is make sure the file exists. To accomplish
this you just need to try and open the file stream at the path. After you
have opened the file stream use stream.fail() to see if it worked as expected,
or not.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fileExists</span><span class="hljs-params">(string fileName)</span>
</span>{

ifstream test;

test.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());

<span class="hljs-keyword">if</span> (test.<span class="hljs-built_in">fail</span>())
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">else</span>
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
}
</code></pre>

<p>You must also verify that the file provided is the correct type of file.
To accomplish this you need to look through the file path provided until 
you find the file extension. Once you have the file extension make sure
that it is a .csv file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
    extension += filename[i];

<span class="hljs-keyword">if</span> (extension == <span class="hljs-string">".csv"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>

<p>This function will return the file extension which is used later in an error message.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">getExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">if</span> (period != <span class="hljs-number">0</span>)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
        extension += filename[i];
}
<span class="hljs-keyword">else</span>
    extension = <span class="hljs-string">"NO FILE"</span>;

<span class="hljs-keyword">return</span> extension;
}
</code></pre>

<p>This function will actually call the error checks created above and then parse through the file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseFile</span><span class="hljs-params">(string fileName)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fileExists</span>(fileName) &amp;&amp; <span class="hljs-built_in">verifyExtension</span>(fileName))
    {
        ifstream fs;
        fs.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());
        string fileCommand;

        <span class="hljs-keyword">while</span> (fs.<span class="hljs-built_in">good</span>())
        {
            string temp;

            <span class="hljs-built_in">getline</span>(fs, fileCommand, <span class="hljs-string">'\n'</span>);

            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fileCommand.<span class="hljs-built_in">length</span>(); i++)
            {
                <span class="hljs-keyword">if</span> (fileCommand[i] != <span class="hljs-string">','</span>)
                    temp += fileCommand[i];
                <span class="hljs-keyword">else</span>
                    temp += <span class="hljs-string">" "</span>;
            }

            <span class="hljs-keyword">if</span> (temp != <span class="hljs-string">"\0"</span>)
            {
                <span class="hljs-comment">// Place your code here to run the file.</span>
            }
        }
        fs.<span class="hljs-built_in">close</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fileExists</span>(fileName))
    {
        cout &lt;&lt; <span class="hljs-string">"Error: The provided file does not exist: "</span> &lt;&lt; fileName &lt;&lt; endl;

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName))
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
                cout &lt;&lt; <span class="hljs-string">"\tCheck the file extension."</span> &lt;&lt; endl;
            <span class="hljs-keyword">else</span>
                cout &lt;&lt; <span class="hljs-string">"\tThere is no file in the provided path."</span> &lt;&lt; endl;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName)) 
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
            cout &lt;&lt; <span class="hljs-string">"Incorrect file extension provided: "</span> &lt;&lt; <span class="hljs-built_in">getExtension</span>(fileName) &lt;&lt; endl;
        <span class="hljs-keyword">else</span>
            cout &lt;&lt; <span class="hljs-string">"There is no file in the following path: "</span> &lt;&lt; fileName &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since i'm not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a ','. You could load this data in the form of an array with the following code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> A[<span class="hljs-number">100</span>][<span class="hljs-number">10</span>];
    ifstream ifs;
    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">"name_of_file.csv"</span>);
    string s1;
    <span class="hljs-type">char</span> c;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">100</span>; k++)
    {
        <span class="hljs-built_in">getline</span>(ifs,s1);
        <span class="hljs-function">stringstream <span class="hljs-title">stream</span><span class="hljs-params">(s1)</span></span>;
        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
            stream &gt;&gt;A[k][j];
            stream &gt;&gt; c;
            j++;
            <span class="hljs-keyword">if</span>(!stream) {<span class="hljs-keyword">break</span>;}
        }
    }


}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use this library:
<a href="https://github.com/vadamsky/csvworker" rel="nofollow noreferrer">https://github.com/vadamsky/csvworker</a></p>

<p>Code for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csvworker.h"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//</span>
    CsvWorker csv;
    csv.<span class="hljs-built_in">loadFromFile</span>(<span class="hljs-string">"example.csv"</span>);
    cout &lt;&lt; csv.<span class="hljs-built_in">getRowsNumber</span>() &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; csv.<span class="hljs-built_in">getColumnsNumber</span>() &lt;&lt; endl;

    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;csv.<span class="hljs-built_in">getRowsNumber</span>();++i)
    {
        <span class="hljs-comment">//cout &lt;&lt; csv.getRow(i) &lt;&lt; endl;</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;csv.<span class="hljs-built_in">getColumnsNumber</span>();++j)
        {
            cout &lt;&lt; csv.<span class="hljs-built_in">getField</span>(i, j) &lt;&lt; <span class="hljs-string">"."</span>;
        }
        cout &lt;&lt; endl;
    }

    csv.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test.csv"</span>);

    <span class="hljs-comment">//</span>
    <span class="hljs-function">CsvWorker <span class="hljs-title">csv2</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span></span>;

    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"c"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"d"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;

    csv2.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test2.csv"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You gotta feel proud when you use something so beautiful as <code>boost::spirit</code></p>

<p>Here my attempt of a parser (almost) complying with the CSV specifications on this link <a href="http://www.ietf.org/rfc/rfc4180.txt" rel="nofollow noreferrer">CSV specs</a> (I didn't need line breaks within fields. Also the spaces around the commas are dismissed).</p>

<p>After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// csvparser.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/qi.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/phoenix_operator.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> qi = boost::spirit::qi;
<span class="hljs-keyword">namespace</span> bascii = boost::spirit::ascii;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_parser</span> : qi::grammar&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(), 
    bascii::space_type&gt;
{
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; COMMA;
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; DDQUOTE;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; non_escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; field;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(),  bascii::space_type  &gt; start;

    <span class="hljs-built_in">csv_parser</span>() : csv_parser::<span class="hljs-built_in">base_type</span>(start)
    {
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> qi;
        <span class="hljs-keyword">using</span> qi::lit;
        <span class="hljs-keyword">using</span> qi::lexeme;
        <span class="hljs-keyword">using</span> bascii::char_;

        start       = field % <span class="hljs-string">','</span>;
        field       = escaped | non_escaped;
        escaped     = lexeme[<span class="hljs-string">'"'</span> &gt;&gt; *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>) | COMMA | DDQUOTE)  &gt;&gt; <span class="hljs-string">'"'</span>];
        non_escaped = lexeme[       *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>)                  )        ];
        DDQUOTE     = <span class="hljs-built_in">lit</span>(<span class="hljs-string">"\"\""</span>)       [_val = <span class="hljs-string">'"'</span>];
        COMMA       = <span class="hljs-built_in">lit</span>(<span class="hljs-string">","</span>)          [_val = <span class="hljs-string">','</span>];
    }

};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">"Enter CSV lines [empty] to quit\n"</span>;

    <span class="hljs-keyword">using</span> bascii::space;
    <span class="hljs-keyword">typedef</span> std::string::const_iterator iterator_type;
    <span class="hljs-keyword">typedef</span> csv_parser&lt;iterator_type&gt; csv_parser;

    csv_parser grammar;
    std::string str;
    <span class="hljs-type">int</span> fid;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(std::cin, str))
    {
        fid = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">break</span>;

        std::vector&lt;std::string&gt; csv;
        std::string::const_iterator it_beg = str.<span class="hljs-built_in">begin</span>();
        std::string::const_iterator it_end = str.<span class="hljs-built_in">end</span>();
        <span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(it_beg, it_end, grammar, space, csv);

        <span class="hljs-keyword">if</span> (r &amp;&amp; it_beg == it_end)
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing succeeded\n"</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field: csv)
            {
                std::cout &lt;&lt; <span class="hljs-string">"field "</span> &lt;&lt; ++fid &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; field &lt;&lt; std::endl;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing failed\n"</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">make csvparser
</code></pre>

<p>Test (example stolen from <a href="https://en.wikipedia.org/wiki/Comma-separated_values#Example" rel="nofollow noreferrer">Wikipedia</a>):</p>

<pre class="lang-none s-code-block"><code>./csvparser
Enter CSV lines [empty] to quit

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00
Parsing succeeded
field 1: 1999
field 2: Chevy
field 3: Venture "Extended Edition, Very Large"
field 4: 
field 5: 5000.00

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00"
Parsing failed
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This solution detects these 4 cases</p>

<p>complete class is at</p>

<p><a href="https://github.com/pedro-vicente/csv-parser" rel="nofollow noreferrer">https://github.com/pedro-vicente/csv-parser</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,field <span class="hljs-number">3</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3 quoted, with separator"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline and separator,"</span>,
</code></pre>

<p>It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.</p>

<p>Usage is</p>

<p>Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">read_csv_t</span> csv;
csv.<span class="hljs-built_in">open</span>(<span class="hljs-string">"../test.csv"</span>);
std::vector&lt;std::string&gt; row;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
  row = csv.<span class="hljs-built_in">read_row</span>();
  <span class="hljs-keyword">if</span> (row.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)
  {
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>

<p>the class declaration</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">read_csv_t</span>
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">read_csv_t</span>();
  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;file_name)</span></span>;
  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_row</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
  std::ifstream m_ifs;
};
</code></pre>

<p>the implementation</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_csv_t::read_row</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">bool</span> quote_mode = <span class="hljs-literal">false</span>;
  std::vector&lt;std::string&gt; row;
  std::string column;
  <span class="hljs-type">char</span> c;
  <span class="hljs-keyword">while</span> (m_ifs.<span class="hljs-built_in">get</span>(c))
  {
    <span class="hljs-keyword">switch</span> (c)
    {
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//separator ',' detected. </span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//push column if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        row.<span class="hljs-built_in">push_back</span>(column);
        column.<span class="hljs-built_in">clear</span>();
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//quote '"' detected. </span>
      <span class="hljs-comment">//toggle quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
      quote_mode = !quote_mode;
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//line end detected</span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//return row if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        <span class="hljs-keyword">return</span> row;
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//default, add character to column</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">default</span>:
      column += c;
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-comment">//return empty vector if end of file detected </span>
  m_ifs.<span class="hljs-built_in">close</span>();
  std::vector&lt;std::string&gt; v;
  <span class="hljs-keyword">return</span> v;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><em>Parsing CSV file lines with Stream</em></strong></p>

<p>I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{


<span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">"Infile.csv"</span>)</span></span>;
<span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">"OutFile.csv"</span>)</span></span>;
string strline, strremain, strCol1 , strout;

string delimeter =<span class="hljs-string">";"</span>;

<span class="hljs-type">int</span> d1;
</code></pre>

<p>to continue until the end of the file:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!fin.<span class="hljs-built_in">eof</span>()){ 
</code></pre>

<p>get first line from InFile :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-built_in">getline</span>(fin,strline,<span class="hljs-string">'\n'</span>);      
</code></pre>

<p>find delimeter position in line:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    d1 = strline.<span class="hljs-built_in">find</span>(<span class="hljs-string">';'</span>);
</code></pre>

<p>and parse first column:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strCol1 = strline.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,d1); <span class="hljs-comment">// parse first Column</span>
    d1++;
    strremain = strline.<span class="hljs-built_in">substr</span>(d1); <span class="hljs-comment">// remaining line</span>
</code></pre>

<p>create output line in CSV format:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strout.<span class="hljs-built_in">append</span>(strCol1);
    strout.<span class="hljs-built_in">append</span>(delimeter);
</code></pre>

<p>write line to Out File:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    fout &lt;&lt; strout &lt;&lt; endl; <span class="hljs-comment">//out file line</span>

} 

fin.<span class="hljs-built_in">close</span>();
fout.<span class="hljs-built_in">close</span>();

<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>

<p>This code is compiled and running. Good luck!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could also take a look at capabilities of <code>Qt</code> library.</p>

<p>It has regular expressions support and QString class has nice methods, e.g. <code>split()</code> returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. </p>

<p>To get a column with a given header name I use following: <a href="https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601">c++ inheritance Qt problem qstring</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)</p>

<p>I have had luck with the CSV parsing here:</p>

<p><a href="http://www.zedwood.com/article/112/cpp-csv-parser" rel="nofollow">http://www.zedwood.com/article/112/cpp-csv-parser</a></p>

<p>It handles quoted fields - but does not handle inline \n characters (which is probably fine for most uses).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn't too difficult) and it does not comply with "\r\n" end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)</span>
<span class="hljs-function">wstring <span class="hljs-title">trimquote</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; str, <span class="hljs-type">const</span> wstring&amp; whitespace, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar)</span>
</span>{
    wstring ws;
    wstring::size_type strBegin = str.<span class="hljs-built_in">find_first_not_of</span>(whitespace);
    <span class="hljs-keyword">if</span> (strBegin == wstring::npos)
        <span class="hljs-keyword">return</span> <span class="hljs-string">L""</span>;

    wstring::size_type strEnd = str.<span class="hljs-built_in">find_last_not_of</span>(whitespace);
    wstring::size_type strRange = strEnd - strBegin + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span>((str[strBegin] == quotChar) &amp;&amp; (str[strEnd] == quotChar))
    {
        ws = str.<span class="hljs-built_in">substr</span>(strBegin+<span class="hljs-number">1</span>, strRange<span class="hljs-number">-2</span>);
        strBegin = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>((strEnd = ws.<span class="hljs-built_in">find</span>(quotChar, strBegin)) != wstring::npos)
        {
            ws.<span class="hljs-built_in">erase</span>(strEnd, <span class="hljs-number">1</span>);
            strBegin = strEnd+<span class="hljs-number">1</span>;
        }

    }
    <span class="hljs-keyword">else</span>
        ws = str.<span class="hljs-built_in">substr</span>(strBegin, strRange);
    <span class="hljs-keyword">return</span> ws;
}

<span class="hljs-function">pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">nextCSVQuotePair</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; line, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar, <span class="hljs-type">unsigned</span> ofs = <span class="hljs-number">0</span>)</span>
</span>{
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; r;
    r.first = line.<span class="hljs-built_in">find</span>(quotChar, ofs);
    r.second = wstring::npos;
    <span class="hljs-keyword">if</span>(r.first != wstring::npos)
    {
        r.second = r.first;
        <span class="hljs-keyword">while</span>(((r.second = line.<span class="hljs-built_in">find</span>(quotChar, r.second+<span class="hljs-number">1</span>)) != wstring::npos)
            &amp;&amp; (line[r.second+<span class="hljs-number">1</span>] == quotChar)) <span class="hljs-comment">// WARNING: assumes null-terminated string such that line[r.second+1] always exist</span>
            r.second++;

    }
    <span class="hljs-keyword">return</span> r;
}

<span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">parseLine</span><span class="hljs-params">(vector&lt;wstring&gt;&amp; fields, <span class="hljs-type">const</span> wstring&amp; line)</span>
</span>{
    <span class="hljs-type">unsigned</span> ofs, ofs0, np;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> delim = <span class="hljs-string">L','</span>;
    <span class="hljs-type">const</span> wstring whitespace = <span class="hljs-string">L" \t\xa0\x3000\x2000\x2001\x2002\x2003\x2004\x2005\x2006\x2007\x2008\x2009\x200a\x202f\x205f"</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar = <span class="hljs-string">L'\"'</span>;
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; quot;

    fields.<span class="hljs-built_in">clear</span>();

    ofs = ofs0 = <span class="hljs-number">0</span>;
    quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar);
    <span class="hljs-keyword">while</span>((np = line.<span class="hljs-built_in">find</span>(delim, ofs)) != wstring::npos)
    {
        <span class="hljs-keyword">if</span>((np &gt; quot.first) &amp;&amp; (np &lt; quot.second))
        { <span class="hljs-comment">// skip delimiter inside quoted field</span>
            ofs = quot.second+<span class="hljs-number">1</span>;
            quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar, ofs);
            <span class="hljs-keyword">continue</span>;
        }
        fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0, np-ofs0), whitespace, quotChar) );
        ofs = ofs0 = np+<span class="hljs-number">1</span>;
    }
    fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0), whitespace, quotChar) );

    <span class="hljs-keyword">return</span> fields.<span class="hljs-built_in">size</span>();
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">/**
 * Parse a CSV data file and fill the 2d STL vector "data".
 * Limits: only "pure datas" of doubles, not encapsulated by " and without \n inside.
 * Further no formatting in the data (e.g. scientific notation)
 * It however handles both dots and commas as decimal separators and removes thousand separator.
 * 
 * returnCodes[0]: file access 0-&gt; ok 1-&gt; not able to read; 2-&gt; decimal separator equal to comma separator
 * returnCodes[1]: number of records
 * returnCodes[2]: number of fields. -1 If rows have different field size
 * 
 */</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt;
<span class="hljs-title">readCsvData</span> <span class="hljs-params">(vector &lt;vector &lt;<span class="hljs-type">double</span>&gt;&gt;&amp; data, <span class="hljs-type">const</span> string&amp; filename, <span class="hljs-type">const</span> string&amp; delimiter, <span class="hljs-type">const</span> string&amp; decseparator)</span></span>{

 <span class="hljs-type">int</span> vv[<span class="hljs-number">3</span>] = { <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> };
 <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">returnCodes</span><span class="hljs-params">(&amp;vv[<span class="hljs-number">0</span>], &amp;vv[<span class="hljs-number">0</span>]+<span class="hljs-number">3</span>)</span></span>;

 string rowstring, stringtoken;
 <span class="hljs-type">double</span> doubletoken;
 <span class="hljs-type">int</span> rowcount=<span class="hljs-number">0</span>;
 <span class="hljs-type">int</span> fieldcount=<span class="hljs-number">0</span>;
 data.<span class="hljs-built_in">clear</span>();

 <span class="hljs-function">ifstream <span class="hljs-title">iFile</span><span class="hljs-params">(filename, ios_base::in)</span></span>;
 <span class="hljs-keyword">if</span> (!iFile.<span class="hljs-built_in">is_open</span>()){
   returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> returnCodes;
 }
 <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(iFile, rowstring)) {
    <span class="hljs-keyword">if</span> (rowstring==<span class="hljs-string">""</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// empty line</span>
    rowcount ++; <span class="hljs-comment">//let's start with 1</span>
    <span class="hljs-keyword">if</span>(delimiter == decseparator){
      returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">return</span> returnCodes;
    }
    <span class="hljs-keyword">if</span>(decseparator != <span class="hljs-string">"."</span>){
     <span class="hljs-comment">// remove dots (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">'.'</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
     <span class="hljs-comment">// replace decimal separator with dots.</span>
     <span class="hljs-built_in">replace</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(),decseparator.<span class="hljs-built_in">c_str</span>()[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>); 
    } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// remove commas (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">','</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
    }
    <span class="hljs-comment">// tokenize..</span>
    vector&lt;<span class="hljs-type">double</span>&gt; tokens;
    <span class="hljs-comment">// Skip delimiters at beginning.</span>
    string::size_type lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// Find first "non-delimiter".</span>
    string::size_type pos     = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    <span class="hljs-keyword">while</span> (string::npos != pos || string::npos != lastPos){
        <span class="hljs-comment">// Found a token, convert it to double add it to the vector.</span>
        stringtoken = rowstring.<span class="hljs-built_in">substr</span>(lastPos, pos - lastPos);
        <span class="hljs-keyword">if</span> (stringtoken == <span class="hljs-string">""</span>) {
      tokens.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0.0</span>);
    } <span class="hljs-keyword">else</span> {
          istringstream <span class="hljs-built_in">totalSString</span>(stringtoken);
      totalSString &gt;&gt; doubletoken;
      tokens.<span class="hljs-built_in">push_back</span>(doubletoken);
    }     
        <span class="hljs-comment">// Skip delimiters.  Note the "not_of"</span>
        lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, pos);
        <span class="hljs-comment">// Find next "non-delimiter"</span>
        pos = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    }
    <span class="hljs-keyword">if</span>(rowcount == <span class="hljs-number">1</span>){
      fieldcount = tokens.<span class="hljs-built_in">size</span>();
      returnCodes[<span class="hljs-number">2</span>] = tokens.<span class="hljs-built_in">size</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> ( tokens.<span class="hljs-built_in">size</span>() != fieldcount){
    returnCodes[<span class="hljs-number">2</span>] = <span class="hljs-number">-1</span>;
      }
    }
    data.<span class="hljs-built_in">push_back</span>(tokens);
 }
 iFile.<span class="hljs-built_in">close</span>();
 returnCodes[<span class="hljs-number">1</span>] = rowcount;
 <span class="hljs-keyword">return</span> returnCodes;
}
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;If you don\u0026apos;t care about escaping comma and newline,\u0026lt;br\u0026gt;\nAND you can\u0026apos;t embed comma and newline in quotes (If you can\u0026apos;t escape then...)\u0026lt;br\u0026gt;\nthen its only about three lines of code (OK 14 -\u0026amp;gt;But its only 15 to read the whole file).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getNextLineAndSplitIntoTokens\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   result;\n    std::string                line;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str,line);\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream          \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(lineStream,cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;))\n    {\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(cell);\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!lineStream \u0026amp;amp;\u0026amp;amp; cell.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If there was a trailing comma then add an empty element.\u0026lt;/span\u0026gt;\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I would just create a class representing a row.\u0026lt;br\u0026gt;\nThen stream into that object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRow\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        std::string_view \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; index) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_view\u0026lt;/span\u0026gt;(\u0026amp;amp;m_line[m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], m_data[index + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] -  (m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str, m_line);\n\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;);\n            std::string::size_type pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, pos)) != std::string::npos)\n            {\n                m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n                ++pos;\n            }\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n            pos   = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n        }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::string         m_line;\n        std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;    m_data;\n};\n\nstd::istream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;(std::istream\u0026amp;amp; str, CSVRow\u0026amp;amp; data)\n{\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;(str);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; str;\n}   \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    CSVRow              row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(file \u0026amp;gt;\u0026amp;gt; row)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But with a little work we could technically create an iterator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;\n{   \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag     iterator_category;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow                      value_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;                 difference_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow*                     pointer;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow\u0026amp;amp;                     reference;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)  :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()?\u0026amp;amp;str:\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) { ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;); }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;()                   :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {}\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Pre Increment\u0026lt;/span\u0026gt;\n        CSVIterator\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++()               {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (m_str) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!((*m_str) \u0026amp;gt;\u0026amp;gt; m_row)){m_str = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;}}\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;}\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Post increment\u0026lt;/span\u0026gt;\n        CSVIterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)             {\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tmp;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*()   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_row;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;()  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;m_row;}\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;rhs) || ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (rhs.m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)));}\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !((*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;) == rhs);}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::istream*       m_str;\n        CSVRow              m_row;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(CSVIterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;(file); loop != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(); ++loop)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (*loop)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now that we are in 2020 lets add a CSVRange object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;\n{\n    std::istream\u0026amp;amp;   stream;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)\n            : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;(str)\n        {}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{stream};}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{};}\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(file))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;spam eggs,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo,bar\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fizz buzz\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.23\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.567\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-8.00E+09\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The code is written as a finite-state machine and is consuming one character at a time. I think it\u0026apos;s easier to reason about.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;istream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVState\u0026lt;/span\u0026gt; {\n    UnquotedField,\n    QuotedField,\n    QuotedQuote\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;row)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    CSVState state = CSVState::UnquotedField;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; fields {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// index of the current field\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c : row) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (state) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::UnquotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of field\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedQuote;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedQuote:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// , after closing quote\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;\u0026quot; -\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt;\n                              fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n                              state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of quote\u0026lt;/span\u0026gt;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read CSV file, Excel dialect. Accept \u0026quot;quoted fields \u0026quot;\u0026quot;with quotes\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\nstd::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in) {\n    std::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; table;\n    std::string row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, row);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad\u0026lt;/span\u0026gt;() || in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; fields = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;(row);\n        table.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(fields);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; table;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Solution using Boost Tokenizer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; vec;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\ntokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tk\u0026lt;/span\u0026gt;(\n   line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;escaped_list_separator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\\\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;));\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (tokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt;::iterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;());\n   i!=tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();++i) \n{\n   vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*i);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++ String Toolkit Library (StrTk)\u0026lt;/a\u0026gt; has a token grid class that allows you to load data either from \u0026lt;b\u0026gt;text files, strings or char buffers\u0026lt;/b\u0026gt;, and to parse/process them in a row-column fashion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can specify the row delimiters and column delimiters or just use the defaults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   std::string data = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,2,3,4,5\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0,2,4,6,8\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,3,5,7,9\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;strtk::token_grid \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;grid\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data,data.size(),\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row_count\u0026lt;/span\u0026gt;(); ++i)\n   {\n      strtk::token_grid::row_type r = grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row\u0026lt;/span\u0026gt;(i);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++j)\n      {\n         std::cout \u0026amp;lt;\u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\t\u0026quot;\u0026lt;/span\u0026gt;;\n      }\n      std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n   }\n   std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;More examples can be found \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html#tutorial\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;You can use Boost Tokenizer with escaped_list_separator.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;escaped_list_separator\u0026lt;/strong\u0026gt; parses a superset of the csv. \u0026lt;a href=\u0026quot;https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost::tokenizer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This only uses Boost tokenizer header files, no linking to boost libraries required.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is an example, (see \u0026lt;a href=\u0026quot;http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Parse CSV File With Boost Tokenizer In C++\u0026lt;/a\u0026gt; for details or \u0026lt;code\u0026gt;Boost::tokenizer\u0026lt;/code\u0026gt; ):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// cout, endl\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// fstream\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ostream_operator\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tokenizer.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;data.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data.c_str())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; tokenizer\u0026amp;lt; escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; Tokenizer;\n    vector\u0026amp;lt; string \u0026amp;gt; vec;\n    string line;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in,line))\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Tokenizer \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tok\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// vector now contains strings from one row, output to cout here\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;|\u0026quot;\u0026lt;/span\u0026gt;));\n\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n----------------------\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(first, last,\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  Begin grammar\u0026lt;/span\u0026gt;\n    (\n        double_ % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;\n    )\n    ,\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  End grammar\u0026lt;/span\u0026gt;\n\n    space, v);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The vector, v, gets stuffed with the values. \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;There is a series of tutorials\u0026lt;/a\u0026gt; touching on this in the new Spirit 2.1 docs that\u0026apos;s just been released with Boost 1.41.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you \u0026lt;strong\u0026gt;DO\u0026lt;/strong\u0026gt; care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ParseCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; csvSource, vector\u0026amp;lt;vector\u0026amp;lt;string\u0026amp;gt; \u0026amp;gt;\u0026amp;amp; lines)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;inQuote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;newLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       string field;\n       lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n       vector\u0026amp;lt;string\u0026amp;gt; line;\n\n       string::const_iterator aChar = csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (aChar != csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;())\n       {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (*aChar)\n          {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             inQuote = !inQuote;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (newLine == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\n                {\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                   lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n                   field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n                }\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*aChar);\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n          }\n\n          aChar++;\n       }\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;It requires an escape-character (default back-slash - \\)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires a splitter/seperator-character (default comma - ,)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires an quote-character (default quote - \u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that data fields can contain separators in quotes (supported):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super, luxurious truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super \u0026quot;\u0026quot;luxurious\u0026quot;\u0026quot; truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format doesn\u0026apos;t specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A possible work-around to fix the default behavior of the boost escaped_list_separator:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;First replace all back-slash characters (\\) with two back-slash characters (\\\\) so they are not stripped away.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Secondly replace all double-quotes (\u0026quot;\u0026quot;) with a single back-slash character and a quote (\\\u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Not pretty but it works, as long there are not newlines within the quotes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/AriaFallah/csv-parser\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;I wrote a header-only, C++11 CSV parser\u0026lt;/a\u0026gt;. It\u0026apos;s well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don\u0026apos;t adhere to the specification.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Configuration is done through a fluent interface:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// constructor accepts any input stream\u0026lt;/span\u0026gt;\nCsvParser parser = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CsvParser\u0026lt;/span\u0026gt;(std::cin)\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;delimiter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// delimited by ; instead of ,\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;quote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;)       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// quoted fields use \u0026apos; instead of \u0026quot;\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;terminator\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// terminated by \\0 instead of by \\r\\n, \\n, or \\r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Parsing is just a range based for loop:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../parser.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; aria::csv;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;some_file.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvParser \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parser\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(f)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row : parser) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field : row) {\n      std::cout \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As all the CSV questions seem to get redirected here, I thought I\u0026apos;d post my answer here.  This answer does not directly address the asker\u0026apos;s question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Comma-separated_values\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;wikipedia\u0026apos;s page on CSV\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; input[] =\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Year,Make,Model,Description,Price\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1997,Ford,E350,\\\u0026quot;ac, abs, moon\\\u0026quot;,3000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,4900.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition, Very Large\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,5000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1996,Jeep,Grand Cherokee,\\\u0026quot;MUST SELL!\\n\\\nair, moon roof, loaded\\\u0026quot;,4799.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, I wanted to be able to read in the data like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(input)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::string title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; year;\nstd::string make, model, desc;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; price;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n    \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n       \u0026amp;gt;\u0026amp;gt; year \u0026amp;gt;\u0026amp;gt; make \u0026amp;gt;\u0026amp;gt; model \u0026amp;gt;\u0026amp;gt; desc \u0026amp;gt;\u0026amp;gt; price) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...do something with the record...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This was the solution I ended up with.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;is_;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; (std::istream \u0026amp;amp;is) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_\u0026lt;/span\u0026gt;(is) {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string *s = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string ws;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; || c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (s) {\n                    ws += c;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) {\n                        *s += ws;\n                        ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                    }\n                }\n                c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;());\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istringstream\u0026lt;/span\u0026gt;(in) \u0026amp;gt;\u0026amp;gt; v;\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\u0026amp;gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; SIGNED\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convert\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (SIGNED) v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoll\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoull\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            convert\u0026amp;lt;is_signed_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;(in, v);\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        std::string tmp;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;tmp);\n        set_value\u0026amp;lt;T, is_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;()(tmp, v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (std::string \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            std::string tmp;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) {\n                v += tmp;\n                v += is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n                std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            }\n            v += tmp;\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;();\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;(*manip)(T \u0026amp;amp;)) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        is_ \u0026amp;gt;\u0026amp;gt; manip;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;(); }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With the following helpers that may be simplified by the new integral traits templates in C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_int\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = (is_signed_int\u0026amp;lt;T\u0026amp;gt;::val || is_unsigned_int\u0026amp;lt;T\u0026amp;gt;::val) };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;C++ (gcc)  Try It Online\u0026quot;\u0026gt;Try it online!\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You might want to look at my FOSS project \u0026lt;a href=\u0026quot;http://code.google.com/p/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSVfix\u0026lt;/a\u0026gt; (\u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;updated link\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;alib/src/a_csv.cpp\u0026lt;/a\u0026gt; for the CSV parser, and \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;csvlib/src/csved_ioman.cpp\u0026lt;/a\u0026gt; (\u0026lt;code\u0026gt;IOManager::ReadCSV\u0026lt;/code\u0026gt;) for a usage example.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another CSV I/O library can be found here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://code.google.com/p/fast-cpp-csv-parser/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://code.google.com/p/fast-cpp-csv-parser/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csv.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;io::CSVReader\u0026amp;lt;3\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ram.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_header\u0026lt;/span\u0026gt;(io::ignore_extra_column, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vendor\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;size\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;speed\u0026quot;\u0026lt;/span\u0026gt;);\n  std::string vendor; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; speed;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;(vendor, size, speed)){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with the data\u0026lt;/span\u0026gt;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another solution similar to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1120224/1749822\u0026quot;\u0026gt;Loki Astari\u0026apos;s answer\u0026lt;/a\u0026gt;, in C++11. Rows here are \u0026lt;code\u0026gt;std::tuple\u0026lt;/code\u0026gt;s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; row : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;std::string, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(file, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)) {\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;first col: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026amp;gt;(row) \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advanges:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;quite clean and simple to use, only C++11.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;automatic type conversion into \u0026lt;code\u0026gt;std::tuple\u0026amp;lt;t1, ...\u0026amp;gt;\u0026lt;/code\u0026gt; via \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What\u0026apos;s missing:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;escaping and quoting\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;no error handling in case of malformed CSV.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The main code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; csvtools {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the last element of the tuple without calling recursively\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;gt;= std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::type\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter) {\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// read the next element of the tuple. Automatically falls in the previous case when\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// reaches the last element of the tuple thanks to enable_if\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;lt; std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;idx + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(in, out, delimiter);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;_in;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; _delim;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::tuple\u0026amp;lt;fields...\u0026amp;gt; value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct from a stream.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt; : _in(in), _delim(delim) {\u0026lt;/span\u0026gt;}\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Status of the underlying stream\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @{\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::istream \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;underlying_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @}\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; value_type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string line;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(_in, line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::tuple\u0026amp;lt;fields...\u0026amp;gt; retval;\n        csvtools::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(line_stream, retval, _delim);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; retval;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterator; just calls recursively @ref csv::read_row and stores the result.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;fields...\u0026amp;gt;::iterator {\n    csv::value_type _row;\n    csv *_parent;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag iterator_category;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type         value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;             difference_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type *       pointer;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type \u0026amp;amp;       reference;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an empty/end iterator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; : _parent(nullptr) {\u0026lt;/span\u0026gt;}\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an iterator at the beginning of the @p parent csv object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(csv \u0026amp;amp;parent)\u0026lt;/span\u0026gt; : _parent(parent.good() ? \u0026amp;amp;parent : nullptr) {\u0026lt;/span\u0026gt;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read one row, if possible. Set to end if parent is not good anymore.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_parent != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {\n            _row = _parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!_parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n                _parent = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) {\n        iterator copy = *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; copy;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;_row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; (_parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; other._parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; (*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == other);\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I put a tiny working example on \u0026lt;a href=\u0026quot;https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt;; I\u0026apos;ve been using it for parsing some numerical data and it served its purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note: This parser is aimed at replicating Excel\u0026apos;s behavior as closely as possible, specifically when importing \u0026lt;strong\u0026gt;broken or malformed\u0026lt;/strong\u0026gt; CSV files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the original question - \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes\u0026quot;\u0026gt;Parsing CSV file with multiline fields and escaped double quotes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the code as a SSCCE (Short, Self-Contained, Correct Example).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdbool.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wchar.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wctype.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extern\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Returns a pointer to the start of the next field,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or zero if this is the last field in the CSV\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p is the start position of the field\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sep is the separator used, i.e. comma or semicolon\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// newline says whether the field ends with a newline or with a comma\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Parse quoted sequences\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; == p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]) {\n        p++;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next double-quote\u0026lt;/span\u0026gt;\n            p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcschr\u0026lt;/span\u0026gt;(p, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If we don\u0026apos;t find it or it\u0026apos;s the last symbol\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// then this is the last field\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p || !p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check for \u0026quot;\u0026quot;, it is an escaped double-quote\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip the escaped double-quote\u0026lt;/span\u0026gt;\n            p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next newline or comma.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\\n\\r \u0026quot;\u0026lt;/span\u0026gt;;\n    newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = sep;\n    p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcspbrk\u0026lt;/span\u0026gt;(p, newline_or_sep);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If no newline or separator, this is the last field.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if we had newline.\u0026lt;/span\u0026gt;\n    *newline = (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; || p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Handle \u0026quot;\\r\\n\u0026quot;, otherwise just increment\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n        p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        p++;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; p;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_e, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *buffer, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; buflen)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *dst = buffer;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *end = buffer + buflen - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *src = fld_s;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*src == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p = src + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (p \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026amp;lt; fld_s \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                *dst++ = p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n                p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                p++;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                *dst++ = *p++;\n        }\n        src = p;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (src \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        *dst++ = *src++;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (dst \u0026amp;gt;= end)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    *dst = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(buffer);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *start = line;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *next;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;     eol;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Input %3zd: [%.*ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, line);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((next = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;(start, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026amp;amp;eol)) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Raw Field: [%.*ls] (eol = %d)\\n\u0026quot;\u0026lt;/span\u0026gt;, (next - start - eol), start, eol);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;(start, next\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, buffer, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Field %3zd: [%ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(buffer), buffer);\n        start = next;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; multiline[] =\n   \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;First field of first row,\\\u0026quot;This field is multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;but that\u0026apos;s OK because it\u0026apos;s enclosed in double quotes, and this\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;is an escaped \\\u0026quot;\\\u0026quot; double quote\\\u0026quot; but this one \\\u0026quot;\\\u0026quot; is not\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   \\\u0026quot;This is second field of second row, but it is not multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   because it doesn\u0026apos;t start \\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   with an immediate double quote\\\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    ;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgetws\u0026lt;/span\u0026gt;(line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]), stdin))\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(line);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(multiline);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is an old thread but its still at the top of search results, so I\u0026apos;m adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn\u0026apos;t deal with quoted strings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; oldStr, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; newStr)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code by  Yves Baumes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(oldStr, pos)) != std::string::npos)\n  {\n     str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(pos, oldStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(), newStr);\n     pos += newStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;();\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;LoadCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string \u0026amp;amp;filename)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   std::string in_line;\n   std::string Field;\n   std::string Chan;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ChanType;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; Scale;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Import;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(stream, in_line)) {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;(in_line, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n      \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in_line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n      line \u0026amp;gt;\u0026amp;gt; Field \u0026amp;gt;\u0026amp;gt; Chan \u0026amp;gt;\u0026amp;gt; ChanType \u0026amp;gt;\u0026amp;gt; Scale \u0026amp;gt;\u0026amp;gt; Import;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)!=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;//\u0026quot;\u0026lt;/span\u0026gt;) {\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do your stuff \u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is CBuilder code for demonstration, sorry\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ShowMessage\u0026lt;/span\u0026gt;((String)Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + Chan.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(ChanType) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FloatToStr\u0026lt;/span\u0026gt;(Scale) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(Import));\n      }\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed an easy-to-use C++ library for parsing CSV files but couldn\u0026apos;t find any available, so I ended up building one.\n\u0026lt;a href=\u0026quot;https://github.com/d99kris/rapidcsv/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Rapidcsv\u0026lt;/a\u0026gt; is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;rapidcsv.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;rapidcsv::Document \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../tests/msft.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt; close = doc.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;GetColumn\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Close\u0026quot;\u0026lt;/span\u0026gt;);\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Read \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; close.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; values.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the header-only \u0026lt;a href=\u0026quot;https://github.com/ashaduri/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Csv::Parser\u0026lt;/a\u0026gt; library.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires only standard C++ (C++17).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It supports reading CSV data from \u0026lt;code\u0026gt;std::string_view\u0026lt;/code\u0026gt; at compile-time.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s extensively tested using \u0026lt;a href=\u0026quot;https://github.com/catchorg/Catch2\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Catch2\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is code for reading a matrix, note you also have a csvwrite function in matlab\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;loadFromCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; filename )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( filename.c_str() )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::vector\u0026amp;lt; std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026amp;gt;   matrix;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   row;\n    std::string                line;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( file )\n    {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(file,line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;( lineStream, cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; ) )\n            row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( cell );\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( !row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() )\n            matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( row );\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); i++ )\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); j++ )\n            std::cout \u0026amp;lt;\u0026amp;lt; matrix[i][j] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n\n        std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why not this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n\n  Read line from a CSV file\n\n  @param[in] fp file pointer to open file\n  @param[in] vls reference to vector of strings to hold next line\n\n  */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( FILE *fp, std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;amp; vls )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buf[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgets\u0026lt;/span\u0026gt;( buf,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999\u0026lt;/span\u0026gt;,fp) )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    std::string s = buf;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p,q;\n    q = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// loop over columns\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ) {\n        p = q;\n        q = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\\n\u0026quot;\u0026lt;/span\u0026gt;,p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( q == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt; ) \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,q-p\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;) );\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _tmain(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, _TCHAR* argv[])\n{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; vls;\n    FILE * fp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;( argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt; );\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;row 3, col 4 is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; vls[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is \u0026apos;,\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose your data1.csv file is as follows : \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;01\u0026lt;/span\u0026gt;\nB,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;77\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;\nC,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;03\u0026lt;/span\u0026gt;\nD,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;44\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;FILE *fp;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str3[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str4[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\nfp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;G:\\\\data1.csv\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; == fp)\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nError in opening file.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(EOF != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fscanf\u0026lt;/span\u0026gt;(fp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; %[^,], %[^,], %[^,], %s, %s, %s, %s \u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4))\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n%s %s %s %s\u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4);\n}\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fclose\u0026lt;/span\u0026gt;(fp);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The first thing you need to do is make sure the file exists. To accomplish\nthis you just need to try and open the file stream at the path. After you\nhave opened the file stream use stream.fail() to see if it worked as expected,\nor not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\nifstream test;\n\ntest.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;())\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You must also verify that the file provided is the correct type of file.\nTo accomplish this you need to look through the file path provided until \nyou find the file extension. Once you have the file extension make sure\nthat it is a .csv file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n    extension += filename[i];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (extension == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.csv\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will return the file extension which is used later in an error message.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (period != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n        extension += filename[i];\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    extension = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; extension;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will actually call the error checks created above and then parse through the file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName) \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n    {\n        ifstream fs;\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n        string fileCommand;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;())\n        {\n            string temp;\n\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fs, fileCommand, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; fileCommand.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fileCommand[i] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)\n                    temp += fileCommand[i];\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                    temp += \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (temp != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\0\u0026quot;\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Place your code here to run the file.\u0026lt;/span\u0026gt;\n            }\n        }\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName))\n    {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error: The provided file does not exist: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tCheck the file extension.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tThere is no file in the provided path.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName)) \n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Incorrect file extension provided: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) \u0026amp;lt;\u0026amp;lt; endl;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There is no file in the following path: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since i\u0026apos;m not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a \u0026apos;,\u0026apos;. You could load this data in the form of an array with the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n    ifstream ifs;\n    ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name_of_file.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    string s1;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; k++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(ifs,s1);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s1)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        {\n            stream \u0026amp;gt;\u0026amp;gt;A[k][j];\n            stream \u0026amp;gt;\u0026amp;gt; c;\n            j++;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!stream) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;}\n        }\n    }\n\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use this library:\n\u0026lt;a href=\u0026quot;https://github.com/vadamsky/csvworker\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/vadamsky/csvworker\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Code for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csvworker.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    CsvWorker csv;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loadFromFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;example.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; endl;\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;();++i)\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//cout \u0026amp;lt;\u0026amp;lt; csv.getRow(i) \u0026amp;lt;\u0026amp;lt; endl;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;j\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;();++j)\n        {\n            cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getField\u0026lt;/span\u0026gt;(i, j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n        cout \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvWorker \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test2.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You gotta feel proud when you use something so beautiful as \u0026lt;code\u0026gt;boost::spirit\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here my attempt of a parser (almost) complying with the CSV specifications on this link \u0026lt;a href=\u0026quot;http://www.ietf.org/rfc/rfc4180.txt\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSV specs\u0026lt;/a\u0026gt; (I didn\u0026apos;t need line breaks within fields. Also the spaces around the commas are dismissed).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// csvparser.cpp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/qi.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/phoenix_operator.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi = boost::spirit::qi;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; bascii = boost::spirit::ascii;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Iterator\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt; : qi::grammar\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(), \n    bascii::space_type\u0026amp;gt;\n{\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; COMMA;\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; DDQUOTE;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; non_escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; field;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(),  bascii::space_type  \u0026amp;gt; start;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt;() : csv_parser::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;base_type\u0026lt;/span\u0026gt;(start)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lit;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lexeme;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::char_;\n\n        start       = field % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n        field       = escaped | non_escaped;\n        escaped     = lexeme[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;) | COMMA | DDQUOTE)  \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        non_escaped = lexeme[       *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)                  )        ];\n        DDQUOTE     = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\\u0026quot;\\\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;)       [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        COMMA       = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)          [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;];\n    }\n\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter CSV lines [empty] to quit\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::space;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::string::const_iterator iterator_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv_parser\u0026amp;lt;iterator_type\u0026amp;gt; csv_parser;\n\n    csv_parser grammar;\n    std::string str;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fid;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, str))\n    {\n        fid = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n        std::vector\u0026amp;lt;std::string\u0026amp;gt; csv;\n        std::string::const_iterator it_beg = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n        std::string::const_iterator it_end = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(it_beg, it_end, grammar, space, csv);\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (r \u0026amp;amp;\u0026amp;amp; it_beg == it_end)\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing succeeded\\n\u0026quot;\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field: csv)\n            {\n                std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; ++fid \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; std::endl;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing failed\\n\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;make csvparser\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Test (example stolen from \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Comma-separated_values#Example\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;./csvparser\nEnter CSV lines [empty] to quit\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\nParsing succeeded\nfield 1: 1999\nfield 2: Chevy\nfield 3: Venture \u0026quot;Extended Edition, Very Large\u0026quot;\nfield 4: \nfield 5: 5000.00\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\u0026quot;\nParsing failed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This solution detects these 4 cases\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;complete class is at\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/pedro-vicente/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/pedro-vicente/csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3 quoted, with separator\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline and separator,\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usage is\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt; csv;\ncsv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../test.csv\u0026quot;\u0026lt;/span\u0026gt;);\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n{\n  row = csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the class declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;file_name)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  std::ifstream m_ifs;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the implementation\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_csv_t::read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; quote_mode = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n  std::string column;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(c))\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c)\n    {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//separator \u0026apos;,\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//push column if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(column);\n        column.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//quote \u0026apos;\u0026quot;\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//toggle quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n      quote_mode = !quote_mode;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//line end detected\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return row if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; row;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//default, add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n      column += c;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return empty vector if end of file detected \u0026lt;/span\u0026gt;\n  m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; v;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Parsing CSV file lines with Stream\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Infile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ofstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fout\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;OutFile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstring strline, strremain, strCol1 , strout;\n\nstring delimeter =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;;\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d1;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;to continue until the end of the file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!fin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){ \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;get first line from InFile :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fin,strline,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;find delimeter position in line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    d1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and parse first column:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strCol1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// parse first Column\u0026lt;/span\u0026gt;\n    d1++;\n    strremain = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remaining line\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;create output line in CSV format:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(strCol1);\n    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(delimeter);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;write line to Out File:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    fout \u0026amp;lt;\u0026amp;lt; strout \u0026amp;lt;\u0026amp;lt; endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//out file line\u0026lt;/span\u0026gt;\n\n} \n\nfin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\nfout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This code is compiled and running. Good luck!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could also take a look at capabilities of \u0026lt;code\u0026gt;Qt\u0026lt;/code\u0026gt; library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It has regular expressions support and QString class has nice methods, e.g. \u0026lt;code\u0026gt;split()\u0026lt;/code\u0026gt; returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To get a column with a given header name I use following: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601\u0026quot;\u0026gt;c++ inheritance Qt problem qstring\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have had luck with the CSV parsing here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.zedwood.com/article/112/cpp-csv-parser\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.zedwood.com/article/112/cpp-csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It handles quoted fields - but does not handle inline \\n characters (which is probably fine for most uses).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn\u0026apos;t too difficult) and it does not comply with \u0026quot;\\r\\n\u0026quot; end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;wstring \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; whitespace, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    wstring ws;\n    wstring::size_type strBegin = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(whitespace);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (strBegin == wstring::npos)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n\n    wstring::size_type strEnd = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_last_not_of\u0026lt;/span\u0026gt;(whitespace);\n    wstring::size_type strRange = strEnd - strBegin + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((str[strBegin] == quotChar) \u0026amp;amp;\u0026amp;amp; (str[strEnd] == quotChar))\n    {\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, strRange\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-2\u0026lt;/span\u0026gt;);\n        strBegin = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((strEnd = ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, strBegin)) != wstring::npos)\n        {\n            ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(strEnd, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n            strBegin = strEnd+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin, strRange);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ws;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; r;\n    r.first = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, ofs);\n    r.second = wstring::npos;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(r.first != wstring::npos)\n    {\n        r.second = r.first;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(((r.second = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) != wstring::npos)\n            \u0026amp;amp;\u0026amp;amp; (line[r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == quotChar)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// WARNING: assumes null-terminated string such that line[r.second+1] always exist\u0026lt;/span\u0026gt;\n            r.second++;\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; r;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector\u0026amp;lt;wstring\u0026amp;gt;\u0026amp;amp; fields, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs, ofs0, np;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; delim = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring whitespace = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot; \\t\\xa0\\x3000\\x2000\\x2001\\x2002\\x2003\\x2004\\x2005\\x2006\\x2007\\x2008\\x2009\\x200a\\x202f\\x205f\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;;\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; quot;\n\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n    ofs = ofs0 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((np = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(delim, ofs)) != wstring::npos)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((np \u0026amp;gt; quot.first) \u0026amp;amp;\u0026amp;amp; (np \u0026amp;lt; quot.second))\n        { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// skip delimiter inside quoted field\u0026lt;/span\u0026gt;\n            ofs = quot.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar, ofs);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;;\n        }\n        fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0, np-ofs0), whitespace, quotChar) );\n        ofs = ofs0 = np+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0), whitespace, quotChar) );\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Parse a CSV data file and fill the 2d STL vector \u0026quot;data\u0026quot;.\n * Limits: only \u0026quot;pure datas\u0026quot; of doubles, not encapsulated by \u0026quot; and without \\n inside.\n * Further no formatting in the data (e.g. scientific notation)\n * It however handles both dots and commas as decimal separators and removes thousand separator.\n * \n * returnCodes[0]: file access 0-\u0026amp;gt; ok 1-\u0026amp;gt; not able to read; 2-\u0026amp;gt; decimal separator equal to comma separator\n * returnCodes[1]: number of records\n * returnCodes[2]: number of fields. -1 If rows have different field size\n * \n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCsvData\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector \u0026amp;lt;vector \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;amp; data, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; filename, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; delimiter, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; decseparator)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; };\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;returnCodes\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n string rowstring, stringtoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; doubletoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; rowcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fieldcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename, ios_base::in)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()){\n   returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n }\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iFile, rowstring)) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (rowstring==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// empty line\u0026lt;/span\u0026gt;\n    rowcount ++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//let\u0026apos;s start with 1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delimiter == decseparator){\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(decseparator != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;){\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove dots (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// replace decimal separator with dots.\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(),decseparator.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;()[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;); \n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove commas (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// tokenize..\u0026lt;/span\u0026gt;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt; tokens;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters at beginning.\u0026lt;/span\u0026gt;\n    string::size_type lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find first \u0026quot;non-delimiter\u0026quot;.\u0026lt;/span\u0026gt;\n    string::size_type pos     = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (string::npos != pos || string::npos != lastPos){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Found a token, convert it to double add it to the vector.\u0026lt;/span\u0026gt;\n        stringtoken = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(lastPos, pos - lastPos);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (stringtoken == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) {\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0\u0026lt;/span\u0026gt;);\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n          istringstream \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;totalSString\u0026lt;/span\u0026gt;(stringtoken);\n      totalSString \u0026amp;gt;\u0026amp;gt; doubletoken;\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(doubletoken);\n    }     \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters.  Note the \u0026quot;not_of\u0026quot;\u0026lt;/span\u0026gt;\n        lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, pos);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next \u0026quot;non-delimiter\u0026quot;\u0026lt;/span\u0026gt;\n        pos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(rowcount == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;){\n      fieldcount = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() != fieldcount){\n    returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n      }\n    }\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(tokens);\n }\n iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = rowcount;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":402,"title":"How can I read and parse CSV files in C++?","content":"\n                \n\u0026lt;p\u0026gt;I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don\u0026apos;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I found this article which looks quite promising:\n\u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve never used Boost\u0026apos;s Spirit, but am willing to try it. But only if there isn\u0026apos;t a more straightforward solution I\u0026apos;m overlooking.\u0026lt;/p\u0026gt;\n    ","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219","postType":"QUESTION","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","tags":[{"id":2159,"name":"text","slug":"text","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2159}},{"id":2160,"name":"csv","slug":"csv","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2160}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},"buildId":"8pZkyd0U8-Y2Qf3QK9j7l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>