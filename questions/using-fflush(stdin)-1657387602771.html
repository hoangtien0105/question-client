<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_buildManifest.js" defer=""></script><script src="/_next/static/8pZkyd0U8-Y2Qf3QK9j7l/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/using-fflush(stdin)-1657387602771#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/using-fflush(stdin)-1657387602771">Using fflush(stdin)</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/fflush">fflush</a></div></div><div class="question-content mt-5">
                
<p>So a quick Google search for <code>fflush(stdin)</code> for clearing the input buffer reveals numerous websites warning against using it. And yet that's exactly how my CS professor taught the class to do it.</p>

<p>How bad is using <code>fflush(stdin)</code>? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple: this is undefined behavior, since <code>fflush</code> is meant to be called on an output stream. This is an excerpt from the C standard:</p>
<blockquote>
<p>int fflush(FILE *ostream);</p>
<p>ostream points to an output stream or
an update stream in which the most
recent operation was not input, the
fflush function causes any unwritten
data for that stream to be delivered
to the host environment to be written
to the file; otherwise, the behavior
is undefined.</p>
</blockquote>
<p>So it's not a question of "how bad" this is. <code>fflush(stdin)</code> is simply not portable, so you should not use it if you want your code to be portable between compilers.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><sup><em>Converting comments into an answer.</em></sup></p>
<h1>TL;DR  <em><strong>Portable code doesn't use <code>fflush(stdin)</code></strong></em></h1>
<p>The rest of this answer explains why portable code does not use <code>fflush(stdin)</code>.  It is tempting to add "reliable code doesn't use <code>fflush(stdin)</code>", which is also generally true.</p>
<h2>Standard C and POSIX leave <code>fflush(stdin)</code> as undefined behaviour</h2>
<p>The <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html" rel="noreferrer">POSIX</a>, C and C++ standards for <code>fflush()</code> explicitly state that the behaviour is undefined (because <code>stdin</code> is an input stream), but none of them prevent a system from defining it.</p>
<p>ISO/IEC 9899:2011 &nbsp;the C11 Standard  says:</p>
<blockquote>
<h3><a href="http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2" rel="noreferrer">§7.21.5.2 The fflush function</a></h3>
<p>¶2 If <code>stream</code> points to an output stream or an update stream in which the most recent operation was not input, the <code>fflush</code> function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.</p>
</blockquote>
<p>POSIX mostly defers to the C standard but it does mark this text as a C extension.</p>
<blockquote>
<p>[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by <code>ungetc()</code> or <code>ungetwc()</code> that have not subsequently been read from the stream shall be discarded (without further changing the file offset). </p>
</blockquote>
<p>Note that terminals are not capable of seeking; neither are pipes or sockets.</p>
<h2>Microsoft defines the behaviour of <code>fflush(stdin)</code></h2>
<p>In 2015, <a href="http://msdn.microsoft.com/en-us/library/9yky46tz.aspx" rel="noreferrer">Microsoft</a> and the Visual Studio runtime used to define the behaviour of <code>fflush()</code> on an input stream like this (but the link leads to different text in 2021):</p>
<blockquote>
<p>If the stream is open for input, <code>fflush</code> clears the contents of the buffer.</p>
</blockquote>
<p><a href="https://stackoverflow.com/users/1505939/m-m">M.M</a> <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209">notes</a>:</p>
<blockquote>
<p>Cygwin is an example of a fairly common platform on which <code>fflush(stdin)</code> does not clear the input.</p>
</blockquote>
<p>This is why this answer version of my <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209">comment</a> notes 'Microsoft and the Visual Studio runtime'  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.</p>
<p><a href="https://stackoverflow.com/users/4142924/weather-vane">Weather Vane</a> pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160" rel="noreferrer"><code>fflush()</code></a> compared with what was originally specified when this answer was written in 2015.  It now says:</p>
<blockquote>
<p>If the stream was opened in read mode, or if the stream has no buffer, the call to <code>fflush</code> has no effect, and any buffer is retained. A call to <code>fflush</code> negates the effect of any prior call to <code>ungetc</code> for the stream.</p>
</blockquote>
<p><a href="https://en.wiktionary.org/wiki/caveat_lector" rel="noreferrer"><em>Caveat Lector:</em></a> it is probably best not to rely on <code>fflush(stdin)</code> on any platform.</p>
<h2>Linux documentation and practice seem to contradict each other</h2>
<p>Surprisingly, <a href="http://linux.die.net/man/3/fflush" rel="noreferrer">Linux</a> nominally documents the behaviour of <code>fflush(stdin)</code> too, and even defines it the same way (miracle of miracles).  This quote is from 2015.</p>
<blockquote>
<p>For input streams, <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.</p>
</blockquote>
<p>In 2021, the quote changes to:</p>
<blockquote>
<p>For input streams, <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.</p>
</blockquote>
<p>And another source for <a href="http://man7.org/linux/man-pages/man3/fflush.3.html" rel="noreferrer"><code>fflush(3)</code></a> on Linux agrees (give or take paragraph breaks):</p>
<blockquote>
<p>For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.</p>
</blockquote>
<p>Neither of these explicitly addresses the points made by the POSIX specification about <code>ungetc()</code>.</p>
<p>In 2021, <a href="https://stackoverflow.com/users/388520/zwol">zwol</a> <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021">commented</a> that the Linux documentation has been improved.
It seems to me that there is still room for improvement.</p>
<p>In 2015, I was a bit puzzled and surprised at the Linux documentation saying that <code>fflush(stdin)</code> will work.
Despite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work &nbsp;at least when the input stream is a non-seekable device such as a terminal.</p>
<h3><code>demo-fflush.c</code></h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-type">int</span> c;
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c; enter some new data\n"</span>, c);
        fflush(<span class="hljs-built_in">stdin</span>);
    }
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3>Example output</h3>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush
Alliteration
Got A; enter some new data
Got l
$
</code></pre>
<p>This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the <code>fflush(stdin)</code> operation worked, I would have to type a new line of text to get information for the second <code>getchar()</code> to read.</p>
<p>Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.</p>
<h3><code>demo-fflush2.c</code></h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-type">int</span> c;
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);
        ungetc(<span class="hljs-string">'B'</span>, <span class="hljs-built_in">stdin</span>);
        ungetc(<span class="hljs-string">'Z'</span>, <span class="hljs-built_in">stdin</span>);
        <span class="hljs-keyword">if</span> ((c = getchar()) == EOF)
        {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Huh?!\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c after ungetc()\n"</span>, c);
        fflush(<span class="hljs-built_in">stdin</span>);
    }
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3>Example output</h3>
<p>Note that <code>/etc/passwd</code> is a seekable file.  On Ubuntu, the first line looks like:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">root:x:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:root:/root:/bin/bash
</code></pre>
<p>On Mac OS X, the first 4 lines look like:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">##
# User Database
# 
# Note that this file is consulted directly only when the system is running
</code></pre>
<p>In other words, there is commentary at the top of the Mac OS X <code>/etc/passwd</code> file.  The non-comment lines conform to the normal layout, so the <code>root</code> entry is:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">root:*:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:System Administrator:/var/root:/bin/sh
</code></pre>
<p>Ubuntu 14.04 LTS:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush2 &lt; /etc/passwd
Got r
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got o
$ ./demo-fflush2
Allotrope
Got A
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got B
$
</code></pre>
<p>Mac OS X 10.11.2:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush2 &lt; /etc/passwd
Got #
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got B
$
</code></pre>
<p>The Mac OS X behaviour ignores (or at least seems to ignore) the <code>fflush(stdin)</code> (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.</p>
<h2>Summary</h2>
<p>Microsoft documents the behaviour of <code>fflush(stdin)</code>, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.</p>
<p>Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of <code>fflush(stdin)</code> is undefined.  POSIX adds the qualifier 'unless the input file is seekable', which a terminal is not.  The behaviour is not the same as Microsoft's.</p>
<p>Consequently, <em><strong>portable code does not use <code>fflush(stdin)</code></strong></em>.  Code that is tied to Microsoft's platform may use it and it may work as expected, but beware of the portability issues.</p>
<h3>POSIX way to discard unread terminal input from a file descriptor</h3>
<p>The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like <code>stdin</code>) is illustrated at <a href="https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system">How can I flush unread data from a tty input queue on a Unix system</a>.  However, that is operating below the standard I/O library level.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>According to the standard, <code>fflush</code> can only be used with output buffers, and obviously <code>stdin</code> isn't one. However, <a href="http://msdn.microsoft.com/en-us/library/9yky46tz.aspx" rel="nofollow noreferrer">some</a> standard C libraries provide the use of <code>fflush(stdin)</code> as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe that you should never call <code>fflush(stdin)</code>, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that <code>scanf</code> is stuck on.</p>
<p>For example, you might have a program that is sitting in a loop reading integers using <code>scanf("%d", &amp;n)</code>.  Soon enough you'll discover that the first time the user types a non-digit character like <code>'x'</code>, <a href="https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code">the program goes into an infinite loop</a>.</p>
<p>When faced with this situation, I believe you basically have three choices:</p>
<ol>
<li>Flush the input somehow (if not by using <code>fflush(stdin)</code>, then by calling <code>getchar</code> in a loop to read characters until <code>\n</code>, as is often recommended).</li>
<li>Tell the user not to type non-digit characters when digits are expected.</li>
<li><a href="https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf">Use something other than <code>scanf</code> to read input</a>.</li>
</ol>
<p>Now, if you're a beginner, <code>scanf</code> <em>seems</em> like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it'd be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using <code>scanf</code>, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they're sorely tempted to use <code>fflush(stdin)</code>.</p>
<p>I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:</p>
<ol>
<li><p>During the earliest stages of your C programming career, before you're comfortable using anything other than <code>scanf</code>, just <em>don't worry about bad input</em>.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You're a beginner, there are lots of things you don't know how to do yet, and one of the things you don't know how to do yet is: deal gracefully with unexpected input.</p>
</li>
<li><p>As soon as you can, <a href="https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf">learn how to do input using functions other than <code>scanf</code></a>.  At that point, you can start dealing gracefully with bad input, and you'll have many more, much better techniques available to you, that won't require trying to "flush the bad input" at all.</p>
</li>
</ol>
<p>Or, in other words, beginners who are still stuck using <code>scanf</code> should feel free to use cop-out #2, and when they're ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with <code>fflush(stdin)</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using <code>fflush(stdin)</code> to flush input is kind of like <a href="https://en.wikipedia.org/wiki/Dowsing" rel="nofollow noreferrer">dowsing for water</a> using a stick shaped like the letter "S".</p>
<p>And helping people to flush input in some "better" way is kind of like rushing up to an S-stick dowser and saying "No, no, you're doing it wrong,
you need to use a Y-shaped stick!".</p>
<p>In other words, the real problem isn't that <code>fflush(stdin)</code> doesn't work.  Calling <code>fflush(stdin)</code> is a symptom of an underlying problem.  Why are you having to "flush" input at all?  <em>That's</em> your problem.</p>
<p>And, usually, that underlying problem is that you're using <code>scanf</code>, in one of its many unhelpful modes that unexpectedly leaves newlines or other "unwanted" text on the input.  The best long-term solution, therefore, is to <a href="https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf">learn how to do input using better techniques than <code>scanf</code></a>, so that you don't have to deal with its unhandled input and other idiosyncrasies at all.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>None of the existing answers point out a key aspect of the issue.</p>
<p>If you find yourself <em>wanting</em> to "clear the input buffer", you're probably writing a command-line interactive program, and it would be more accurate to say that what you want is to <em>discard characters from the current <strong>line</strong> of input that you haven't already read.</em></p>
<p><strong>This is not what <code>fflush(stdin)</code> does.</strong>  The C libraries that support using <code>fflush</code> on an input stream, document it as either doing <em>nothing,</em> or as discarding <em>buffered data that has been read from the underlying file but not passed to the application</em>.  That can easily be either <em>more</em> or <em>less</em> input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large "blocks" (often 4 to 8 kB) with no relationship to line boundaries, and you'll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the <em>middle</em> of some apparently random line below.  Or, if you decide to test your program on a very <em>long</em> line typed by hand, then the terminal driver won't be able to give the program the whole line at once and <code>fflush(stdin)</code> won't skip all of it.</p>
<p>So what should you do instead?  The approach that I prefer is, if you're processing input one line at a time, then <em>read an entire line all at once</em>.  The C library has functions specifically for this: <code>fgets</code> (in C90, so fully portable, but does still make you process very long lines in chunks) and <code>getline</code> (POSIX-specific, but will manage a <code>malloc</code>ed buffer for you so you can process long lines all at once no matter how long they get).  There's usually a direct translation from code that processes "the current line" directly from stdin to code that processes a string containing "the current line".</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Quote from <a href="https://www.unix.com/man-page/posix/3P/fflush/" rel="nofollow noreferrer" title="POSIX">POSIX</a>:</p>
<blockquote>
<p>For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one
capable of seeking, the file offset of the underlying open file description shall  be  set
to  the   file  position  of  the stream, and any characters pushed back onto the stream by
ungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-
carded (without further changing the file offset).</p>
</blockquote>
<p>Note that terminal is not capable of seeking.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Simple: this is undefined behavior, since \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; is meant to be called on an output stream. This is an excerpt from the C standard:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;int fflush(FILE *ostream);\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ostream points to an output stream or\nan update stream in which the most\nrecent operation was not input, the\nfflush function causes any unwritten\ndata for that stream to be delivered\nto the host environment to be written\nto the file; otherwise, the behavior\nis undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;So it\u0026apos;s not a question of \u0026quot;how bad\u0026quot; this is. \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is simply not portable, so you should not use it if you want your code to be portable between compilers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;em\u0026gt;Converting comments into an answer.\u0026lt;/em\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;TL;DR  \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Portable code doesn\u0026apos;t use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;The rest of this answer explains why portable code does not use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.  It is tempting to add \u0026quot;reliable code doesn\u0026apos;t use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026quot;, which is also generally true.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Standard C and POSIX leave \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; as undefined behaviour\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;POSIX\u0026lt;/a\u0026gt;, C and C++ standards for \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; explicitly state that the behaviour is undefined (because \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; is an input stream), but none of them prevent a system from defining it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ISO/IEC 9899:2011 \u0026amp;nbsp;the C11 Standard  says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;§7.21.5.2 The fflush function\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;¶2 If \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; points to an output stream or an update stream in which the most recent operation was not input, the \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;POSIX mostly defers to the C standard but it does mark this text as a C extension.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by \u0026lt;code\u0026gt;ungetc()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;ungetwc()\u0026lt;/code\u0026gt; that have not subsequently been read from the stream shall be discarded (without further changing the file offset). \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note that terminals are not capable of seeking; neither are pipes or sockets.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Microsoft defines the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In 2015, \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Microsoft\u0026lt;/a\u0026gt; and the Visual Studio runtime used to define the behaviour of \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; on an input stream like this (but the link leads to different text in 2021):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If the stream is open for input, \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; clears the contents of the buffer.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/users/1505939/m-m\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209\u0026quot;\u0026gt;notes\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Cygwin is an example of a fairly common platform on which \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; does not clear the input.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This is why this answer version of my \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209\u0026quot;\u0026gt;comment\u0026lt;/a\u0026gt; notes \u0026apos;Microsoft and the Visual Studio runtime\u0026apos;  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/users/4142924/weather-vane\u0026quot;\u0026gt;Weather Vane\u0026lt;/a\u0026gt; pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of \u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; compared with what was originally specified when this answer was written in 2015.  It now says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If the stream was opened in read mode, or if the stream has no buffer, the call to \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; has no effect, and any buffer is retained. A call to \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; negates the effect of any prior call to \u0026lt;code\u0026gt;ungetc\u0026lt;/code\u0026gt; for the stream.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wiktionary.org/wiki/caveat_lector\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;Caveat Lector:\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; it is probably best not to rely on \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; on any platform.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Linux documentation and practice seem to contradict each other\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Surprisingly, \u0026lt;a href=\u0026quot;http://linux.die.net/man/3/fflush\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Linux\u0026lt;/a\u0026gt; nominally documents the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; too, and even defines it the same way (miracle of miracles).  This quote is from 2015.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams, \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In 2021, the quote changes to:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams, \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;And another source for \u0026lt;a href=\u0026quot;http://man7.org/linux/man-pages/man3/fflush.3.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fflush(3)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; on Linux agrees (give or take paragraph breaks):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Neither of these explicitly addresses the points made by the POSIX specification about \u0026lt;code\u0026gt;ungetc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In 2021, \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/388520/zwol\u0026quot;\u0026gt;zwol\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021\u0026quot;\u0026gt;commented\u0026lt;/a\u0026gt; that the Linux documentation has been improved.\nIt seems to me that there is still room for improvement.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In 2015, I was a bit puzzled and surprised at the Linux documentation saying that \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; will work.\nDespite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work \u0026amp;nbsp;at least when the input stream is a non-seekable device such as a terminal.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;code\u0026gt;demo-fflush.c\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c; enter some new data\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        fflush(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Example output\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush\nAlliteration\nGot A; enter some new data\nGot l\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; operation worked, I would have to type a new line of text to get information for the second \u0026lt;code\u0026gt;getchar()\u0026lt;/code\u0026gt; to read.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;code\u0026gt;demo-fflush2.c\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        ungetc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n        ungetc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Z\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) == EOF)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Huh?!\\n\u0026quot;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c after ungetc()\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        fflush(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Example output\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;/etc/passwd\u0026lt;/code\u0026gt; is a seekable file.  On Ubuntu, the first line looks like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;root:x:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:root:/root:/bin/bash\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;On Mac OS X, the first 4 lines look like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In other words, there is commentary at the top of the Mac OS X \u0026lt;code\u0026gt;/etc/passwd\u0026lt;/code\u0026gt; file.  The non-comment lines conform to the normal layout, so the \u0026lt;code\u0026gt;root\u0026lt;/code\u0026gt; entry is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;root:*:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:System Administrator:/var/root:/bin/sh\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Ubuntu 14.04 LTS:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush2 \u0026amp;lt; /etc/passwd\nGot r\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot o\n$ ./demo-fflush2\nAllotrope\nGot A\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot B\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Mac OS X 10.11.2:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush2 \u0026amp;lt; /etc/passwd\nGot #\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot B\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The Mac OS X behaviour ignores (or at least seems to ignore) the \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Summary\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Microsoft documents the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is undefined.  POSIX adds the qualifier \u0026apos;unless the input file is seekable\u0026apos;, which a terminal is not.  The behaviour is not the same as Microsoft\u0026apos;s.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Consequently, \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;portable code does not use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;.  Code that is tied to Microsoft\u0026apos;s platform may use it and it may work as expected, but beware of the portability issues.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;POSIX way to discard unread terminal input from a file descriptor\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt;) is illustrated at \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system\u0026quot;\u0026gt;How can I flush unread data from a tty input queue on a Unix system\u0026lt;/a\u0026gt;.  However, that is operating below the standard I/O library level.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;According to the standard, \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; can only be used with output buffers, and obviously \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; isn\u0026apos;t one. However, \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;some\u0026lt;/a\u0026gt; standard C libraries provide the use of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe that you should never call \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; is stuck on.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, you might have a program that is sitting in a loop reading integers using \u0026lt;code\u0026gt;scanf(\u0026quot;%d\u0026quot;, \u0026amp;amp;n)\u0026lt;/code\u0026gt;.  Soon enough you\u0026apos;ll discover that the first time the user types a non-digit character like \u0026lt;code\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/code\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code\u0026quot;\u0026gt;the program goes into an infinite loop\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When faced with this situation, I believe you basically have three choices:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Flush the input somehow (if not by using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, then by calling \u0026lt;code\u0026gt;getchar\u0026lt;/code\u0026gt; in a loop to read characters until \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;, as is often recommended).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Tell the user not to type non-digit characters when digits are expected.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf\u0026quot;\u0026gt;Use something other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; to read input\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Now, if you\u0026apos;re a beginner, \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;seems\u0026lt;/em\u0026gt; like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it\u0026apos;d be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they\u0026apos;re sorely tempted to use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;During the earliest stages of your C programming career, before you\u0026apos;re comfortable using anything other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, just \u0026lt;em\u0026gt;don\u0026apos;t worry about bad input\u0026lt;/em\u0026gt;.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You\u0026apos;re a beginner, there are lots of things you don\u0026apos;t know how to do yet, and one of the things you don\u0026apos;t know how to do yet is: deal gracefully with unexpected input.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As soon as you can, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf\u0026quot;\u0026gt;learn how to do input using functions other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  At that point, you can start dealing gracefully with bad input, and you\u0026apos;ll have many more, much better techniques available to you, that won\u0026apos;t require trying to \u0026quot;flush the bad input\u0026quot; at all.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Or, in other words, beginners who are still stuck using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; should feel free to use cop-out #2, and when they\u0026apos;re ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; to flush input is kind of like \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Dowsing\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dowsing for water\u0026lt;/a\u0026gt; using a stick shaped like the letter \u0026quot;S\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And helping people to flush input in some \u0026quot;better\u0026quot; way is kind of like rushing up to an S-stick dowser and saying \u0026quot;No, no, you\u0026apos;re doing it wrong,\nyou need to use a Y-shaped stick!\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other words, the real problem isn\u0026apos;t that \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; doesn\u0026apos;t work.  Calling \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is a symptom of an underlying problem.  Why are you having to \u0026quot;flush\u0026quot; input at all?  \u0026lt;em\u0026gt;That\u0026apos;s\u0026lt;/em\u0026gt; your problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And, usually, that underlying problem is that you\u0026apos;re using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, in one of its many unhelpful modes that unexpectedly leaves newlines or other \u0026quot;unwanted\u0026quot; text on the input.  The best long-term solution, therefore, is to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf\u0026quot;\u0026gt;learn how to do input using better techniques than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, so that you don\u0026apos;t have to deal with its unhandled input and other idiosyncrasies at all.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;None of the existing answers point out a key aspect of the issue.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you find yourself \u0026lt;em\u0026gt;wanting\u0026lt;/em\u0026gt; to \u0026quot;clear the input buffer\u0026quot;, you\u0026apos;re probably writing a command-line interactive program, and it would be more accurate to say that what you want is to \u0026lt;em\u0026gt;discard characters from the current \u0026lt;strong\u0026gt;line\u0026lt;/strong\u0026gt; of input that you haven\u0026apos;t already read.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This is not what \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; does.\u0026lt;/strong\u0026gt;  The C libraries that support using \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; on an input stream, document it as either doing \u0026lt;em\u0026gt;nothing,\u0026lt;/em\u0026gt; or as discarding \u0026lt;em\u0026gt;buffered data that has been read from the underlying file but not passed to the application\u0026lt;/em\u0026gt;.  That can easily be either \u0026lt;em\u0026gt;more\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;less\u0026lt;/em\u0026gt; input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large \u0026quot;blocks\u0026quot; (often 4 to 8 kB) with no relationship to line boundaries, and you\u0026apos;ll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the \u0026lt;em\u0026gt;middle\u0026lt;/em\u0026gt; of some apparently random line below.  Or, if you decide to test your program on a very \u0026lt;em\u0026gt;long\u0026lt;/em\u0026gt; line typed by hand, then the terminal driver won\u0026apos;t be able to give the program the whole line at once and \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; won\u0026apos;t skip all of it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So what should you do instead?  The approach that I prefer is, if you\u0026apos;re processing input one line at a time, then \u0026lt;em\u0026gt;read an entire line all at once\u0026lt;/em\u0026gt;.  The C library has functions specifically for this: \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; (in C90, so fully portable, but does still make you process very long lines in chunks) and \u0026lt;code\u0026gt;getline\u0026lt;/code\u0026gt; (POSIX-specific, but will manage a \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;ed buffer for you so you can process long lines all at once no matter how long they get).  There\u0026apos;s usually a direct translation from code that processes \u0026quot;the current line\u0026quot; directly from stdin to code that processes a string containing \u0026quot;the current line\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Quote from \u0026lt;a href=\u0026quot;https://www.unix.com/man-page/posix/3P/fflush/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;POSIX\u0026quot;\u0026gt;POSIX\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one\ncapable of seeking, the file offset of the underlying open file description shall  be  set\nto  the   file  position  of  the stream, and any characters pushed back onto the stream by\nungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-\ncarded (without further changing the file offset).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note that terminal is not capable of seeking.\u0026lt;/p\u0026gt;\n    "],"id":314,"title":"Using fflush(stdin)","content":"\n                \n\u0026lt;p\u0026gt;So a quick Google search for \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; for clearing the input buffer reveals numerous websites warning against using it. And yet that\u0026apos;s exactly how my CS professor taught the class to do it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How bad is using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?\u0026lt;/p\u0026gt;\n    ","slug":"using-fflush(stdin)-1657387602771","postType":"QUESTION","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","tags":[{"id":1849,"name":"stdin","slug":"stdin","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1849}},{"id":1850,"name":"fflush","slug":"fflush","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1850}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"using-fflush(stdin)-1657387602771"},"buildId":"8pZkyd0U8-Y2Qf3QK9j7l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>