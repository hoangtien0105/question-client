<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>When can I use a forward declaration? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am looking for the definition of when I am allowed to do forward declaration of a class in another class&#x27;s header file:

Am I allowed to do it for a base class, for a class held as a member, for a class passed to member function by reference, etc. ?
    "/><meta property="og:title" content="When can I use a forward declaration? | Solutions Checker"/><meta property="og:description" content="I am looking for the definition of when I am allowed to do forward declaration of a class in another class&#x27;s header file:

Am I allowed to do it for a base class, for a class held as a member, for a class passed to member function by reference, etc. ?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"When can I use a forward declaration?","text":"I am looking for the definition of when I am allowed to do forward declaration of a class in another class&apos;s header file:\n\nAm I allowed to do it for a base class, for a class held as a member, for a class passed to member function by reference, etc. ?\n    ","answerCount":13,"upVoteCount":500,"suggestedAnswer":[{"text":"Put yourself in the compiler&apos;s position: when you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods. This is why it&apos;s called an incomplete type. Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.\n\nAssuming the following forward declaration.\n\nclass X;\n\n\nHere&apos;s what you can and cannot do.\n\nWhat you can do with an incomplete type:\n\n\nDeclare a member to be a pointer or a reference to the incomplete type:\n\nclass Foo {\n    X *p;\n    X &amp;r;\n};\n\nDeclare functions or methods which accept/return incomplete types:\n\nvoid f1(X);\nX    f2();\n\nDefine functions or methods which accept/return pointers/references to the incomplete type (but without using its members):\n\nvoid f3(X*, X&amp;) {}\nX&amp;   f4()       {}\nX*   f5()       {}\n\n\n\nWhat you cannot do with an incomplete type:\n\n\nUse it as a base class\n\nclass Foo : X {} // compiler error!\n\nUse it to declare a member:\n\nclass Foo {\n    X m; // compiler error!\n};\n\nDefine functions or methods using this type\n\nvoid f1(X x) {} // compiler error!\nX    f2()    {} // compiler error!\n\nUse its methods or fields, in fact trying to dereference a variable with incomplete type\n\nclass Foo {\n    X *m;            \n    void method()            \n    {\n        m-&gt;someMethod();      // compiler error!\n        int i = m-&gt;someField; // compiler error!\n    }\n};\n\n\n\n\n\nWhen it comes to templates, there is no absolute rule: whether you can use an incomplete type as a template parameter is dependent on the way the type is used in the template.\n\nFor instance, std::vector&lt;T&gt; requires its parameter to be a complete type, while boost::container::vector&lt;T&gt; does not. Sometimes, a complete type is required only if you use certain member functions; this is the case for std::unique_ptr&lt;T&gt;, for example.\n\nA well-documented template should indicate in its documentation all the requirements of its parameters, including whether they need to be complete types or not.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The main rule is that you can only forward-declare classes whose memory layout (and thus member functions and data members) do not need to be known in the file you forward-declare it.\n\nThis would rule out base classes and anything but classes used via references and pointers.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Lakos distinguishes between class usage\n\n\nin-name-only (for which a forward declaration is sufficient) and\nin-size (for which the class definition is needed).\n\n\nI&apos;ve never seen it pronounced more succinctly :)\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"As well as pointers and references to incomplete types, you can also declare function prototypes that specify parameters and/or return values that are incomplete types.  However, you cannot define a function having a parameter or return type that is incomplete, unless it is a pointer or reference.\n\nExamples:\n\nstruct X;              // Forward declaration of X\n\nvoid f1(X* px) {}      // Legal: can always use a pointer\nvoid f2(X&amp;  x) {}      // Legal: can always use a reference\nX f3(int);             // Legal: return value in function prototype\nvoid f4(X);            // Legal: parameter in function prototype\nvoid f5(X) {}          // ILLEGAL: *definitions* require complete types\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"None of the answers so far describe when one can use a forward declaration of a class template. So, here it goes.\n\nA class template can be forwarded declared as:\n\ntemplate &lt;typename&gt; struct X;\n\n\nFollowing the structure of the accepted answer,\n\nHere&apos;s what you can and cannot do.\n\nWhat you can do with an incomplete type:\n\n\nDeclare a member to be a pointer or a reference to the incomplete type in another class template:\n\ntemplate &lt;typename T&gt;\nclass Foo {\n    X&lt;T&gt;* ptr;\n    X&lt;T&gt;&amp; ref;\n};\n\nDeclare a member to be a pointer or a reference to one of its incomplete instantiations:\n\nclass Foo {\n    X&lt;int&gt;* ptr;\n    X&lt;int&gt;&amp; ref;\n};\n\nDeclare function templates or member function templates which accept/return incomplete types:\n\ntemplate &lt;typename T&gt;\n   void      f1(X&lt;T&gt;);\ntemplate &lt;typename T&gt;\n   X&lt;T&gt;    f2();\n\nDeclare functions or member functions which accept/return one of its incomplete instantiations:\n\nvoid      f1(X&lt;int&gt;);\nX&lt;int&gt;    f2();\n\nDefine function templates or member function templates which accept/return pointers/references to the incomplete type (but without using its members):\n\ntemplate &lt;typename T&gt;\n   void      f3(X&lt;T&gt;*, X&lt;T&gt;&amp;) {}\ntemplate &lt;typename T&gt;\n   X&lt;T&gt;&amp;   f4(X&lt;T&gt;&amp; in) { return in; }\ntemplate &lt;typename T&gt;\n   X&lt;T&gt;*   f5(X&lt;T&gt;* in) { return in; }\n\nDefine functions or methods which accept/return pointers/references to one of its incomplete instantiations  (but without using its members):\n\nvoid      f3(X&lt;int&gt;*, X&lt;int&gt;&amp;) {}\nX&lt;int&gt;&amp;   f4(X&lt;int&gt;&amp; in) { return in; }\nX&lt;int&gt;*   f5(X&lt;int&gt;* in) { return in; }\n\nUse it as a base class of another template class\n\ntemplate &lt;typename T&gt;\nclass Foo : X&lt;T&gt; {} // OK as long as X is defined before\n                    // Foo is instantiated.\n\nFoo&lt;int&gt; a1; // Compiler error.\n\ntemplate &lt;typename T&gt; struct X {};\nFoo&lt;int&gt; a2; // OK since X is now defined.\n\nUse it to declare a member of another class template:\n\ntemplate &lt;typename T&gt;\nclass Foo {\n    X&lt;T&gt; m; // OK as long as X is defined before\n            // Foo is instantiated. \n};\n\nFoo&lt;int&gt; a1; // Compiler error.\n\ntemplate &lt;typename T&gt; struct X {};\nFoo&lt;int&gt; a2; // OK since X is now defined.\n\nDefine function templates or methods using this type\n\ntemplate &lt;typename T&gt;\n  void    f1(X&lt;T&gt; x) {}    // OK if X is defined before calling f1\ntemplate &lt;typename T&gt;\n  X&lt;T&gt;    f2(){return X&lt;T&gt;(); }  // OK if X is defined before calling f2\n\nvoid test1()\n{\n   f1(X&lt;int&gt;());  // Compiler error\n   f2&lt;int&gt;();     // Compiler error\n}\n\ntemplate &lt;typename T&gt; struct X {};\n\nvoid test2()\n{\n   f1(X&lt;int&gt;());  // OK since X is defined now\n   f2&lt;int&gt;();     // OK since X is defined now\n}\n\n\n\nWhat you cannot do with an incomplete type:\n\n\nUse one of its instantiations as a base class\n\nclass Foo : X&lt;int&gt; {} // compiler error!\n\nUse one of its instantiations to declare a member:\n\nclass Foo {\n    X&lt;int&gt; m; // compiler error!\n};\n\nDefine functions or methods using one of its instantiations\n\nvoid      f1(X&lt;int&gt; x) {}            // compiler error!\nX&lt;int&gt;    f2() {return X&lt;int&gt;(); }   // compiler error!\n\nUse the methods or fields of one of its instantiations, in fact trying to dereference a variable with incomplete type\n\nclass Foo {\n    X&lt;int&gt;* m;            \n    void method()            \n    {\n        m-&gt;someMethod();      // compiler error!\n        int i = m-&gt;someField; // compiler error!\n    }\n};\n\nCreate explicit instantiations of the class template\n\ntemplate struct X&lt;int&gt;;\n\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In file in which you use only Pointer or Reference to a class.And no member/member function should be invoked thought those Pointer/ reference.\n\nwith class Foo;//forward declaration\n\nWe can declare data members of type Foo* or Foo&amp;.\n\nWe can declare (but not define) functions with arguments, and/or return values, of type Foo.\n\nWe can declare static data members of type Foo. This is because static data members are defined outside the class definition.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I&apos;m writing this as a separate answer rather than just a comment because I disagree with Luc Touraille&apos;s answer, not on the grounds of legality but for robust software and the danger of misinterpretation.\n\nSpecifically, I have an issue with the implied contract of what you expect users of your interface to have to know.\n\nIf you are returning or accepting reference types, then you are just saying they can pass through a pointer or reference which they may in turn have known only through a forward declaration.\n\nWhen you are returning an incomplete type X    f2(); then you are saying your caller must have the full type specification of X. They need it in order to create the LHS or temporary object at the call site.\n\nSimilarly, if you accept an incomplete type, the caller has to have constructed the object which is the parameter. Even if that object was returned as another incomplete type from a function, the call site needs the full declaration. i.e.:\n\nclass X;  // forward for two legal declarations \nX returnsX();\nvoid XAcceptor(X);\n\nXAcepptor( returnsX() );  // X declaration needs to be known here\n\n\nI think there&apos;s an important principle that a header should supply enough information to use it without a dependency requiring other headers. That means header should be able to be included in a  compilation unit without causing a compiler error when you use any functions it declares.\n\nExcept\n\n\nIf this external dependency is desired behaviour. Instead of using conditional compilation you could have a well-documented requirement for them to supply their own header declaring X. This is an alternative to using #ifdefs and can be a useful way to introduce mocks or other variants.\nThe important distinction being some template techniques where you are explicitly NOT expected to instantiate them, mentioned just so someone doesn&apos;t get snarky with me.\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The general rule I follow is not to include any header file unless I have to.  So unless I am storing the object of a class as a member variable of my class I won&apos;t include it, I&apos;ll just use the forward declaration.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"As long as you don&apos;t need the definition (think pointers and references) you can get away with forward declarations. This is why mostly you&apos;d see them in headers while implementation files typically will pull the header for the appropriate definition(s).\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"You will usually want to use forward declaration in a classes header file when you want to use the other type (class) as a member of the class. You can not use the forward-declared classes methods in the header file because C++ does not know the definition of that class at that point yet. That&apos;s logic you have to move into the .cpp-files, but if you are using template-functions you should reduce them to only the part that uses the template and move that function into the header. \n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Take it that forward declaration will get your code to compile (obj is created). Linking however (exe creation) will not be successfull unless the definitions are found. \n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I just want to add one important thing you can do with a forwarded class not mentioned in the answer of Luc Touraille.\n\nWhat you can do with an incomplete type:\n\nDefine functions or methods which accept/return \npointers/references to the incomplete type and forward that pointers/references \nto another function.     \n\nvoid  f6(X*)       {}\nvoid  f7(X&amp;)       {}\nvoid  f8(X* x_ptr, X&amp; x_ref) { f6(x_ptr); f7(x_ref); }\n\n\nA module can pass through an object of a forward declared class to another module.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"As, Luc Touraille has already explained it very well where to use and not use forward declaration of the class.\n\nI will just add to that why we need to use it.\n\nWe should be using Forward declaration wherever possible to avoid the unwanted dependency injection.\n\nAs #include header files are added on multiple files therefore, if we add a header into another header file it will add unwanted dependency injection in various parts of source code which can be avoided by adding #include header into .cpp files wherever possible rather than adding to another header file and use class forward declaration wherever possible in header .h files.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-88567075f6bc9c6b.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-2e45c38dc6fe8298.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_buildManifest.js" defer=""></script><script src="/_next/static/d4czOeg3MGPNUI9SipfjN/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/when-can-i-use-a-forward-declaration-1657388251827#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/when-can-i-use-a-forward-declaration-1657388251827">When can I use a forward declaration?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/forward-declaration">forward-declaration</a></div></div><div class="question-content mt-5">
                
<p>I am looking for the definition of when I am allowed to do forward declaration of a class in another class's header file:</p>

<p>Am I allowed to do it for a base class, for a class held as a member, for a class passed to member function by reference, etc. ?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Put yourself in the compiler's position: when you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods. This is why it's called an <em>incomplete type</em>. Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.</p>

<p>Assuming the following forward declaration.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>;
</code></pre>

<p>Here's what you can and cannot do.</p>

<p><strong>What you can do with an incomplete type:</strong></p>

<ul>
<li><p>Declare a member to be a pointer or a reference to the incomplete type:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X *p;
    X &amp;r;
};
</code></pre></li>
<li><p><em>Declare</em> functions or methods which accept/return incomplete types:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(X)</span></span>;
<span class="hljs-function">X    <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;
</code></pre></li>
<li><p><em>Define</em> functions or methods which accept/return pointers/references to the incomplete type (but without using its members):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(X*, X&amp;)</span> </span>{}
<span class="hljs-function">X&amp;   <span class="hljs-title">f4</span><span class="hljs-params">()</span>       </span>{}
<span class="hljs-function">X*   <span class="hljs-title">f5</span><span class="hljs-params">()</span>       </span>{}
</code></pre></li>
</ul>

<p><strong>What you cannot do with an incomplete type:</strong></p>

<ul>
<li><p>Use it as a base class</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> : X {} <span class="hljs-comment">// compiler error!</span>
</code></pre></li>
<li><p>Use it to declare a member:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X m; <span class="hljs-comment">// compiler error!</span>
};
</code></pre></li>
<li><p><em>Define</em> functions or methods using this type</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(X x)</span> </span>{} <span class="hljs-comment">// compiler error!</span>
<span class="hljs-function">X    <span class="hljs-title">f2</span><span class="hljs-params">()</span>    </span>{} <span class="hljs-comment">// compiler error!</span>
</code></pre></li>
<li><p>Use its methods or fields, in fact trying to dereference a variable with incomplete type</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X *m;            
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span>            
    </span>{
        m-&gt;<span class="hljs-built_in">someMethod</span>();      <span class="hljs-comment">// compiler error!</span>
        <span class="hljs-type">int</span> i = m-&gt;someField; <span class="hljs-comment">// compiler error!</span>
    }
};
</code></pre></li>
</ul>

<hr>

<p>When it comes to templates, there is no absolute rule: whether you can use an incomplete type as a template parameter is dependent on the way the type is used in the template.</p>

<p>For instance, <code>std::vector&lt;T&gt;</code> requires its parameter to be a complete type, while <code>boost::container::vector&lt;T&gt;</code> does not. Sometimes, a complete type is required only if you use certain member functions; <a href="https://stackoverflow.com/questions/6012157/is-stdunique-ptrt-required-to-know-the-full-definition-of-t">this is the case for <code>std::unique_ptr&lt;T&gt;</code></a>, for example.</p>

<p>A well-documented template should indicate in its documentation all the requirements of its parameters, including whether they need to be complete types or not.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The main rule is that you can only forward-declare classes whose memory layout (and thus member functions and data members) do not need to be known in the file you forward-declare it.</p>

<p>This would rule out base classes and anything but classes used via references and pointers.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://rads.stackoverflow.com/amzn/click/com/0201633620" rel="noreferrer">Lakos</a> distinguishes between class usage</p>

<ol>
<li><em>in-name-only</em> (for which a forward declaration is sufficient) and</li>
<li><em>in-size</em> (for which the class definition is needed).</li>
</ol>

<p>I've never seen it pronounced more succinctly :)</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As well as pointers and references to incomplete types, you can also declare function prototypes that specify parameters and/or return values that are incomplete types.  However, you cannot <em>define</em> a function having a parameter or return type that is incomplete, unless it is a pointer or reference.</p>

<p>Examples:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>;              <span class="hljs-comment">// Forward declaration of X</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(X* px)</span> </span>{}      <span class="hljs-comment">// Legal: can always use a pointer</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(X&amp;  x)</span> </span>{}      <span class="hljs-comment">// Legal: can always use a reference</span>
<span class="hljs-function">X <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;             <span class="hljs-comment">// Legal: return value in function prototype</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">(X)</span></span>;            <span class="hljs-comment">// Legal: parameter in function prototype</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f5</span><span class="hljs-params">(X)</span> </span>{}          <span class="hljs-comment">// ILLEGAL: *definitions* require complete types</span>
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>None of the answers so far describe when one can use a forward declaration of a class template. So, here it goes.</p>

<p>A class template can be forwarded declared as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>;
</code></pre>

<p>Following the structure of the <a href="https://stackoverflow.com/a/553869/434551">accepted answer</a>,</p>

<p>Here's what you can and cannot do.</p>

<p><strong>What you can do with an incomplete type:</strong></p>

<ul>
<li><p>Declare a member to be a pointer or a reference to the incomplete type in another class template:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X&lt;T&gt;* ptr;
    X&lt;T&gt;&amp; ref;
};
</code></pre></li>
<li><p>Declare a member to be a pointer or a reference to one of its incomplete instantiations:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X&lt;<span class="hljs-type">int</span>&gt;* ptr;
    X&lt;<span class="hljs-type">int</span>&gt;&amp; ref;
};
</code></pre></li>
<li><p>Declare function templates or member function templates which accept/return incomplete types:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function"><span class="hljs-type">void</span>      <span class="hljs-title">f1</span><span class="hljs-params">(X&lt;T&gt;)</span></span>;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function">X&lt;T&gt;    <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;
</code></pre></li>
<li><p>Declare functions or member functions which accept/return one of its incomplete instantiations:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>      <span class="hljs-title">f1</span><span class="hljs-params">(X&lt;<span class="hljs-type">int</span>&gt;)</span></span>;
<span class="hljs-function">X&lt;<span class="hljs-type">int</span>&gt;    <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;
</code></pre></li>
<li><p>Define function templates or member function templates which accept/return pointers/references to the incomplete type (but without using its members):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function"><span class="hljs-type">void</span>      <span class="hljs-title">f3</span><span class="hljs-params">(X&lt;T&gt;*, X&lt;T&gt;&amp;)</span> </span>{}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function">X&lt;T&gt;&amp;   <span class="hljs-title">f4</span><span class="hljs-params">(X&lt;T&gt;&amp; in)</span> </span>{ <span class="hljs-keyword">return</span> in; }
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function">X&lt;T&gt;*   <span class="hljs-title">f5</span><span class="hljs-params">(X&lt;T&gt;* in)</span> </span>{ <span class="hljs-keyword">return</span> in; }
</code></pre></li>
<li><p>Define functions or methods which accept/return pointers/references to one of its incomplete instantiations  (but without using its members):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>      <span class="hljs-title">f3</span><span class="hljs-params">(X&lt;<span class="hljs-type">int</span>&gt;*, X&lt;<span class="hljs-type">int</span>&gt;&amp;)</span> </span>{}
<span class="hljs-function">X&lt;<span class="hljs-type">int</span>&gt;&amp;   <span class="hljs-title">f4</span><span class="hljs-params">(X&lt;<span class="hljs-type">int</span>&gt;&amp; in)</span> </span>{ <span class="hljs-keyword">return</span> in; }
<span class="hljs-function">X&lt;<span class="hljs-type">int</span>&gt;*   <span class="hljs-title">f5</span><span class="hljs-params">(X&lt;<span class="hljs-type">int</span>&gt;* in)</span> </span>{ <span class="hljs-keyword">return</span> in; }
</code></pre></li>
<li><p>Use it as a base class of another template class</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> : X&lt;T&gt; {} <span class="hljs-comment">// OK as long as X is defined before</span>
                    <span class="hljs-comment">// Foo is instantiated.</span>

Foo&lt;<span class="hljs-type">int</span>&gt; a1; <span class="hljs-comment">// Compiler error.</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {};
Foo&lt;<span class="hljs-type">int</span>&gt; a2; <span class="hljs-comment">// OK since X is now defined.</span>
</code></pre></li>
<li><p>Use it to declare a member of another class template:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X&lt;T&gt; m; <span class="hljs-comment">// OK as long as X is defined before</span>
            <span class="hljs-comment">// Foo is instantiated. </span>
};

Foo&lt;<span class="hljs-type">int</span>&gt; a1; <span class="hljs-comment">// Compiler error.</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {};
Foo&lt;<span class="hljs-type">int</span>&gt; a2; <span class="hljs-comment">// OK since X is now defined.</span>
</code></pre></li>
<li><p><em>Define</em> function templates or methods using this type</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-type">void</span>    <span class="hljs-title">f1</span><span class="hljs-params">(X&lt;T&gt; x)</span> </span>{}    <span class="hljs-comment">// OK if X is defined before calling f1</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function">X&lt;T&gt;    <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>&lt;T&gt;(); }  <span class="hljs-comment">// OK if X is defined before calling f2</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-built_in">f1</span>(<span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;());  <span class="hljs-comment">// Compiler error</span>
   <span class="hljs-built_in">f2</span>&lt;<span class="hljs-type">int</span>&gt;();     <span class="hljs-comment">// Compiler error</span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-built_in">f1</span>(<span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;());  <span class="hljs-comment">// OK since X is defined now</span>
   <span class="hljs-built_in">f2</span>&lt;<span class="hljs-type">int</span>&gt;();     <span class="hljs-comment">// OK since X is defined now</span>
}
</code></pre></li>
</ul>

<p><strong>What you cannot do with an incomplete type:</strong></p>

<ul>
<li><p>Use one of its instantiations as a base class</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> : X&lt;<span class="hljs-type">int</span>&gt; {} <span class="hljs-comment">// compiler error!</span>
</code></pre></li>
<li><p>Use one of its instantiations to declare a member:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X&lt;<span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// compiler error!</span>
};
</code></pre></li>
<li><p><em>Define</em> functions or methods using one of its instantiations</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>      <span class="hljs-title">f1</span><span class="hljs-params">(X&lt;<span class="hljs-type">int</span>&gt; x)</span> </span>{}            <span class="hljs-comment">// compiler error!</span>
<span class="hljs-function">X&lt;<span class="hljs-type">int</span>&gt;    <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;(); }   <span class="hljs-comment">// compiler error!</span>
</code></pre></li>
<li><p>Use the methods or fields of one of its instantiations, in fact trying to dereference a variable with incomplete type</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    X&lt;<span class="hljs-type">int</span>&gt;* m;            
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span>            
    </span>{
        m-&gt;<span class="hljs-built_in">someMethod</span>();      <span class="hljs-comment">// compiler error!</span>
        <span class="hljs-type">int</span> i = m-&gt;someField; <span class="hljs-comment">// compiler error!</span>
    }
};
</code></pre></li>
<li><p>Create explicit instantiations of the class template</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>&lt;<span class="hljs-type">int</span>&gt;;
</code></pre></li>
</ul>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In file in which you use only Pointer or Reference to a class.And no member/member function should be invoked thought those Pointer/ reference.</p>

<p>with <code>class Foo;</code>//forward declaration</p>

<p>We can declare data members of type Foo* or Foo&amp;.</p>

<p>We can declare (but not define) functions with arguments, and/or return values, of type Foo.</p>

<p>We can declare static data members of type Foo. This is because static data members are defined outside the class definition.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm writing this as a separate answer rather than just a comment because I disagree with Luc Touraille's answer, not on the grounds of legality but for robust software and the danger of misinterpretation.</p>

<p>Specifically, I have an issue with the implied contract of what you expect users of your interface to have to know.</p>

<p>If you are returning or accepting reference types, then you are just saying they can pass through a pointer or reference which they may in turn have known only through a forward declaration.</p>

<p>When you are returning an incomplete type <code>X    f2();</code> then you are saying your caller <strong>must</strong> have the full type specification of X. They need it in order to create the LHS or temporary object at the call site.</p>

<p>Similarly, if you accept an incomplete type, the caller has to have constructed the object which is the parameter. Even if that object was returned as another incomplete type from a function, the call site needs the full declaration. i.e.:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>;  <span class="hljs-comment">// forward for two legal declarations </span>
<span class="hljs-function">X <span class="hljs-title">returnsX</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">XAcceptor</span><span class="hljs-params">(X)</span></span>;

<span class="hljs-built_in">XAcepptor</span>( <span class="hljs-built_in">returnsX</span>() );  <span class="hljs-comment">// X declaration needs to be known here</span>
</code></pre>

<p>I think there's an important principle that a header should supply enough information to use it without a dependency requiring other headers. That means header should be able to be included in a  compilation unit without causing a compiler error when you use any functions it declares.</p>

<p><strong>Except</strong></p>

<ol>
<li><p>If this external dependency is <strong>desired</strong> behaviour. Instead of using conditional compilation you could have a <em>well-documented</em> requirement for them to supply their own header declaring X. This is an alternative to using #ifdefs and can be a useful way to introduce mocks or other variants.</p></li>
<li><p>The important distinction being some template techniques where you are explicitly NOT expected to instantiate them, mentioned just so someone doesn't get snarky with me.</p></li>
</ol>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The general rule I follow is not to include any header file unless I have to.  So unless I am storing the object of a class as a member variable of my class I won't include it, I'll just use the forward declaration.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As long as you don't need the definition (think pointers and references) you can get away with forward declarations. This is why mostly you'd see them in headers while implementation files typically will pull the header for the appropriate definition(s).</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You will usually want to use forward declaration in a classes header file when you want to use the other type (class) as a member of the class. You can not use the forward-declared classes <em>methods</em> in the header file because C++ does not know the definition of that class at that point yet. That's logic you have to move into the .cpp-files, but if you are using template-functions you should reduce them to only the part that uses the template and move that function into the header. </p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Take it that forward declaration will get your code to compile (obj is created). Linking however (exe creation) will not be successfull unless the definitions are found. </p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just want to add one important thing you can do with a forwarded class not mentioned in the answer of Luc Touraille.</p>

<p><strong>What you can do with an incomplete type:</strong></p>

<p><em>Define</em> functions or methods which accept/return 
pointers/references to the incomplete type and forward that pointers/references 
to another function.     </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">f6</span><span class="hljs-params">(X*)</span>       </span>{}
<span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">f7</span><span class="hljs-params">(X&amp;)</span>       </span>{}
<span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">f8</span><span class="hljs-params">(X* x_ptr, X&amp; x_ref)</span> </span>{ <span class="hljs-built_in">f6</span>(x_ptr); <span class="hljs-built_in">f7</span>(x_ref); }
</code></pre>

<p>A module can pass through an object of a forward declared class to another module.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As, Luc Touraille has already explained it very well where to use and not use forward declaration of the class.</p>

<p>I will just add to that why we need to use it.</p>

<p>We should be using Forward declaration wherever possible to avoid the unwanted dependency injection.</p>

<p>As <code>#include</code> header files are added on multiple files therefore, if we add a header into another header file it will add unwanted dependency injection in various parts of source code which can be avoided by adding <code>#include</code> header into <code>.cpp</code> files wherever possible rather than adding to another header file and use class forward declaration wherever possible in header <code>.h</code> files.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Put yourself in the compiler\u0026apos;s position: when you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods. This is why it\u0026apos;s called an \u0026lt;em\u0026gt;incomplete type\u0026lt;/em\u0026gt;. Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assuming the following forward declaration.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s what you can and cannot do.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What you can do with an incomplete type:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declare a member to be a pointer or a reference to the incomplete type:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X *p;\n    X \u0026amp;amp;r;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Declare\u0026lt;/em\u0026gt; functions or methods which accept/return incomplete types:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Define\u0026lt;/em\u0026gt; functions or methods which accept/return pointers/references to the incomplete type (but without using its members):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X*, X\u0026amp;amp;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;amp;   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;       \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X*   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f5\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;       \u0026lt;/span\u0026gt;{}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What you cannot do with an incomplete type:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use it as a base class\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; : X {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use it to declare a member:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X m; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Define\u0026lt;/em\u0026gt; functions or methods using this type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X x)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;    \u0026lt;/span\u0026gt;{} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use its methods or fields, in fact trying to dereference a variable with incomplete type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X *m;            \n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;            \n    \u0026lt;/span\u0026gt;{\n        m-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;someMethod\u0026lt;/span\u0026gt;();      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = m-\u0026amp;gt;someField; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;When it comes to templates, there is no absolute rule: whether you can use an incomplete type as a template parameter is dependent on the way the type is used in the template.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For instance, \u0026lt;code\u0026gt;std::vector\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; requires its parameter to be a complete type, while \u0026lt;code\u0026gt;boost::container::vector\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; does not. Sometimes, a complete type is required only if you use certain member functions; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/6012157/is-stdunique-ptrt-required-to-know-the-full-definition-of-t\u0026quot;\u0026gt;this is the case for \u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, for example.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A well-documented template should indicate in its documentation all the requirements of its parameters, including whether they need to be complete types or not.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The main rule is that you can only forward-declare classes whose memory layout (and thus member functions and data members) do not need to be known in the file you forward-declare it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This would rule out base classes and anything but classes used via references and pointers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201633620\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Lakos\u0026lt;/a\u0026gt; distinguishes between class usage\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;in-name-only\u0026lt;/em\u0026gt; (for which a forward declaration is sufficient) and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;in-size\u0026lt;/em\u0026gt; (for which the class definition is needed).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve never seen it pronounced more succinctly :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As well as pointers and references to incomplete types, you can also declare function prototypes that specify parameters and/or return values that are incomplete types.  However, you cannot \u0026lt;em\u0026gt;define\u0026lt;/em\u0026gt; a function having a parameter or return type that is incomplete, unless it is a pointer or reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;;              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Forward declaration of X\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X* px)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal: can always use a pointer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;amp;  x)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal: can always use a reference\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal: return value in function prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal: parameter in function prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f5\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ILLEGAL: *definitions* require complete types\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;None of the answers so far describe when one can use a forward declaration of a class template. So, here it goes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A class template can be forwarded declared as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Following the structure of the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/553869/434551\u0026quot;\u0026gt;accepted answer\u0026lt;/a\u0026gt;,\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s what you can and cannot do.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What you can do with an incomplete type:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declare a member to be a pointer or a reference to the incomplete type in another class template:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X\u0026amp;lt;T\u0026amp;gt;* ptr;\n    X\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; ref;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declare a member to be a pointer or a reference to one of its incomplete instantiations:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;* ptr;\n    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; ref;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declare function templates or member function templates which accept/return incomplete types:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;T\u0026amp;gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;T\u0026amp;gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Declare functions or member functions which accept/return one of its incomplete instantiations:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Define function templates or member function templates which accept/return pointers/references to the incomplete type (but without using its members):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;T\u0026amp;gt;*, X\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp;   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; in)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; in; }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;T\u0026amp;gt;*   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f5\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;T\u0026amp;gt;* in)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; in; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Define functions or methods which accept/return pointers/references to one of its incomplete instantiations  (but without using its members):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;*, X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp;   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;amp; in)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; in; }\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;*   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f5\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;* in)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; in; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use it as a base class of another template class\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; : X\u0026amp;lt;T\u0026amp;gt; {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK as long as X is defined before\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Foo is instantiated.\u0026lt;/span\u0026gt;\n\nFoo\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {};\nFoo\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK since X is now defined.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use it to declare a member of another class template:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X\u0026amp;lt;T\u0026amp;gt; m; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK as long as X is defined before\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Foo is instantiated. \u0026lt;/span\u0026gt;\n};\n\nFoo\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {};\nFoo\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK since X is now defined.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Define\u0026lt;/em\u0026gt; function templates or methods using this type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;T\u0026amp;gt; x)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK if X is defined before calling f1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;T\u0026amp;gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(); }  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK if X is defined before calling f2\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;());  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;();     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compiler error\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;());  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK since X is defined now\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;();     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK since X is defined now\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What you cannot do with an incomplete type:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use one of its instantiations as a base class\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; : X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use one of its instantiations to declare a member:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; m; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Define\u0026lt;/em\u0026gt; functions or methods using one of its instantiations\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; x)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); }   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use the methods or fields of one of its instantiations, in fact trying to dereference a variable with incomplete type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;* m;            \n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;            \n    \u0026lt;/span\u0026gt;{\n        m-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;someMethod\u0026lt;/span\u0026gt;();      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = m-\u0026amp;gt;someField; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error!\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Create explicit instantiations of the class template\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In file in which you use only Pointer or Reference to a class.And no member/member function should be invoked thought those Pointer/ reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;with \u0026lt;code\u0026gt;class Foo;\u0026lt;/code\u0026gt;//forward declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can declare data members of type Foo* or Foo\u0026amp;amp;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can declare (but not define) functions with arguments, and/or return values, of type Foo.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can declare static data members of type Foo. This is because static data members are defined outside the class definition.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m writing this as a separate answer rather than just a comment because I disagree with Luc Touraille\u0026apos;s answer, not on the grounds of legality but for robust software and the danger of misinterpretation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Specifically, I have an issue with the implied contract of what you expect users of your interface to have to know.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are returning or accepting reference types, then you are just saying they can pass through a pointer or reference which they may in turn have known only through a forward declaration.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you are returning an incomplete type \u0026lt;code\u0026gt;X    f2();\u0026lt;/code\u0026gt; then you are saying your caller \u0026lt;strong\u0026gt;must\u0026lt;/strong\u0026gt; have the full type specification of X. They need it in order to create the LHS or temporary object at the call site.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, if you accept an incomplete type, the caller has to have constructed the object which is the parameter. Even if that object was returned as another incomplete type from a function, the call site needs the full declaration. i.e.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// forward for two legal declarations \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;returnsX\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;XAcceptor\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;XAcepptor\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;returnsX\u0026lt;/span\u0026gt;() );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// X declaration needs to be known here\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I think there\u0026apos;s an important principle that a header should supply enough information to use it without a dependency requiring other headers. That means header should be able to be included in a  compilation unit without causing a compiler error when you use any functions it declares.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Except\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If this external dependency is \u0026lt;strong\u0026gt;desired\u0026lt;/strong\u0026gt; behaviour. Instead of using conditional compilation you could have a \u0026lt;em\u0026gt;well-documented\u0026lt;/em\u0026gt; requirement for them to supply their own header declaring X. This is an alternative to using #ifdefs and can be a useful way to introduce mocks or other variants.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The important distinction being some template techniques where you are explicitly NOT expected to instantiate them, mentioned just so someone doesn\u0026apos;t get snarky with me.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The general rule I follow is not to include any header file unless I have to.  So unless I am storing the object of a class as a member variable of my class I won\u0026apos;t include it, I\u0026apos;ll just use the forward declaration.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As long as you don\u0026apos;t need the definition (think pointers and references) you can get away with forward declarations. This is why mostly you\u0026apos;d see them in headers while implementation files typically will pull the header for the appropriate definition(s).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You will usually want to use forward declaration in a classes header file when you want to use the other type (class) as a member of the class. You can not use the forward-declared classes \u0026lt;em\u0026gt;methods\u0026lt;/em\u0026gt; in the header file because C++ does not know the definition of that class at that point yet. That\u0026apos;s logic you have to move into the .cpp-files, but if you are using template-functions you should reduce them to only the part that uses the template and move that function into the header. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take it that forward declaration will get your code to compile (obj is created). Linking however (exe creation) will not be successfull unless the definitions are found. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just want to add one important thing you can do with a forwarded class not mentioned in the answer of Luc Touraille.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What you can do with an incomplete type:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Define\u0026lt;/em\u0026gt; functions or methods which accept/return \npointers/references to the incomplete type and forward that pointers/references \nto another function.     \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f6\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X*)\u0026lt;/span\u0026gt;       \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f7\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X\u0026amp;amp;)\u0026lt;/span\u0026gt;       \u0026lt;/span\u0026gt;{}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f8\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(X* x_ptr, X\u0026amp;amp; x_ref)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f6\u0026lt;/span\u0026gt;(x_ptr); \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f7\u0026lt;/span\u0026gt;(x_ref); }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A module can pass through an object of a forward declared class to another module.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As, Luc Touraille has already explained it very well where to use and not use forward declaration of the class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I will just add to that why we need to use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We should be using Forward declaration wherever possible to avoid the unwanted dependency injection.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As \u0026lt;code\u0026gt;#include\u0026lt;/code\u0026gt; header files are added on multiple files therefore, if we add a header into another header file it will add unwanted dependency injection in various parts of source code which can be avoided by adding \u0026lt;code\u0026gt;#include\u0026lt;/code\u0026gt; header into \u0026lt;code\u0026gt;.cpp\u0026lt;/code\u0026gt; files wherever possible rather than adding to another header file and use class forward declaration wherever possible in header \u0026lt;code\u0026gt;.h\u0026lt;/code\u0026gt; files.\u0026lt;/p\u0026gt;\n    "],"id":516,"title":"When can I use a forward declaration?","content":"\n                \n\u0026lt;p\u0026gt;I am looking for the definition of when I am allowed to do forward declaration of a class in another class\u0026apos;s header file:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Am I allowed to do it for a base class, for a class held as a member, for a class passed to member function by reference, etc. ?\u0026lt;/p\u0026gt;\n    ","slug":"when-can-i-use-a-forward-declaration-1657388251827","postType":"QUESTION","createdAt":"2022-07-09T17:37:31.000Z","updatedAt":"2022-07-09T17:37:31.000Z","tags":[{"id":2555,"name":"forward-declaration","slug":"forward-declaration","createdAt":"2022-07-09T17:37:31.000Z","updatedAt":"2022-07-09T17:37:31.000Z","Questions_Tags":{"questionId":516,"tagId":2555}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"when-can-i-use-a-forward-declaration-1657388251827"},"buildId":"d4czOeg3MGPNUI9SipfjN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>