<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I&#x27;m a bit confused about how Java generics handle inheritance / polymorphism.

Assume the following hierarchy -

Animal (Parent)

Dog - Cat (Children)

So suppose I have a method doSomething(List&lt;Animal&gt; animals). By all the rules of inheritance and polymorphism, I would assume that a List&lt;Dog&gt; is a List&lt;Animal&gt; and a List&lt;Cat&gt; is a List&lt;Animal&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying doSomething(List&lt;? extends Animal&gt; animals). 

I understand that this is Java&#x27;s behavior. My question is why? Why is polymorphism generally implicit, but when it comes to generics it must be specified?
    "/><meta property="og:title" content="Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic? | Solutions Checker"/><meta property="og:description" content="I&#x27;m a bit confused about how Java generics handle inheritance / polymorphism.

Assume the following hierarchy -

Animal (Parent)

Dog - Cat (Children)

So suppose I have a method doSomething(List&lt;Animal&gt; animals). By all the rules of inheritance and polymorphism, I would assume that a List&lt;Dog&gt; is a List&lt;Animal&gt; and a List&lt;Cat&gt; is a List&lt;Animal&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying doSomething(List&lt;? extends Animal&gt; animals). 

I understand that this is Java&#x27;s behavior. My question is why? Why is polymorphism generally implicit, but when it comes to generics it must be specified?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic?","text":"I&apos;m a bit confused about how Java generics handle inheritance / polymorphism.\n\nAssume the following hierarchy -\n\nAnimal (Parent)\n\nDog - Cat (Children)\n\nSo suppose I have a method doSomething(List&lt;Animal&gt; animals). By all the rules of inheritance and polymorphism, I would assume that a List&lt;Dog&gt; is a List&lt;Animal&gt; and a List&lt;Cat&gt; is a List&lt;Animal&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying doSomething(List&lt;? extends Animal&gt; animals). \n\nI understand that this is Java&apos;s behavior. My question is why? Why is polymorphism generally implicit, but when it comes to generics it must be specified?\n    ","answerCount":20,"upVoteCount":500,"suggestedAnswer":[{"text":"No, a List&lt;Dog&gt; is not a List&lt;Animal&gt;. Consider what you can do with a List&lt;Animal&gt; - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); // ArrayList implements List\nList&lt;Animal&gt; animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\n\nSuddenly you have a very confused cat.\n\nNow, you can&apos;t add a Cat to a List&lt;? extends Animal&gt; because you don&apos;t know it&apos;s a List&lt;Cat&gt;. You can retrieve a value and know that it will be an Animal, but you can&apos;t add arbitrary animals. The reverse is true for List&lt;? super Animal&gt; - in that case you can add an Animal to it safely, but you don&apos;t know anything about what might be retrieved from it, because it could be a List&lt;Object&gt;.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"What you are looking for is called covariant type parameters. This means that if one type of object can be substituted for another in a method (for instance, Animal can be replaced with Dog), the same applies to expressions using those objects (so List&lt;Animal&gt; could be replaced with List&lt;Dog&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a List&lt;Dog&gt;, and it is being used as a List&lt;Animal&gt;.  What happens when you try to add a Cat to this List&lt;Animal&gt; which is really a List&lt;Dog&gt;?  Automatically allowing type parameters to be covariant breaks the type system.\n\nIt would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the ? extends Foo in method declarations, but that does add additional complexity.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The reason a List&lt;Dog&gt; is not a List&lt;Animal&gt;, is that, for example, you can insert a Cat into a List&lt;Animal&gt;, but not into a List&lt;Dog&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a List&lt;Dog&gt; is the similar to reading from a List&lt;Animal&gt; -- but not writing.\n\nThe Generics in the Java Language and the Section on Generics from the Java Tutorials have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"A point I think should be added to what other answers mention is that while\n\nList&lt;Dog&gt; isn&apos;t-a List&lt;Animal&gt; in Java\n\nit is also true that\n\nA list of dogs is-a list of animals in English (under a reasonable interpretation)\n\nThe way the OP&apos;s intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.\nTo put it another way: A List&lt;Dog&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list of dogs and nothing other than dogs&quot;.\nMore generally, OP&apos;s intuition lends itself towards a language in which operations on objects can change their type, or rather, an object&apos;s type(s) is a (dynamic) function of its value.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I would say the whole point of Generics is that it doesn&apos;t allow that. Consider the situation with arrays, which do allow that type of covariance:\n\n  Object[] objects = new String[10];\n  objects[0] = Boolean.FALSE;\n\n\nThat code compiles fine, but throws a runtime error (java.lang.ArrayStoreException: java.lang.Boolean in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.\n\nNow there are times where you need to be more flexible and that is what the ? super Class and ? extends Class are for. The former is when you need to insert into a type Collection (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"To understand the problem it&apos;s useful to make comparison to arrays.\n\nList&lt;Dog&gt; is not subclass of List&lt;Animal&gt;.\nBut Dog[] is subclass of Animal[].\n\nArrays are reifiable and covariant. Reifiable means their type information is fully available at runtime. Therefore arrays provide runtime type safety but not compile-time type safety.\n\n    // All compiles but throws ArrayStoreException at runtime at last line\n    Dog[] dogs = new Dog[10];\n    Animal[] animals = dogs; // compiles\n    animals[0] = new Cat(); // throws ArrayStoreException at runtime\n\n\nIt&apos;s vice versa for generics:\nGenerics are erased and invariant. Therefore generics can&apos;t provide runtime type safety, but they provide compile-time type safety. In the code below if generics were covariant it will be possible to make heap pollution at line 3.\n\n    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();\n    List&lt;Animal&gt; animals = dogs; // compile-time error, otherwise heap pollution\n    animals.add(new Cat());\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"The answers given here didn&apos;t fully convince me. So instead, I make another example.\n\npublic void passOn(Consumer&lt;Animal&gt; consumer, Supplier&lt;Animal&gt; supplier) {\n    consumer.accept(supplier.get());\n}\n\n\nsounds fine, doesn&apos;t it? But you can only pass Consumers and Suppliers for Animals. If you have a Mammal consumer, but a Duck supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.\n\nInstead of the above, we have to define relationships between the types we use.\n\nE. g.,\n\npublic &lt;A extends Animal&gt; void passOn(Consumer&lt;A&gt; consumer, Supplier&lt;? extends A&gt; supplier) {\n    consumer.accept(supplier.get());\n}\n\n\nmakes sure that we can only use a supplier which provides us the right type of object for the consumer.\n\nOTOH, we could as well do\n\npublic &lt;A extends Animal&gt; void passOn(Consumer&lt;? super A&gt; consumer, Supplier&lt;A&gt; supplier) {\n    consumer.accept(supplier.get());\n}\n\n\nwhere we go the other way: we define the type of the Supplier and restrict that it can be put into the Consumer.\n\nWe even can do\n\npublic &lt;A extends Animal&gt; void passOn(Consumer&lt;? super A&gt; consumer, Supplier&lt;? extends A&gt; supplier) {\n    consumer.accept(supplier.get());\n}\n\n\nwhere, having the intuitive relations Life -&gt; Animal -&gt; Mammal -&gt; Dog, Cat etc., we could even put a Mammal into a Life consumer, but not a String into a Life consumer.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The basis logic for such behavior is that Generics follow a mechanism of type erasure. So at run time you have no way if identifying the type of collection unlike arrays where there is no such erasure process. So coming back to your question...\n\nSo suppose there is a method as given below:\n\nadd(List&lt;Animal&gt;){\n    //You can add List&lt;Dog or List&lt;Cat&gt; and this will compile as per rules of polymorphism\n}\n\n\nNow if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...\n\nThus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Actually you can use an interface to achieve what you want.\n\npublic interface Animal {\n    String getName();\n    String getVoice();\n}\npublic class Dog implements Animal{\n    @Override \n    String getName(){return &quot;Dog&quot;;}\n    @Override\n    String getVoice(){return &quot;woof!&quot;;}\n\n\n}\n\nyou can then use the collections using\n\nList &lt;Animal&gt; animalGroup = new ArrayList&lt;Animal&gt;();\nanimalGroup.add(new Dog());\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Subtyping is invariant for parameterized types. Even tough the class Dog is a subtype of Animal, the parameterized type List&lt;Dog&gt; is not a subtype of List&lt;Animal&gt;. In contrast, covariant subtyping is used by arrays, so the array\ntype Dog[] is a subtype of Animal[].\n\nInvariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:\n\nList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(1);\nList&lt;Animal&gt; animals = dogs;\nanimals.add(new Cat()); // compile-time error\nDog dog = dogs.get(0);\n\n\nAs stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.\n\nIt is instructive to compare the above to analogous code for arrays.\n\nDog[] dogs = new Dog[1];\nObject[] animals = dogs;\nanimals[0] = new Cat(); // run-time error\nDog dog = dogs[0];\n\n\nThe code is legal. However, throws an array store exception.\nAn array carries its type at run-time this way JVM can enforce\ntype safety of covariant subtyping. \n\nTo understand this further let&apos;s look at the bytecode generated by javap of the class below:\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Demonstration {\n    public void normal() {\n        List normal = new ArrayList(1);\n        normal.add(&quot;lorem ipsum&quot;);\n    }\n\n    public void parameterized() {\n        List&lt;String&gt; parameterized = new ArrayList&lt;&gt;(1);\n        parameterized.add(&quot;lorem ipsum&quot;);\n    }\n}\n\n\nUsing the command javap -c Demonstration, this shows the following Java bytecode:\n\nCompiled from &quot;Demonstration.java&quot;\npublic class Demonstration {\n  public Demonstration();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n       4: return\n\n  public void normal();\n    Code:\n       0: new           #2                  // class java/util/ArrayList\n       3: dup\n       4: iconst_1\n       5: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:(I)V\n       8: astore_1\n       9: aload_1\n      10: ldc           #4                  // String lorem ipsum\n      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\n      17: pop\n      18: return\n\n  public void parameterized();\n    Code:\n       0: new           #2                  // class java/util/ArrayList\n       3: dup\n       4: iconst_1\n       5: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:(I)V\n       8: astore_1\n       9: aload_1\n      10: ldc           #4                  // String lorem ipsum\n      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\n      17: pop\n      18: return\n}\n\n\nObserve that the translated code of method bodies are identical. Compiler replaced each parameterized type by its erasure. This property is crucial meaning that it did not break backwards compatibility.\n\nIn conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"If you are sure that the list items are subclasses of that given super type, you can cast the list using this approach:\n(List&lt;Animal&gt;) (List&lt;?&gt;) dogs\n\nThis is usefull when you want to pass the list inside of a constructor or iterate over it.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"The answer  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.  \n\nIn most cases, we can use Collection&lt;? extends T&gt; rather then Collection&lt;T&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a Collection&lt;? extends T&gt; to a Collection&lt;T&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use Collection&lt;? extends Object&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.\n\n/**Could use Collection&lt;? extends Object&gt; and that is the better choice. \n* But I am doing this to illustrate how to use DownCastCollection. **/\n\npublic static void print(Collection&lt;Object&gt; col){  \n    for(Object obj : col){\n    System.out.println(obj);\n    }\n}\npublic static void main(String[] args){\n  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n  list.addAll(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));\n  print(new DownCastCollection&lt;Object&gt;(list));\n}\n\n\nNow the class:\n\nimport java.util.AbstractCollection;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class DownCastCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {\nprivate Collection&lt;? extends E&gt; delegate;\n\npublic DownCastCollection(Collection&lt;? extends E&gt; delegate) {\n    super();\n    this.delegate = delegate;\n}\n\n@Override\npublic int size() {\n    return delegate ==null ? 0 : delegate.size();\n}\n\n@Override\npublic boolean isEmpty() {\n    return delegate==null || delegate.isEmpty();\n}\n\n@Override\npublic boolean contains(Object o) {\n    if(isEmpty()) return false;\n    return delegate.contains(o);\n}\nprivate class MyIterator implements Iterator&lt;E&gt;{\n    Iterator&lt;? extends E&gt; delegateIterator;\n\n    protected MyIterator() {\n        super();\n        this.delegateIterator = delegate == null ? null :delegate.iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return delegateIterator != null &amp;&amp; delegateIterator.hasNext();\n    }\n\n    @Override\n    public  E next() {\n        if(!hasNext()) throw new NoSuchElementException(&quot;The iterator is empty&quot;);\n        return delegateIterator.next();\n    }\n\n    @Override\n    public void remove() {\n        delegateIterator.remove();\n\n    }\n\n}\n@Override\npublic Iterator&lt;E&gt; iterator() {\n    return new MyIterator();\n}\n\n\n\n@Override\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n\n@Override\npublic boolean remove(Object o) {\n    if(delegate == null) return false;\n    return delegate.remove(o);\n}\n\n@Override\npublic boolean containsAll(Collection&lt;?&gt; c) {\n    if(delegate==null) return false;\n    return delegate.containsAll(c);\n}\n\n@Override\npublic boolean addAll(Collection&lt;? extends E&gt; c) {\n    throw new UnsupportedOperationException();\n}\n\n@Override\npublic boolean removeAll(Collection&lt;?&gt; c) {\n    if(delegate == null) return false;\n    return delegate.removeAll(c);\n}\n\n@Override\npublic boolean retainAll(Collection&lt;?&gt; c) {\n    if(delegate == null) return false;\n    return delegate.retainAll(c);\n}\n\n@Override\npublic void clear() {\n    if(delegate == null) return;\n        delegate.clear();\n\n}\n\n\n}\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Others have done a decent job of explaining why you cannot just cast a list of descendant to list of superclass.\nHowever, many people visit this question looking for a solution.\nSo, the solution to this problem in modern java is as follows:\n(Note: S = superclass)\nList&lt;S&gt; supers = List.copyOf( descendants );\n\nFor an explanation as to why this is safe, (taking into consideration the potential pitfalls mentioned by other answers,) and why this is the best way of achieving this, see related question and my 2022 answer to it: https://stackoverflow.com/a/72195980/773113\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"The issue has been correctly identified as related to variance but the details are not correct. A purely functional list is a covariant data functor, which means if a type Sub is a subtype of Super, then a list of Sub is definitely a subtype of a list of Super.\nHowever mutability of a list is not the basic problem here. The problem is mutability in general. The problem is well known, and is called the Covariance Problem, it was first identified I think by Castagna, and it completely and utterly destroys object orientation as a general paradigm. It is based on previously established variance rules established by Cardelli and Reynolds.\nSomewhat oversimplifying, lets consider assignment of an object B of type T to an object A of type T as a mutation. This is without loss of generality: a mutation of A can be written A = f (A) where f: T -&gt; T. The problem, of course, is that whilst functions are covariant in their codomain, they&apos;re contravariant in their domain, but with assignments the domain and codomain are the same, so assignment is invariant!\nIt follows, generalising, that subtypes cannot be mutated. But with object orientation mutation is fundamental, hence object orientation is intrinsically flawed.\nHere&apos;s a simple example: in a purely functional setting a symmetric matrix is clearly a matrix, it is a subtype, no problem. Now lets add to matrix the ability to set a single element at coordinates (x,y) with the rule no other element changes. Now symmetric matrix is no longer a subtype, if you change (x,y) you have also changed (y,x). The functional operation is delta: Sym -&gt; Mat, if you change one element of a symmetric matrix you get a general non-symmetric matrix back. Therefore if you included a &quot;change one element&quot; method in Mat, Sym is not a subtype. In fact .. there are almost certainly NO proper subtypes.\nTo put all this in easier terms: if you have a general data type with a wide range of mutators which leverage its generality you can be certain any proper subtype cannot possibly support all those mutations: if it could, it would be just as general as the supertype, contrary to the specification of &quot;proper&quot; subtype.\nThe fact Java prevents subtyping mutable lists fails to address the real issue: why are you using object oriented rubbish like Java when it was discredited several decades ago??\nIn any case there&apos;s a reasonable discussion here:\nhttps://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Lets take the example from JavaSE tutorial \n\npublic abstract class Shape {\n    public abstract void draw(Canvas c);\n}\n\npublic class Circle extends Shape {\n    private int x, y, radius;\n    public void draw(Canvas c) {\n        ...\n    }\n}\n\npublic class Rectangle extends Shape {\n    private int x, y, width, height;\n    public void draw(Canvas c) {\n        ...\n    }\n}\n\n\nSo why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:\n\n// drawAll method call\ndrawAll(circleList);\n\n\npublic void drawAll(List&lt;Shape&gt; shapes) {\n   shapes.add(new Rectangle());    \n}\n\n\nSo Java &quot;architects&quot; had 2 options which address this problem:\n\n\ndo not consider that a subtype is implicitly it&apos;s supertype, and give a compile error, like it happens now\nconsider the subtype to be it&apos;s supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).\n\n\nFor obvious reasons, that chose the first way. \n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.\n\nThus we have ListOfAnimal, ListOfDog, ListOfCat, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to List is not a hierarchy at all).\n\nAnother argument why covariance doesn&apos;t make sense in case of generic classes is the fact that at base all classes are the same - are List instances. Specialising a List by filling the generic argument doesn&apos;t extend the class, it just makes it work for that particular generic argument.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"The problem has been well-identified. But there&apos;s a solution; make doSomething generic:\n\n&lt;T extends Animal&gt; void doSomething&lt;List&lt;T&gt; animals) {\n}\n\n\nnow you can call doSomething with either List&lt;Dog&gt; or List&lt;Cat&gt; or List&lt;Animal&gt;.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"another solution is to build a new list\n\nList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); \nList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;(dogs);\nanimals.add(new Cat());\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Further to the answer by Jon Skeet, which uses this example code:\n\n// Illegal code - because otherwise life would be Bad\nList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); // ArrayList implements List\nList&lt;Animal&gt; animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\n\nAt the deepest level, the problem here is that dogs and animals share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:\n\n// This code is fine\nList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();\ndogs.add(new Dog());\nList&lt;Animal&gt; animals = new ArrayList&lt;&gt;(dogs); // Copy list\nanimals.add(new Cat());\nDog dog = dogs.get(0);   // This is fine now, because it does not return the Cat\n\n\nAfter calling List&lt;Animal&gt; animals = new ArrayList&lt;&gt;(dogs);, you cannot subsequently directly assign animals to either dogs or cats:\n\n// These are both illegal\ndogs = animals;\ncats = animals;\n\n\ntherefore you can&apos;t put the wrong subtype of Animal into the list, because there is no wrong subtype -- any object of subtype ? extends Animal can be added to animals.\n\nObviously, this changes the semantics, since the lists animals and dogs are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a Cat could be added to a list that is only supposed to contain Dog objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I see that the question has already been answered a number of times, just want to put in my inputs on the same question.\nLets us go ahead and create a simplified Animal class hierarchy.\nabstract class Animal {\n    void eat() {\n        System.out.println(&quot;animal eating&quot;);\n    }\n}\n\nclass Dog extends Animal {\n    void bark() { }\n}\n\nclass Cat extends Animal {\n    void meow() { }\n}\n\nNow let us have a look at our old friend Arrays, which we know support polymorphism implicitly-\nclass TestAnimals {\n    public static void main(String[] args) {\n        Animal[] animals = {new Dog(), new Cat(), new Dog()};\n        Dog[] dogs = {new Dog(), new Dog(), new Dog()};\n        takeAnimals(animals);\n        takeAnimals(dogs);\n    }\n\n    public void takeAnimals(Animal[] animals) {\n        for(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\nThe class compiles fine and when we run the above class we get the output\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\n\nThe point to note here is that the takeAnimals() method is defined to take anything which is of type Animal, it can take an array of type Animal and it can take an array of Dog as well because Dog-is-a-Animal. So this is Polymorphism in action.\nLet us now use this same approach with generics,\nNow say we tweak our code a little bit and use ArrayLists instead of Arrays -\nclass TestAnimals {\n    public static void main(String[] args) {\n        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        animals.add(new Dog());\n        takeAnimals(animals);\n    }\n\n    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {\n        for(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\nThe class above will compile and will produce the output -\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\n\nSo we know this works, now lets tweak this class a little bit to use Animal type polymorphically -\nclass TestAnimals {\n    public static void main(String[] args) {\n        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        animals.add(new Dog());\n\n        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();\n        takeAnimals(animals);\n        takeAnimals(dogs);\n    }\n\n    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {\n        for(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\nLooks like there should be no problem in compiling the above class as the takeAnimals() method is designed to take any ArrayList of type Animal and Dog-is-a-Animal so it should not be a deal breaker here.\nBut, unfortunately the compiler throws an error and doesn&apos;t allow us to pass a Dog ArrayList to a variable expecting Animal ArrayList.\nYou ask why?\nBecause just imagine, if JAVA were to allow the Dog ArrayList - dogs - to be put into the Animal ArrayList - animals - and then inside the takeAnimals() method somebody does something like -\nanimals.add(new Cat());\n\nthinking that this should be doable because ideally it is an Animal ArrayList and you should be in a position to add any cat to it as Cat-is-also-a-Animal, but in real you passed a Dog type ArrayList to it.\nSo, now you must be thinking the the same should have happened with the Arrays as well. You are right in thinking so.\nIf somebody tries to do the same thing with Arrays then Arrays are also going to throw an error but Arrays handle this error at runtime whereas ArrayLists handle this error at compile time.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9fb80f4eb9e2d3c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9fb80f4eb9e2d3c9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-18d80dcb3110b1ad.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/532-fec3344a80918110.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/817-363561828babdd16.js" defer=""></script><script src="/_next/static/chunks/81-89fd2eaadd8354ed.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-16d8c84aea765d4e.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_buildManifest.js" defer=""></script><script src="/_next/static/D-Vv5KfwuaE883xCdWfex/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.dlbxiY code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-344134f6-0"]{content:"dlbxiY,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo.svg" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-listlessdoggreater-a-subclass-of-listlessanimalgreater-why-are-java-generics-not-implicitly-polymorphic-1657384766724#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-344134f6-0 dlbxiY flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-listlessdoggreater-a-subclass-of-listlessanimalgreater-why-are-java-generics-not-implicitly-polymorphic-1657384766724">Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/polymorphism">polymorphism</a></div></div><div class="question-content mt-5">
                
<p>I'm a bit confused about how Java generics handle inheritance / polymorphism.</p>

<p>Assume the following hierarchy -</p>

<p><strong>Animal</strong> (Parent)</p>

<p><strong>Dog</strong> - <strong>Cat</strong> (Children)</p>

<p>So suppose I have a method <code>doSomething(List&lt;Animal&gt; animals)</code>. By all the rules of inheritance and polymorphism, I would assume that a <code>List&lt;Dog&gt;</code> <em>is</em> a <code>List&lt;Animal&gt;</code> and a <code>List&lt;Cat&gt;</code> <em>is</em> a <code>List&lt;Animal&gt;</code> - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying <code>doSomething(List&lt;? extends Animal&gt; animals)</code>. </p>

<p>I understand that this is Java's behavior. My question is <em>why</em>? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</p>
    </div></div></div><div class="sc-344134f6-2 EUowZ"><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>No, a <code>List&lt;Dog&gt;</code> is <em>not</em> a <code>List&lt;Animal&gt;</code>. Consider what you can do with a <code>List&lt;Animal&gt;</code> - you can add <em>any</em> animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// Illegal code - because otherwise life would be Bad</span>
List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;(); <span class="hljs-comment">// ArrayList implements List</span>
List&lt;Animal&gt; animals = dogs; <span class="hljs-comment">// Awooga awooga</span>
animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogs.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// This should be safe, right?</span>
</code></pre>

<p>Suddenly you have a <em>very</em> confused cat.</p>

<p>Now, you <em>can't</em> add a <code>Cat</code> to a <code>List&lt;? extends Animal&gt;</code> because you don't know it's a <code>List&lt;Cat&gt;</code>. You can retrieve a value and know that it will be an <code>Animal</code>, but you can't add arbitrary animals. The reverse is true for <code>List&lt;? super Animal&gt;</code> - in that case you can add an <code>Animal</code> to it safely, but you don't know anything about what might be retrieved from it, because it could be a <code>List&lt;Object&gt;</code>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What you are looking for is called <em><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noreferrer">covariant type</a> parameters</em>. This means that if one type of object can be substituted for another in a method (for instance, <code>Animal</code> can be replaced with <code>Dog</code>), the same applies to expressions using those objects (so <code>List&lt;Animal&gt;</code> could be replaced with <code>List&lt;Dog&gt;</code>). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a <code>List&lt;Dog&gt;</code>, and it is being used as a <code>List&lt;Animal&gt;</code>.  What happens when you try to add a Cat to this <code>List&lt;Animal&gt;</code> which is really a <code>List&lt;Dog&gt;</code>?  Automatically allowing type parameters to be covariant breaks the type system.</p>

<p>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the <code>? extends Foo</code> in method declarations, but that does add additional complexity.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason a <code>List&lt;Dog&gt;</code> is not a <code>List&lt;Animal&gt;</code>, is that, for example, you can insert a <code>Cat</code> into a <code>List&lt;Animal&gt;</code>, but not into a <code>List&lt;Dog&gt;</code>... you can use wildcards to make generics more extensible where possible; for example, reading from  a <code>List&lt;Dog&gt;</code> is the similar to reading from a <code>List&lt;Animal&gt;</code> -- but not writing.</p>

<p>The <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html" rel="noreferrer">Generics in the Java Language</a> and the <a href="http://java.sun.com/docs/books/tutorial/java/generics/index.html" rel="noreferrer">Section on Generics from the Java Tutorials</a> have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A point I think should be added to what <a href="https://stackoverflow.com/a/2745301/1593077">other</a> <a href="https://stackoverflow.com/a/2745319/1593077">answers</a> mention is that while</p>
<blockquote>
<p><code>List&lt;Dog&gt;</code> isn't-a <code>List&lt;Animal&gt;</code> <strong>in Java</strong></p>
</blockquote>
<p>it is also true that</p>
<blockquote>
<p>A list of dogs is-a list of animals <strong>in English</strong> (under a reasonable interpretation)</p>
</blockquote>
<p>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</p>
<p>To put it another way: A <code>List&lt;Dog&gt;</code> in Java does not mean "a list of dogs" in English, it means "a list of dogs and nothing other than dogs".</p>
<p>More generally, <strong>OP's intuition lends itself towards a language in which operations on objects can change their type</strong>, or rather, an object's type(s) is a (dynamic) function of its value.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">  Object[] objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];
  objects[<span class="hljs-number">0</span>] = Boolean.FALSE;
</code></pre>

<p>That code compiles fine, but throws a runtime error (<code>java.lang.ArrayStoreException: java.lang.Boolean</code> in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</p>

<p>Now there are times where you need to be more flexible and that is what the <code>? super Class</code> and <code>? extends Class</code> are for. The former is when you need to insert into a type <code>Collection</code> (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To understand the problem it's useful to make comparison to arrays.</p>

<p><code>List&lt;Dog&gt;</code> is <strong>not</strong> subclass of <code>List&lt;Animal&gt;</code>.<br>
<strong>But</strong> <code>Dog[]</code> <strong>is</strong> subclass of <code>Animal[]</code>.</p>

<p><strong>Arrays are <a href="http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html" rel="noreferrer">reifiable</a> and covariant</strong>. <br><a href="http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html" rel="noreferrer">Reifiable</a> means their type information is fully available at runtime. <br>Therefore arrays provide runtime type safety but not compile-time type safety.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    <span class="hljs-comment">// All compiles but throws ArrayStoreException at runtime at last line</span>
    Dog[] dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>[<span class="hljs-number">10</span>];
    Animal[] animals = dogs; <span class="hljs-comment">// compiles</span>
    animals[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// throws ArrayStoreException at runtime</span>
</code></pre>

<p>It's vice versa for generics:<br>
<strong>Generics are <a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html" rel="noreferrer">erased</a> and invariant</strong>. <br>Therefore generics can't provide runtime type safety, but they provide compile-time type safety. <br>In the code below if generics were covariant it will be possible to make <a href="https://en.wikipedia.org/wiki/Heap_pollution" rel="noreferrer">heap pollution</a> at line 3.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    List&lt;Animal&gt; animals = dogs; <span class="hljs-comment">// compile-time error, otherwise heap pollution</span>
    animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The answers given here didn't fully convince me. So instead, I make another example.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">passOn</span><span class="hljs-params">(Consumer&lt;Animal&gt; consumer, Supplier&lt;Animal&gt; supplier)</span> {
    consumer.accept(supplier.get());
}
</code></pre>

<p>sounds fine, doesn't it? But you can only pass <code>Consumer</code>s and <code>Supplier</code>s for <code>Animal</code>s. If you have a <code>Mammal</code> consumer, but a <code>Duck</code> supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</p>

<p>Instead of the above, we have to define relationships between the types we use.</p>

<p>E. g.,</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">passOn</span><span class="hljs-params">(Consumer&lt;A&gt; consumer, Supplier&lt;? extends A&gt; supplier)</span> {
    consumer.accept(supplier.get());
}
</code></pre>

<p>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</p>

<p>OTOH, we could as well do</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">passOn</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> A&gt; consumer, Supplier&lt;A&gt; supplier)</span> {
    consumer.accept(supplier.get());
}
</code></pre>

<p>where we go the other way: we define the type of the <code>Supplier</code> and restrict that it can be put into the <code>Consumer</code>.</p>

<p>We even can do</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">passOn</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> A&gt; consumer, Supplier&lt;? extends A&gt; supplier)</span> {
    consumer.accept(supplier.get());
}
</code></pre>

<p>where, having the intuitive relations <code>Life</code> -&gt; <code>Animal</code> -&gt; <code>Mammal</code> -&gt; <code>Dog</code>, <code>Cat</code> etc., we could even put a <code>Mammal</code> into a <code>Life</code> consumer, but not a <code>String</code> into a <code>Life</code> consumer.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The basis logic for such behavior is that <code>Generics</code> follow a mechanism of type erasure. So at run time you have no way if identifying the type of <code>collection</code> unlike <code>arrays</code> where there is no such erasure process. So coming back to your question...</p>

<p>So suppose there is a method as given below:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">add(List&lt;Animal&gt;){
    <span class="hljs-comment">//You can add List&lt;Dog or List&lt;Cat&gt; and this will compile as per rules of polymorphism</span>
}
</code></pre>

<p>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</p>

<p>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Actually you can use an interface to achieve what you want.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;
    String <span class="hljs-title function_">getVoice</span><span class="hljs-params">()</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>{
    <span class="hljs-meta">@Override</span> 
    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">"Dog"</span>;}
    <span class="hljs-meta">@Override</span>
    String <span class="hljs-title function_">getVoice</span><span class="hljs-params">()</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">"woof!"</span>;}
</code></pre>

<p>}</p>

<p>you can then use the collections using</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List &lt;Animal&gt; animalGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();
animalGroup.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Subtyping is <a href="https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english">invariant</a> for parameterized types. Even tough the class <code>Dog</code> is a subtype of <code>Animal</code>, the parameterized type <code>List&lt;Dog&gt;</code> is not a subtype of <code>List&lt;Animal&gt;</code>. In contrast, <a href="https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english">covariant</a> subtyping is used by arrays, so the array
type <code>Dog[]</code> is a subtype of <code>Animal[]</code>.</p>

<p>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;(<span class="hljs-number">1</span>);
List&lt;Animal&gt; animals = dogs;
animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()); <span class="hljs-comment">// compile-time error</span>
<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogs.get(<span class="hljs-number">0</span>);
</code></pre>

<p>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</p>

<p>It is instructive to compare the above to analogous code for arrays.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Dog[] dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>[<span class="hljs-number">1</span>];
Object[] animals = dogs;
animals[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// run-time error</span>
<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogs[<span class="hljs-number">0</span>];
</code></pre>

<p>The code is legal. However, throws an <a href="https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception">array store exception</a>.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping. </p>

<p>To understand this further let's look at the bytecode generated by <code>javap</code> of the class below:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demonstration</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">normal</span><span class="hljs-params">()</span> {
        <span class="hljs-type">List</span> <span class="hljs-variable">normal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-number">1</span>);
        normal.add(<span class="hljs-string">"lorem ipsum"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parameterized</span><span class="hljs-params">()</span> {
        List&lt;String&gt; parameterized = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1</span>);
        parameterized.add(<span class="hljs-string">"lorem ipsum"</span>);
    }
}
</code></pre>

<p>Using the command <code>javap -c Demonstration</code>, this shows the following Java bytecode:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Compiled from <span class="hljs-string">"Demonstration.java"</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demonstration</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demonstration</span><span class="hljs-params">()</span>;
    Code:
       <span class="hljs-number">0</span>: aload_0
       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>
       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">normal</span><span class="hljs-params">()</span>;
    Code:
       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span>
       <span class="hljs-number">3</span>: dup
       <span class="hljs-number">4</span>: iconst_1
       <span class="hljs-number">5</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList."&lt;init&gt;":(I)V</span>
       <span class="hljs-number">8</span>: astore_1
       <span class="hljs-number">9</span>: aload_1
      <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String lorem ipsum</span>
      <span class="hljs-number">12</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span>
      <span class="hljs-number">17</span>: pop
      <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parameterized</span><span class="hljs-params">()</span>;
    Code:
       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span>
       <span class="hljs-number">3</span>: dup
       <span class="hljs-number">4</span>: iconst_1
       <span class="hljs-number">5</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList."&lt;init&gt;":(I)V</span>
       <span class="hljs-number">8</span>: astore_1
       <span class="hljs-number">9</span>: aload_1
      <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String lorem ipsum</span>
      <span class="hljs-number">12</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span>
      <span class="hljs-number">17</span>: pop
      <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span>
}
</code></pre>

<p>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its <a href="https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java">erasure</a>. This property is crucial meaning that it did not break backwards compatibility.</p>

<p>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are sure that the list items are subclasses of that given super type, you can cast the list using this approach:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">(List&lt;Animal&gt;) (List&lt;?&gt;) dogs
</code></pre>
<p>This is usefull when you want to pass the list inside of a constructor or iterate over it.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="https://stackoverflow.com/a/2745301/4350148">answer</a>  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.  </p>

<p>In most cases, we can use <code>Collection&lt;? extends T&gt;</code> rather then <code>Collection&lt;T&gt;</code> and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a <code>Collection&lt;? extends T&gt;</code> to a <code>Collection&lt;T&gt;</code> (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use <code>Collection&lt;? extends Object&gt;</code> in this case, but I am keeping it simple to illustrate using DownCastCollection.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">/**Could use Collection&lt;? extends Object&gt; and that is the better choice. 
* But I am doing this to illustrate how to use DownCastCollection. **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Collection&lt;Object&gt; col)</span>{  
    <span class="hljs-keyword">for</span>(Object obj : col){
    System.out.println(obj);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
  ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
  list.addAll(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>));
  print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DownCastCollection</span>&lt;Object&gt;(list));
}
</code></pre>

<p>Now the class:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.AbstractCollection;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.NoSuchElementException;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownCastCollection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; {
<span class="hljs-keyword">private</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span>&gt; delegate;

<span class="hljs-keyword">public</span> <span class="hljs-title function_">DownCastCollection</span><span class="hljs-params">(Collection&lt;? extends E&gt; delegate)</span> {
    <span class="hljs-built_in">super</span>();
    <span class="hljs-built_in">this</span>.delegate = delegate;
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> {
    <span class="hljs-type">return</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span>=<span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : delegate.size();
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> delegate==<span class="hljs-literal">null</span> || delegate.isEmpty();
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> {
    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> delegate.contains(o);
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;{
    Iterator&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span>&gt; delegateIterator;

    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MyIterator</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-built_in">this</span>.delegateIterator = delegate == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> :delegate.iterator();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> delegateIterator != <span class="hljs-literal">null</span> &amp;&amp; delegateIterator.hasNext();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span>  E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span>(!hasNext()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">"The iterator is empty"</span>);
        <span class="hljs-keyword">return</span> delegateIterator.next();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {
        delegateIterator.remove();

    }

}
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();
}



<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> {
    <span class="hljs-keyword">if</span>(delegate == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> delegate.remove(o);
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> {
    <span class="hljs-keyword">if</span>(delegate==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> delegate.containsAll(c);
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> {
    <span class="hljs-keyword">if</span>(delegate == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> delegate.removeAll(c);
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> {
    <span class="hljs-keyword">if</span>(delegate == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> delegate.retainAll(c);
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span>(delegate == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        delegate.clear();

}
</code></pre>

<p>}</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Others have done a decent job of explaining why you cannot just cast a list of descendant to list of superclass.</p>
<p>However, many people visit this question looking for a solution.</p>
<p>So, the solution to this problem in modern java is as follows:</p>
<p>(Note: S = superclass)</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;S&gt; supers = List.copyOf( descendants );
</code></pre>
<p>For an explanation as to why this is safe, (taking into consideration the potential pitfalls mentioned by other answers,) and why this is the best way of achieving this, see related question and my 2022 answer to it: <a href="https://stackoverflow.com/a/72195980/773113">https://stackoverflow.com/a/72195980/773113</a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The issue has been correctly identified as related to variance but the details are not correct. A purely functional list is a covariant data functor, which means if a type Sub is a subtype of Super, then a list of Sub is definitely a subtype of a list of Super.</p>
<p>However mutability of a list is not the basic problem here. The problem is mutability in general. The problem is well known, and is called the Covariance Problem, it was first identified I think by Castagna, and it completely and utterly destroys object orientation as a general paradigm. It is based on previously established variance rules established by Cardelli and Reynolds.</p>
<p>Somewhat oversimplifying, lets consider assignment of an object B of type T to an object A of type T as a mutation. This is without loss of generality: a mutation of A can be written A = f (A) where f: T -&gt; T. The problem, of course, is that whilst functions are covariant in their codomain, they're contravariant in their domain, but with assignments the domain and codomain are the same, so assignment is invariant!</p>
<p>It follows, generalising, that subtypes cannot be mutated. But with object orientation mutation is fundamental, hence object orientation is intrinsically flawed.</p>
<p>Here's a simple example: in a purely functional setting a symmetric matrix is clearly a matrix, it is a subtype, no problem. Now lets add to matrix the ability to set a single element at coordinates (x,y) with the rule no other element changes. Now symmetric matrix is no longer a subtype, if you change (x,y) you have also changed (y,x). The functional operation is delta: Sym -&gt; Mat, if you change one element of a symmetric matrix you get a general non-symmetric matrix back. Therefore if you included a "change one element" method in Mat, Sym is not a subtype. In fact .. there are almost certainly NO proper subtypes.</p>
<p>To put all this in easier terms: if you have a general data type with a wide range of mutators which leverage its generality you can be certain any proper subtype cannot possibly support all those mutations: if it could, it would be just as general as the supertype, contrary to the specification of "proper" subtype.</p>
<p>The fact Java prevents subtyping mutable lists fails to address the real issue: why are you using object oriented rubbish like Java when it was discredited several decades ago??</p>
<p>In any case there's a reasonable discussion here:</p>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Lets take the example from JavaSE <a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" rel="nofollow">tutorial</a> </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, radius;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span> {
        ...
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, width, height;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span> {
        ...
    }
}
</code></pre>

<p>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// drawAll method call</span>
drawAll(circleList);


<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawAll</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> {
   shapes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());    
}
</code></pre>

<p>So Java "architects" had 2 options which address this problem:</p>

<ol>
<li><p>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</p></li>
<li><p>consider the subtype to be it's supertype and restrict at compile the "add" method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</p></li>
</ol>

<p>For obvious reasons, that chose the first way. </p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We should also take in consideration how the compiler threats the generic classes: in "instantiates" a different type whenever we fill the generic arguments.</p>

<p>Thus we have <code>ListOfAnimal</code>, <code>ListOfDog</code>, <code>ListOfCat</code>, etc, which are distinct classes that end up being "created" by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to <code>List</code> is not a hierarchy at all).</p>

<p>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are <code>List</code> instances. Specialising a <code>List</code> by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem has been well-identified. But there's a solution; make <em>doSomething</em> generic:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; <span class="hljs-keyword">void</span> doSomething&lt;List&lt;T&gt; animals) {
}
</code></pre>

<p>now you can call doSomething with either List&lt;Dog&gt; or List&lt;Cat&gt; or List&lt;Animal&gt;.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>another solution is to build a new list</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;(); 
List&lt;Animal&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;(dogs);
animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Further to the answer by Jon Skeet, which uses this example code:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// Illegal code - because otherwise life would be Bad</span>
List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;(); <span class="hljs-comment">// ArrayList implements List</span>
List&lt;Animal&gt; animals = dogs; <span class="hljs-comment">// Awooga awooga</span>
animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogs.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// This should be safe, right?</span>
</code></pre>

<p>At the deepest level, the problem here is that <code>dogs</code> and <code>animals</code> share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// This code is fine</span>
List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();
dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());
List&lt;Animal&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(dogs); <span class="hljs-comment">// Copy list</span>
animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogs.get(<span class="hljs-number">0</span>);   <span class="hljs-comment">// This is fine now, because it does not return the Cat</span>
</code></pre>

<p>After calling <code>List&lt;Animal&gt; animals = new ArrayList&lt;&gt;(dogs);</code>, you cannot subsequently directly assign <code>animals</code> to either <code>dogs</code> or <code>cats</code>:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// These are both illegal</span>
dogs = animals;
cats = animals;
</code></pre>

<p>therefore you can't put the wrong subtype of <code>Animal</code> into the list, because there is no wrong subtype -- any object of subtype <code>? extends Animal</code> can be added to <code>animals</code>.</p>

<p>Obviously, this changes the semantics, since the lists <code>animals</code> and <code>dogs</code> are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a <code>Cat</code> could be added to a list that is only supposed to contain <code>Dog</code> objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I see that the question has already been answered a number of times, just want to put in my inputs on the same question.</p>
<p>Lets us go ahead and create a simplified Animal class hierarchy.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"animal eating"</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> { }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">meow</span><span class="hljs-params">()</span> { }
}
</code></pre>
<p>Now let us have a look at our old friend Arrays, which we know support polymorphism implicitly-</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnimals</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        Animal[] animals = {<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()};
        Dog[] dogs = {<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()};
        takeAnimals(animals);
        takeAnimals(dogs);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeAnimals</span><span class="hljs-params">(Animal[] animals)</span> {
        <span class="hljs-keyword">for</span>(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
<p>The class compiles fine and when we run the above class we get the output</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">animal eating
animal eating
animal eating
animal eating
animal eating
animal eating
</code></pre>
<p>The point to note here is that the takeAnimals() method is defined to take anything which is of type Animal, it can take an array of type Animal and it can take an array of Dog as well because Dog-is-a-Animal. So this is Polymorphism in action.</p>
<p>Let us now use this same approach with generics,</p>
<p>Now say we tweak our code a little bit and use ArrayLists instead of Arrays -</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnimals</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Animal&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());
        takeAnimals(animals);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeAnimals</span><span class="hljs-params">(ArrayList&lt;Animal&gt; animals)</span> {
        <span class="hljs-keyword">for</span>(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
<p>The class above will compile and will produce the output -</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">animal eating
animal eating
animal eating
animal eating
animal eating
animal eating
</code></pre>
<p>So we know this works, now lets tweak this class a little bit to use Animal type polymorphically -</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnimals</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Animal&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
        animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());

        ArrayList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();
        takeAnimals(animals);
        takeAnimals(dogs);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeAnimals</span><span class="hljs-params">(ArrayList&lt;Animal&gt; animals)</span> {
        <span class="hljs-keyword">for</span>(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
<p>Looks like there should be no problem in compiling the above class as the takeAnimals() method is designed to take any ArrayList of type Animal and Dog-is-a-Animal so it should not be a deal breaker here.</p>
<p>But, unfortunately the compiler throws an error and doesn't allow us to pass a Dog ArrayList to a variable expecting Animal ArrayList.</p>
<p>You ask why?</p>
<p>Because just imagine, if JAVA were to allow the Dog ArrayList - dogs - to be put into the Animal ArrayList - animals - and then inside the takeAnimals() method somebody does something like -</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">animals.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());
</code></pre>
<p>thinking that this should be doable because ideally it is an Animal ArrayList and you should be in a position to add any cat to it as Cat-is-also-a-Animal, but in real you passed a Dog type ArrayList to it.</p>
<p>So, now you must be thinking the the same should have happened with the Arrays as well. You are right in thinking so.</p>
<p>If somebody tries to do the same thing with Arrays then Arrays are also going to throw an error but Arrays handle this error at runtime whereas ArrayLists handle this error at compile time.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;No, a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;. Consider what you can do with a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; - you can add \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Illegal code - because otherwise life would be Bad\u0026lt;/span\u0026gt;\nList\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ArrayList implements List\u0026lt;/span\u0026gt;\nList\u0026amp;lt;Animal\u0026amp;gt; animals = dogs; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Awooga awooga\u0026lt;/span\u0026gt;\nanimals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dogs.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This should be safe, right?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Suddenly you have a \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; confused cat.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, you \u0026lt;em\u0026gt;can\u0026apos;t\u0026lt;/em\u0026gt; add a \u0026lt;code\u0026gt;Cat\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;List\u0026amp;lt;? extends Animal\u0026amp;gt;\u0026lt;/code\u0026gt; because you don\u0026apos;t know it\u0026apos;s a \u0026lt;code\u0026gt;List\u0026amp;lt;Cat\u0026amp;gt;\u0026lt;/code\u0026gt;. You can retrieve a value and know that it will be an \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt;, but you can\u0026apos;t add arbitrary animals. The reverse is true for \u0026lt;code\u0026gt;List\u0026amp;lt;? super Animal\u0026amp;gt;\u0026lt;/code\u0026gt; - in that case you can add an \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt; to it safely, but you don\u0026apos;t know anything about what might be retrieved from it, because it could be a \u0026lt;code\u0026gt;List\u0026amp;lt;Object\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What you are looking for is called \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;covariant type\u0026lt;/a\u0026gt; parameters\u0026lt;/em\u0026gt;. This means that if one type of object can be substituted for another in a method (for instance, \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt; can be replaced with \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt;), the same applies to expressions using those objects (so \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; could be replaced with \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt;, and it is being used as a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;.  What happens when you try to add a Cat to this \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; which is really a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt;?  Automatically allowing type parameters to be covariant breaks the type system.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the \u0026lt;code\u0026gt;? extends Foo\u0026lt;/code\u0026gt; in method declarations, but that does add additional complexity.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; is not a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;, is that, for example, you can insert a \u0026lt;code\u0026gt;Cat\u0026lt;/code\u0026gt; into a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;, but not into a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; is the similar to reading from a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; -- but not writing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Generics in the Java Language\u0026lt;/a\u0026gt; and the \u0026lt;a href=\u0026quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Section on Generics from the Java Tutorials\u0026lt;/a\u0026gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A point I think should be added to what \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2745301/1593077\u0026quot;\u0026gt;other\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2745319/1593077\u0026quot;\u0026gt;answers\u0026lt;/a\u0026gt; mention is that while\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; isn\u0026apos;t-a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;in Java\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;it is also true that\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;A list of dogs is-a list of animals \u0026lt;strong\u0026gt;in English\u0026lt;/strong\u0026gt; (under a reasonable interpretation)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The way the OP\u0026apos;s intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To put it another way: A \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; in Java does not mean \u0026quot;a list of dogs\u0026quot; in English, it means \u0026quot;a list of dogs and nothing other than dogs\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;More generally, \u0026lt;strong\u0026gt;OP\u0026apos;s intuition lends itself towards a language in which operations on objects can change their type\u0026lt;/strong\u0026gt;, or rather, an object\u0026apos;s type(s) is a (dynamic) function of its value.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would say the whole point of Generics is that it doesn\u0026apos;t allow that. Consider the situation with arrays, which do allow that type of covariance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;  Object[] objects = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n  objects[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = Boolean.FALSE;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That code compiles fine, but throws a runtime error (\u0026lt;code\u0026gt;java.lang.ArrayStoreException: java.lang.Boolean\u0026lt;/code\u0026gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now there are times where you need to be more flexible and that is what the \u0026lt;code\u0026gt;? super Class\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;? extends Class\u0026lt;/code\u0026gt; are for. The former is when you need to insert into a type \u0026lt;code\u0026gt;Collection\u0026lt;/code\u0026gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To understand the problem it\u0026apos;s useful to make comparison to arrays.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; subclass of \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\n\u0026lt;strong\u0026gt;But\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;Dog[]\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;is\u0026lt;/strong\u0026gt; subclass of \u0026lt;code\u0026gt;Animal[]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Arrays are \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;reifiable\u0026lt;/a\u0026gt; and covariant\u0026lt;/strong\u0026gt;. \u0026lt;br\u0026gt;\u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Reifiable\u0026lt;/a\u0026gt; means their type information is fully available at runtime. \u0026lt;br\u0026gt;Therefore arrays provide runtime type safety but not compile-time type safety.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// All compiles but throws ArrayStoreException at runtime at last line\u0026lt;/span\u0026gt;\n    Dog[] dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n    Animal[] animals = dogs; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiles\u0026lt;/span\u0026gt;\n    animals[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// throws ArrayStoreException at runtime\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s vice versa for generics:\u0026lt;br\u0026gt;\n\u0026lt;strong\u0026gt;Generics are \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;erased\u0026lt;/a\u0026gt; and invariant\u0026lt;/strong\u0026gt;. \u0026lt;br\u0026gt;Therefore generics can\u0026apos;t provide runtime type safety, but they provide compile-time type safety. \u0026lt;br\u0026gt;In the code below if generics were covariant it will be possible to make \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Heap_pollution\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;heap pollution\u0026lt;/a\u0026gt; at line 3.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    List\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n    List\u0026amp;lt;Animal\u0026amp;gt; animals = dogs; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compile-time error, otherwise heap pollution\u0026lt;/span\u0026gt;\n    animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The answers given here didn\u0026apos;t fully convince me. So instead, I make another example.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passOn\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Consumer\u0026amp;lt;Animal\u0026amp;gt; consumer, Supplier\u0026amp;lt;Animal\u0026amp;gt; supplier)\u0026lt;/span\u0026gt; {\n    consumer.accept(supplier.get());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;sounds fine, doesn\u0026apos;t it? But you can only pass \u0026lt;code\u0026gt;Consumer\u0026lt;/code\u0026gt;s and \u0026lt;code\u0026gt;Supplier\u0026lt;/code\u0026gt;s for \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt;s. If you have a \u0026lt;code\u0026gt;Mammal\u0026lt;/code\u0026gt; consumer, but a \u0026lt;code\u0026gt;Duck\u0026lt;/code\u0026gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of the above, we have to define relationships between the types we use.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;E. g.,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026amp;lt;A \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passOn\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Consumer\u0026amp;lt;A\u0026amp;gt; consumer, Supplier\u0026amp;lt;? extends A\u0026amp;gt; supplier)\u0026lt;/span\u0026gt; {\n    consumer.accept(supplier.get());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;makes sure that we can only use a supplier which provides us the right type of object for the consumer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;OTOH, we could as well do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026amp;lt;A \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passOn\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Consumer\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; A\u0026amp;gt; consumer, Supplier\u0026amp;lt;A\u0026amp;gt; supplier)\u0026lt;/span\u0026gt; {\n    consumer.accept(supplier.get());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where we go the other way: we define the type of the \u0026lt;code\u0026gt;Supplier\u0026lt;/code\u0026gt; and restrict that it can be put into the \u0026lt;code\u0026gt;Consumer\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We even can do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026amp;lt;A \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passOn\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Consumer\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; A\u0026amp;gt; consumer, Supplier\u0026amp;lt;? extends A\u0026amp;gt; supplier)\u0026lt;/span\u0026gt; {\n    consumer.accept(supplier.get());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where, having the intuitive relations \u0026lt;code\u0026gt;Life\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;Mammal\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Cat\u0026lt;/code\u0026gt; etc., we could even put a \u0026lt;code\u0026gt;Mammal\u0026lt;/code\u0026gt; into a \u0026lt;code\u0026gt;Life\u0026lt;/code\u0026gt; consumer, but not a \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; into a \u0026lt;code\u0026gt;Life\u0026lt;/code\u0026gt; consumer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The basis logic for such behavior is that \u0026lt;code\u0026gt;Generics\u0026lt;/code\u0026gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of \u0026lt;code\u0026gt;collection\u0026lt;/code\u0026gt; unlike \u0026lt;code\u0026gt;arrays\u0026lt;/code\u0026gt; where there is no such erasure process. So coming back to your question...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So suppose there is a method as given below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;add(List\u0026amp;lt;Animal\u0026amp;gt;){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//You can add List\u0026amp;lt;Dog or List\u0026amp;lt;Cat\u0026amp;gt; and this will compile as per rules of polymorphism\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Actually you can use an interface to achieve what you want.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt; {\n    String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n    String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getVoice\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt; \n    String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Dog\u0026quot;\u0026lt;/span\u0026gt;;}\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n    String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getVoice\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;woof!\u0026quot;\u0026lt;/span\u0026gt;;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;}\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;you can then use the collections using\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List \u0026amp;lt;Animal\u0026amp;gt; animalGroup = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Animal\u0026amp;gt;();\nanimalGroup.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Subtyping is \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english\u0026quot;\u0026gt;invariant\u0026lt;/a\u0026gt; for parameterized types. Even tough the class \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; is a subtype of \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt;, the parameterized type \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; is not a subtype of \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt;. In contrast, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english\u0026quot;\u0026gt;covariant\u0026lt;/a\u0026gt; subtyping is used by arrays, so the array\ntype \u0026lt;code\u0026gt;Dog[]\u0026lt;/code\u0026gt; is a subtype of \u0026lt;code\u0026gt;Animal[]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\nList\u0026amp;lt;Animal\u0026amp;gt; animals = dogs;\nanimals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compile-time error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dogs.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is instructive to compare the above to analogous code for arrays.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Dog[] dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\nObject[] animals = dogs;\nanimals[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// run-time error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dogs[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The code is legal. However, throws an \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception\u0026quot;\u0026gt;array store exception\u0026lt;/a\u0026gt;.\nAn array carries its type at run-time this way JVM can enforce\ntype safety of covariant subtyping. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To understand this further let\u0026apos;s look at the bytecode generated by \u0026lt;code\u0026gt;javap\u0026lt;/code\u0026gt; of the class below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.ArrayList;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.List;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Demonstration\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;normal\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;normal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        normal.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;lorem ipsum\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;parameterized\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        List\u0026amp;lt;String\u0026amp;gt; parameterized = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        parameterized.add(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;lorem ipsum\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using the command \u0026lt;code\u0026gt;javap -c Demonstration\u0026lt;/code\u0026gt;, this shows the following Java bytecode:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Compiled from \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Demonstration.java\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Demonstration\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Demonstration\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n    Code:\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: aload_0\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: invokespecial #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Method java/lang/Object.\u0026quot;\u0026amp;lt;init\u0026amp;gt;\u0026quot;:()V\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;normal\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n    Code:\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;           #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// class java/util/ArrayList\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: dup\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: iconst_1\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;: invokespecial #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Method java/util/ArrayList.\u0026quot;\u0026amp;lt;init\u0026amp;gt;\u0026quot;:(I)V\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;: astore_1\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;: aload_1\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;: ldc           #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// String lorem ipsum\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;: invokeinterface #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;: pop\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;parameterized\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n    Code:\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;           #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// class java/util/ArrayList\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: dup\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;: iconst_1\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;: invokespecial #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Method java/util/ArrayList.\u0026quot;\u0026amp;lt;init\u0026amp;gt;\u0026quot;:(I)V\u0026lt;/span\u0026gt;\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;: astore_1\n       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;: aload_1\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;: ldc           #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// String lorem ipsum\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;: invokeinterface #\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;: pop\n      \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java\u0026quot;\u0026gt;erasure\u0026lt;/a\u0026gt;. This property is crucial meaning that it did not break backwards compatibility.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are sure that the list items are subclasses of that given super type, you can cast the list using this approach:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;(List\u0026amp;lt;Animal\u0026amp;gt;) (List\u0026amp;lt;?\u0026amp;gt;) dogs\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is usefull when you want to pass the list inside of a constructor or iterate over it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2745301/4350148\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In most cases, we can use \u0026lt;code\u0026gt;Collection\u0026amp;lt;? extends T\u0026amp;gt;\u0026lt;/code\u0026gt; rather then \u0026lt;code\u0026gt;Collection\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a \u0026lt;code\u0026gt;Collection\u0026amp;lt;? extends T\u0026amp;gt;\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;Collection\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use \u0026lt;code\u0026gt;Collection\u0026amp;lt;? extends Object\u0026amp;gt;\u0026lt;/code\u0026gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**Could use Collection\u0026amp;lt;? extends Object\u0026amp;gt; and that is the better choice. \n* But I am doing this to illustrate how to use DownCastCollection. **/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;Object\u0026amp;gt; col)\u0026lt;/span\u0026gt;{  \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Object obj : col){\n    System.out.println(obj);\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;{\n  ArrayList\u0026amp;lt;String\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n  list.addAll(Arrays.asList(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;));\n  print(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DownCastCollection\u0026lt;/span\u0026gt;\u0026amp;lt;Object\u0026amp;gt;(list));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.AbstractCollection;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Collection;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Iterator;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.NoSuchElementException;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DownCastCollection\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AbstractCollection\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Collection\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Collection\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;E\u0026lt;/span\u0026gt;\u0026amp;gt; delegate;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;DownCastCollection\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;? extends E\u0026amp;gt; delegate)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.delegate = delegate;\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;delegate\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; ? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; : delegate.size();\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;isEmpty\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate==\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; || delegate.isEmpty();\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;contains\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object o)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(isEmpty()) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate.contains(o);\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyIterator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Iterator\u0026lt;/span\u0026gt;\u0026amp;lt;E\u0026amp;gt;{\n    Iterator\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;E\u0026lt;/span\u0026gt;\u0026amp;gt; delegateIterator;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MyIterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.delegateIterator = delegate == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; ? \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; :delegate.iterator();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasNext\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegateIterator != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; delegateIterator.hasNext();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;  E \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!hasNext()) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;NoSuchElementException\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The iterator is empty\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegateIterator.next();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        delegateIterator.remove();\n\n    }\n\n}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Iterator\u0026amp;lt;E\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyIterator\u0026lt;/span\u0026gt;();\n}\n\n\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(E e)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnsupportedOperationException\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object o)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delegate == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate.remove(o);\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;containsAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;?\u0026amp;gt; c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delegate==\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate.containsAll(c);\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;? extends E\u0026amp;gt; c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnsupportedOperationException\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;removeAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;?\u0026amp;gt; c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delegate == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate.removeAll(c);\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;retainAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Collection\u0026amp;lt;?\u0026amp;gt; c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delegate == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; delegate.retainAll(c);\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delegate == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n        delegate.clear();\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;}\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Others have done a decent job of explaining why you cannot just cast a list of descendant to list of superclass.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, many people visit this question looking for a solution.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, the solution to this problem in modern java is as follows:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Note: S = superclass)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;S\u0026amp;gt; supers = List.copyOf( descendants );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For an explanation as to why this is safe, (taking into consideration the potential pitfalls mentioned by other answers,) and why this is the best way of achieving this, see related question and my 2022 answer to it: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/72195980/773113\u0026quot;\u0026gt;https://stackoverflow.com/a/72195980/773113\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The issue has been correctly identified as related to variance but the details are not correct. A purely functional list is a covariant data functor, which means if a type Sub is a subtype of Super, then a list of Sub is definitely a subtype of a list of Super.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However mutability of a list is not the basic problem here. The problem is mutability in general. The problem is well known, and is called the Covariance Problem, it was first identified I think by Castagna, and it completely and utterly destroys object orientation as a general paradigm. It is based on previously established variance rules established by Cardelli and Reynolds.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Somewhat oversimplifying, lets consider assignment of an object B of type T to an object A of type T as a mutation. This is without loss of generality: a mutation of A can be written A = f (A) where f: T -\u0026amp;gt; T. The problem, of course, is that whilst functions are covariant in their codomain, they\u0026apos;re contravariant in their domain, but with assignments the domain and codomain are the same, so assignment is invariant!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It follows, generalising, that subtypes cannot be mutated. But with object orientation mutation is fundamental, hence object orientation is intrinsically flawed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple example: in a purely functional setting a symmetric matrix is clearly a matrix, it is a subtype, no problem. Now lets add to matrix the ability to set a single element at coordinates (x,y) with the rule no other element changes. Now symmetric matrix is no longer a subtype, if you change (x,y) you have also changed (y,x). The functional operation is delta: Sym -\u0026amp;gt; Mat, if you change one element of a symmetric matrix you get a general non-symmetric matrix back. Therefore if you included a \u0026quot;change one element\u0026quot; method in Mat, Sym is not a subtype. In fact .. there are almost certainly NO proper subtypes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To put all this in easier terms: if you have a general data type with a wide range of mutators which leverage its generality you can be certain any proper subtype cannot possibly support all those mutations: if it could, it would be just as general as the supertype, contrary to the specification of \u0026quot;proper\u0026quot; subtype.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The fact Java prevents subtyping mutable lists fails to address the real issue: why are you using object oriented rubbish like Java when it was discredited several decades ago??\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In any case there\u0026apos;s a reasonable discussion here:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Lets take the example from JavaSE \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;tutorial\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;abstract\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Shape\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;abstract\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;draw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Canvas c)\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Circle\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Shape\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, y, radius;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;draw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Canvas c)\u0026lt;/span\u0026gt; {\n        ...\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Rectangle\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Shape\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, y, width, height;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;draw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Canvas c)\u0026lt;/span\u0026gt; {\n        ...\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// drawAll method call\u0026lt;/span\u0026gt;\ndrawAll(circleList);\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;drawAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(List\u0026amp;lt;Shape\u0026amp;gt; shapes)\u0026lt;/span\u0026gt; {\n   shapes.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Rectangle\u0026lt;/span\u0026gt;());    \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So Java \u0026quot;architects\u0026quot; had 2 options which address this problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;do not consider that a subtype is implicitly it\u0026apos;s supertype, and give a compile error, like it happens now\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;consider the subtype to be it\u0026apos;s supertype and restrict at compile the \u0026quot;add\u0026quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;For obvious reasons, that chose the first way. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We should also take in consideration how the compiler threats the generic classes: in \u0026quot;instantiates\u0026quot; a different type whenever we fill the generic arguments.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Thus we have \u0026lt;code\u0026gt;ListOfAnimal\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ListOfDog\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ListOfCat\u0026lt;/code\u0026gt;, etc, which are distinct classes that end up being \u0026quot;created\u0026quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; is not a hierarchy at all).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another argument why covariance doesn\u0026apos;t make sense in case of generic classes is the fact that at base all classes are the same - are \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; instances. Specialising a \u0026lt;code\u0026gt;List\u0026lt;/code\u0026gt; by filling the generic argument doesn\u0026apos;t extend the class, it just makes it work for that particular generic argument.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The problem has been well-identified. But there\u0026apos;s a solution; make \u0026lt;em\u0026gt;doSomething\u0026lt;/em\u0026gt; generic:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026amp;lt;T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; doSomething\u0026amp;lt;List\u0026amp;lt;T\u0026amp;gt; animals) {\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;now you can call doSomething with either List\u0026amp;lt;Dog\u0026amp;gt; or List\u0026amp;lt;Cat\u0026amp;gt; or List\u0026amp;lt;Animal\u0026amp;gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;another solution is to build a new list\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;(); \nList\u0026amp;lt;Animal\u0026amp;gt; animals = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Animal\u0026amp;gt;(dogs);\nanimals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Further to the answer by Jon Skeet, which uses this example code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Illegal code - because otherwise life would be Bad\u0026lt;/span\u0026gt;\nList\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ArrayList implements List\u0026lt;/span\u0026gt;\nList\u0026amp;lt;Animal\u0026amp;gt; animals = dogs; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Awooga awooga\u0026lt;/span\u0026gt;\nanimals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dogs.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This should be safe, right?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;At the deepest level, the problem here is that \u0026lt;code\u0026gt;dogs\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;animals\u0026lt;/code\u0026gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This code is fine\u0026lt;/span\u0026gt;\nList\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;();\ndogs.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\nList\u0026amp;lt;Animal\u0026amp;gt; animals = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(dogs); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy list\u0026lt;/span\u0026gt;\nanimals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dogs.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is fine now, because it does not return the Cat\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;After calling \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt; animals = new ArrayList\u0026amp;lt;\u0026amp;gt;(dogs);\u0026lt;/code\u0026gt;, you cannot subsequently directly assign \u0026lt;code\u0026gt;animals\u0026lt;/code\u0026gt; to either \u0026lt;code\u0026gt;dogs\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;cats\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// These are both illegal\u0026lt;/span\u0026gt;\ndogs = animals;\ncats = animals;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;therefore you can\u0026apos;t put the wrong subtype of \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt; into the list, because there is no wrong subtype -- any object of subtype \u0026lt;code\u0026gt;? extends Animal\u0026lt;/code\u0026gt; can be added to \u0026lt;code\u0026gt;animals\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, this changes the semantics, since the lists \u0026lt;code\u0026gt;animals\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;dogs\u0026lt;/code\u0026gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a \u0026lt;code\u0026gt;Cat\u0026lt;/code\u0026gt; could be added to a list that is only supposed to contain \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I see that the question has already been answered a number of times, just want to put in my inputs on the same question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Lets us go ahead and create a simplified Animal class hierarchy.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;abstract\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;eat\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;animal eating\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bark\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; { }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Animal\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;meow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; { }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now let us have a look at our old friend Arrays, which we know support polymorphism implicitly-\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestAnimals\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        Animal[] animals = {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;()};\n        Dog[] dogs = {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;()};\n        takeAnimals(animals);\n        takeAnimals(dogs);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;takeAnimals\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Animal[] animals)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The class compiles fine and when we run the above class we get the output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;animal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The point to note here is that the takeAnimals() method is defined to take anything which is of type Animal, it can take an array of type Animal and it can take an array of Dog as well because Dog-is-a-Animal. So this is Polymorphism in action.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let us now use this same approach with generics,\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now say we tweak our code a little bit and use ArrayLists instead of Arrays -\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestAnimals\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        ArrayList\u0026amp;lt;Animal\u0026amp;gt; animals = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Animal\u0026amp;gt;();\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\n        takeAnimals(animals);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;takeAnimals\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ArrayList\u0026amp;lt;Animal\u0026amp;gt; animals)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The class above will compile and will produce the output -\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;animal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\nanimal eating\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So we know this works, now lets tweak this class a little bit to use Animal type polymorphically -\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestAnimals\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        ArrayList\u0026amp;lt;Animal\u0026amp;gt; animals = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Animal\u0026amp;gt;();\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n        animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\n\n        ArrayList\u0026amp;lt;Dog\u0026amp;gt; dogs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Dog\u0026amp;gt;();\n        takeAnimals(animals);\n        takeAnimals(dogs);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;takeAnimals\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ArrayList\u0026amp;lt;Animal\u0026amp;gt; animals)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Animal a : animals) {\n            System.out.println(a.eat());\n        }\n    }   \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Looks like there should be no problem in compiling the above class as the takeAnimals() method is designed to take any ArrayList of type Animal and Dog-is-a-Animal so it should not be a deal breaker here.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But, unfortunately the compiler throws an error and doesn\u0026apos;t allow us to pass a Dog ArrayList to a variable expecting Animal ArrayList.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You ask why?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because just imagine, if JAVA were to allow the Dog ArrayList - dogs - to be put into the Animal ArrayList - animals - and then inside the takeAnimals() method somebody does something like -\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;animals.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Cat\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;thinking that this should be doable because ideally it is an Animal ArrayList and you should be in a position to add any cat to it as Cat-is-also-a-Animal, but in real you passed a Dog type ArrayList to it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, now you must be thinking the the same should have happened with the Arrays as well. You are right in thinking so.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If somebody tries to do the same thing with Arrays then Arrays are also going to throw an error but Arrays handle this error at runtime whereas ArrayLists handle this error at compile time.\u0026lt;/p\u0026gt;\n    "],"id":149,"title":"Is List\u003cDog\u003e a subclass of List\u003cAnimal\u003e? Why are Java generics not implicitly polymorphic?","content":"\n                \n\u0026lt;p\u0026gt;I\u0026apos;m a bit confused about how Java generics handle inheritance / polymorphism.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assume the following hierarchy -\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Animal\u0026lt;/strong\u0026gt; (Parent)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Dog\u0026lt;/strong\u0026gt; - \u0026lt;strong\u0026gt;Cat\u0026lt;/strong\u0026gt; (Children)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So suppose I have a method \u0026lt;code\u0026gt;doSomething(List\u0026amp;lt;Animal\u0026amp;gt; animals)\u0026lt;/code\u0026gt;. By all the rules of inheritance and polymorphism, I would assume that a \u0026lt;code\u0026gt;List\u0026amp;lt;Dog\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;List\u0026amp;lt;Cat\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; a \u0026lt;code\u0026gt;List\u0026amp;lt;Animal\u0026amp;gt;\u0026lt;/code\u0026gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying \u0026lt;code\u0026gt;doSomething(List\u0026amp;lt;? extends Animal\u0026amp;gt; animals)\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I understand that this is Java\u0026apos;s behavior. My question is \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?\u0026lt;/p\u0026gt;\n    ","slug":"is-listlessdoggreater-a-subclass-of-listlessanimalgreater-why-are-java-generics-not-implicitly-polymorphic-1657384766724","postType":"QUESTION","createdAt":"2022-07-09T16:39:26.000Z","updatedAt":"2022-07-09T16:39:26.000Z","tags":[{"id":542,"name":"polymorphism","slug":"polymorphism","createdAt":"2022-07-09T16:39:26.000Z","updatedAt":"2022-07-09T16:39:26.000Z","Questions_Tags":{"questionId":149,"tagId":542}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-listlessdoggreater-a-subclass-of-listlessanimalgreater-why-are-java-generics-not-implicitly-polymorphic-1657384766724"},"buildId":"D-Vv5KfwuaE883xCdWfex","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>